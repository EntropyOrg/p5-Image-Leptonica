[
   {
      "function" : "DSCreateBitmapInfo",
      "comment" : "/* **********************************************************************\n  HBITMAP DSCreateBitmapInfo(l_int32 width, l_int32 height, l_int32 depth,\n                             PIXCMAP *cmap)\n\n  PARAMETERS:\n    l_int32 width - Desired width of the DIBSection\n    l_int32 height - Desired height of the DIBSection\n    l_int32 depth - Desired bit-depth of the DIBSection\n    PIXCMAP cmap - leptonica colormap for depths < 16\n\n  RETURNS:\n    LPBITMAPINFO - a ptr to BITMAPINFO of the desired size and bit-depth\n                   NULL on failure\n\n  REMARKS:\n    Creates a BITMAPINFO based on the criteria passed in as parameters.\n\n********************************************************************** */",
      "file" : "leptwin.c"
   },
   {
      "function" : "DSCreateDIBSection",
      "comment" : "/* **********************************************************************\n  HBITMAP DSCreateDIBSection(l_int32 width, l_int32 height, l_int32 depth,\n                             PIXCMAP *cmap)\n\n  PARAMETERS:\n    l_int32 width - Desired width of the DIBSection\n    l_int32 height - Desired height of the DIBSection\n    l_int32 depth - Desired bit-depth of the DIBSection\n    PIXCMAP cmap - leptonica colormap for depths < 16\n\n  RETURNS:\n    HBITMAP      - a DIBSection HBITMAP of the desired size and bit-depth\n                   NULL on failure\n\n  REMARKS:\n    Creates a DIBSection based on the criteria passed in as parameters.\n\n********************************************************************** */",
      "file" : "leptwin.c"
   },
   {
      "function" : "DSImageBitsSize",
      "comment" : "/* **********************************************************************\n  DWORD DSImageBitsSize(LPBITMAPINFO pbmi)\n\n  PARAMETERS:\n    LPBITMAPINFO - pointer to a BITMAPINFO describing a DIB\n\n  RETURNS:\n    DWORD    - the size, in bytes, of the DIB's image bits\n\n  REMARKS:\n    Calculates and returns the size, in bytes, of the image bits for\n    the DIB described by the BITMAPINFO.\n********************************************************************** */",
      "file" : "leptwin.c"
   },
   {
      "function" : "ImageBitsSize",
      "comment" : "/* **********************************************************************\n  DWORD ImageBitsSize(HBITMAP hbitmap)\n\n  PARAMETERS:\n    HBITMAP - hbitmap\n\n  RETURNS:\n    DWORD    - the size, in bytes, of the HBITMAP's image bits\n\n  REMARKS:\n    Calculates and returns the size, in bytes, of the image bits for\n    the DIB described by the HBITMAP.\n********************************************************************** */",
      "file" : "leptwin.c"
   },
   {
      "function" : "addColorizedGrayToCmap",
      "comment" : "/*!\n *  addColorizedGrayToCmap()\n *\n *      Input:  cmap (from 2 or 4 bpp pix)\n *              type (L_PAINT_LIGHT, L_PAINT_DARK)\n *              rval, gval, bval (target color)\n *              &na (<optional return> table for mapping new cmap entries)\n *      Return: 0 if OK; 1 on error; 2 if new colors will not fit in cmap.\n *\n *  Notes:\n *      (1) If type == L_PAINT_LIGHT, it colorizes non-black pixels,\n *          preserving antialiasing.\n *          If type == L_PAINT_DARK, it colorizes non-white pixels,\n *          preserving antialiasing.\n *      (2) This increases the colormap size by the number of\n *          different gray (non-black or non-white) colors in the\n *          input colormap.  If there is not enough room in the colormap\n *          for this expansion, it returns 1 (treated as a warning);\n *          the caller should check the return value.\n *      (3) This can be used to determine if the new colors will fit in\n *          the cmap, using null for &na.  Returns 0 if they fit; 2 if\n *          they don't fit.\n *      (4) The mapping table contains, for each gray color found, the\n *          index of the corresponding colorized pixel.  Non-gray\n *          pixels are assigned the invalid index 256.\n *      (5) See pixColorGrayCmap() for usage.\n */",
      "file" : "paintcmap.c"
   },
   {
      "function" : "adjacentOnPixelInRaster",
      "comment" : "/*!\n *  adjacentOnPixelInRaster()\n *\n *      Input:  pixs (1 bpp)\n *              x, y (current pixel)\n *              xa, ya (adjacent ON pixel, found by simple CCW search)\n *      Return: 1 if a pixel is found; 0 otherwise or on error\n *\n *  Notes:\n *      (1) Search is in 4-connected directions first; then on diagonals.\n *          This allows traversal along a 4-connected boundary.\n */",
      "file" : "selgen.c"
   },
   {
      "function" : "affineInvertXform",
      "comment" : "/*!\n *  affineInvertXform()\n *\n *      Input:  vc (vector of 6 coefficients)\n *              *vci (<return> inverted transform)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) The 6 affine transform coefficients are the first\n *          two rows of a 3x3 matrix where the last row has\n *          only a 1 in the third column.  We invert this\n *          using gaussjordan(), and select the first 2 rows\n *          as the coefficients of the inverse affine transform.\n *      (2) Alternatively, we can find the inverse transform\n *          coefficients by inverting the 2x2 submatrix,\n *          and treating the top 2 coefficients in the 3rd column as\n *          a RHS vector for that 2x2 submatrix.  Then the\n *          6 inverted transform coefficients are composed of\n *          the inverted 2x2 submatrix and the negative of the\n *          transformed RHS vector.  Why is this so?  We have\n *             Y = AX + R  (2 equations in 6 unknowns)\n *          Then\n *             X = A'Y - A'R\n *          Gauss-jordan solves\n *             AF = R\n *          and puts the solution for F, which is A'R,\n *          into the input R vector.\n *\n */",
      "file" : "affine.c"
   },
   {
      "function" : "affineXformPt",
      "comment" : "/*!\n *  affineXformPt()\n *\n *      Input:  vc (vector of 6 coefficients)\n *              (x, y)  (initial point)\n *              (&xp, &yp)   (<return> transformed point)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This computes the floating point location of the transformed point.\n *      (2) It does not check ptrs for returned data!\n */",
      "file" : "affine.c"
   },
   {
      "function" : "affineXformSampledPt",
      "comment" : "/*!\n *  affineXformSampledPt()\n *\n *      Input:  vc (vector of 6 coefficients)\n *              (x, y)  (initial point)\n *              (&xp, &yp)   (<return> transformed point)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This finds the nearest pixel coordinates of the transformed point.\n *      (2) It does not check ptrs for returned data!\n */",
      "file" : "affine.c"
   },
   {
      "function" : "applyCubicFit",
      "comment" : "/*!\n *  applyCubicFit()\n *\n *      Input: a, b, c, d (cubic fit coefficients)\n *             x\n *             &y (<return> y = a * x^3 + b * x^2  + c * x + d)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "applyLinearFit",
      "comment" : "/*!\n *  applyLinearFit()\n *\n *      Input: a, b (linear fit coefficients)\n *             x\n *             &y (<return> y = a * x + b)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "applyQuadraticFit",
      "comment" : "/*!\n *  applyQuadraticFit()\n *\n *      Input: a, b, c (quadratic fit coefficients)\n *             x\n *             &y (<return> y = a * x^2 + b * x + c)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "applyQuarticFit",
      "comment" : "/*!\n *  applyQuarticFit()\n *\n *      Input: a, b, c, d, e (quartic fit coefficients)\n *             x\n *             &y (<return> y = a * x^4 + b * x^3  + c * x^2 + d * x + e)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "applyWarpTransform",
      "comment" : "/*!\n *  applyWarpTransform()\n *\n *  Notes:\n *      (1) Uses the internal sin function.\n */",
      "file" : "warper.c"
   },
   {
      "function" : "applyWarpTransformLUT",
      "comment" : "/*!\n *  applyWarpTransformLUT()\n *\n *  Notes:\n *      (1) Uses an LUT for computing sin(theta).  There is little speed\n *          advantage to using the LUT.\n */",
      "file" : "warper.c"
   },
   {
      "function" : "arrayFindEachSequence",
      "comment" : "/*!\n *  arrayFindEachSequence()\n *\n *      Input:  data (byte array)\n *              datalen (length of data, in bytes)\n *              sequence (subarray of bytes to find in data)\n *              seqlen (length of sequence, in bytes)\n *      Return: dna of offsets where the sequence is found, or null if\n *              none are found or on error\n *\n *  Notes:\n *      (1) The byte arrays @data and @sequence are not C strings,\n *          as they can contain null bytes.  Therefore, for each\n *          we must give the length of the array.\n *      (2) This finds every occurrence in @data of @sequence.\n */",
      "file" : "utils.c"
   },
   {
      "function" : "arrayFindSequence",
      "comment" : "/*!\n *  arrayFindSequence()\n *\n *      Input:  data (byte array)\n *              datalen (length of data, in bytes)\n *              sequence (subarray of bytes to find in data)\n *              seqlen (length of sequence, in bytes)\n *              &offset (return> offset from beginning of\n *                       data where the sequence begins)\n *              &found (<optional return> 1 if sequence is found; 0 otherwise)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The byte arrays 'data' and 'sequence' are not C strings,\n *          as they can contain null bytes.  Therefore, for each\n *          we must give the length of the array.\n *      (2) This searches for the first occurrence in @data of @sequence,\n *          which consists of @seqlen bytes.  The parameter @seqlen\n *          must not exceed the actual length of the @sequence byte array.\n *      (3) If the sequence is not found, the offset will be set to -1.\n */",
      "file" : "utils.c"
   },
   {
      "function" : "barcodeDecode2of5",
      "comment" : "/*!\n *  barcodeDecode2of5()\n *\n *      Input:  barstr (of widths, in set {1, 2})\n *              debugflag\n *      Return: data (string of digits), or null if none found or on error\n *\n *  Notes:\n *      (1) Ref: http://en.wikipedia.org/wiki/Two-out-of-five_code (Note:\n *                 the codes given here are wrong!)\n *               http://morovia.com/education/symbology/code25.asp\n *      (2) This is a very low density encoding for the 10 digits.\n *          Each digit is encoded with 5 black bars, of which 2 are wide\n *          and 3 are narrow.  No information is carried in the spaces\n *          between the bars, which are all equal in width, represented by\n *          a \"1\" in our encoding.\n *      (3) The mapping from the sequence of five bar widths to the\n *          digit is identical to the mapping used by the interleaved\n *          2 of 5 code.  The start code is 21211, representing two\n *          wide bars and a narrow bar, and the interleaved \"1\" spaces\n *          are explicit.  The stop code is 21112.  For all codes\n *          (including start and stop), the trailing space \"1\" is\n *          implicit -- there is no reason to represent it in the\n *          Code2of5[] array.\n */",
      "file" : "bardecode.c"
   },
   {
      "function" : "barcodeDecode39",
      "comment" : "/*!\n *  barcodeDecode39()\n *\n *      Input:  barstr (of widths, in set {1, 2})\n *              debugflag\n *      Return: data (string of digits), or null if none found or on error\n *\n *  Notes:\n *      (1) Ref:  http://en.wikipedia.org/wiki/Code39\n *                http://morovia.com/education/symbology/code39.asp\n *      (2) Each symbol has 5 black and 4 white bars.\n *          The start and stop codes are 121121211 (the asterisk)\n *      (3) This decoder was contributed by Roger Hyde.\n */",
      "file" : "bardecode.c"
   },
   {
      "function" : "barcodeDecode93",
      "comment" : "/*!\n *  barcodeDecode93()\n *\n *      Input:  barstr (of widths, in set {1, 2, 3, 4})\n *              debugflag\n *      Return: data (string of digits), or null if none found or on error\n *\n *  Notes:\n *      (1) Ref:  http://en.wikipedia.org/wiki/Code93\n *                http://morovia.com/education/symbology/code93.asp\n *      (2) Each symbol has 3 black and 3 white bars.\n *          The start and stop codes are 111141; the stop code then is\n *          terminated with a final (1) bar.\n *      (3) The last two codes are check codes.  We are checking them\n *          for correctness, and issuing a warning on failure.  Should\n *          probably not return any data on failure.\n */",
      "file" : "bardecode.c"
   },
   {
      "function" : "barcodeDecodeCodabar",
      "comment" : "/*!\n *  barcodeDecodeCodabar()\n *\n *      Input:  barstr (of widths, in set {1, 2})\n *              debugflag\n *      Return: data (string of digits), or null if none found or on error\n *\n *  Notes:\n *      (1) Ref:  http://en.wikipedia.org/wiki/Codabar\n *                http://morovia.com/education/symbology/codabar.asp\n *      (2) Each symbol has 4 black and 3 white bars.  They represent the\n *          10 digits, and optionally 6 other characters.  The start and\n *          stop codes can be any of four (typically denoted A,B,C,D).\n */",
      "file" : "bardecode.c"
   },
   {
      "function" : "barcodeDecodeEan13",
      "comment" : "/*!\n *  barcodeDecodeEan13()\n *\n *      Input:  barstr (of widths, in set {1, 2, 3, 4})\n *              first (first digit: 0 - 9)\n *              debugflag\n *      Return: data (string of digits), or null if none found or on error\n *\n *  Notes:\n *      (1) Ref:  http://en.wikipedia.org/wiki/UniversalProductCode\n *                http://morovia.com/education/symbology/ean-13.asp\n *      (2) The encoding is essentially the same as UPC-A, except\n *          there are 13 digits in total, of which 12 are encoded\n *          by bars (as with UPC-A) and the 13th is a leading digit\n *          that determines the encoding of the next 6 digits,\n *          selecting each digit from one of two tables.\n *          encoded in the bars (as with UPC-A).  If the first digit\n *          is 0, the encoding is identical to UPC-A.\n *      (3) As with UPC-A, the last digit is a check digit.\n *      (4) For now, we assume the first digit is input to this function.\n *          Eventually, we will read it by pattern matching.\n *\n *    TODO: fix this for multiple tables, depending on the value of @first\n */",
      "file" : "bardecode.c"
   },
   {
      "function" : "barcodeDecodeI2of5",
      "comment" : "/*!\n *  barcodeDecodeI2of5()\n *\n *      Input:  barstr (of widths, in set {1, 2})\n *              debugflag\n *      Return: data (string of digits), or null if none found or on error\n *\n *  Notes:\n *      (1) Ref: http://en.wikipedia.org/wiki/Interleaved_2_of_5\n *      (2) This always encodes an even number of digits.\n *          The start code is 1111; the stop code is 211.\n */",
      "file" : "bardecode.c"
   },
   {
      "function" : "barcodeDecodeUpca",
      "comment" : "/*!\n *  barcodeDecodeUpca()\n *\n *      Input:  barstr (of widths, in set {1, 2, 3, 4})\n *              debugflag\n *      Return: data (string of digits), or null if none found or on error\n *\n *  Notes:\n *      (1) Ref:  http://en.wikipedia.org/wiki/UniversalProductCode\n *                http://morovia.com/education/symbology/upc-a.asp\n *      (2) Each symbol has 2 black and 2 white bars, and encodes a digit.\n *          The start and stop codes are 111 and 111.  There are a total of\n *          30 black bars, encoding 12 digits in two sets of 6, with\n *          2 black bars separating the sets.\n *      (3) The last digit is a check digit.  We check for correctness, and\n *          issue a warning on failure.  Should probably not return any\n *          data on failure.\n */",
      "file" : "bardecode.c"
   },
   {
      "function" : "barcodeDispatchDecoder",
      "comment" : "/*!\n *  barcodeDispatchDecoder()\n *\n *      Input:  barstr (string of integers in set {1,2,3,4} of bar widths)\n *              format (L_BF_ANY, L_BF_CODEI2OF5, L_BF_CODE93, ...)\n *              debugflag (use 1 to generate debug output)\n *      Return: data (string of decoded barcode data), or null on error\n */",
      "file" : "bardecode.c"
   },
   {
      "function" : "barcodeFindFormat",
      "comment" : "/*!\n *  barcodeFindFormat()\n *\n *      Input:  barstr (of barcode widths, in set {1,2,3,4})\n *      Return: format (for barcode), or L_BF_UNKNOWN if not recognized\n */",
      "file" : "bardecode.c"
   },
   {
      "function" : "barcodeFormatIsSupported",
      "comment" : "/*!\n *  barcodeFormatIsSupported()\n *\n *      Input:  format\n *      Return: 1 if format is one of those supported; 0 otherwise\n *\n */",
      "file" : "bardecode.c"
   },
   {
      "function" : "barcodeVerifyFormat",
      "comment" : "/*!\n *  barcodeVerifyFormat()\n *\n *      Input:  barstr (of barcode widths, in set {1,2,3,4})\n *              format (L_BF_CODEI2OF5, L_BF_CODE93, ...)\n *              &valid (<return> 0 if not valid, 1 and 2 if valid)\n *              &reverse (<optional return> 1 if reversed; 0 otherwise)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If valid == 1, the barcode is of the given format in the\n *          forward order; if valid == 2, it is backwards.\n *      (2) If the barcode needs to be reversed to read it, and &reverse\n *          is provided, a 1 is put into @reverse.\n *      (3) Add to this as more formats are supported.\n */",
      "file" : "bardecode.c"
   },
   {
      "function" : "bbufferBytesToWrite",
      "comment" : "/*!\n *  bbufferBytesToWrite()\n *\n *      Input:  bbuffer\n *              &nbytes (<return>)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "bbuffer.c"
   },
   {
      "function" : "bbufferCreate",
      "comment" : "/*!\n *  bbufferCreate()\n *\n *      Input:  buffer address in memory (<optional>)\n *              size of byte array to be alloc'd (0 for default)\n *      Return: bbuffer, or null on error\n *\n *  Notes:\n *      (1) If a buffer address is given, you should read all the data in.\n *      (2) Allocates a bbuffer with associated byte array of\n *          the given size.  If a buffer address is given,\n *          it then reads the number of bytes into the byte array.\n */",
      "file" : "bbuffer.c"
   },
   {
      "function" : "bbufferDestroy",
      "comment" : "/*!\n *  bbufferDestroy()\n *\n *      Input:  &bbuffer  (<to be nulled>)\n *      Return: void\n *\n *  Notes:\n *      (1) Destroys the byte array in the bbuffer and then the bbuffer;\n *          then nulls the contents of the input ptr.\n */",
      "file" : "bbuffer.c"
   },
   {
      "function" : "bbufferDestroyAndSaveData",
      "comment" : "/*!\n *  bbufferDestroyAndSaveData()\n *\n *      Input:  &bbuffer (<to be nulled>)\n *              &nbytes  (<return> number of bytes saved in array)\n *      Return: barray (newly allocated array of data)\n *\n *  Notes:\n *      (1) Copies data to newly allocated array; then destroys the bbuffer.\n */",
      "file" : "bbuffer.c"
   },
   {
      "function" : "bbufferExtendArray",
      "comment" : "/*!\n *  bbufferExtendArray()\n *\n *      Input:  bbuffer\n *              nbytes  (number of bytes to extend array size)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) reallocNew() copies all bb->nalloc bytes, even though\n *          only bb->n are data.\n */",
      "file" : "bbuffer.c"
   },
   {
      "function" : "bbufferRead",
      "comment" : "/*!\n *  bbufferRead()\n *\n *      Input:  bbuffer\n *              src      (source memory buffer from which bytes are read)\n *              nbytes   (bytes to be read)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) For a read after write, first remove the written\n *          bytes by shifting the unwritten bytes in the array,\n *          then check if there is enough room to add the new bytes.\n *          If not, realloc with bbufferExpandArray(), resulting\n *          in a second writing of the unwritten bytes.  While less\n *          efficient, this is simpler than making a special case\n *          of reallocNew().\n */",
      "file" : "bbuffer.c"
   },
   {
      "function" : "bbufferReadStdin",
      "comment" : "/*!\n *  bbufferReadStdin()\n *\n *      Input:  &data (<return> binary data read in)\n *              &nbytes (<return>)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This can be used to capture data piped in from stdin.\n *          For example, you can read an image from stdin into memory\n *          using shell redirection, with one of these:\n *             cat <imagefile> | readprog\n *             readprog < <imagefile>\n *          where readprog is:\n *             bbufferReadStdin(&data, &nbytes);  // l_uint8*, size_t\n *             Pix *pix = pixReadMem(data, nbytes);\n */",
      "file" : "bbuffer.c"
   },
   {
      "function" : "bbufferReadStream",
      "comment" : "/*!\n *  bbufferReadStream()\n *\n *      Input:  bbuffer\n *              fp      (source stream from which bytes are read)\n *              nbytes   (bytes to be read)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "bbuffer.c"
   },
   {
      "function" : "bbufferWrite",
      "comment" : "/*!\n *  bbufferWrite()\n *\n *      Input:  bbuffer\n *              dest     (dest memory buffer to which bytes are written)\n *              nbytes   (bytes requested to be written)\n *              &nout    (<return> bytes actually written)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "bbuffer.c"
   },
   {
      "function" : "bbufferWriteStream",
      "comment" : "/*!\n *  bbufferWriteStream()\n *\n *      Input:  bbuffer\n *              fp       (dest stream to which bytes are written)\n *              nbytes   (bytes requested to be written)\n *              &nout    (<return> bytes actually written)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "bbuffer.c"
   },
   {
      "function" : "bilateralApply",
      "comment" : "/*!\n *  bilateralApply()\n *\n *      Input:  bil\n *      Return: pixd\n */",
      "file" : "bilateral.c"
   },
   {
      "function" : "bilateralCreate",
      "comment" : "/*!\n *  bilateralCreate()\n *\n *      Input:  pixs (8 bpp gray, no colormap)\n *              spatial_stdev  (of gaussian kernel; in pixels, > 0.5)\n *              range_stdev  (of gaussian range kernel; > 5.0; typ. 50.0)\n *              ncomps (number of intermediate sums J(k,x); in [4 ... 30])\n *              reduction  (1, 2 or 4)\n *      Return: bil, or null on error\n *\n *  Notes:\n *      (1) This initializes a bilateral filtering operation, generating all\n *          the data required.  It takes most of the time in the bilateral\n *          filtering operation.\n *      (2) See bilateral.h for details of the algorithm.\n *      (3) See pixBilateral() for constraints on input parameters, which\n *          are not checked here.\n */",
      "file" : "bilateral.c"
   },
   {
      "function" : "bilateralDestroy",
      "comment" : "/*!\n *  bilateralDestroy()\n *\n *      Input:  &bil\n *      Return: void\n */",
      "file" : "bilateral.c"
   },
   {
      "function" : "bilinearXformPt",
      "comment" : "/*!\n *  bilinearXformPt()\n *\n *      Input:  vc (vector of 8 coefficients)\n *              (x, y)  (initial point)\n *              (&xp, &yp)   (<return> transformed point)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This computes the floating point location of the transformed point.\n *      (2) It does not check ptrs for returned data!\n */",
      "file" : "bilinear.c"
   },
   {
      "function" : "bilinearXformSampledPt",
      "comment" : "/*!\n *  bilinearXformSampledPt()\n *\n *      Input:  vc (vector of 8 coefficients)\n *              (x, y)  (initial point)\n *              (&xp, &yp)   (<return> transformed point)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This finds the nearest pixel coordinates of the transformed point.\n *      (2) It does not check ptrs for returned data!\n */",
      "file" : "bilinear.c"
   },
   {
      "function" : "blendComponents",
      "comment" : "/* Check limits for src1, in case clipping was not done */",
      "file" : "blend.c"
   },
   {
      "function" : "blendHardLightComponents",
      "comment" : "/*\n *  blendHardLightComponents()\n *      Input:  a (8 bpp blendee component)\n *              b (8 bpp blender component)\n *              fract (fraction of blending; use 1.0 for usual definition)\n *      Return: blended 8 bpp component\n *\n *  Notes:\n *\n *    The basic logic for this blending is:\n *      b < 0.5:\n *          a --> 2 * a * (0.5 - f * (0.5 - b))\n *      b >= 0.5:\n *          a --> 1 - 2 * (1 - a) * (1 - (0.5 - f * (0.5 - b)))\n *\n *    In the limit that f == 1 (standard hardlight blending):\n *      b < 0.5:   a --> 2 * a * b\n *                     or\n *                 a --> a - a * (1 - 2 * b)\n *      b >= 0.5:  a --> 1 - 2 * (1 - a) * (1 - b)\n *                     or\n *                 a --> a + (1 - a) * (2 * b - 1)\n *\n *    You can see that for standard hardlight blending:\n *      b < 0.5:   a is pushed linearly with b down to 0\n *      b >= 0.5:  a is pushed linearly with b up to 1\n *    a is unchanged if b = 0.5\n *\n *    Our opacity factor f reduces the deviation of b from 0.5:\n *      f == 0:  b -->  0.5, so no blending occurs\n *      f == 1:  b -->  b, so we get full conventional blending\n *\n *    There is a variant of hardlight blending called \"softlight\" blending:\n *    (e.g., http://jswidget.com/blog/tag/hard-light/)\n *      b < 0.5:\n *          a --> a - a * (0.5 - b) * (1 - Abs(2 * a - 1))\n *      b >= 0.5:\n *          a --> a + (1 - a) * (b - 0.5) * (1 - Abs(2 * a - 1))\n *    which limits the amount that 'a' can be moved to a maximum of\n *    halfway toward 0 or 1, and further reduces it as 'a' moves\n *    away from 0.5.\n *    As you can see, there are a nearly infinite number of different\n *    blending formulas that can be conjured up.\n */",
      "file" : "blend.c"
   },
   {
      "function" : "blockconvAccumLow",
      "comment" : "/*\n *  blockconvAccumLow()\n *\n *      Input:  datad  (32 bpp dest)\n *              w, h, wpld (of 32 bpp dest)\n *              datas (1, 8 or 32 bpp src)\n *              d (bpp of src)\n *              wpls (of src)\n *      Return: void\n *\n *  Notes:\n *      (1) The general recursion relation is\n *             a(i,j) = v(i,j) + a(i-1, j) + a(i, j-1) - a(i-1, j-1)\n *          For the first line, this reduces to the special case\n *             a(i,j) = v(i,j) + a(i, j-1)\n *          For the first column, the special case is\n *             a(i,j) = v(i,j) + a(i-1, j)\n */",
      "file" : "convolvelow.c"
   },
   {
      "function" : "blockconvLow",
      "comment" : "/*!\n *  blockconvLow()\n *\n *      Input:  data   (data of input image, to be convolved)\n *              w, h, wpl\n *              dataa    (data of 32 bpp accumulator)\n *              wpla     (accumulator)\n *              wc      (convolution \"half-width\")\n *              hc      (convolution \"half-height\")\n *      Return: void\n *\n *  Notes:\n *      (1) The full width and height of the convolution kernel\n *          are (2 * wc + 1) and (2 * hc + 1).\n *      (2) The lack of symmetry between the handling of the\n *          first (hc + 1) lines and the last (hc) lines,\n *          and similarly with the columns, is due to fact that\n *          for the pixel at (x,y), the accumulator values are\n *          taken at (x + wc, y + hc), (x - wc - 1, y + hc),\n *          (x + wc, y - hc - 1) and (x - wc - 1, y - hc - 1).\n *      (3) We compute sums, normalized as if there were no reduced\n *          area at the boundary.  This under-estimates the value\n *          of the boundary pixels, so we multiply them by another\n *          normalization factor that is greater than 1.\n *      (4) This second normalization is done first for the first\n *          hc + 1 lines; then for the last hc lines; and finally\n *          for the first wc + 1 and last wc columns in the intermediate\n *          lines.\n *      (5) The caller should verify that wc < w and hc < h.\n *          Under those conditions, illegal reads and writes can occur.\n *      (6) Implementation note: to get the same results in the interior\n *          between this function and pixConvolve(), it is necessary to\n *          add 0.5 for roundoff in the main loop that runs over all pixels.\n *          However, if we do that and have white (255) pixels near the\n *          image boundary, some overflow occurs for pixels very close\n *          to the boundary.  We can't fix this by subtracting from the\n *          normalized values for the boundary pixels, because this results\n *          in underflow if the boundary pixels are black (0).  Empirically,\n *          adding 0.25 (instead of 0.5) before truncating in the main\n *          loop will not cause overflow, but this gives some\n *          off-by-1-level errors in interior pixel values.  So we add\n *          0.5 for roundoff in the main loop, and for pixels within a\n *          half filter width of the boundary, use a L_MIN of the\n *          computed value and 255 to avoid overflow during normalization.\n */",
      "file" : "convolvelow.c"
   },
   {
      "function" : "blocksumLow",
      "comment" : "/*!\n *  blocksumLow()\n *\n *      Input:  datad  (of 8 bpp dest)\n *              w, h, wpl  (of 8 bpp dest)\n *              dataa (of 32 bpp accum)\n *              wpla  (of 32 bpp accum)\n *              wc, hc  (convolution \"half-width\" and \"half-height\")\n *      Return: void\n *\n *  Notes:\n *      (1) The full width and height of the convolution kernel\n *          are (2 * wc + 1) and (2 * hc + 1).\n *      (2) The lack of symmetry between the handling of the\n *          first (hc + 1) lines and the last (hc) lines,\n *          and similarly with the columns, is due to fact that\n *          for the pixel at (x,y), the accumulator values are\n *          taken at (x + wc, y + hc), (x - wc - 1, y + hc),\n *          (x + wc, y - hc - 1) and (x - wc - 1, y - hc - 1).\n *      (3) Compute sums of ON pixels within the block filter size,\n *          normalized between 0 and 255, as if there were no reduced\n *          area at the boundary.  This under-estimates the value\n *          of the boundary pixels, so we multiply them by another\n *          normalization factor that is greater than 1.\n *      (4) This second normalization is done first for the first\n *          hc + 1 lines; then for the last hc lines; and finally\n *          for the first wc + 1 and last wc columns in the intermediate\n *          lines.\n *      (5) The caller should verify that wc < w and hc < h.\n *          Under those conditions, illegal reads and writes can occur.\n */",
      "file" : "convolvelow.c"
   },
   {
      "function" : "bmfCreate",
      "comment" : "/*!\n *  bmfCreate()\n *\n *      Input:  dir (directory holding pixa of character set)\n *              size (4, 6, 8, ... , 20)\n *      Return: bmf (holding the bitmap font and associated information)\n *\n *  Notes:\n *      (1) This first tries to read a pre-computed pixa file with the\n *          95 ascii chars in it.  If the file is not found, it\n *          creates the pixa from the raw image.  It then generates all\n *          associated data required to use the bmf.\n */",
      "file" : "bmf.c"
   },
   {
      "function" : "bmfDestroy",
      "comment" : "/*!\n *  bmfDestroy()\n *\n *      Input:  &bmf (<set to null>)\n *      Return: void\n */",
      "file" : "bmf.c"
   },
   {
      "function" : "bmfGetBaseline",
      "comment" : "/*!\n *  bmfGetBaseline()\n *\n *      Input:  bmf\n *              chr (should be one of the 95 supported bitmaps)\n *              &baseline (<return>; distance below UL corner of bitmap char)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "bmf.c"
   },
   {
      "function" : "bmfGetLineStrings",
      "comment" : "/*!\n *  bmfGetLineStrings()\n *\n *      Input:  bmf\n *              textstr\n *              maxw (max width of a text line in pixels)\n *              firstindent (indentation of first line, in x-widths)\n *              &h (<return> height required to hold text bitmap)\n *      Return: sarray of text strings for each line, or null on error\n *\n *  Notes:\n *      (1) Divides the input text string into an array of text strings,\n *          each of which will fit within maxw bits of width.\n */",
      "file" : "textops.c"
   },
   {
      "function" : "bmfGetPix",
      "comment" : "/*!\n *  bmfGetPix()\n *\n *      Input:  bmf\n *              chr (should be one of the 95 supported printable bitmaps)\n *      Return: pix (clone of pix in bmf), or null on error\n */",
      "file" : "bmf.c"
   },
   {
      "function" : "bmfGetStringWidth",
      "comment" : "/*!\n *  bmfGetStringWidth()\n *\n *      Input:  bmf\n *              textstr\n *              &w (<return> width of text string, in pixels for the\n *                 font represented by the bmf)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "textops.c"
   },
   {
      "function" : "bmfGetWidth",
      "comment" : "/*!\n *  bmfGetWidth()\n *\n *      Input:  bmf\n *              chr (should be one of the 95 supported bitmaps)\n *              &w (<return> character width; -1 if not printable)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "bmf.c"
   },
   {
      "function" : "bmfGetWordWidths",
      "comment" : "/*!\n *  bmfGetWordWidths()\n *\n *      Input:  bmf\n *              textstr\n *              sa (of individual words)\n *      Return: numa (of word lengths in pixels for the font represented\n *                    by the bmf), or null on error\n */",
      "file" : "textops.c"
   },
   {
      "function" : "bmfMakeAsciiTables",
      "comment" : "/*!\n *  bmfMakeAsciiTables\n *\n *      Input:  bmf\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This makes three tables, each of size 128, as follows:\n *          - fonttab is a table containing the index of the Pix\n *            that corresponds to each input ascii character;\n *            it maps (ascii-index) --> Pixa index\n *          - baselinetab is a table containing the baseline offset\n *            for the Pix that corresponds to each input ascii character;\n *            it maps (ascii-index) --> baseline offset\n *          - widthtab is a table containing the character width in\n *            pixels for the Pix that corresponds to that character;\n *            it maps (ascii-index) --> bitmap width\n *     (2) This also computes\n *          - lineheight (sum of maximum character extensions above and\n *                        below the baseline)\n *          - kernwidth (spacing between characters within a word)\n *          - spacewidth (space between words)\n *          - vertlinesep (extra vertical spacing between textlines)\n *     (3) The baselines apply as follows:\n *          baseline1   (ascii 32 - 57), ascii 92\n *          baseline2   (ascii 58 - 91)\n *          baseline3   (ascii 93 - 126)\n *     (4) The only array in bmf that is not ascii-based is the\n *         array of bitmaps in the pixa, which starts at ascii 32.\n */",
      "file" : "bmf.c"
   },
   {
      "function" : "box3dCopy",
      "comment" : "/*\n *  Note: don't copy the sortparam.\n */",
      "file" : "colorquant2.c"
   },
   {
      "function" : "box3dCreate",
      "comment" : "/*!\n *  vboxGetVolume()\n *\n *      Input:  vbox (3d region of color space for one quantized color)\n *      Return: quantized volume of vbox, or 0 on error\n */",
      "file" : "colorquant2.c"
   },
   {
      "function" : "boxAdjustSides",
      "comment" : "/*!\n *  boxAdjustSides()\n *\n *      Input:  boxd  (<optional>; this can be null, equal to boxs,\n *                     or different from boxs)\n *              boxs  (starting box; to have sides adjusted)\n *              delleft, delright, deltop, delbot (changes in location of\n *                                                 each side)\n *      Return: boxd, or null on error or if the computed boxd has\n *              width or height <= 0.\n *\n *  Notes:\n *      (1) Set boxd == NULL to get new box; boxd == boxs for in-place;\n *          or otherwise to resize existing boxd.\n *      (2) For usage, suggest one of these:\n *               boxd = boxAdjustSides(NULL, boxs, ...);   // new\n *               boxAdjustSides(boxs, boxs, ...);          // in-place\n *               boxAdjustSides(boxd, boxs, ...);          // other\n *      (1) New box dimensions are cropped at left and top to x >= 0 and y >= 0.\n *      (2) For example, to expand in-place by 20 pixels on each side, use\n *             boxAdjustSides(box, box, -20, 20, -20, 20);\n */",
      "file" : "boxfunc1.c"
   },
   {
      "function" : "boxBoundingRegion",
      "comment" : "/*!\n *  boxBoundingRegion()\n *\n *      Input:  box1, box2 (two boxes)\n *      Return: box (of bounding region containing the input boxes),\n *              or null on error\n */",
      "file" : "boxfunc1.c"
   },
   {
      "function" : "boxChangeRefcount",
      "comment" : "/*!\n *  boxGetSideLocation()\n *\n *      Input:  box\n *              side (L_GET_LEFT, L_GET_RIGHT, L_GET_TOP, L_GET_BOT)\n *              &loc (<return> location)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) All returned values are within the box.  In particular:\n *            right = left + width - 1\n *            bottom = top + height - 1\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxCheckIfOverlapIsBig",
      "comment" : "/*!\n *  boxCheckIfOverlapIsBig()\n *\n *      Input:  box (to be tested)\n *              boxa (of boxes already stored)\n *              maxoverlap (maximum fractional overlap of the input box\n *                          by any of the boxes in boxa)\n *      Return: 0 if box has small overlap with every box in boxa;\n *              1 otherwise or on error\n */",
      "file" : "partition.c"
   },
   {
      "function" : "boxClipToRectangle",
      "comment" : "/*!\n *  boxClipToRectangle()\n *\n *      Input:  box\n *              wi, hi (rectangle representing image)\n *      Return: part of box within given rectangle, or NULL on error\n *              or if box is entirely outside the rectangle\n *\n *  Notes:\n *      (1) This can be used to clip a rectangle to an image.\n *          The clipping rectangle is assumed to have a UL corner at (0, 0),\n *          and a LR corner at (wi - 1, hi - 1).\n */",
      "file" : "boxfunc1.c"
   },
   {
      "function" : "boxClipToRectangleParams",
      "comment" : "/*!\n *  boxClipToRectangleParams()\n *\n *      Input:  box (<optional> requested box; can be null)\n *              w, h (clipping box size; typ. the size of an image)\n *              &xstart (<return>)\n *              &ystart (<return>)\n *              &xend (<return> one pixel beyond clipping box)\n *              &yend (<return> one pixel beyond clipping box)\n *              &bw (<optional return> clipped width)\n *              &bh (<optional return> clipped height)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) The return value should be checked.  If it is 1, the\n *          returned parameter values are bogus.\n *      (2) This simplifies the selection of pixel locations within\n *          a given rectangle:\n *             for (i = ystart; i < yend; i++ {\n *                 ...\n *                 for (j = xstart; j < xend; j++ {\n *                     ....\n */",
      "file" : "boxfunc1.c"
   },
   {
      "function" : "boxClone",
      "comment" : "/*!\n *  boxClone()\n *\n *      Input:  box\n *      Return: ptr to same box, or null on error\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxContains",
      "comment" : "/*!\n *  boxContains()\n *\n *      Input:  box1, box2\n *              &result (<return> 1 if box2 is entirely contained within\n *                       box1, and 0 otherwise)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "boxfunc1.c"
   },
   {
      "function" : "boxContainsPt",
      "comment" : "/*!\n *  boxContainsPt()\n *\n *      Input:  box\n *              x, y (a point)\n *              &contains (<return> 1 if box contains point; 0 otherwise)\n *      Return: 0 if OK, 1 on error.\n */",
      "file" : "boxfunc1.c"
   },
   {
      "function" : "boxCopy",
      "comment" : "/*!\n *  boxCopy()\n *\n *      Input:  box\n *      Return: copy of box, or null on error\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxCreate",
      "comment" : "/*!\n *  boxCreate()\n *\n *      Input:  x, y, w, h\n *      Return: box, or null on error\n *\n *  Notes:\n *      (1) This clips the box to the +quad.  If no part of the\n *          box is in the +quad, this returns NULL.\n *      (2) We allow you to make a box with w = 0 and/or h = 0.\n *          This does not represent a valid region, but it is useful\n *          as a placeholder in a boxa for which the index of the\n *          box in the boxa is important.  This is an atypical\n *          situation; usually you want to put only valid boxes with\n *          nonzero width and height in a boxa.  If you have a boxa\n *          with invalid boxes, the accessor boxaGetValidBox()\n *          will return NULL on each invalid box.\n *      (3) If you want to create only valid boxes, use boxCreateValid(),\n *          which returns NULL if either w or h is 0.\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxCreateValid",
      "comment" : "/*!\n *  boxCreateValid()\n *\n *      Input:  x, y, w, h\n *      Return: box, or null on error\n *\n *  Notes:\n *      (1) This returns NULL if either w = 0 or h = 0.\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxDestroy",
      "comment" : "/*!\n *  boxDestroy()\n *\n *      Input:  &box (<will be set to null before returning>)\n *      Return: void\n *\n *  Notes:\n *      (1) Decrements the ref count and, if 0, destroys the box.\n *      (2) Always nulls the input ptr.\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxEqual",
      "comment" : "/*!\n *  boxEqual()\n *\n *      Input:  box1\n *              box2\n *              &same (<return> 1 if equal; 0 otherwise)\n *      Return  0 if OK, 1 on error\n */",
      "file" : "boxfunc1.c"
   },
   {
      "function" : "boxGetCenter",
      "comment" : "/*!\n *  boxGetCenter()\n *\n *      Input:  box\n *              &cx, &cy (<return> location of center of box)\n *      Return  0 if OK, 1 on error\n */",
      "file" : "boxfunc1.c"
   },
   {
      "function" : "boxGetGeometry",
      "comment" : "/*!\n *  boxGetGeometry()\n *\n *      Input:  box\n *              &x, &y, &w, &h (<optional return>; each can be null)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxGetRefcount",
      "comment" : "/*!\n *  boxGetSideLocation()\n *\n *      Input:  box\n *              side (L_GET_LEFT, L_GET_RIGHT, L_GET_TOP, L_GET_BOT)\n *              &loc (<return> location)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) All returned values are within the box.  In particular:\n *            right = left + width - 1\n *            bottom = top + height - 1\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxGetSideLocation",
      "comment" : "/*!\n *  boxGetSideLocation()\n *\n *      Input:  box\n *              side (L_GET_LEFT, L_GET_RIGHT, L_GET_TOP, L_GET_BOT)\n *              &loc (<return> location)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) All returned values are within the box.  In particular:\n *            right = left + width - 1\n *            bottom = top + height - 1\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxIntersectByLine",
      "comment" : "/*!\n *  boxIntersectByLine()\n *\n *      Input:  box\n *              x, y (point that line goes through)\n *              slope (of line)\n *              (&x1, &y1) (<return> 1st point of intersection with box)\n *              (&x2, &y2) (<return> 2nd point of intersection with box)\n *              &n (<return> number of points of intersection)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If the intersection is at only one point (a corner), the\n *          coordinates are returned in (x1, y1).\n *      (2) Represent a vertical line by one with a large but finite slope.\n */",
      "file" : "boxfunc1.c"
   },
   {
      "function" : "boxIntersects",
      "comment" : "/*!\n *  boxIntersects()\n *\n *      Input:  box1, box2\n *              &result (<return> 1 if any part of box2 is contained\n *                      in box1, and 0 otherwise)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "boxfunc1.c"
   },
   {
      "function" : "boxIsValid",
      "comment" : "/*!\n *  boxIsValid()\n *\n *      Input:  box\n *              &valid (<return> 1 if valid; 0 otherwise)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxOverlapArea",
      "comment" : "/*!\n *  boxOverlapArea()\n *\n *      Input:  box1, box2 (two boxes)\n *              &area (<return> the number of pixels in the overlap)\n *      Return: 0 if OK, 1 on error.\n */",
      "file" : "boxfunc1.c"
   },
   {
      "function" : "boxOverlapFraction",
      "comment" : "/*!\n *  boxOverlapFraction()\n *\n *      Input:  box1, box2 (two boxes)\n *              &fract (<return> the fraction of box2 overlapped by box1)\n *      Return: 0 if OK, 1 on error.\n *\n *  Notes:\n *      (1) The result depends on the order of the input boxes,\n *          because the overlap is taken as a fraction of box2.\n */",
      "file" : "boxfunc1.c"
   },
   {
      "function" : "boxOverlapRegion",
      "comment" : "/*!\n *  boxOverlapRegion()\n *\n *      Input:  box1, box2 (two boxes)\n *      Return: box (of overlap region between input boxes),\n *              or null if no overlap or on error\n */",
      "file" : "boxfunc1.c"
   },
   {
      "function" : "boxPrintStreamInfo",
      "comment" : "/*!\n *  boxPrintStreamInfo()\n *\n *      Input:  stream\n *              box\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This outputs debug info.  Use serialization functions to\n *          write to file if you want to read the data back.\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxRelocateOneSide",
      "comment" : "/*!\n *  boxRelocateOneSide()\n *\n *      Input:  boxd (<optional>; this can be null, equal to boxs,\n *                    or different from boxs);\n *              boxs (starting box; to have one side relocated)\n *              loc (new location of the side that is changing)\n *              sideflag (L_FROM_LEFT, etc., indicating the side that moves)\n *      Return: boxd, or null on error or if the computed boxd has\n *              width or height <= 0.\n *\n *  Notes:\n *      (1) Set boxd == NULL to get new box; boxd == boxs for in-place;\n *          or otherwise to resize existing boxd.\n *      (2) For usage, suggest one of these:\n *               boxd = boxRelocateOneSide(NULL, boxs, ...);   // new\n *               boxRelocateOneSide(boxs, boxs, ...);          // in-place\n *               boxRelocateOneSide(boxd, boxs, ...);          // other\n */",
      "file" : "boxfunc1.c"
   },
   {
      "function" : "boxRotateOrth",
      "comment" : "/*!\n *  boxRotateOrth()\n *\n *      Input:  box\n *              w, h (of image in which the box is embedded)\n *              rotation (0 = noop, 1 = 90 deg, 2 = 180 deg, 3 = 270 deg;\n *                        all rotations are clockwise)\n *      Return: boxd, or null on error\n *\n *  Notes:\n *      (1) Rotate the image with the embedded box by the specified amount.\n *      (2) After rotation, the rotated box is always measured with\n *          respect to the UL corner of the image.\n */",
      "file" : "boxfunc2.c"
   },
   {
      "function" : "boxSeparationDistance",
      "comment" : "/*!\n *  boxSeparationDistance()\n *\n *      Input:  box1, box2 (two boxes, in any order)\n *              &h_sep (<optional return> horizontal separation)\n *              &v_sep (<optional return> vertical separation)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This measures horizontal and vertical separation of the\n *          two boxes.  If the boxes are touching but have no pixels\n *          in common, the separation is 0.  If the boxes overlap by\n *          a distance d, the returned separation is -d.\n */",
      "file" : "boxfunc1.c"
   },
   {
      "function" : "boxSetGeometry",
      "comment" : "/*!\n *  boxSetGeometry()\n *\n *      Input:  box\n *              x, y, w, h (use -1 to leave unchanged)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxSimilar",
      "comment" : "/*!\n *  boxSimilar()\n *\n *      Input:  box1\n *              box2\n *              leftdiff, rightdiff, topdiff, botdiff\n *              &similar (<return> 1 if similar; 0 otherwise)\n *      Return  0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The values of leftdiff (etc) are the maximum allowed deviations\n *          between the locations of the left (etc) sides.  If any side\n *          pairs differ by more than this amount, the boxes are not similar.\n */",
      "file" : "boxfunc1.c"
   },
   {
      "function" : "boxTransform",
      "comment" : "/*!\n *  boxTransform()\n *\n *      Input:  box\n *              shiftx, shifty\n *              scalex, scaley\n *      Return: boxd, or null on error\n *\n *  Notes:\n *      (1) This is a very simple function that first shifts, then scales.\n *      (2) If the box is invalid, a new invalid box is returned.\n */",
      "file" : "boxfunc2.c"
   },
   {
      "function" : "boxTransformOrdered",
      "comment" : "/*!\n *  boxTransformOrdered()\n *\n *      Input:  boxs\n *              shiftx, shifty\n *              scalex, scaley\n *              xcen, ycen (center of rotation)\n *              angle (in radians; clockwise is positive)\n *              order (one of 6 combinations: L_TR_SC_RO, ...)\n *      Return: boxd, or null on error\n *\n *  Notes:\n *      (1) This allows a sequence of linear transforms, composed of\n *          shift, scaling and rotation, where the order of the\n *          transforms is specified.\n *      (2) The rotation is taken about a point specified by (xcen, ycen).\n *          Let the components of the vector from the center of rotation\n *          to the box center be (xdif, ydif):\n *            xdif = (bx + 0.5 * bw) - xcen\n *            ydif = (by + 0.5 * bh) - ycen\n *          Then the box center after rotation has new components:\n *            bxcen = xcen + xdif * cosa + ydif * sina\n *            bycen = ycen + ydif * cosa - xdif * sina\n *          where cosa and sina are the cos and sin of the angle,\n *          and the enclosing box for the rotated box has size:\n *            rw = |bw * cosa| + |bh * sina|\n *            rh = |bh * cosa| + |bw * sina|\n *          where bw and bh are the unrotated width and height.\n *          Then the box UL corner (rx, ry) is\n *            rx = bxcen - 0.5 * rw\n *            ry = bycen - 0.5 * rh\n *      (3) The center of rotation specified by args @xcen and @ycen\n *          is the point BEFORE any translation or scaling.  If the\n *          rotation is not the first operation, this function finds\n *          the actual center at the time of rotation.  It does this\n *          by making the following assumptions:\n *             (1) Any scaling is with respect to the UL corner, so\n *                 that the center location scales accordingly.\n *             (2) A translation does not affect the center of\n *                 the image; it just moves the boxes.\n *          We always use assumption (1).  However, assumption (2)\n *          will be incorrect if the apparent translation is due\n *          to a clipping operation that, in effect, moves the\n *          origin of the image.  In that case, you should NOT use\n *          these simple functions.  Instead, use the functions\n *          in affinecompose.c, where the rotation center can be\n *          computed from the actual clipping due to translation\n *          of the image origin.\n */",
      "file" : "boxfunc2.c"
   },
   {
      "function" : "boxaAddBox",
      "comment" : "/*!\n *  boxaAddBox()\n *\n *      Input:  boxa\n *              box  (to be added)\n *              copyflag (L_INSERT, L_COPY, L_CLONE)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaAdjustHeightToTarget",
      "comment" : "/*!\n *  boxaAdjustHeightToTarget()\n *\n *      Input:  boxad (use null to get a new one)\n *              boxas\n *              sides (L_ADJUST_TOP, L_ADJUST_BOT, L_ADJUST_TOP_AND_BOT)\n *              target (target height if differs by more than thresh)\n *              thresh (min abs difference in height to cause adjustment)\n *      Return: boxad, or null on error\n *\n *  Notes:\n *      (1) Conditionally adjusts the height of each box, by moving\n *          the indicated edges (top and/or bot) if the height differs\n *          by @thresh or more from @target.\n *      (2) Use boxad == NULL for a new boxa, and boxad == boxas for in-place.\n *          Use one of these:\n *               boxad = boxaAdjustHeightToTarget(NULL, boxas, ...);   // new\n *               boxaAdjustHeightToTarget(boxas, boxas, ...);  // in-place\n */",
      "file" : "boxfunc1.c"
   },
   {
      "function" : "boxaAdjustWidthToTarget",
      "comment" : "/*!\n *  boxaAdjustWidthToTarget()\n *\n *      Input:  boxad (use null to get a new one; same as boxas for in-place)\n *              boxas\n *              sides (L_ADJUST_LEFT, L_ADJUST_RIGHT, L_ADJUST_LEFTL_AND_RIGHT)\n *              target (target width if differs by more than thresh)\n *              thresh (min abs difference in width to cause adjustment)\n *      Return: boxad, or null on error\n *\n *  Notes:\n *      (1) Conditionally adjusts the width of each box, by moving\n *          the indicated edges (left and/or right) if the width differs\n *          by @thresh or more from @target.\n *      (2) Use boxad == NULL for a new boxa, and boxad == boxas for in-place.\n *          Use one of these:\n *               boxad = boxaAdjustWidthToTarget(NULL, boxas, ...);   // new\n *               boxaAdjustWidthToTarget(boxas, boxas, ...);  // in-place\n */",
      "file" : "boxfunc1.c"
   },
   {
      "function" : "boxaAffineTransform",
      "comment" : "/*!\n *  boxaAffineTransform()\n *\n *      Input:  boxas\n *              mat  (3x3 transform matrix; canonical form)\n *      Return: boxad  (transformed boxas), or null on error\n */",
      "file" : "affinecompose.c"
   },
   {
      "function" : "boxaBinSort",
      "comment" : "/*!\n *  boxaBinSort()\n *\n *      Input:  boxa\n *              sorttype (L_SORT_BY_X, L_SORT_BY_Y, L_SORT_BY_WIDTH,\n *                        L_SORT_BY_HEIGHT, L_SORT_BY_PERIMETER)\n *              sortorder  (L_SORT_INCREASING, L_SORT_DECREASING)\n *              &naindex (<optional return> index of sorted order into\n *                        original array)\n *      Return: boxad (sorted version of boxas), or null on error\n *\n *  Notes:\n *      (1) For a large number of boxes (say, greater than 1000), this\n *          O(n) binsort is much faster than the O(nlogn) shellsort.\n *          For 5000 components, this is over 20x faster than boxaSort().\n *      (2) Consequently, boxaSort() calls this function if it will\n *          likely go much faster.\n */",
      "file" : "boxfunc2.c"
   },
   {
      "function" : "boxaClear",
      "comment" : "/*!\n *  boxaClear()\n *\n *      Input:  boxa\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This destroys all boxes in the boxa, setting the ptrs\n *          to null.  The number of allocated boxes, n, is set to 0.\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaClipToBox",
      "comment" : "/*!\n *  boxaClipToBox()\n *\n *      Input:  boxas\n *              box (for clipping)\n *      Return  boxad (boxa with boxes in boxas clipped to box),\n *                     or null on error\n *\n *  Notes:\n *      (1) All boxes in boxa not intersecting with box are removed, and\n *          the remaining boxes are clipped to box.\n */",
      "file" : "boxfunc1.c"
   },
   {
      "function" : "boxaCombineOverlaps",
      "comment" : "/*!\n *  boxaCombineOverlaps()\n *\n *      Input:  boxas\n *      Return: boxad (where each set of boxes in boxas that overlap are\n *                     combined into a single bounding box in boxad), or\n *                     null on error.\n *\n *  Notes:\n *      (1) If there are no overlapping boxes, it simply returns a copy\n *          of @boxas.\n *      (2) The alternative method of painting each rectanle and finding\n *          the 4-connected components gives the wrong result, because\n *          two non-overlapping rectangles, when rendered, can still\n *          be 4-connected, and hence they will be joined.\n *      (3) A bad case is to have n boxes, none of which overlap.\n *          Then you have one iteration with O(n^2) compares.  This\n *          is still faster than painting each rectangle and finding\n *          the connected components, even for thousands of rectangles.\n */",
      "file" : "boxfunc1.c"
   },
   {
      "function" : "boxaCompareRegions",
      "comment" : "/*!\n *  boxaCompareRegions()\n *\n *      Input:  boxa1, boxa2\n *              areathresh (minimum area of boxes to be considered)\n *              &pnsame  (<return> true if same number of boxes)\n *              &pdiffarea (<return> fractional difference in total area)\n *              &pdiffxor (<optional return> fractional difference\n *                         in xor of regions)\n *              &pixdb (<optional return> debug pix showing two boxa)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This takes 2 boxa, removes all boxes smaller than a given area,\n *          and compares the remaining boxes between the boxa.\n *      (2) The area threshold is introduced to help remove noise from\n *          small components.  Any box with a smaller value of w * h\n *          will be removed from consideration.\n *      (3) The xor difference is the most stringent test, requiring alignment\n *          of the corresponding boxes.  It is also more computationally\n *          intensive and is optionally returned.  Alignment is to the\n *          UL corner of each region containing all boxes, as given by\n *          boxaGetExtent().\n *      (4) Both fractional differences are with respect to the total\n *          area in the two boxa.  They range from 0.0 to 1.0.\n *          A perfect match has value 0.0.  If both boxa are empty,\n *          we return 0.0; if one is empty we return 1.0.\n *      (5) An example input might be the rectangular regions of a\n *          segmentation mask for text or images from two pages.\n */",
      "file" : "boxfunc3.c"
   },
   {
      "function" : "boxaConstrainSize",
      "comment" : "/*!\n *  boxaConstrainSize()\n *\n *      Input:  boxas\n *              width (force width of all boxes to this size;\n *                     input 0 to use the median width)\n *              widthflag (L_ADJUST_SKIP, L_ADJUST_LEFT, L_ADJUST_RIGHT,\n *                         or L_ADJUST_LEFT_AND_RIGHT)\n *              height (force height of all boxes to this size;\n *                      input 0 to use the median height)\n *              heightflag (L_ADJUST_SKIP, L_ADJUST_TOP, L_ADJUST_BOT,\n *                          or L_ADJUST_TOP_AND_BOT)\n *      Return: boxad (adjusted so all boxes are the same size)\n *\n *  Notes:\n *      (1) Forces either width or height (or both) of every box in\n *          the boxa to a specified size, by moving the indicated sides.\n *      (2) All input boxes should be valid.  Median values will be\n *          used with invalid boxes.\n *      (3) Typical input might be the output of boxaLinearFit(),\n *          where each side has been fit.\n *      (4) Unlike boxaAdjustWidthToTarget() and boxaAdjustHeightToTarget(),\n *          this is not dependent on a difference threshold to change the size.\n */",
      "file" : "boxfunc4.c"
   },
   {
      "function" : "boxaContainedInBox",
      "comment" : "/*!\n *  boxaContainedInBox()\n *\n *      Input:  boxas\n *              box (for containment)\n *      Return: boxad (boxa with all boxes in boxas that are\n *                     entirely contained in box), or null on error\n *\n *  Notes:\n *      (1) All boxes in boxa that are entirely outside box are removed.\n */",
      "file" : "boxfunc1.c"
   },
   {
      "function" : "boxaConvertToPta",
      "comment" : "/*!\n *  boxaConvertToPta()\n *\n *      Input:  boxa\n *              ncorners (2 or 4 for the representation of each box)\n *      Return: pta (with @ncorners points for each box in the boxa),\n *                   or null on error\n *\n *  Notes:\n *      (1) If ncorners == 2, we select the UL and LR corners.\n *          Otherwise we save all 4 corners in this order: UL, UR, LL, LR.\n */",
      "file" : "boxfunc4.c"
   },
   {
      "function" : "boxaCopy",
      "comment" : "/*!\n *  boxaCopy()\n *\n *      Input:  boxa\n *              copyflag (L_COPY, L_CLONE, L_COPY_CLONE)\n *      Return: new boxa, or null on error\n *\n *  Notes:\n *      (1) See pix.h for description of the copyflag.\n *      (2) The copy-clone makes a new boxa that holds clones of each box.\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaCreate",
      "comment" : "/*!\n *  boxaCreate()\n *\n *      Input:  n  (initial number of ptrs)\n *      Return: boxa, or null on error\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaDestroy",
      "comment" : "/*!\n *  boxaDestroy()\n *\n *      Input:  &boxa (<will be set to null before returning>)\n *      Return: void\n *\n *  Note:\n *      - Decrements the ref count and, if 0, destroys the boxa.\n *      - Always nulls the input ptr.\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaDisplayTiled",
      "comment" : "/*!\n *  boxaDisplayTiled()\n *\n *      Input:  boxa\n *              pixa (<optional> background for each box)\n *              maxwidth (of output image)\n *              linewidth (width of box outlines, before scaling)\n *              scalefactor (applied to every box; use 1.0 for no scaling)\n *              background (0 for white, 1 for black; this is the color\n *                          of the spacing between the images)\n *              spacing  (between images, and on outside)\n *              border (width of black border added to each image;\n *                      use 0 for no border)\n *              fontdir (<optional> can be NULL; use to number the boxes)\n *      Return: pixd (of tiled images of boxes), or null on error\n *\n *  Notes:\n *      (1) Displays each box separately in a tiled 32 bpp image.\n *      (2) If pixa is defined, it must have the same count as the boxa,\n *          and it will be a background over with each box is rendered.\n *          If pixa is not defined, the boxes will be rendered over\n *          blank images of identical size.\n *      (3) See pixaDisplayTiledInRows() for other parameters.\n */",
      "file" : "boxfunc4.c"
   },
   {
      "function" : "boxaEncapsulateAligned",
      "comment" : "/*!\n *  boxaEncapsulateAligned()\n *\n *      Input:  boxa\n *              num (number put into each boxa in the baa)\n *              copyflag  (L_COPY or L_CLONE)\n *      Return: baa, or null on error\n *\n *  Notes:\n *      (1) This puts @num boxes from the input @boxa into each of a\n *          set of boxa within an output baa.\n *      (2) This assumes that the boxes in @boxa are in sets of @num each.\n */",
      "file" : "boxfunc2.c"
   },
   {
      "function" : "boxaEqual",
      "comment" : "/*!\n *  boxaEqual()\n *\n *      Input:  boxa1\n *              boxa2\n *              maxdist\n *              &naindex (<optional return> index array of correspondences\n *              &same (<return> 1 if equal; 0 otherwise)\n *      Return  0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The two boxa are the \"same\" if they contain the same\n *          boxes and each box is within @maxdist of its counterpart\n *          in their positions within the boxa.  This allows for\n *          small rearrangements.  Use 0 for maxdist if the boxa\n *          must be identical.\n *      (2) This applies only to geometry and ordering; refcounts\n *          are not considered.\n *      (3) @maxdist allows some latitude in the ordering of the boxes.\n *          For the boxa to be the \"same\", corresponding boxes must\n *          be within @maxdist of each other.  Note that for large\n *          @maxdist, we should use a hash function for efficiency.\n *      (4) naindex[i] gives the position of the box in boxa2 that\n *          corresponds to box i in boxa1.  It is only returned if the\n *          boxa are equal.\n */",
      "file" : "boxfunc1.c"
   },
   {
      "function" : "boxaExtendArray",
      "comment" : "/*!\n *  boxaExtendArray()\n *\n *      Input:  boxa\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) Reallocs with doubled size of ptr array.\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaExtendArrayToSize",
      "comment" : "/*!\n *  boxaExtendArrayToSize()\n *\n *      Input:  boxa\n *              size (new size of boxa array)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) If necessary, reallocs new boxa ptr array to @size.\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaExtractAsNuma",
      "comment" : "/*!\n *  boxaExtractAsNuma()\n *\n *      Input:  boxa\n *              &nax (<optional return> array of x locations)\n *              &nay (<optional return> array of y locations)\n *              &naw (<optional return> array of w locations)\n *              &nah (<optional return> array of h locations)\n *              keepinvalid (1 to keep invalid boxes; 0 to remove them)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "boxfunc2.c"
   },
   {
      "function" : "boxaExtractAsPta",
      "comment" : "/*!\n *  boxaExtractAsPta()\n *\n *      Input:  boxa\n *              &ptal (<optional return> array of left locations vs. index)\n *              &ptat (<optional return> array of top locations vs. index)\n *              &ptar (<optional return> array of right locations vs. index)\n *              &ptab (<optional return> array of bottom locations vs. index)\n *              keepinvalid (1 to keep invalid boxes; 0 to remove them)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "boxfunc2.c"
   },
   {
      "function" : "boxaExtractSortedPattern",
      "comment" : "/*!\n *  boxaExtractSortedPattern()\n *\n *      Input:  boxa (typ. of word bounding boxes, in textline order)\n *              numa (index of textline for each box in boxa)\n *      Return: naa (numaa, where each numa represents one textline),\n *                   or null on error\n *\n *  Notes:\n *      (1) The input is expected to come from pixGetWordBoxesInTextlines().\n *      (2) Each numa in the output consists of an average y coordinate\n *          of the first box in the textline, followed by pairs of\n *          x coordinates representing the left and right edges of each\n *          of the boxes in the textline.\n */",
      "file" : "classapp.c"
   },
   {
      "function" : "boxaGenerateSubboxes",
      "comment" : "/*!\n *  boxaGenerateSubboxes()\n *\n *      Input:  box (region to be split into up to four overlapping subregions)\n *              boxa (boxes of rectangles intersecting the box)\n *              maxperim (maximum half-perimeter for which pivot\n *                        is selected by proximity to box centroid)\n *              fract (fraction of box diagonal that is an acceptable\n *                     distance from the box centroid to select the pivot)\n *      Return: boxa (of four or less overlapping subrectangles of the box),\n *              or null on error\n */",
      "file" : "partition.c"
   },
   {
      "function" : "boxaGetArea",
      "comment" : "/*!\n *  boxaGetArea()\n *\n *      Input:  boxa\n *              &area (<return> total area of all boxes)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Measures the total area of the boxes, without regard to overlaps.\n */",
      "file" : "boxfunc4.c"
   },
   {
      "function" : "boxaGetBox",
      "comment" : "/*!\n *  boxaGetBox()\n *\n *      Input:  boxa\n *              index  (to the index-th box)\n *              accessflag  (L_COPY or L_CLONE)\n *      Return: box, or null on error\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaGetBoxGeometry",
      "comment" : "/*!\n *  boxaGetBoxGeometry()\n *\n *      Input:  boxa\n *              index  (to the index-th box)\n *              &x, &y, &w, &h (<optional return>; each can be null)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaGetCount",
      "comment" : "/*!\n *  boxaGetCount()\n *\n *      Input:  boxa\n *      Return: count (of all boxes); 0 if no boxes or on error\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaGetCoverage",
      "comment" : "/*!\n *  boxaGetCoverage()\n *\n *      Input:  boxa\n *              wc, hc (dimensions of overall clipping rectangle with UL\n *                      corner at (0, 0) that is covered by the boxes.\n *              exactflag (1 for guaranteeing an exact result; 0 for getting\n *                         an exact result only if the boxes do not overlap)\n *              &fract (<return> sum of box area as fraction of w * h)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The boxes in boxa are clipped to the input rectangle.\n *      (2) * When @exactflag == 1, we generate a 1 bpp pix of size\n *            wc x hc, paint all the boxes black, and count the fg pixels.\n *            This can take 1 msec on a large page with many boxes.\n *          * When @exactflag == 0, we clip each box to the wc x hc region\n *            and sum the resulting areas.  This is faster.\n *          * The results are the same when none of the boxes overlap\n *            within the wc x hc region.\n */",
      "file" : "boxfunc4.c"
   },
   {
      "function" : "boxaGetExtent",
      "comment" : "/*!\n *  boxaGetExtent()\n *\n *      Input:  boxa\n *              &w  (<optional return> width)\n *              &h  (<optional return> height)\n *              &box (<optional return>, minimum box containing all boxes\n *                    in boxa)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The returned w and h are the minimum size image\n *          that would contain all boxes untranslated.\n *      (2) If there are no valid boxes, returned w and h are 0 and\n *          all parameters in the returned box are 0.  This\n *          is not an error, because an empty boxa is valid and\n *          boxaGetExtent() is required for serialization.\n */",
      "file" : "boxfunc4.c"
   },
   {
      "function" : "boxaGetMedian",
      "comment" : "/*!\n *  boxaGetMedian()\n *\n *      Input:  boxa\n *      Return: box (with median values for x, y, w, h), or null on error\n *              or if the boxa is empty.\n *\n *  Notes:\n *      (1) See boxaGetRankSize()\n */",
      "file" : "boxfunc2.c"
   },
   {
      "function" : "boxaGetNearestToPt",
      "comment" : "/*!\n *  boxaGetNearestToPt()\n *\n *      Input:  boxa\n *              x, y  (point)\n *      Return  box (box with centroid closest to the given point [x,y]),\n *              or NULL if no boxes in boxa)\n *\n *  Notes:\n *      (1) Uses euclidean distance between centroid and point.\n */",
      "file" : "boxfunc1.c"
   },
   {
      "function" : "boxaGetRankSize",
      "comment" : "/*!\n *  boxaGetRankSize()\n *\n *      Input:  boxa\n *              fract (use 0.0 for smallest, 1.0 for largest)\n *      Return: box (with rank values for x, y, w, h), or null on error\n *              or if the boxa is empty (has no valid boxes)\n *\n *  Notes:\n *      (1) This function does not assume that all boxes in the boxa are valid\n *      (2) The four box parameters are sorted independently.\n *          For rank order, the width and height are sorted in increasing\n *          order.  But what does it mean to sort x and y in \"rank order\"?\n *          If the boxes are of comparable size and somewhat\n *          aligned (e.g., from multiple images), it makes some sense\n *          to give a \"rank order\" for x and y by sorting them in\n *          decreasing order.  But in general, the interpretation of a rank\n *          order on x and y is highly application dependent.  In summary:\n *             - x and y are sorted in decreasing order\n *             - w and h are sorted in increasing order\n */",
      "file" : "boxfunc2.c"
   },
   {
      "function" : "boxaGetValidBox",
      "comment" : "/*!\n *  boxaGetValidBox()\n *\n *      Input:  boxa\n *              index  (to the index-th box)\n *              accessflag  (L_COPY or L_CLONE)\n *      Return: box, or null if box is not valid or on error\n *\n *  Notes:\n *      (1) This returns NULL for an invalid box in a boxa.\n *          For a box to be valid, both the width and height must be > 0.\n *      (2) We allow invalid boxes, with w = 0 or h = 0, as placeholders\n *          in boxa for which the index of the box in the boxa is important.\n *          This is an atypical situation; usually you want to put only\n *          valid boxes in a boxa.\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaGetValidCount",
      "comment" : "/*!\n *  boxaGetValidCount()\n *\n *      Input:  boxa\n *      Return: count (of valid boxes); 0 if no valid boxes or on error\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaGetWhiteblocks",
      "comment" : "/*!\n *  boxaGetWhiteblocks()\n *\n *      Input:  boxas (typically, a set of bounding boxes of fg components)\n *              box (initial region; typically including all boxes in boxas;\n *                   if null, it computes the region to include all boxes\n *                   in boxas)\n *              sortflag (L_SORT_BY_WIDTH, L_SORT_BY_HEIGHT,\n *                        L_SORT_BY_MIN_DIMENSION, L_SORT_BY_MAX_DIMENSION,\n *                        L_SORT_BY_PERIMETER, L_SORT_BY_AREA)\n *              maxboxes (maximum number of output whitespace boxes; e.g., 100)\n *              maxoverlap (maximum fractional overlap of a box by any\n *                          of the larger boxes; e.g., 0.2)\n *              maxperim (maximum half-perimeter, in pixels, for which\n *                        pivot is selected by proximity to box centroid;\n *                        e.g., 200)\n *              fract (fraction of box diagonal that is an acceptable\n *                     distance from the box centroid to select the pivot;\n *                     e.g., 0.2)\n *              maxpops (maximum number of pops from the heap; use 0 as default)\n *      Return: boxa (of sorted whitespace boxes), or null on error\n *\n *  Notes:\n *      (1) This uses the elegant Breuel algorithm, found in \"Two\n *          Geometric Algorithms for Layout Analysis\", 2002,\n *          url: \"citeseer.ist.psu.edu/breuel02two.html\".\n *          It starts with the bounding boxes (b.b.) of the connected\n *          components (c.c.) in a region, along with the rectangle\n *          representing that region.  It repeatedly divides the\n *          rectangle into four maximal rectangles that exclude a\n *          pivot rectangle, sorting them in a priority queue\n *          according to one of the six sort flags.  It returns a boxa\n *          of the \"largest\" set that have no intersection with boxes\n *          from the input boxas.\n *      (2) If box == NULL, the initial region is the minimal region\n *          that includes the origin and every box in boxas.\n *      (3) maxboxes is the maximum number of whitespace boxes that will\n *          be returned.  The actual number will depend on the image\n *          and the values chosen for maxoverlap and maxpops.  In many\n *          cases, the actual number will be 'maxboxes'.\n *      (4) maxoverlap allows pruning of whitespace boxes depending on\n *          the overlap.  To avoid all pruning, use maxoverlap = 1.0.\n *          To select only boxes that have no overlap with each other\n *          (maximal pruning), choose maxoverlap = 0.0.\n *          Otherwise, no box can have more than the 'maxoverlap' fraction\n *          of its area overlapped by any larger (in the sense of the\n *          sortflag) box.\n *      (5) Choose maxperim (actually, maximum half-perimeter) to\n *          represent a c.c. that is small enough so that you don't care\n *          about the white space that could be inside of it.  For all such\n *          c.c., the pivot for 'quadfurcation' of a rectangle is selected\n *          as having a reasonable proximity to the rectangle centroid.\n *      (6) Use fract in the range [0.0 ... 1.0].  Set fract = 0.0\n *          to choose the small box nearest the centroid as the pivot.\n *          If you choose fract > 0.0, it is suggested that you call\n *          boxaPermuteRandom() first, to permute the boxes (see usage below).\n *          This should reduce the search time for each of the pivot boxes.\n *      (7) Choose maxpops to be the maximum number of rectangles that\n *          are popped from the heap.  This is an indirect way to limit the\n *          execution time.  Use 0 for default (a fairly large number).\n *          At any time, you can expect the heap to contain about\n *          2.5 times as many boxes as have been popped off.\n *      (8) The output result is a sorted set of overlapping\n *          boxes, constrained by 'maxboxes', 'maxoverlap' and 'maxpops'.\n *      (9) The main defect of the method is that it abstracts out the\n *          actual components, retaining only the b.b. for analysis.\n *          Consider a component with a large b.b.  If this is chosen\n *          as a pivot, all white space inside is immediately taken\n *          out of consideration.  Furthermore, even if it is never chosen\n *          as a pivot, as the partitioning continues, at no time will\n *          any of the whitespace inside this component be part of a\n *          rectangle with zero overlapping boxes.  Thus, the interiors\n*           of all boxes are necessarily excluded from the union of\n*           the returned whitespace boxes.\n *     (10) USAGE: One way to accommodate to this weakness is to remove such\n *          large b.b. before starting the computation.  For example,\n *          if 'box' is an input image region containing 'boxa' b.b. of c.c.:\n *\n *                   // Faster pivot choosing\n *               boxaPermuteRandom(boxa, boxa);\n *\n *                   // Remove anything either large width or height\n *               boxat = boxaSelectBySize(boxa, maxwidth, maxheight,\n *                                        L_SELECT_IF_BOTH, L_SELECT_IF_LT,\n *                                        NULL);\n *\n *               boxad = boxaGetWhiteblocks(boxat, box, type, maxboxes,\n *                                          maxoverlap, maxperim, fract,\n *                                          maxpops);\n *\n *          The result will be rectangular regions of \"white space\" that\n *          extend into (and often through) the excluded components.\n *     (11) As a simple example, suppose you wish to find the columns on a page.\n *          First exclude large c.c. that may block the columns, and then call:\n *\n *               boxad = boxaGetWhiteblocks(boxa, box, L_SORT_BY_HEIGHT,\n *                                          20, 0.15, 200, 0.2, 2000);\n *\n *          to get the 20 tallest boxes with no more than 0.15 overlap\n *          between a box and any of the taller ones, and avoiding the\n *          use of any c.c. with a b.b. half perimeter greater than 200\n *          as a pivot.\n */",
      "file" : "partition.c"
   },
   {
      "function" : "boxaHandleOverlaps",
      "comment" : "/*!\n *  boxaHandleOverlaps()\n *\n *      Input:  boxas\n *              op (L_COMBINE, L_REMOVE_SMALL)\n *              range (> 0, forward distance over which overlaps are checked)\n *              min_overlap (minimum fraction of smaller box required for\n *                           overlap to count; 0.0 to ignore)\n *              max_ratio (maximum fraction of small/large areas for\n *                         overlap to count; 1.0 to ignore)\n *              &namap (<optional return> combining map)\n *      Return: boxad, or null on error.\n *\n *  Notes:\n *      (1) For all n(n-1)/2 box pairings, if two boxes overlap, either:\n *          (a) op == L_COMBINE: get the bounding region for the two,\n *              replace the larger with the bounding region, and remove\n *              the smaller of the two, or\n *          (b) op == L_REMOVE_SMALL: just remove the smaller.\n *      (2) If boxas is 2D sorted, range can be small, but if it is\n *          not spatially sorted, range should be large to allow all\n *          pairwise comparisons to be made.\n *      (3) The @min_overlap parameter allows ignoring small overlaps.\n *          If @min_overlap == 1.0, only boxes fully contained in larger\n *          boxes can be considered for removal; if @min_overlap == 0.0,\n *          this constraint is ignored.\n *      (4) The @max_ratio parameter allows ignoring overlaps between\n *          boxes that are not too different in size.  If @max_ratio == 0.0,\n *          no boxes can be removed; if @max_ratio == 1.0, this constraint\n *          is ignored.\n */",
      "file" : "boxfunc1.c"
   },
   {
      "function" : "boxaInitFull",
      "comment" : "/*!\n *  boxaInitFull()\n *\n *      Input:  boxa (typically empty)\n *              box (<optional> to be replicated into the entire ptr array)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This initializes a boxa by filling up the entire box ptr array\n *          with copies of @box.  If @box == NULL, use a placeholder box\n *          of zero size.  Any existing boxes are destroyed.\n *          After this opepration, the number of boxes is equal to\n *          the number of allocated ptrs.\n *      (2) Note that we use boxaReplaceBox() instead of boxaInsertBox().\n *          They both have the same effect when inserting into a NULL ptr\n *          in the boxa ptr array:\n *      (3) Example usage.  This function is useful to prepare for a\n *          random insertion (or replacement) of boxes into a boxa.\n *          To randomly insert boxes into a boxa, up to some index \"max\":\n *             Boxa *boxa = boxaCreate(max);\n *             boxaInitFull(boxa, NULL);\n *          If you want placeholder boxes of non-zero size:\n *             Boxa *boxa = boxaCreate(max);\n *             Box *box = boxCreate(...);\n *             boxaInitFull(boxa, box);\n *             boxDestroy(&box);\n *          If we have an existing boxa with a smaller ptr array, it can\n *          be reused for up to max boxes:\n *             boxaExtendArrayToSize(boxa, max);\n *             boxaInitFull(boxa, NULL);\n *          The initialization allows the boxa to always be properly\n *          filled, even if all the boxes are not later replaced.\n *          If you want to know which boxes have been replaced,\n *          and you initialized with invalid zero-sized boxes,\n *          use boxaGetValidBox() to return NULL for the invalid boxes.\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaInsertBox",
      "comment" : "/*!\n *  boxaInsertBox()\n *\n *      Input:  boxa\n *              index (location in boxa to insert new value)\n *              box (new box to be inserted)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This shifts box[i] --> box[i + 1] for all i >= index,\n *          and then inserts box as box[index].\n *      (2) To insert at the beginning of the array, set index = 0.\n *      (3) To append to the array, it's easier to use boxaAddBox().\n *      (4) This should not be used repeatedly to insert into large arrays,\n *          because the function is O(n).\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaIntersectsBox",
      "comment" : "/*!\n *  boxaIntersectsBox()\n *\n *      Input:  boxas\n *              box (for intersecting)\n *      Return  boxad (boxa with all boxes in boxas that intersect box),\n *                     or null on error\n *\n *  Notes:\n *      (1) All boxes in boxa that intersect with box (i.e., are completely\n *          or partially contained in box) are retained.\n */",
      "file" : "boxfunc1.c"
   },
   {
      "function" : "boxaIsFull",
      "comment" : "/*!\n *  boxaIsFull()\n *\n *      Input:  boxa\n *              &full (return> 1 if boxa is full)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaJoin",
      "comment" : "/*!\n *  boxaJoin()\n *\n *      Input:  boxad  (dest boxa; add to this one)\n *              boxas  (source boxa; add from this one)\n *              istart  (starting index in boxas)\n *              iend  (ending index in boxas; use -1 to cat all)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This appends a clone of each indicated box in boxas to boxad\n *      (2) istart < 0 is taken to mean 'read from the start' (istart = 0)\n *      (3) iend < 0 means 'read to the end'\n *      (4) if boxas == NULL or has no boxes, this is a no-op.\n */",
      "file" : "boxfunc1.c"
   },
   {
      "function" : "boxaLinearFit",
      "comment" : "/*!\n *  boxaLinearFit()\n *\n *      Input:  boxas (source boxa)\n *              factor (reject outliers with error greater than this\n *                      number of median errors; typically ~3)\n *              max_error (maximum difference in pixels between fitted\n *                         and original location to allow using the\n *                         original value instead of the fitted value)\n *              debug (1 for debug output)\n *      Return: boxad (fitted boxa), or null on error\n *\n *  Notes:\n *      (1) Suppose you have a boxa where the box edges are expected\n *          to vary slowly and linearly across the set.  These could\n *          be, for example, noisy measurements of similar regions\n *          on successive scanned pages.\n *      (2) Method: there are 2 basic steps:\n *          (a) Find outliers, separately based on the deviation\n *              from the median of the width and height of the box.\n *              After the width- and height-based outliers are removed,\n *              do a linear LSF for each of the four sides.  Use\n *              @factor to specify tolerance to outliers; use a very large\n *              value of @factor to avoid rejecting points.\n *          (b) Using the LSF of (a), make the final determination of\n *              the four edge locations.  See (3) for details.\n *      (3) The parameter @max_error makes the input values somewhat sticky.\n *          Use the fitted values only when the difference between input\n *          and fitted value is greater than @max_error.  Two special cases:\n *          (a) set @max_error == 0 to use only fitted values in boxad.\n *          (b) set @max_error == 10000 to ignore all fitted values; then\n *              boxad will be the same as boxas.\n *      (4) Invalid input boxes are not used in computation of the LSF,\n *          and the output boxes are found from the LSF.\n *      (5) To enforce additional constraints on the size of each box,\n *          follow this operation with boxaConstrainSize(), taking boxad\n *          as input.\n */",
      "file" : "boxfunc4.c"
   },
   {
      "function" : "boxaLocationRange",
      "comment" : "/*!\n *  boxaLocationRange()\n *\n *      Input:  boxa\n *              &minx, &miny, &maxx, &maxy (<optional return> range of\n *                                          UL corner positions)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "boxfunc4.c"
   },
   {
      "function" : "boxaMakeAreaIndicator",
      "comment" : "/*!\n *  boxaMakeAreaIndicator()\n *\n *      Input:  boxa\n *              area (threshold value of width * height)\n *              relation (L_SELECT_IF_LT, L_SELECT_IF_GT,\n *                        L_SELECT_IF_LTE, L_SELECT_IF_GTE)\n *      Return: na (indicator array), or null on error\n *\n *  Notes:\n *      (1) To keep small components, use relation = L_SELECT_IF_LT or\n *          L_SELECT_IF_LTE.\n *          To keep large components, use relation = L_SELECT_IF_GT or\n *          L_SELECT_IF_GTE.\n */",
      "file" : "boxfunc4.c"
   },
   {
      "function" : "boxaMakeSizeIndicator",
      "comment" : "/*!\n *  boxaMakeSizeIndicator()\n *\n *      Input:  boxa\n *              width, height (threshold dimensions)\n *              type (L_SELECT_WIDTH, L_SELECT_HEIGHT,\n *                    L_SELECT_IF_EITHER, L_SELECT_IF_BOTH)\n *              relation (L_SELECT_IF_LT, L_SELECT_IF_GT,\n *                        L_SELECT_IF_LTE, L_SELECT_IF_GTE)\n *      Return: na (indicator array), or null on error\n *\n *  Notes:\n *      (1) The args specify constraints on the size of the\n *          components that are kept.\n *      (2) If the selection type is L_SELECT_WIDTH, the input\n *          height is ignored, and v.v.\n *      (3) To keep small components, use relation = L_SELECT_IF_LT or\n *          L_SELECT_IF_LTE.\n *          To keep large components, use relation = L_SELECT_IF_GT or\n *          L_SELECT_IF_GTE.\n */",
      "file" : "boxfunc4.c"
   },
   {
      "function" : "boxaMergeEvenOdd",
      "comment" : "/*!\n *  boxaMergeEvenOdd()\n *\n *      Input:  boxae (boxes to go in even positions in merged boxa)\n *              boxao (boxes to go in odd positions in merged boxa)\n *              fillflag (1 if there are invalid boxes in placeholders)\n *      Return: boxad (merged), or null on error\n *\n *  Notes:\n *      (1) This is essentially the inverse of boxaSplitEvenOdd().\n *          Typically, boxae and boxao were generated by boxaSplitEvenOdd(),\n *          and the value of @fillflag needs to be the same in both calls.\n *      (2) If @fillflag == 1, both boxae and boxao are of the same size;\n *          otherwise boxae may have one more box than boxao.\n */",
      "file" : "boxfunc1.c"
   },
   {
      "function" : "boxaPermutePseudorandom",
      "comment" : "/*!\n *  boxaPermutePseudorandom()\n *\n *      Input:  boxas (input boxa)\n *      Return: boxad (with boxes permuted), or null on error\n *\n *  Notes:\n *      (1) This does a pseudorandom in-place permutation of the boxes.\n *      (2) The result is guaranteed not to have any boxes in their\n *          original position, but it is not very random.  If you\n *          need randomness, use boxaPermuteRandom().\n */",
      "file" : "boxfunc4.c"
   },
   {
      "function" : "boxaPermuteRandom",
      "comment" : "/*!\n *  boxaPermuteRandom()\n *\n *      Input:  boxad (<optional> can be null or equal to boxas)\n *              boxas (input boxa)\n *      Return: boxad (with boxes permuted), or null on error\n *\n *  Notes:\n *      (1) If boxad is null, make a copy of boxas and permute the copy.\n *          Otherwise, boxad must be equal to boxas, and the operation\n *          is done in-place.\n *      (2) This does a random in-place permutation of the boxes,\n *          by swapping each box in turn with a random box.  The\n *          result is almost guaranteed not to have any boxes in their\n *          original position.\n *      (3) MSVC rand() has MAX_RAND = 2^15 - 1, so it will not do\n *          a proper permutation is the number of boxes exceeds this.\n */",
      "file" : "boxfunc4.c"
   },
   {
      "function" : "boxaPlotSides",
      "comment" : "/*!\n *  boxaPlotSides()\n *\n *      Input:  boxas (source boxa)\n *              plotname (<optional>, can be NULL)\n *              &nal (<optional return> na of left sides)\n *              &nat (<optional return> na of top sides)\n *              &nar (<optional return> na of right sides)\n *              &nab (<optional return> na of bottom sides)\n *              outformat (GPLOT_NONE for no output; GPLOT_PNG for png, etc)\n *               ut\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is a debugging function to show the progression of\n *          the four sides in the boxes.  There must be at least 2 boxes.\n *      (2) One of three conditions holds:\n *          (a) only the even indices have valid boxes\n *          (b) only the odd indices have valid boxes\n *          (c) all indices have valid boxes\n *          This condition is determined by looking at the first 2 boxes.\n *      (3) The plotfiles are put in /tmp, and are named either with\n *          @plotname or, if NULL, a default name.\n */",
      "file" : "boxfunc4.c"
   },
   {
      "function" : "boxaPruneSortedOnOverlap",
      "comment" : "/*!\n *  boxaPruneSortedOnOverlap()\n *\n *      Input:  boxas (sorted by size in decreasing order)\n *              maxoverlap (maximum fractional overlap of a box by any\n *                          of the larger boxes)\n *      Return: boxad (pruned), or null on error\n *\n *  Notes:\n *      (1) This selectively removes smaller boxes when they are overlapped\n *          by any larger box by more than the input 'maxoverlap' fraction.\n *      (2) To avoid all pruning, use maxoverlap = 1.0.  To select only\n *          boxes that have no overlap with each other (maximal pruning),\n *          set maxoverlap = 0.0.\n *      (3) If there are no boxes in boxas, returns an empty boxa.\n */",
      "file" : "partition.c"
   },
   {
      "function" : "boxaRead",
      "comment" : "/*!\n *  boxaRead()\n *\n *      Input:  filename\n *      Return: boxa, or null on error\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaReadMem",
      "comment" : "/*!\n *  boxaReadMem()\n *\n *      Input:  data (ascii)\n *              size (of data; can use strlen to get it)\n *      Return: boxa, or null on error\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaReadStream",
      "comment" : "/*!\n *  boxaReadStream()\n *\n *      Input:  stream\n *      Return: boxa, or null on error\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaReconcileEvenOddHeight",
      "comment" : "/*!\n *  boxaReconcileEvenOddHeight()\n *\n *      Input:  boxas (containing at least 3 valid boxes in even and odd)\n *              sides (L_ADJUST_TOP, L_ADJUST_BOT, L_ADJUST_TOP_AND_BOT)\n *              delh (threshold on median height difference)\n *              op (L_ADJUST_CHOOSE_MIN, L_ADJUST_CHOOSE_MAX)\n *              factor (> 0.0, typically near 1.0)\n *      Return: boxad (adjusted)\n *\n *  Notes:\n *      (1) The basic idea is to reconcile differences in box height\n *          in the even and odd boxes, by moving the top and/or bottom\n *          edges in the even and odd boxes.  Choose the edge or edges\n *          to be moved, whether to adjust the boxes with the min\n *          or the max of the medians, and the threshold on the median\n *          difference between even and odd box heights for the operations\n *          to take place.  The same threshold is also used to\n *          determine if each individual box edge is to be adjusted.\n *      (2) Boxes are conditionally reset with either the same top (y)\n *          value or the same bottom value, or both.  The value is\n *          determined by the greater or lesser of the medians of the\n *          even and odd boxes, with the choice depending on the value\n *          of @op, which selects for either min or max median height.\n *          If the median difference between even and odd boxes is\n *          greater than @dely, then any individual box edge that differs\n *          from the selected median by more than @dely is set to\n *          the selected median times a factor typically near 1.0.\n *      (3) Note that if selecting for minimum height, you will choose\n *          the largest y-value for the top and the smallest y-value for\n *          the bottom of the box.\n *      (4) Typical input might be the output of boxaSmoothSequence(),\n *          where even and odd boxa have been independently regulated.\n *      (5) Require at least 3 valid even boxes and 3 valid odd boxes.\n *          Median values will be used for invalid boxes.\n */",
      "file" : "boxfunc4.c"
   },
   {
      "function" : "boxaRemoveBox",
      "comment" : "/*!\n *  boxaRemoveBox()\n *\n *      Input:  boxa\n *              index (of box to be removed)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This removes box[index] and then shifts\n *          box[i] --> box[i - 1] for all i > index.\n *      (2) It should not be used repeatedly to remove boxes from\n *          large arrays, because the function is O(n).\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaRemoveBoxAndSave",
      "comment" : "/*!\n *  boxaRemoveBoxAndSave()\n *\n *      Input:  boxa\n *              index (of box to be removed)\n *              &box (<optional return> removed box)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This removes box[index] and then shifts\n *          box[i] --> box[i - 1] for all i > index.\n *      (2) It should not be used repeatedly to remove boxes from\n *          large arrays, because the function is O(n).\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaReplaceBox",
      "comment" : "/*!\n *  boxaReplaceBox()\n *\n *      Input:  boxa\n *              index  (to the index-th box)\n *              box (insert to replace existing one)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) In-place replacement of one box.\n *      (2) The previous box at that location, if any, is destroyed.\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaRotate",
      "comment" : "/*!\n *  boxaRotate()\n *\n *      Input:  boxas\n *              (xc, yc)  (location of center of rotation)\n *              angle  (rotation in radians; clockwise is positive)\n *      Return: boxad  (scaled boxas), or null on error\n *\n *  Notes;\n *      (1) See createMatrix2dRotate() for details of transform.\n */",
      "file" : "affinecompose.c"
   },
   {
      "function" : "boxaRotateOrth",
      "comment" : "/*!\n *  boxaRotateOrth()\n *\n *      Input:  boxa\n *              w, h (of image in which the boxa is embedded)\n *              rotation (0 = noop, 1 = 90 deg, 2 = 180 deg, 3 = 270 deg;\n *                        all rotations are clockwise)\n *      Return: boxad, or null on error\n *\n *  Notes:\n *      (1) See boxRotateOrth() for details.\n */",
      "file" : "boxfunc2.c"
   },
   {
      "function" : "boxaScale",
      "comment" : "/*!\n *  boxaScale()\n *\n *      Input:  boxas\n *              scalex  (horizontal scale factor)\n *              scaley  (vertical scale factor)\n *      Return: boxad  (scaled boxas), or null on error\n *\n *  Notes;\n *      (1) See createMatrix2dScale() for details of transform.\n */",
      "file" : "affinecompose.c"
   },
   {
      "function" : "boxaSelectByArea",
      "comment" : "/*!\n *  boxaSelectByArea()\n *\n *      Input:  boxas\n *              area (threshold value of width * height)\n *              relation (L_SELECT_IF_LT, L_SELECT_IF_GT,\n *                        L_SELECT_IF_LTE, L_SELECT_IF_GTE)\n *              &changed (<optional return> 1 if changed; 0 if clone returned)\n *      Return: boxad (filtered set), or null on error\n *\n *  Notes:\n *      (1) Uses box clones in the new boxa.\n *      (2) To keep small components, use relation = L_SELECT_IF_LT or\n *          L_SELECT_IF_LTE.\n *          To keep large components, use relation = L_SELECT_IF_GT or\n *          L_SELECT_IF_GTE.\n */",
      "file" : "boxfunc4.c"
   },
   {
      "function" : "boxaSelectBySize",
      "comment" : "/*!\n *  boxaSelectBySize()\n *\n *      Input:  boxas\n *              width, height (threshold dimensions)\n *              type (L_SELECT_WIDTH, L_SELECT_HEIGHT,\n *                    L_SELECT_IF_EITHER, L_SELECT_IF_BOTH)\n *              relation (L_SELECT_IF_LT, L_SELECT_IF_GT,\n *                        L_SELECT_IF_LTE, L_SELECT_IF_GTE)\n *              &changed (<optional return> 1 if changed; 0 if clone returned)\n *      Return: boxad (filtered set), or null on error\n *\n *  Notes:\n *      (1) The args specify constraints on the size of the\n *          components that are kept.\n *      (2) Uses box clones in the new boxa.\n *      (3) If the selection type is L_SELECT_WIDTH, the input\n *          height is ignored, and v.v.\n *      (4) To keep small components, use relation = L_SELECT_IF_LT or\n *          L_SELECT_IF_LTE.\n *          To keep large components, use relation = L_SELECT_IF_GT or\n *          L_SELECT_IF_GTE.\n */",
      "file" : "boxfunc4.c"
   },
   {
      "function" : "boxaSelectPivotBox",
      "comment" : "/*!\n *  boxaSelectPivotBox()\n *\n *      Input:  box (containing box; to be split by the pivot box)\n *              boxa (boxes of rectangles, from which 1 is to be chosen)\n *              maxperim (maximum half-perimeter for which pivot\n *                        is selected by proximity to box centroid)\n *              fract (fraction of box diagonal that is an acceptable\n *                     distance from the box centroid to select the pivot)\n *      Return: box (pivot box for subdivision into 4 rectangles), or\n *                   null on error\n *\n *  Notes:\n *      (1) This is a tricky piece that wasn't discussed in the\n *          Breuel's 2002 paper.\n *      (2) Selects a box from boxa whose centroid is reasonably close to\n *          the centroid of the containing box (xc, yc) and whose\n *          half-perimeter does not exceed the maxperim value.\n *      (3) If there are no boxes in the boxa that are small enough,\n *          then it selects the smallest of the larger boxes,\n *          without reference to its location in the containing box.\n *      (4) If a small box has a centroid at a distance from the\n *          centroid of the containing box that is not more than\n *          the fraction 'fract' of the diagonal of the containing\n *          box, that box is chosen as the pivot, terminating the\n *          search for the nearest small box.\n *      (5) Use fract in the range [0.0 ... 1.0].  Set fract = 0.0\n *          to choose the small box nearest the centroid.\n *      (6) Choose maxperim to represent a connected component that is\n *          small enough so that you don't care about the white space\n *          that could be inside of it.\n */",
      "file" : "partition.c"
   },
   {
      "function" : "boxaSelectRange",
      "comment" : "/*!\n *  boxaSelectRange()\n *\n *      Input:  boxas\n *              first (use 0 to select from the beginning)\n *              last (use 0 to select to the end)\n *              copyflag (L_COPY, L_CLONE)\n *      Return: boxad, or null on error\n *\n *  Notes:\n *      (1) The copyflag specifies what we do with each box from boxas.\n *          Specifically, L_CLONE inserts a clone into boxad of each\n *          selected box from boxas.\n */",
      "file" : "boxfunc4.c"
   },
   {
      "function" : "boxaSelectWithIndicator",
      "comment" : "/*!\n *  boxaSelectWithIndicator()\n *\n *      Input:  boxas\n *              na (indicator numa)\n *              &changed (<optional return> 1 if changed; 0 if clone returned)\n *      Return: boxad, or null on error\n *\n *  Notes:\n *      (1) Returns a boxa clone if no components are removed.\n *      (2) Uses box clones in the new boxa.\n *      (3) The indicator numa has values 0 (ignore) and 1 (accept).\n */",
      "file" : "boxfunc4.c"
   },
   {
      "function" : "boxaSetSide",
      "comment" : "/*!\n *  boxaSetSide()\n *\n *      Input:  boxad (use null to get a new one; same as boxas for in-place)\n *              boxas\n *              side (L_SET_LEFT, L_SET_RIGHT, L_SET_TOP, L_SET_BOT)\n *              val (location to set for given side, for each box)\n *              thresh (min abs difference to cause resetting to @val)\n *      Return: boxad, or null on error\n *\n *  Notes:\n *      (1) Sets the given side of each box.  Use boxad == NULL for a new\n *          boxa, and boxad == boxas for in-place.\n *      (2) Use one of these:\n *               boxad = boxaSetSide(NULL, boxas, ...);   // new\n *               boxaSetSide(boxas, boxas, ...);  // in-place\n */",
      "file" : "boxfunc1.c"
   },
   {
      "function" : "boxaSimilar",
      "comment" : "/*!\n *  boxaSimilar()\n *\n *      Input:  boxa1\n *              boxa2\n *              leftdiff, rightdiff, topdiff, botdiff\n *              debugflag (output details of non-similar boxes)\n *              &similar (<return> 1 if similar; 0 otherwise)\n *      Return  0 if OK, 1 on error\n *\n *  Notes:\n *      (1) See boxSimilar() for parameter usage.\n *      (2) Corresponding boxes are taken in order in the two boxa.\n *      (3) With debugflag == 1, boxes continue to be tested after failure.\n */",
      "file" : "boxfunc1.c"
   },
   {
      "function" : "boxaSizeRange",
      "comment" : "/*!\n *  boxaSizeRange()\n *\n *      Input:  boxa\n *              &minw, &minh, &maxw, &maxh (<optional return> range of\n *                                          dimensions of box in the array)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "boxfunc4.c"
   },
   {
      "function" : "boxaSmoothSequence",
      "comment" : "/*!\n *  boxaSmoothSequence()\n *\n *      Input:  boxas (source boxa)\n *              factor (reject outliers with error greater than this\n *                      number of median errors; typically ~3)\n *              max_error (maximum difference in pixels between fitted\n *                         and original location to allow using the\n *                         original value instead of the fitted value)\n *              debug (1 for debug output)\n *      Return: boxad (fitted boxa), or null on error\n *\n *  Notes:\n *      (1) This does linear fitting separately to the sequences of\n *          even and odd boxes.  It is assumed that in both the even and\n *          odd sets, the box edges vary slowly and linearly across each set.\n */",
      "file" : "boxfunc4.c"
   },
   {
      "function" : "boxaSort",
      "comment" : "/*!\n *  boxaSort()\n *\n *      Input:  boxa\n *              sorttype (L_SORT_BY_X, L_SORT_BY_Y,\n *                        L_SORT_BY_RIGHT, L_SORT_BY_BOT,\n *                        L_SORT_BY_WIDTH, L_SORT_BY_HEIGHT,\n *                        L_SORT_BY_MIN_DIMENSION, L_SORT_BY_MAX_DIMENSION,\n *                        L_SORT_BY_PERIMETER, L_SORT_BY_AREA,\n *                        L_SORT_BY_ASPECT_RATIO)\n *              sortorder  (L_SORT_INCREASING, L_SORT_DECREASING)\n *              &naindex (<optional return> index of sorted order into\n *                        original array)\n *      Return: boxad (sorted version of boxas), or null on error\n */",
      "file" : "boxfunc2.c"
   },
   {
      "function" : "boxaSort2d",
      "comment" : "/*!\n *  boxaSort2d()\n *\n *      Input:  boxas\n *              &naa (<optional return> numaa with sorted indices\n *                    whose values are the indices of the input array)\n *              delta1 (min overlap that permits aggregation of a box\n *                      onto a boxa of horizontally-aligned boxes; pass 1)\n *              delta2 (min overlap that permits aggregation of a box\n *                      onto a boxa of horizontally-aligned boxes; pass 2)\n *              minh1 (components less than this height either join an\n *                     existing boxa or are set aside for pass 2)\n *      Return: baa (2d sorted version of boxa), or null on error\n *\n *  Notes:\n *      (1) The final result is a sort where the 'fast scan' direction is\n *          left to right, and the 'slow scan' direction is from top\n *          to bottom.  Each boxa in the baa represents a sorted set\n *          of boxes from left to right.\n *      (2) Three passes are used to aggregate the boxas, which can correspond\n *          to characters or words in a line of text.  In pass 1, only\n *          taller components, which correspond to xheight or larger,\n *          are permitted to start a new boxa.  In pass 2, the remaining\n *          vertically-challenged components are allowed to join an\n *          existing boxa or start a new one.  In pass 3, boxa whose extent\n *          is overlapping are joined.  After that, the boxes in each\n *          boxa are sorted horizontally, and finally the boxa are\n *          sorted vertically.\n *      (3) If delta1 < 0, the first pass allows aggregation when\n *          boxes in the same boxa do not overlap vertically.\n *          The distance by which they can miss and still be aggregated\n *          is the absolute value |delta1|.   Similar for delta2 on\n *          the second pass.\n *      (4) On the first pass, any component of height less than minh1\n *          cannot start a new boxa; it's put aside for later insertion.\n *      (5) On the second pass, any small component that doesn't align\n *          with an existing boxa can start a new one.\n *      (6) This can be used to identify lines of text from\n *          character or word bounding boxes.\n */",
      "file" : "boxfunc2.c"
   },
   {
      "function" : "boxaSort2dByIndex",
      "comment" : "/*!\n *  boxaSort2dByIndex()\n *\n *      Input:  boxas\n *              naa (numaa that maps from the new baa to the input boxa)\n *      Return: baa (sorted boxaa), or null on error\n */",
      "file" : "boxfunc2.c"
   },
   {
      "function" : "boxaSortByIndex",
      "comment" : "/*!\n *  boxaSortByIndex()\n *\n *      Input:  boxas\n *              naindex (na that maps from the new boxa to the input boxa)\n *      Return: boxad (sorted), or null on error\n */",
      "file" : "boxfunc2.c"
   },
   {
      "function" : "boxaSplitEvenOdd",
      "comment" : "/*!\n *  boxaSplitEvenOdd()\n *\n *      Input:  boxa\n *              fillflag (1 to put invalid boxes in place; 0 to omit)\n *              &boxae, &boxao (<return> save even and odd boxes in their\n *                 separate boxa, setting the other type to invalid boxes.)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If @fillflag == 1, boxae has copies of the even boxes\n *          in their original location, and nvalid boxes are placed\n *          in the odd array locations.  And v.v.\n *      (2) If @fillflag == 0, boxae has only copies of the even boxes.\n */",
      "file" : "boxfunc1.c"
   },
   {
      "function" : "boxaSwapBoxes",
      "comment" : "/*!\n *  boxaSwapBoxes()\n *\n *      Input:  boxa\n *              i, j (two indices of boxes, that are to be swapped)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "boxfunc4.c"
   },
   {
      "function" : "boxaTransform",
      "comment" : "/*!\n *  boxaTransform()\n *\n *      Input:  boxa\n *              shiftx, shifty\n *              scalex, scaley\n *      Return: boxad, or null on error\n *\n *  Notes:\n *      (1) This is a very simple function that first shifts, then scales.\n */",
      "file" : "boxfunc2.c"
   },
   {
      "function" : "boxaTransformOrdered",
      "comment" : "/*!\n *  boxaTransformOrdered()\n *\n *      Input:  boxa\n *              shiftx, shifty\n *              scalex, scaley\n *              xcen, ycen (center of rotation)\n *              angle (in radians; clockwise is positive)\n *              order (one of 6 combinations: L_TR_SC_RO, ...)\n *      Return: boxd, or null on error\n *\n *  Notes:\n *      (1) This allows a sequence of linear transforms on each box.\n *          the transforms are from the affine set, composed of\n *          shift, scaling and rotation, and the order of the\n *          transforms is specified.\n *      (2) Although these operations appear to be on an infinite\n *          2D plane, in practice the region of interest is clipped\n *          to a finite image.  The center of rotation is usually taken\n *          with respect to the image (either the UL corner or the\n *          center).  A translation can have two very different effects:\n *            (a) Moves the boxes across the fixed image region.\n *            (b) Moves the image origin, causing a change in the image\n *                region and an opposite effective translation of the boxes.\n *          This function should only be used for (a), where the image\n *          region is fixed on translation.  If the image region is\n *          changed by the translation, use instead the functions\n *          in affinecompose.c, where the image region and rotation\n *          center can be computed from the actual clipping due to\n *          translation of the image origin.\n *      (3) See boxTransformOrdered() for usage and implementation details.\n */",
      "file" : "boxfunc2.c"
   },
   {
      "function" : "boxaTranslate",
      "comment" : "/*!\n *  boxaTranslate()\n *\n *      Input:  boxas\n *              transx  (x component of translation wrt. the origin)\n *              transy  (y component of translation wrt. the origin)\n *      Return: boxad  (translated boxas), or null on error\n *\n *  Notes;\n *      (1) See createMatrix2dTranslate() for details of transform.\n */",
      "file" : "affinecompose.c"
   },
   {
      "function" : "boxaWrite",
      "comment" : "/*!\n *  boxaWrite()\n *\n *      Input:  filename\n *              boxa\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaWriteMem",
      "comment" : "/*!\n *  boxaWriteMem()\n *\n *      Input:  &data (<return> data of serialized boxa; ascii)\n *              &size (<return> size of returned data)\n *              boxa\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaWriteStream",
      "comment" : "/*!\n *  boxaWriteStream()\n *\n *      Input: stream\n *             boxa\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaaAddBox",
      "comment" : "/*!\n *  boxaaAddBox()\n *\n *      Input:  boxaa\n *              index (of boxa with boxaa)\n *              box (to be added)\n *              accessflag (L_INSERT, L_COPY or L_CLONE)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Adds to an existing boxa only.\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaaAddBoxa",
      "comment" : "/*!\n *  boxaaAddBoxa()\n *\n *      Input:  boxaa\n *              boxa     (to be added)\n *              copyflag  (L_INSERT, L_COPY, L_CLONE)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaaAlignBox",
      "comment" : "/*!\n *  boxaaAlignBox()\n *\n *      Input:  baa\n *              box (to be aligned with the bext boxa in the baa, if possible)\n *              delta (amount by which consecutive components can miss\n *                     in overlap and still be included in the array)\n *              &index (of boxa with best overlap, or if none match,\n *                      this is the index of the next boxa to be generated)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is not greedy.  It finds the boxa whose vertical\n *          extent has the closest overlap with the input box.\n */",
      "file" : "boxfunc2.c"
   },
   {
      "function" : "boxaaCopy",
      "comment" : "/*!\n *  boxaaCopy()\n *\n *      Input:  baas (input boxaa to be copied)\n *              copyflag (L_COPY, L_CLONE)\n *      Return: baad (new boxaa, composed of copies or clones of the boxa\n *                    in baas), or null on error\n *\n *  Notes:\n *      (1) L_COPY makes a copy of each boxa in baas.\n *          L_CLONE makes a clone of each boxa in baas.\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaaCreate",
      "comment" : "/*!\n *  boxaaCreate()\n *\n *      Input:  size of boxa ptr array to be alloc'd (0 for default)\n *      Return: baa, or null on error\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaaDestroy",
      "comment" : "/*!\n *  boxaaDestroy()\n *\n *      Input:  &boxaa (<will be set to null before returning>)\n *      Return: void\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaaDisplay",
      "comment" : "/*!\n *  boxaaDisplay()\n *\n *      Input:  baa\n *              linewba (line width to display boxa)\n *              linewb (line width to display box)\n *              colorba (color to display boxa)\n *              colorb (color to display box)\n *              w (of pix; use 0 if determined by baa)\n *              h (of pix; use 0 if determined by baa)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "boxfunc3.c"
   },
   {
      "function" : "boxaaExtendArray",
      "comment" : "/*!\n *  boxaaExtendArray()\n *\n *      Input:  boxaa\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaaExtendArrayToSize",
      "comment" : "/*!\n *  boxaaExtendArrayToSize()\n *\n *      Input:  boxaa\n *              size (new size of boxa array)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) If necessary, reallocs the boxa ptr array to @size.\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaaExtendWithInit",
      "comment" : "/*!\n *  boxaaExtendWithInit()\n *\n *      Input:  boxaa\n *              maxindex\n *              boxa (to be replicated into the extended ptr array)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This should be used on an existing boxaa that has been\n *          fully loaded with boxa.  It then extends the boxaa,\n *          loading all the additional ptrs with copies of boxa.\n *          Typically, boxa will be empty.\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaaFlattenAligned",
      "comment" : "/*!\n *  boxaaFlattenAligned()\n *\n *      Input:  baa\n *              num (number extracted from each)\n *              fillerbox (<optional> that fills if necessary)\n *              copyflag  (L_COPY or L_CLONE)\n *      Return: boxa, or null on error\n *\n *  Notes:\n *      (1) This 'flattens' the baa to a boxa, taking the first @num\n *          boxes from each boxa.\n *      (2) In each boxa, if there are less than @num boxes, we preserve\n *          the alignment between the input baa and the output boxa\n *          by inserting one or more fillerbox(es) or, if @fillerbox == NULL,\n *          one or more invalid placeholder boxes.\n */",
      "file" : "boxfunc2.c"
   },
   {
      "function" : "boxaaFlattenToBoxa",
      "comment" : "/*!\n *  boxaaFlattenToBoxa()\n *\n *      Input:  baa\n *              &naindex  (<optional return> the boxa index in the baa)\n *              copyflag  (L_COPY or L_CLONE)\n *      Return: boxa, or null on error\n *\n *  Notes:\n *      (1) This 'flattens' the baa to a boxa, taking the boxes in\n *          order in the first boxa, then the second, etc.\n *      (2) If a boxa is empty, we generate an invalid, placeholder box\n *          of zero size.  This is useful when converting from a baa\n *          where each boxa has either 0 or 1 boxes, and it is necessary\n *          to maintain a 1:1 correspondence between the initial\n *          boxa array and the resulting box array.\n *      (3) If &naindex is defined, we generate a Numa that gives, for\n *          each box in the baa, the index of the boxa to which it belongs.\n */",
      "file" : "boxfunc2.c"
   },
   {
      "function" : "boxaaGetBox",
      "comment" : "/*!\n *  boxaaGetBox()\n *\n *      Input:  baa\n *              iboxa  (index into the boxa array in the boxaa)\n *              ibox  (index into the box array in the boxa)\n *              accessflag   (L_COPY or L_CLONE)\n *      Return: box, or null on error\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaaGetBoxCount",
      "comment" : "/*!\n *  boxaaGetBoxCount()\n *\n *      Input:  boxaa\n *      Return: count (number of boxes), or 0 if no boxes or on error\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaaGetBoxa",
      "comment" : "/*!\n *  boxaaGetBoxa()\n *\n *      Input:  boxaa\n *              index  (to the index-th boxa)\n *              accessflag   (L_COPY or L_CLONE)\n *      Return: boxa, or null on error\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaaGetCount",
      "comment" : "/*!\n *  boxaaGetCount()\n *\n *      Input:  boxaa\n *      Return: count (number of boxa), or 0 if no boxa or on error\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaaGetExtent",
      "comment" : "/*!\n *  boxaaGetExtent()\n *\n *      Input:  baa\n *              &w  (<optional return> width)\n *              &h  (<optional return> height)\n *              &box (<optional return>, minimum box containing all boxa\n *                    in boxaa)\n *              &boxa (<optional return>, boxa containing all boxes in each\n *                     boxa in the boxaa)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The returned w and h are the minimum size image\n *          that would contain all boxes untranslated.\n *      (2) Each box in the returned boxa is the minimum box required to\n *          hold all the boxes in the respective boxa of baa.\n *      (3) If there are no valid boxes in a boxa, the box corresponding\n *          to its extent has all fields set to 0 (an invalid box).\n */",
      "file" : "boxfunc2.c"
   },
   {
      "function" : "boxaaInitFull",
      "comment" : "/*!\n *  boxaaInitFull()\n *\n *      Input:  boxaa (typically empty)\n *              boxa (to be replicated into the entire ptr array)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This initializes a boxaa by filling up the entire boxa ptr array\n *          with copies of @boxa.  Any existing boxa are destroyed.\n *          After this operation, the number of boxa is equal to\n *          the number of allocated ptrs.\n *      (2) Note that we use boxaaReplaceBox() instead of boxaInsertBox().\n *          They both have the same effect when inserting into a NULL ptr\n *          in the boxa ptr array\n *      (3) Example usage.  This function is useful to prepare for a\n *          random insertion (or replacement) of boxa into a boxaa.\n *          To randomly insert boxa into a boxaa, up to some index \"max\":\n *             Boxaa *baa = boxaaCreate(max);\n *               // initialize the boxa\n *             Boxa *boxa = boxaCreate(...);\n *             ...  [optionally fix with boxes]\n *             boxaaInitFull(baa, boxa);\n *          A typical use is to initialize the array with empty boxa,\n *          and to replace only a subset that must be aligned with\n *          something else, such as a pixa.\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaaInsertBoxa",
      "comment" : "/*!\n *  boxaaInsertBoxa()\n *\n *      Input:  boxaa\n *              index (location in boxaa to insert new boxa)\n *              boxa (new boxa to be inserted)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This shifts boxa[i] --> boxa[i + 1] for all i >= index,\n *          and then inserts boxa as boxa[index].\n *      (2) To insert at the beginning of the array, set index = 0.\n *      (3) To append to the array, it's easier to use boxaaAddBoxa().\n *      (4) This should not be used repeatedly to insert into large arrays,\n *          because the function is O(n).\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaaJoin",
      "comment" : "/*!\n *  boxaaJoin()\n *\n *      Input:  baad  (dest boxaa; add to this one)\n *              baas  (source boxaa; add from this one)\n *              istart  (starting index in baas)\n *              iend  (ending index in baas; use -1 to cat all)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This appends a clone of each indicated boxa in baas to baad\n *      (2) istart < 0 is taken to mean 'read from the start' (istart = 0)\n *      (3) iend < 0 means 'read to the end'\n *      (4) if baas == NULL, this is a no-op.\n */",
      "file" : "boxfunc1.c"
   },
   {
      "function" : "boxaaQuadtreeRegions",
      "comment" : "/*!\n *  boxaaQuadtreeRegions()\n *\n *      Input:  w, h (of pix that is being quadtree-ized)\n *              nlevels (in quadtree)\n *      Return: baa (for quadtree regions at each level), or null on error\n *\n *  Notes:\n *      (1) The returned boxaa has @nlevels of boxa, each containing\n *          the set of rectangles at that level.  The rectangle at\n *          level 0 is the entire region; at level 1 the region is\n *          divided into 4 rectangles, and at level n there are n^4\n *          rectangles.\n *      (2) At each level, the rectangles in the boxa are in \"raster\"\n *          order, with LR (fast scan) and TB (slow scan).\n */",
      "file" : "quadtree.c"
   },
   {
      "function" : "boxaaRead",
      "comment" : "/*!\n *  boxaaRead()\n *\n *      Input:  filename\n *      Return: boxaa, or null on error\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaaReadFromFiles",
      "comment" : "/*!\n *  boxaaReadFromFiles()\n *\n *      Input:  dirname (directory)\n *              substr (<optional> substring filter on filenames; can be NULL)\n *              first (0-based)\n *              nfiles (use 0 for everything from @first to the end)\n *      Return: baa, or null on error or if no boxa files are found.\n *\n *  Notes:\n *      (1) The files must be serialized boxa files (e.g., *.ba).\n *          If some files cannot be read, warnings are issued.\n *      (2) Use @substr to filter filenames in the directory.  If\n *          @substr == NULL, this takes all files.\n *      (3) After filtering, use @first and @nfiles to select\n *          a contiguous set of files, that have been lexically\n *          sorted in increasing order.\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaaReadStream",
      "comment" : "/*!\n *  boxaaReadStream()\n *\n *      Input:  stream\n *      Return: boxaa, or null on error\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaaRemoveBoxa",
      "comment" : "/*!\n *  boxaaRemoveBoxa()\n *\n *      Input:  boxaa\n *              index  (of the boxa to be removed)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This removes boxa[index] and then shifts\n *          boxa[i] --> boxa[i - 1] for all i > index.\n *      (2) The removed boxaa is destroyed.\n *      (2) This should not be used repeatedly on large arrays,\n *          because the function is O(n).\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaaReplaceBoxa",
      "comment" : "/*!\n *  boxaaReplaceBoxa()\n *\n *      Input:  boxaa\n *              index  (to the index-th boxa)\n *              boxa (insert and replace any existing one)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Any existing boxa is destroyed, and the input one\n *          is inserted in its place.\n *      (2) If the index is invalid, return 1 (error)\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaaSelectRange",
      "comment" : "/*!\n *  boxaaSelectRange()\n *\n *      Input:  baas\n *              first (use 0 to select from the beginning)\n *              last (use 0 to select to the end)\n *              copyflag (L_COPY, L_CLONE)\n *      Return: baad, or null on error\n *\n *  Notes:\n *      (1) The copyflag specifies what we do with each boxa from baas.\n *          Specifically, L_CLONE inserts a clone into baad of each\n *          selected boxa from baas.\n */",
      "file" : "boxfunc4.c"
   },
   {
      "function" : "boxaaSizeRange",
      "comment" : "/*!\n *  boxaaSizeRange()\n *\n *      Input:  baa\n *              &minw, &minh, &maxw, &maxh (<optional return> range of\n *                                          dimensions of all boxes)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "boxfunc4.c"
   },
   {
      "function" : "boxaaWrite",
      "comment" : "/*!\n *  boxaaWrite()\n *\n *      Input:  filename\n *              boxaa\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "boxaaWriteStream",
      "comment" : "/*!\n *  boxaaWriteStream()\n *\n *      Input: stream\n *             boxaa\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "boxbasic.c"
   },
   {
      "function" : "captureProtoSignature",
      "comment" : "/*\n *  captureProtoSignature()\n *\n *      Input:  sa (output from cpp, by line)\n *              start (starting index to search; never a comment line)\n *              stop (index of line on which pattern is completed)\n *              charindex (char index of completing ')' character)\n *      Return: cleanstr (prototype string), or NULL on error\n *\n *  Notes:\n *      (1) Return all characters, ending with a ';' after the ')'\n */",
      "file" : "parseprotos.c"
   },
   {
      "function" : "ccbCreate",
      "comment" : "/*!\n *  ccbCreate()\n *\n *     Input:  pixs  (<optional>)\n *     Return: ccb or null on error\n */",
      "file" : "ccbord.c"
   },
   {
      "function" : "ccbDestroy",
      "comment" : "/*!\n *  ccbDestroy()\n *\n *     Input:  &ccb (<to be nulled>)\n *     Return: void\n */",
      "file" : "ccbord.c"
   },
   {
      "function" : "ccbaAddCcb",
      "comment" : "/*!\n *  ccbaAddCcb()\n *\n *      Input:  ccba\n *              ccb (to be added by insertion)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "ccbord.c"
   },
   {
      "function" : "ccbaCreate",
      "comment" : "/*!\n *   ccbaCreate()\n *\n *       Input:  pixs  (binary image; can be null)\n *               n  (initial number of ptrs)\n *       Return: ccba, or null on error\n */",
      "file" : "ccbord.c"
   },
   {
      "function" : "ccbaDestroy",
      "comment" : "/*!\n *  ccbaDestroy()\n *\n *     Input:  &ccba  (<to be nulled>)\n *     Return: void\n */",
      "file" : "ccbord.c"
   },
   {
      "function" : "ccbaDisplayBorder",
      "comment" : "/*!\n *  ccbaDisplayBorder()\n *\n *      Input:  ccba\n *      Return: pix of border pixels, or null on error\n *\n *  Notes:\n *      (1) Uses global ptaa, which gives each border pixel in\n *          global coordinates, and must be computed in advance\n *          by calling ccbaGenerateGlobalLocs().\n */",
      "file" : "ccbord.c"
   },
   {
      "function" : "ccbaDisplayImage1",
      "comment" : "/*!\n *  ccbaDisplayImage1()\n *\n *      Input:  ccborda\n *      Return: pix of image, or null on error\n *\n *  Notes:\n *      (1) Uses local ptaa, which gives each border pixel in\n *          local coordinates, so the actual pixel positions must\n *          be computed using all offsets.\n *      (2) For the holes, use coordinates relative to the c.c.\n *      (3) This is slower than Method 2.\n *      (4) This uses topological properties (Method 1) to do scan\n *          conversion to raster\n *\n *  This algorithm deserves some commentary.\n *\n *  I first tried the following:\n *    - outer borders: 4-fill from outside, stopping at the\n *         border, using pixFillClosedBorders()\n *    - inner borders: 4-fill from outside, stopping again\n *         at the border, XOR with the border, and invert\n *         to get the hole.  This did not work, because if\n *         you have a hole border that looks like:\n *\n *                x x x x x x\n *                x          x\n *                x   x x x   x\n *                  x x o x   x\n *                      x     x\n *                      x     x\n *                        x x x\n *\n *         if you 4-fill from the outside, the pixel 'o' will\n *         not be filled!  XORing with the border leaves it OFF.\n *         Inverting then gives a single bad ON pixel that is not\n *         actually part of the hole.\n *\n *  So what you must do instead is 4-fill the holes from inside.\n *  You can do this from a seedfill, using a pix with the hole\n *  border as the filling mask.  But you need to start with a\n *  pixel inside the hole.  How is this determined?  The best\n *  way is from the contour.  We have a right-hand shoulder\n *  rule for inside (i.e., the filled region).   Take the\n *  first 2 pixels of the hole border, and compute dx and dy\n *  (second coord minus first coord:  dx = sx - fx, dy = sy - fy).\n *  There are 8 possibilities, depending on the values of dx and\n *  dy (which can each be -1, 0, and +1, but not both 0).\n *  These 8 cases can be broken into 4; see the simple algorithm below.\n *  Once you have an interior seed pixel, you fill from the seed,\n *  clipping with the hole border pix by filling into its invert.\n *\n *  You then successively XOR these interior filled components, in any order.\n */",
      "file" : "ccbord.c"
   },
   {
      "function" : "ccbaDisplayImage2",
      "comment" : "/*!\n *  ccbaDisplayImage2()\n *\n *      Input: ccborda\n *      Return: pix of image, or null on error\n *\n *  Notes:\n *      (1) Uses local chain ptaa, which gives each border pixel in\n *          local coordinates, so the actual pixel positions must\n *          be computed using all offsets.\n *      (2) Treats exterior and hole borders on equivalent\n *          footing, and does all calculations on a pix\n *          that spans the c.c. with a 1 pixel added boundary.\n *      (3) This uses topological properties (Method 2) to do scan\n *          conversion to raster\n *      (4) The algorithm is described at the top of this file (Method 2).\n *          It is preferred to Method 1 because it is between 1.2x and 2x\n *          faster than Method 1.\n */",
      "file" : "ccbord.c"
   },
   {
      "function" : "ccbaDisplaySPBorder",
      "comment" : "/*!\n *  ccbaDisplaySPBorder()\n *\n *      Input:  ccba\n *      Return: pix of border pixels, or null on error\n *\n *  Notes:\n *      (1) Uses spglobal pta, which gives each border pixel in\n *          global coordinates, one path per c.c., and must\n *          be computed in advance by calling ccbaGenerateSPGlobalLocs().\n */",
      "file" : "ccbord.c"
   },
   {
      "function" : "ccbaExtendArray",
      "comment" : "/*!\n *  ccbaExtendArray()\n *\n *      Input:  ccba\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "ccbord.c"
   },
   {
      "function" : "ccbaGenerateGlobalLocs",
      "comment" : "/*!\n *  ccbaGenerateGlobalLocs()\n *\n *      Input:  ccba (with local chain ptaa of borders computed)\n *      Return: 0 if OK, 1 on error\n *\n *  Action: this uses the pixel locs in the local ptaa, which are all\n *          relative to each c.c., to find the global pixel locations,\n *          and stores them in the global ptaa.\n */",
      "file" : "ccbord.c"
   },
   {
      "function" : "ccbaGenerateSPGlobalLocs",
      "comment" : "/*!\n *  ccbaGenerateSPGlobalLocs()\n *\n *      Input:  ccba\n *              ptsflag  (CCB_SAVE_ALL_PTS or CCB_SAVE_TURNING_PTS)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This calculates the splocal rep if not yet made.\n *      (2) It uses the local pixel values in splocal, the single\n *          path pta, which are all relative to each c.c., to find\n *          the corresponding global pixel locations, and stores\n *          them in the spglobal pta.\n *      (3) This lists only the turning points: it both makes a\n *          valid svg file and is typically about half the size\n *          when all border points are listed.\n */",
      "file" : "ccbord.c"
   },
   {
      "function" : "ccbaGenerateSinglePath",
      "comment" : "/*!\n *  ccbaGenerateSinglePath()\n *\n *      Input:  ccba\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Generates a single border in local pixel coordinates.\n *          For each c.c., if there is just an outer border, copy it.\n *          If there are also hole borders, for each hole border,\n *          determine the smallest horizontal or vertical\n *          distance from the border to the outside of the c.c.,\n *          and find a path through the c.c. for this cut.\n *          We do this in a way that guarantees a pixel from the\n *          hole border is the starting point of the path, and\n *          we must verify that the path intersects the outer\n *          border (if it intersects it, then it ends on it).\n *          One can imagine pathological cases, but they may not\n *          occur in images of text characters and un-textured\n *          line graphics.\n *      (2) Once it is verified that the path through the c.c.\n *          intersects both the hole and outer borders, we\n *          generate the full single path for all borders in the\n *          c.c.  Starting at the start point on the outer\n *          border, when we hit a line on a cut, we take\n *          the cut, do the hold border, and return on the cut\n *          to the outer border.  We compose a pta of the\n *          outer border pts that are on cut paths, and for\n *          every point on the outer border (as we go around),\n *          we check against this pta.  When we find a matching\n *          point in the pta, we do its cut path and hole border.\n *          The single path is saved in the ccb.\n */",
      "file" : "ccbord.c"
   },
   {
      "function" : "ccbaGenerateStepChains",
      "comment" : "/*!\n *  ccbaGenerateStepChains()\n *\n *      Input:  ccba (with local chain ptaa of borders computed)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This uses the pixel locs in the local ptaa,\n *          which are all relative to each c.c., to find\n *          the step directions for successive pixels in\n *          the chain, and stores them in the step numaa.\n *      (2) To get the step direction, use\n *              1   2   3\n *              0   P   4\n *              7   6   5\n *          where P is the previous pixel at (px, py).  The step direction\n *          is the number (from 0 through 7) for each relative location\n *          of the current pixel at (cx, cy).  It is easily found by\n *          indexing into a 2-d 3x3 array (dirtab).\n */",
      "file" : "ccbord.c"
   },
   {
      "function" : "ccbaGetCcb",
      "comment" : "/*!\n *  ccbaGetCcb()\n *\n *     Input:  ccba\n *     Return: ccb, or null on error\n */",
      "file" : "ccbord.c"
   },
   {
      "function" : "ccbaGetCount",
      "comment" : "/*!\n *  ccbaGetCount()\n *\n *     Input:  ccba\n *     Return: count, with 0 on error\n */",
      "file" : "ccbord.c"
   },
   {
      "function" : "ccbaRead",
      "comment" : "/*!\n *  ccbaRead()\n *\n *      Input:  filename\n *      Return: ccba, or null on error\n */",
      "file" : "ccbord.c"
   },
   {
      "function" : "ccbaReadStream",
      "comment" : "/*!\n *  ccbaReadStream()\n *\n *      Input:   stream\n *      Return:  ccba, or null on error\n *\n *  Format:  ccba: %7d cc\\n (num. c.c.) (ascii)   (17B)\n *           pix width (4B)\n *           pix height (4B)\n *           [for i = 1, ncc]\n *               ulx  (4B)\n *               uly  (4B)\n *               w    (4B)       -- not req'd for reconstruction\n *               h    (4B)       -- not req'd for reconstruction\n *               number of borders (4B)\n *               [for j = 1, nb]\n *                   startx  (4B)\n *                   starty  (4B)\n *                   [for k = 1, nb]\n *                        2 steps (1B)\n *                   end in z8 or 88  (1B)\n */",
      "file" : "ccbord.c"
   },
   {
      "function" : "ccbaStepChainsToPixCoords",
      "comment" : "/*!\n *  ccbaStepChainsToPixCoords()\n *\n *      Input:  ccba (with step chains numaa of borders)\n *              coordtype  (CCB_GLOBAL_COORDS or CCB_LOCAL_COORDS)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This uses the step chain data in each ccb to determine\n *          the pixel locations, either global or local,\n *          and stores them in the appropriate ptaa,\n *          either global or local.  For the latter, the\n *          pixel locations are relative to the c.c.\n */",
      "file" : "ccbord.c"
   },
   {
      "function" : "ccbaWrite",
      "comment" : "/*!\n *  ccbaWrite()\n *\n *      Input:  filename\n *              ccba\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "ccbord.c"
   },
   {
      "function" : "ccbaWriteSVG",
      "comment" : "/*!\n *  ccbaWriteSVG()\n *\n *      Input:  filename\n *              ccba\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "ccbord.c"
   },
   {
      "function" : "ccbaWriteSVGString",
      "comment" : "/*!\n *  ccbaWriteSVGString()\n *\n *      Input:  filename\n *              ccba\n *      Return: string in svg-formatted, that can be written to file,\n *              or null on error.\n */",
      "file" : "ccbord.c"
   },
   {
      "function" : "ccbaWriteStream",
      "comment" : "/*!\n *  ccbaWriteStream()\n *\n *      Input:  stream\n *              ccba\n *      Return: 0 if OK; 1 on error\n *\n *  Format:  ccba: %7d cc\\n (num. c.c.) (ascii)   (18B)\n *           pix width (4B)\n *           pix height (4B)\n *           [for i = 1, ncc]\n *               ulx  (4B)\n *               uly  (4B)\n *               w    (4B)       -- not req'd for reconstruction\n *               h    (4B)       -- not req'd for reconstruction\n *               number of borders (4B)\n *               [for j = 1, nb]\n *                   startx  (4B)\n *                   starty  (4B)\n *                   [for k = 1, nb]\n *                        2 steps (1B)\n *                   end in z8 or 88  (1B)\n */",
      "file" : "ccbord.c"
   },
   {
      "function" : "cidConvertToPdfData",
      "comment" : "/*!\n *  cidConvertToPdfData()\n *\n *      Input:  cid (compressed image data -- of jp2k image)\n *              title (<optional> pdf title; can be NULL)\n *              &data (<return> output pdf data for image)\n *              &nbytes (<return> size of output pdf data)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Caller must not destroy the cid.  It is absorbed in the\n *          lpd and destroyed by this function.\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "cleanProtoSignature",
      "comment" : "/*\n *  cleanProtoSignature()\n *\n *      Input:  instr (input prototype string)\n *      Return: cleanstr (clean prototype string), or NULL on error\n *\n *  Notes:\n *      (1) Adds 'extern' at beginning and regularizes spaces\n *          between tokens.\n */",
      "file" : "parseprotos.c"
   },
   {
      "function" : "composeRGBAPixel",
      "comment" : "/*!\n *  composeRGBAPixel()\n *\n *      Input:  rval, gval, bval, aval\n *              &pixel  (<return> 32-bit pixel)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) All channels are 8 bits: the input values must be between\n *          0 and 255.  For speed, this is not enforced by masking\n *          with 0xff before shifting.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "composeRGBPixel",
      "comment" : "/*!\n *  composeRGBPixel()\n *\n *      Input:  rval, gval, bval\n *              &pixel  (<return> 32-bit pixel)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) All channels are 8 bits: the input values must be between\n *          0 and 255.  For speed, this is not enforced by masking\n *          with 0xff before shifting.\n *      (2) A slower implementation uses macros:\n *            SET_DATA_BYTE(ppixel, COLOR_RED, rval);\n *            SET_DATA_BYTE(ppixel, COLOR_GREEN, gval);\n *            SET_DATA_BYTE(ppixel, COLOR_BLUE, bval);\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "concatenatePdf",
      "comment" : "/*!\n *  concatenatePdf()\n *\n *      Input:  directory name (containing single-page pdf files)\n *              substr (<optional> substring filter on filenames; can be NULL)\n *              fileout (concatenated pdf file)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This only works with leptonica-formatted single-page pdf files.\n *      (2) If @substr is not NULL, only filenames that contain\n *          the substring can be returned.  If @substr == NULL,\n *          none of the filenames are filtered out.\n *      (3) The files in the directory, after optional filtering by\n *          the substring, are lexically sorted in increasing order\n *          before concatenation.\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "concatenatePdfToData",
      "comment" : "/*!\n *  concatenatePdfToData()\n *\n *      Input:  directory name (containing single-page pdf files)\n *              substr (<optional> substring filter on filenames; can be NULL)\n *              &data (<return> concatenated pdf data in memory)\n *              &nbytes (<return> number of bytes in pdf data)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This only works with leptonica-formatted single-page pdf files.\n *      (2) If @substr is not NULL, only filenames that contain\n *          the substring can be returned.  If @substr == NULL,\n *          none of the filenames are filtered out.\n *      (3) The files in the directory, after optional filtering by\n *          the substring, are lexically sorted in increasing order\n *          before concatenation.\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "convertBinaryToGrayCode",
      "comment" : "/*!\n *  convertBinaryToGrayCode()\n *\n *      Input:  val\n *      Return: gray code value\n *\n *  Notes:\n *      (1) Gray code values corresponding to integers differ by\n *          only one bit transition between successive integers.\n */",
      "file" : "utils.c"
   },
   {
      "function" : "convertByteToHexAscii",
      "comment" : "/*!\n *  convertByteToHexAscii()\n *\n *      Input:  byteval  (input byte)\n *              &nib1, &nib2  (<return> two hex ascii characters)\n *      Return: void\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "convertChunkToAscii85",
      "comment" : "/*!\n *  convertChunkToAscii85()\n *\n *      Input:  inarray (input data)\n *              insize  (number of bytes in input array)\n *              &index (use and <return> -- ptr)\n *              outbuf (holds 8 ascii chars; we use no more than 7)\n *              &nbsout (<return> number of bytes written to outbuf)\n *      Return: boolean for eof (0 if more data, 1 if end of file)\n *\n *  Notes:\n *      (1) Attempts to read 4 bytes and write 5.\n *      (2) Writes 1 byte if the value is 0.\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "convertFilesFittedToPS",
      "comment" : "/*\n *  convertFilesFittedToPS()\n *\n *      Input:  dirin (input directory)\n *              substr (<optional> substring filter on filenames; can be NULL)\n *              xpts, ypts (desired size in printer points; use 0 for default)\n *              fileout (output ps file)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This generates a PS file for all files in a specified directory\n *          that contain the substr pattern to be matched.\n *      (2) Each image is written to a separate page in the output PS file.\n *      (3) All images are written compressed:\n *              * if tiffg4  -->  use ccittg4\n *              * if jpeg    -->  use dct\n *              * all others -->  use flate\n *          If the image is jpeg or tiffg4, we use the existing compressed\n *          strings for the encoding; otherwise, we read the image into\n *          a pix and flate-encode the pieces.\n *      (4) The resolution is internally determined such that the images\n *          are rendered, in at least one direction, at 100% of the given\n *          size in printer points.  Use 0.0 for xpts or ypts to get\n *          the default value, which is 612.0 or 792.0, rsp.\n *      (5) The size of the PostScript file is independent of the resolution,\n *          because the entire file is encoded.  The @xpts and @ypts\n *          parameter tells the PS decomposer how to render the page.\n */",
      "file" : "psio1.c"
   },
   {
      "function" : "convertFilesTo1bpp",
      "comment" : "/*!\n *  convertFilesTo1bpp()\n *\n *      Input:  dirin\n *              substr (<optional> substring filter on filenames; can be NULL)\n *              upscaling (1, 2 or 4; only for input color or grayscale)\n *              thresh  (global threshold for binarization; use 0 for default)\n *              firstpage\n *              npages (use 0 to do all from @firstpage to the end)\n *              dirout\n *              outformat (IFF_PNG, IFF_TIFF_G4)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Images are sorted lexicographically, and the names in the\n *          output directory are retained except for the extension.\n */",
      "file" : "convertfiles.c"
   },
   {
      "function" : "convertFilesToPS",
      "comment" : "/*\n *  convertFilesToPS()\n *\n *      Input:  dirin (input directory)\n *              substr (<optional> substring filter on filenames; can be NULL)\n *              res (typ. 300 or 600 ppi)\n *              fileout (output ps file)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This generates a PS file for all image files in a specified\n *          directory that contain the substr pattern to be matched.\n *      (2) Each image is written to a separate page in the output PS file.\n *      (3) All images are written compressed:\n *              * if tiffg4  -->  use ccittg4\n *              * if jpeg    -->  use dct\n *              * all others -->  use flate\n *          If the image is jpeg or tiffg4, we use the existing compressed\n *          strings for the encoding; otherwise, we read the image into\n *          a pix and flate-encode the pieces.\n *      (4) The resolution is often confusing.  It is interpreted\n *          as the resolution of the output display device:  \"If the\n *          input image were digitized at 300 ppi, what would it\n *          look like when displayed at res ppi.\"  So, for example,\n *          if res = 100 ppi, then the display pixels are 3x larger\n *          than the 300 ppi pixels, and the image will be rendered\n *          3x larger.\n *      (5) The size of the PostScript file is independent of the resolution,\n *          because the entire file is encoded.  The res parameter just\n *          tells the PS decomposer how to render the page.  Therefore,\n *          for minimum file size without loss of visual information,\n *          if the output res is less than 300, you should downscale\n *          the image to the output resolution before wrapping in PS.\n *      (6) The \"canvas\" on which the image is rendered, at the given\n *          output resolution, is a standard page size (8.5 x 11 in).\n */",
      "file" : "psio1.c"
   },
   {
      "function" : "convertFilesToPdf",
      "comment" : "/*!\n *  convertFilesToPdf()\n *\n *      Input:  directory name (containing images)\n *              substr (<optional> substring filter on filenames; can be NULL)\n *              res (input resolution of all images)\n *              scalefactor (scaling factor applied to each image; > 0.0)\n *              type (encoding type (L_JPEG_ENCODE, L_G4_ENCODE,\n *                    L_FLATE_ENCODE, or 0 for default)\n *              quality (used for JPEG only; 0 for default (75))\n *              title (<optional> pdf title; if null, taken from the first\n *                     image filename)\n *              fileout (pdf file of all images)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If @substr is not NULL, only image filenames that contain\n *          the substring can be used.  If @substr == NULL, all files\n *          in the directory are used.\n *      (2) The files in the directory, after optional filtering by\n *          the substring, are lexically sorted in increasing order\n *          before concatenation.\n *      (3) The scalefactor is applied to each image before encoding.\n *          If you enter a value <= 0.0, it will be set to 1.0.\n *      (4) Specifying one of the three encoding types for @type forces\n *          all images to be compressed with that type.  Use 0 to have\n *          the type determined for each image based on depth and whether\n *          or not it has a colormap.\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "convertFlateToPS",
      "comment" : "/*!\n *  convertFlateToPS()\n *\n *      Input:  filein (input file -- any format)\n *              fileout (output ps file)\n *              operation (\"w\" for write; \"a\" for append)\n *              x, y (location of LL corner of image, in pixels, relative\n *                    to the PostScript origin (0,0) at the LL corner\n *                    of the page)\n *              res (resolution of the input image, in ppi; use 0 for default)\n *              scale (scaling by printer; use 0.0 or 1.0 for no scaling)\n *              pageno (page number; must start with 1; you can use 0\n *                      if there is only one page.)\n *              endpage (boolean: use TRUE if this is the last image to be\n *                       added to the page; FALSE otherwise)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This outputs level 3 PS as flate compressed (overlaid\n *          with ascii85 encoding).\n *      (2) An output file can contain multiple pages, each with\n *          multiple images.  The arguments to convertFlateToPS()\n *          allow you to control placement of png images on multiple\n *          pages within a PostScript file.\n *      (3) For the first image written to a file, use \"w\", which\n *          opens for write and clears the file.  For all subsequent\n *          images written to that file, use \"a\".\n *      (4) The (x, y) parameters give the LL corner of the image\n *          relative to the LL corner of the page.  They are in\n *          units of pixels if scale = 1.0.  If you use (e.g.)\n *          scale = 2.0, the image is placed at (2x, 2y) on the page,\n *          and the image dimensions are also doubled.\n *      (5) Display vs printed resolution:\n *           * If your display is 75 ppi and your image was created\n *             at a resolution of 300 ppi, you can get the image\n *             to print at the same size as it appears on your display\n *             by either setting scale = 4.0 or by setting  res = 75.\n *             Both tell the printer to make a 4x enlarged image.\n *           * If your image is generated at 150 ppi and you use scale = 1,\n *             it will be rendered such that 150 pixels correspond\n *             to 72 pts (1 inch on the printer).  This function does\n *             the conversion from pixels (with or without scaling) to\n *             pts, which are the units that the printer uses.\n *           * The printer will choose its own resolution to use\n *             in rendering the image, which will not affect the size\n *             of the rendered image.  That is because the output\n *             PostScript file describes the geometry in terms of pts,\n *             which are defined to be 1/72 inch.  The printer will\n *             only see the size of the image in pts, through the\n *             scale and translate parameters and the affine\n *             transform (the ImageMatrix) of the image.\n *      (6) To render multiple images on the same page, set\n *          endpage = FALSE for each image until you get to the\n *          last, for which you set endpage = TRUE.  This causes the\n *          \"showpage\" command to be invoked.  Showpage outputs\n *          the entire page and clears the raster buffer for the\n *          next page to be added.  Without a \"showpage\",\n *          subsequent images from the next page will overlay those\n *          previously put down.\n *      (7) For multiple pages, increment the page number, starting\n *          with page 1.  This allows PostScript (and PDF) to build\n *          a page directory, which viewers use for navigation.\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "convertFlateToPSEmbed",
      "comment" : "/*!\n *  convertFlateToPSEmbed()\n *\n *      Input:  filein (input file -- any format)\n *              fileout (output ps file)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This function takes any image file as input and generates a\n *          flate-compressed, ascii85 encoded PS file, with a bounding box.\n *      (2) The bounding box is required when a program such as TeX\n *          (through epsf) places and rescales the image.\n *      (3) The bounding box is sized for fitting the image to an\n *          8.5 x 11.0 inch page.\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "convertFlateToPSString",
      "comment" : "/*!\n *  convertFlateToPSString()\n *\n *      Generates level 3 PS string in flate compressed format.\n *\n *      Input:  filein (input image file)\n *              &poutstr (<return> PS string)\n *              &nbytes (<return> number of bytes in PS string)\n *              x, y (location of LL corner of image, in pixels, relative\n *                    to the PostScript origin (0,0) at the LL corner\n *                    of the page)\n *              res (resolution of the input image, in ppi; use 0 for default)\n *              scale (scaling by printer; use 0.0 or 1.0 for no scaling)\n *              pageno (page number; must start with 1; you can use 0\n *                      if there is only one page.)\n *              endpage (boolean: use TRUE if this is the last image to be\n *                       added to the page; FALSE otherwise)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The returned PS character array is a null-terminated\n *          ascii string.  All the raster data is ascii85 encoded, so\n *          there are no null bytes embedded in it.\n *      (2) The raster encoding is made with gzip, the same as that\n *          in a png file that is compressed without prediction.\n *          The raster data itself is 25% larger than that in the\n *          binary form, due to the ascii85 encoding.\n *\n *  Usage:  See convertFlateToPS()\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "convertG4ToPS",
      "comment" : "/*!\n *  convertG4ToPS()\n *\n *      Input:  filein (input tiff g4 file)\n *              fileout (output ps file)\n *              operation (\"w\" for write; \"a\" for append)\n *              x, y (location of LL corner of image, in pixels, relative\n *                    to the PostScript origin (0,0) at the LL corner\n *                    of the page)\n *              res (resolution of the input image, in ppi; typ. values\n *                   are 300 and 600; use 0 for automatic determination\n *                   based on image size)\n *              scale (scaling by printer; use 0.0 or 1.0 for no scaling)\n *              pageno (page number; must start with 1; you can use 0\n *                      if there is only one page.)\n *              maskflag (boolean: use TRUE if just painting through fg;\n *                        FALSE if painting both fg and bg.\n *              endpage (boolean: use TRUE if this is the last image to be\n *                       added to the page; FALSE otherwise)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) See the usage comments in convertJpegToPS(), some of\n *          which are repeated here.\n *      (2) This is a wrapper for tiff g4.  The PostScript that\n *          is generated is expanded by about 5/4 (due to the\n *          ascii85 encoding.  If you convert to pdf (ps2pdf), the\n *          ascii85 decoder is automatically invoked, so that the\n *          pdf wrapped g4 file is essentially the same size as\n *          the original g4 file.  It's useful to have the PS\n *          file ascii85 encoded, because many printers will not\n *          print binary PS files.\n *      (3) For the first image written to a file, use \"w\", which\n *          opens for write and clears the file.  For all subsequent\n *          images written to that file, use \"a\".\n *      (4) To render multiple images on the same page, set\n *          endpage = FALSE for each image until you get to the\n *          last, for which you set endpage = TRUE.  This causes the\n *          \"showpage\" command to be invoked.  Showpage outputs\n *          the entire page and clears the raster buffer for the\n *          next page to be added.  Without a \"showpage\",\n *          subsequent images from the next page will overlay those\n *          previously put down.\n *      (5) For multiple images to the same page, where you are writing\n *          both jpeg and tiff-g4, you have two options:\n *           (a) write the g4 first, as either image (maskflag == FALSE)\n *               or imagemask (maskflag == TRUE), and then write the\n *               jpeg over it.\n *           (b) write the jpeg first and as the last item, write\n *               the g4 as an imagemask (maskflag == TRUE), to paint\n *               through the foreground only.\n *          We have this flexibility with the tiff-g4 because it is 1 bpp.\n *      (6) For multiple pages, increment the page number, starting\n *          with page 1.  This allows PostScript (and PDF) to build\n *          a page directory, which viewers use for navigation.\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "convertG4ToPSEmbed",
      "comment" : "/*!\n *  convertG4ToPSEmbed()\n *\n *      Input:  filein (input tiff file)\n *              fileout (output ps file)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This function takes a g4 compressed tif file as input and\n *          generates a g4 compressed, ascii85 encoded PS file, with\n *          a bounding box.\n *      (2) The bounding box is required when a program such as TeX\n *          (through epsf) places and rescales the image.\n *      (3) The bounding box is sized for fitting the image to an\n *          8.5 x 11.0 inch page.\n *      (4) We paint this through a mask, over whatever is below.\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "convertG4ToPSString",
      "comment" : "/*!\n *  convertG4ToPSString()\n *\n *      Input:  filein (input tiff g4 file)\n *              &poutstr (<return> PS string)\n *              &nbytes (<return> number of bytes in PS string)\n *              x, y (location of LL corner of image, in pixels, relative\n *                    to the PostScript origin (0,0) at the LL corner\n *                    of the page)\n *              res (resolution of the input image, in ppi; typ. values\n *                   are 300 and 600; use 0 for automatic determination\n *                   based on image size)\n *              scale (scaling by printer; use 0.0 or 1.0 for no scaling)\n *              pageno (page number; must start with 1; you can use 0\n *                      if there is only one page.)\n *              maskflag (boolean: use TRUE if just painting through fg;\n *                        FALSE if painting both fg and bg.\n *              endpage (boolean: use TRUE if this is the last image to be\n *                       added to the page; FALSE otherwise)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Generates PS string in G4 compressed tiff format from G4 tiff file.\n *      (2) For usage, see convertG4ToPS().\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "convertGrayCodeToBinary",
      "comment" : "/*!\n *  convertGrayCodeToBinary()\n *\n *      Input:  gray code value\n *      Return: binary value\n */",
      "file" : "utils.c"
   },
   {
      "function" : "convertHSVToRGB",
      "comment" : "/*!\n *  convertHSVToRGB()\n *\n *      Input:  hval, sval, vval\n *              &rval, &gval, &bval (<return> RGB values)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) See convertRGBToHSV() for valid input range of HSV values\n *          and their interpretation in color space.\n */",
      "file" : "colorspace.c"
   },
   {
      "function" : "convertImageDataToPdf",
      "comment" : "/*!\n *  convertImageDataToPdf()\n *\n *      Input:  imdata (array of formatted image data; e.g., png, jpeg)\n *              size (size of image data)\n *              type (L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE)\n *              quality (used for JPEG only; 0 for default (75))\n *              fileout (output pdf file; only required on last image on page)\n *              x, y (location of lower-left corner of image, in pixels,\n *                    relative to the PostScript origin (0,0) at\n *                    the lower-left corner of the page)\n *              res (override the resolution of the input image, in ppi;\n *                   use 0 to respect the resolution embedded in the input)\n *              title (<optional> pdf title)\n *              &lpd (ptr to lpd, which is created on the first invocation\n *                    and returned until last image is processed, at which\n *                    time it is destroyed)\n *              position (in image sequence: L_FIRST_IMAGE, L_NEXT_IMAGE,\n *                       L_LAST_IMAGE)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If @res == 0 and the input resolution field is 0,\n *          this will use DEFAULT_INPUT_RES.\n *      (2) See comments in convertToPdf().\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "convertImageDataToPdfData",
      "comment" : "/*!\n *  convertImageDataToPdfData()\n *\n *      Input:  imdata (array of formatted image data; e.g., png, jpeg)\n *              size (size of image data)\n *              type (L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE)\n *              quality (used for JPEG only; 0 for default (75))\n *              &data (<return> pdf data in memory)\n *              &nbytes (<return> number of bytes in pdf data)\n *              x, y (location of lower-left corner of image, in pixels,\n *                    relative to the PostScript origin (0,0) at\n *                    the lower-left corner of the page)\n *              res (override the resolution of the input image, in ppi;\n *                   use 0 to respect the resolution embedded in the input)\n *              title (<optional> pdf title)\n *              &lpd (ptr to lpd, which is created on the first invocation\n *                    and returned until last image is processed, at which\n *                    time it is destroyed)\n *              position (in image sequence: L_FIRST_IMAGE, L_NEXT_IMAGE,\n *                       L_LAST_IMAGE)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If @res == 0 and the input resolution field is 0,\n *          this will use DEFAULT_INPUT_RES.\n *      (2) See comments in convertToPdf().\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "convertJpegToPS",
      "comment" : "/*!\n *  convertJpegToPS()\n *\n *      Input:  filein (input jpeg file)\n *              fileout (output ps file)\n *              operation (\"w\" for write; \"a\" for append)\n *              x, y (location of LL corner of image, in pixels, relative\n *                    to the PostScript origin (0,0) at the LL corner\n *                    of the page)\n *              res (resolution of the input image, in ppi; use 0 for default)\n *              scale (scaling by printer; use 0.0 or 1.0 for no scaling)\n *              pageno (page number; must start with 1; you can use 0\n *                      if there is only one page)\n *              endpage (boolean: use TRUE if this is the last image to be\n *                       added to the page; FALSE otherwise)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is simpler to use than pixWriteStringPS(), and\n *          it outputs in level 2 PS as compressed DCT (overlaid\n *          with ascii85 encoding).\n *      (2) An output file can contain multiple pages, each with\n *          multiple images.  The arguments to convertJpegToPS()\n *          allow you to control placement of jpeg images on multiple\n *          pages within a PostScript file.\n *      (3) For the first image written to a file, use \"w\", which\n *          opens for write and clears the file.  For all subsequent\n *          images written to that file, use \"a\".\n *      (4) The (x, y) parameters give the LL corner of the image\n *          relative to the LL corner of the page.  They are in\n *          units of pixels if scale = 1.0.  If you use (e.g.)\n *          scale = 2.0, the image is placed at (2x, 2y) on the page,\n *          and the image dimensions are also doubled.\n *      (5) Display vs printed resolution:\n *           * If your display is 75 ppi and your image was created\n *             at a resolution of 300 ppi, you can get the image\n *             to print at the same size as it appears on your display\n *             by either setting scale = 4.0 or by setting  res = 75.\n *             Both tell the printer to make a 4x enlarged image.\n *           * If your image is generated at 150 ppi and you use scale = 1,\n *             it will be rendered such that 150 pixels correspond\n *             to 72 pts (1 inch on the printer).  This function does\n *             the conversion from pixels (with or without scaling) to\n *             pts, which are the units that the printer uses.\n *           * The printer will choose its own resolution to use\n *             in rendering the image, which will not affect the size\n *             of the rendered image.  That is because the output\n *             PostScript file describes the geometry in terms of pts,\n *             which are defined to be 1/72 inch.  The printer will\n *             only see the size of the image in pts, through the\n *             scale and translate parameters and the affine\n *             transform (the ImageMatrix) of the image.\n *      (6) To render multiple images on the same page, set\n *          endpage = FALSE for each image until you get to the\n *          last, for which you set endpage = TRUE.  This causes the\n *          \"showpage\" command to be invoked.  Showpage outputs\n *          the entire page and clears the raster buffer for the\n *          next page to be added.  Without a \"showpage\",\n *          subsequent images from the next page will overlay those\n *          previously put down.\n *      (7) For multiple pages, increment the page number, starting\n *          with page 1.  This allows PostScript (and PDF) to build\n *          a page directory, which viewers use for navigation.\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "convertJpegToPSEmbed",
      "comment" : "/*!\n *  convertJpegToPSEmbed()\n *\n *      Input:  filein (input jpeg file)\n *              fileout (output ps file)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This function takes a jpeg file as input and generates a DCT\n *          compressed, ascii85 encoded PS file, with a bounding box.\n *      (2) The bounding box is required when a program such as TeX\n *          (through epsf) places and rescales the image.\n *      (3) The bounding box is sized for fitting the image to an\n *          8.5 x 11.0 inch page.\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "convertJpegToPSString",
      "comment" : "/*!\n *  convertJpegToPSString()\n *\n *      Generates PS string in jpeg format from jpeg file\n *\n *      Input:  filein (input jpeg file)\n *              &poutstr (<return> PS string)\n *              &nbytes (<return> number of bytes in PS string)\n *              x, y (location of LL corner of image, in pixels, relative\n *                    to the PostScript origin (0,0) at the LL corner\n *                    of the page)\n *              res (resolution of the input image, in ppi; use 0 for default)\n *              scale (scaling by printer; use 0.0 or 1.0 for no scaling)\n *              pageno (page number; must start with 1; you can use 0\n *                      if there is only one page)\n *              endpage (boolean: use TRUE if this is the last image to be\n *                       added to the page; FALSE otherwise)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) For usage, see convertJpegToPS()\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "convertNumberedMasksToBoxaa",
      "comment" : "/*!\n *  convertNumberedMasksToBoxaa()\n *\n *      Input:  directory name (containing mask images)\n *              substr (<optional> substring filter on filenames; can be NULL)\n *              numpre (number of characters in name before number)\n *              numpost (number of characters in name after number, up\n *                       to a dot before an extension)\n *                       including an extension and the dot separator)\n *      Return: boxaa of mask regions, or null on error\n *\n *  Notes:\n *      (1) This is conveniently used to generate the input boxaa\n *          for convertSegmentedFilesToPdf().  It guarantees that the\n *          boxa will be aligned with the page images, even if some\n *          of the boxa are empty.\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "convertOnBigEnd16",
      "comment" : "/*--------------------------------------------------------------------*\n *                        16-bit byte swapping                        *\n *--------------------------------------------------------------------*/",
      "file" : "utils.c"
   },
   {
      "function" : "convertOnBigEnd16",
      "comment" : "/* L_LITTLE_ENDIAN */",
      "file" : "utils.c"
   },
   {
      "function" : "convertOnBigEnd32",
      "comment" : "/*--------------------------------------------------------------------*\n *                        32-bit byte swapping                        *\n *--------------------------------------------------------------------*/",
      "file" : "utils.c"
   },
   {
      "function" : "convertOnBigEnd32",
      "comment" : "/*  L_LITTLE_ENDIAN */",
      "file" : "utils.c"
   },
   {
      "function" : "convertOnLittleEnd16",
      "comment" : "/*--------------------------------------------------------------------*\n *                        16-bit byte swapping                        *\n *--------------------------------------------------------------------*/",
      "file" : "utils.c"
   },
   {
      "function" : "convertOnLittleEnd16",
      "comment" : "/* L_LITTLE_ENDIAN */",
      "file" : "utils.c"
   },
   {
      "function" : "convertOnLittleEnd32",
      "comment" : "/*--------------------------------------------------------------------*\n *                        32-bit byte swapping                        *\n *--------------------------------------------------------------------*/",
      "file" : "utils.c"
   },
   {
      "function" : "convertOnLittleEnd32",
      "comment" : "/*  L_LITTLE_ENDIAN */",
      "file" : "utils.c"
   },
   {
      "function" : "convertPtaLineTo4cc",
      "comment" : "/*!\n *  convertPtaLineTo4cc()\n *\n *      Input:  ptas (8-connected line of points)\n *      Return: ptad (4-connected line), or null on error\n *\n *  Notes:\n *      (1) When a polyline is generated with width = 1, the resulting\n *          line is not 4-connected in general.  This function adds\n *          points as necessary to convert the line to 4-cconnected.\n *          It is useful when rendering 1 bpp on a pix.\n *      (2) Do not use this for lines generated with width > 1.\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "convertRGBToHSV",
      "comment" : "/*!\n *  convertRGBToHSV()\n *\n *      Input:  rval, gval, bval (RGB input)\n *              &hval, &sval, &vval (<return> HSV values)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The range of returned values is:\n *            h [0 ... 239]\n *            s [0 ... 255]\n *            v [0 ... 255]\n *      (2) If r = g = b, the pixel is gray (s = 0), and we define h = 0.\n *      (3) h wraps around, so that h = 0 and h = 240 are equivalent\n *          in hue space.\n *      (4) h has the following correspondence to color:\n *            h = 0         magenta\n *            h = 40        red\n *            h = 80        yellow\n *            h = 120       green\n *            h = 160       cyan\n *            h = 200       blue\n */",
      "file" : "colorspace.c"
   },
   {
      "function" : "convertRGBToYUV",
      "comment" : "/*!\n *  convertRGBToYUV()\n *\n *      Input:  rval, gval, bval (RGB input)\n *              &yval, &uval, &vval (<return> YUV values)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The range of returned values is:\n *            Y [16 ... 235]\n *            U [16 ... 240]\n *            V [16 ... 240]\n */",
      "file" : "colorspace.c"
   },
   {
      "function" : "convertSegmentedFilesToPdf",
      "comment" : "/*!\n *  convertSegmentedFilesToPdf()\n *\n *      Input:  directory name (containing images)\n *              substr (<optional> substring filter on filenames; can be NULL)\n *              res (input resolution of all images)\n *              type (compression type for non-image regions; the\n *                    image regions are always compressed with L_JPEG_ENCODE)\n *              thresh (used for converting gray --> 1 bpp with L_G4_ENCODE)\n *              boxaa (<optional> of image regions)\n *              quality (used for JPEG only; 0 for default (75))\n *              scalefactor (scaling factor applied to each image region)\n *              title (<optional> pdf title; if null, taken from the first\n *                     image filename)\n *              fileout (pdf file of all images)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If @substr is not NULL, only image filenames that contain\n *          the substring can be used.  If @substr == NULL, all files\n *          in the directory are used.\n *      (2) The files in the directory, after optional filtering by\n *          the substring, are lexically sorted in increasing order\n *          before concatenation.\n *      (3) The images are encoded with G4 if 1 bpp; JPEG if 8 bpp without\n *          colormap and many colors, or 32 bpp; FLATE for anything else.\n *      (4) The boxaa, if it exists, contains one boxa of \"image regions\"\n *          for each image file.  The boxa must be aligned with the\n *          sorted set of images.\n *      (5) The scalefactor is applied to each image region.  It is\n *          typically < 1.0, to save bytes in the final pdf, because\n *          the resolution is often not critical in non-text regions.\n *      (6) If the non-image regions have pixel depth > 1 and the encoding\n *          type is G4, they are automatically scaled up by 2x and\n *          thresholded.  Otherwise, no scaling is performed on them.\n *      (7) Note that this function can be used to generate multipage\n *          G4 compressed pdf from any input, by using @boxaa == NULL\n *          and @type == L_G4_ENCODE.\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "convertSegmentedPagesToPS",
      "comment" : "/*\n *  convertSegmentedPagesToPS()\n *\n *      Input:  pagedir (input page image directory)\n *              pagestr (<optional> substring filter on page filenames;\n *                       can be NULL)\n *              maskdir (input mask image directory)\n *              maskstr (<optional> substring filter on mask filenames;\n *                       can be NULL)\n *              numpre (number of characters in name before number)\n *              numpost (number of characters in name after number)\n *              maxnum (only consider page numbers up to this value)\n *              textscale (scale of text output relative to pixs)\n *              imagescale (scale of image output relative to pixs)\n *              threshold (for binarization; typ. about 190; 0 for default)\n *              fileout (output ps file)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This generates a PS file for all page image and mask files in two\n *          specified directories and that contain the page numbers as\n *          specified below.  The two directories can be the same, in which\n *          case the page and mask files are differentiated by the two\n *          substrings for string matches.\n *      (2) The page images are taken in lexicographic order.\n *          Mask images whose numbers match the page images are used to\n *          segment the page images.  Page images without a matching\n *          mask image are scaled, thresholded and rendered entirely as text.\n *      (3) Each PS page is generated as a compressed representation of\n *          the page image, where the part of the image under the mask\n *          is suitably scaled and compressed as DCT (i.e., jpeg), and\n *          the remaining part of the page is suitably scaled, thresholded,\n *          compressed as G4 (i.e., tiff g4), and rendered by painting\n *          black through the resulting text mask.\n *      (4) The scaling is typically 2x down for the DCT component\n *          (@imagescale = 0.5) and 2x up for the G4 component\n *          (@textscale = 2.0).\n *      (5) The resolution is automatically set to fit to a\n *          letter-size (8.5 x 11 inch) page.\n *      (6) Both the DCT and the G4 encoding are PostScript level 2.\n *      (7) It is assumed that the page number is contained within\n *          the basename (the filename without directory or extension).\n *          @numpre is the number of characters in the basename\n *          preceeding the actual page numer; @numpost is the number\n *          following the page number.  Note: the same numbers must be\n *          applied to both the page and mask image names.\n *      (8) To render a page as is -- that is, with no thresholding\n *          of any pixels -- use a mask in the mask directory that is\n *          full size with all pixels set to 1.  If the page is 1 bpp,\n *          it is not necessary to have a mask.\n */",
      "file" : "psio1.c"
   },
   {
      "function" : "convertSortedToNumberedPathnames",
      "comment" : "/*!\n *  convertSortedToNumberedPathnames()\n *\n *      Input:  sorted pathnames (including zero-padded integers)\n *              numpre (number of characters in name before number)\n *              numpost (number of characters in name after the number,\n *                       up to a dot before an extension)\n *              maxnum (only consider page numbers up to this value)\n *      Return: sarray of numbered pathnames, or NULL on error\n *\n *  Notes:\n *      (1) Typically, numpre = numpost = 0; e.g., when the filename\n *          just has a number followed by an optional extension.\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "convertTiffMultipageToPS",
      "comment" : "/*!\n *  convertTiffMultipageToPS()\n *\n *      Input:  filein (input tiff multipage file)\n *              fileout (output ps file)\n *              tempfile (<optional> for temporary g4 tiffs;\n *                        use NULL for default)\n *              factor (for filling 8.5 x 11 inch page;\n *                      use 0.0 for DEFAULT_FILL_FRACTION)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This converts a multipage tiff file of binary page images\n *          into a ccitt g4 compressed PS file.\n *      (2) If the images are generated from a standard resolution fax,\n *          the vertical resolution is doubled to give a normal-looking\n *          aspect ratio.\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "convertToNUpFiles",
      "comment" : "/*!\n *  convertToNUpFiles()\n *\n *      Input:  indir (full path to directory of images)\n *              substr (<optional> can be null)\n *              nx, ny (in [1, ... 50], tiling factors in each direction)\n *              scaling (approximate overall scaling factor, after tiling)\n *              spacing  (between images, and on outside)\n *              border (width of additional black border on each image;\n *                      use 0 for no border)\n *              outdir (subdirectory of /tmp to put N-up tiled images)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Each set of nx*ny images is scaled and tiled into a single\n *          image, that is written out to @outdir.\n *      (2) All images in each nx*ny set are scaled to the same width.\n *          This is typically used when all images are roughly the same\n *          size.\n *      (3) Typical values for nx and ny are in [2 ... 5].\n *      (4) The reciprocal of nx is used for scaling.  If nx == ny, the\n *          resulting image shape is similar to that of the input images.\n */",
      "file" : "pixafunc2.c"
   },
   {
      "function" : "convertToNUpPixa",
      "comment" : "/*!\n *  convertToNUpPixa()\n *\n *      Input:  dir (full path to directory of images)\n *              substr (<optional> can be null)\n *              nx, ny (in [1, ... 50], tiling factors in each direction)\n *              scaling (approximate overall scaling factor, after tiling)\n *              spacing  (between images, and on outside)\n *              border (width of additional black border on each image;\n *                      use 0 for no border)\n *      Return: pixad, or null on error\n *\n *  Notes:\n *      (1) See notes for filesTileNUp()\n */",
      "file" : "pixafunc2.c"
   },
   {
      "function" : "convertToPSEmbed",
      "comment" : "/*\n *  convertToPSEmbed()\n *\n *      Input:  filein (input image file -- any format)\n *              fileout (output ps file)\n *              level (compression: 1 (uncompressed), 2 or 3)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is a wrapper function that generates a PS file with\n *          a bounding box, from any input image file.\n *      (2) Do the best job of compression given the specified level.\n *          @level=3 does flate compression on anything that is not\n *          tiffg4 (1 bpp) or jpeg (8 bpp or rgb).\n *      (3) If @level=2 and the file is not tiffg4 or jpeg, it will\n *          first be written to file as jpeg with quality = 75.\n *          This will remove the colormap and cause some degradation\n *          in the image.\n *      (4) The bounding box is required when a program such as TeX\n *          (through epsf) places and rescales the image.  It is\n *          sized for fitting the image to an 8.5 x 11.0 inch page.\n */",
      "file" : "psio1.c"
   },
   {
      "function" : "convertToPdf",
      "comment" : "/*!\n *  convertToPdf()\n *\n *      Input:  filein (input image file -- any format)\n *              type (L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE)\n *              quality (used for JPEG only; 0 for default (75))\n *              fileout (output pdf file; only required on last image on page)\n *              x, y (location of lower-left corner of image, in pixels,\n *                    relative to the PostScript origin (0,0) at\n *                    the lower-left corner of the page)\n *              res (override the resolution of the input image, in ppi;\n *                   use 0 to respect the resolution embedded in the input)\n *              title (<optional> pdf title; if null, taken from filein)\n *              &lpd (ptr to lpd, which is created on the first invocation\n *                    and returned until last image is processed, at which\n *                    time it is destroyed)\n *              position (in image sequence: L_FIRST_IMAGE, L_NEXT_IMAGE,\n *                       L_LAST_IMAGE)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) To wrap only one image in pdf, input @plpd = NULL, and\n *          the value of @position will be ignored:\n *            convertToPdf(...  type, quality, x, y, res, NULL, 0);\n *      (2) To wrap multiple images on a single pdf page, this is called\n *          once for each successive image.  Do it this way:\n *            L_PDF_DATA   *lpd;\n *            convertToPdf(...  type, quality, x, y, res, &lpd, L_FIRST_IMAGE);\n *            convertToPdf(...  type, quality, x, y, res, &lpd, L_NEXT_IMAGE);\n *            ...\n *            convertToPdf(...  type, quality, x, y, res, &lpd, L_LAST_IMAGE);\n *          This will write the result to the value of @fileout specified\n *          in the first call; succeeding values of @fileout are ignored.\n *          On the last call: the pdf data bytes are computed and written\n *          to @fileout, lpd is destroyed internally, and the returned\n *          value of lpd is null.  So the client has nothing to clean up.\n *      (3) (a) Set @res == 0 to respect the resolution embedded in the\n *              image file.  If no resolution is embedded, it will be set\n *              to the default value.\n *          (b) Set @res to some other value to override the file resolution.\n *      (4) (a) If the input @res and the resolution of the output device\n *              are equal, the image will be \"displayed\" at the same size\n *              as the original.\n *          (b) If the input @res is 72, the output device will render\n *              the image at 1 pt/pixel.\n *          (c) Some possible choices for the default input pix resolution are:\n *                 72 ppi     Render pix on any output device at one pt/pixel\n *                 96 ppi     Windows default for generated display images\n *                300 ppi     Typical default for scanned images.\n *              We choose 300, which is sensible for rendering page images.\n *              However,  images come from a variety of sources, and\n *              some are explicitly created for viewing on a display.\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "convertToPdfData",
      "comment" : "/*!\n *  convertToPdfData()\n *\n *      Input:  filein (input image file -- any format)\n *              type (L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE)\n *              quality (used for JPEG only; 0 for default (75))\n *              &data (<return> pdf data in memory)\n *              &nbytes (<return> number of bytes in pdf data)\n *              x, y (location of lower-left corner of image, in pixels,\n *                    relative to the PostScript origin (0,0) at\n *                    the lower-left corner of the page)\n *              res (override the resolution of the input image, in ppi;\n *                   use 0 to respect the resolution embedded in the input)\n *              title (<optional> pdf title; if null, use filein)\n *              &lpd (ptr to lpd, which is created on the first invocation\n *                    and returned until last image is processed, at which\n *                    time it is destroyed)\n *              position (in image sequence: L_FIRST_IMAGE, L_NEXT_IMAGE,\n *                       L_LAST_IMAGE)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If @res == 0 and the input resolution field is 0,\n *          this will use DEFAULT_INPUT_RES.\n *      (2) See comments in convertToPdf().\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "convertToPdfDataSegmented",
      "comment" : "/*!\n *  convertToPdfDataSegmented()\n *\n *      Input:  filein (input image file -- any format)\n *              res (input image resolution; typ. 300 ppi; use 0 for default)\n *              type (compression type for non-image regions; the\n *                    image regions are always compressed with L_JPEG_ENCODE)\n *              thresh (used for converting gray --> 1 bpp with L_G4_ENCODE)\n *              boxa (<optional> image regions; can be null)\n *              quality (used for jpeg image regions; 0 for default)\n *              scalefactor (used for jpeg regions; must be <= 1.0)\n *              title (<optional> pdf title; if null, uses filein)\n *              &data (<return> pdf data in memory)\n *              &nbytes (<return> number of bytes in pdf data)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If there are no image regions, set @boxa == NULL;\n *          @quality and @scalefactor are ignored.\n *      (2) Typically, @scalefactor is < 1.0.  The image regions are\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "convertToPdfSegmented",
      "comment" : "/*!\n *  convertToPdfSegmented()\n *\n *      Input:  filein (input image file -- any format)\n *              res (input image resolution; typ. 300 ppi; use 0 for default)\n *              type (compression type for non-image regions; the\n *                    image regions are always compressed with L_JPEG_ENCODE)\n *              thresh (used for converting gray --> 1 bpp with L_G4_ENCODE)\n *              boxa (<optional> of image regions; can be null)\n *              quality (used for jpeg image regions; 0 for default)\n *              scalefactor (used for jpeg regions; must be <= 1.0)\n *              title (<optional> pdf title; typically taken from the\n *                     input file for the pix)\n *              fileout (output pdf file)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If there are no image regions, set @boxa == NULL;\n *          @quality and @scalefactor are ignored.\n *      (2) Typically, @scalefactor is < 1.0, because the image regions\n *          can be rendered at a lower resolution (for better compression)\n *          than the text regions.  If @scalefactor == 0, we use 1.0.\n *          If the input image is 1 bpp and scalefactor < 1.0, we\n *          use scaleToGray() to downsample the image regions to gray\n *          before compressing them.\n *      (3) If the compression type for non-image regions is L_G4_ENCODE\n *          and bpp > 1, the image is upscaled 2x and thresholded\n *          to 1 bpp.  That is the only situation where @thresh is used.\n *      (4) The parameter @quality is only used for image regions.\n *          If @type == L_JPEG_ENCODE, default jpeg quality (75) is\n *          used for the non-image regions.\n *      (5) Processing matrix for non-image regions.\n *\n *          Input           G4              JPEG                FLATE\n *          ----------|---------------------------------------------------\n *          1 bpp     |  1x, 1 bpp       1x flate, 1 bpp     1x, 1 bpp\n *                    |\n *          cmap      |  2x, 1 bpp       1x flate, cmap      1x, cmap\n *                    |\n *          2,4 bpp   |  2x, 1 bpp       1x flate            1x, 2,4 bpp\n *          no cmap   |                  2,4 bpp\n *                    |\n *          8,32 bpp  |  2x, 1 bpp       1x (jpeg)           1x, 8,32 bpp\n *          no cmap   |                  8,32 bpp\n *\n *          Summary:\n *          (a) if G4 is requested, G4 is used, with 2x upscaling\n *              for all cases except 1 bpp.\n *          (b) if JPEG is requested, use flate encoding for all cases\n *              except 8 bpp without cmap and 32 bpp (rgb).\n *          (c) if FLATE is requested, use flate with no transformation\n *              of the raster data.\n *      (6) Calling options/sequence for these functions:\n *              file  -->  file      (convertToPdfSegmented)\n *                  pix  -->  file      (pixConvertToPdfSegmented)\n *                      pix  -->  data      (pixConvertToPdfDataSegmented)\n *              file  -->  data      (convertToPdfDataSegmented)\n *                      pix  -->  data      (pixConvertToPdfDataSegmented)\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "convertUnscaledFilesToPdf",
      "comment" : "/*!\n *  convertUnscaledFilesToPdf()\n *\n *      Input:  directory name (containing images)\n *              substr (<optional> substring filter on filenames; can be NULL)\n *              title (<optional> pdf title; if null, taken from the first\n *                     image filename)\n *              fileout (pdf file of all images)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If @substr is not NULL, only image filenames that contain\n *          the substring can be used.  If @substr == NULL, all files\n *          in the directory are used.\n *      (2) The files in the directory, after optional filtering by\n *          the substring, are lexically sorted in increasing order\n *          before concatenation.\n *      (3) For jpeg and jp2k, this is very fast because the compressed\n *          data is wrapped up and concatenated.  For png and tiffg4,\n *          the images must be read and recompressed.\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "convertUnscaledToPdfData",
      "comment" : "/*!\n *  convertUnscaledToPdfData()\n *\n *      Input:  fname (of image file)\n *              title (<optional> pdf title; can be NULL)\n *              &data (<return> output pdf data for image)\n *              &nbytes (<return> size of output pdf data)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "convertYUVToRGB",
      "comment" : "/*!\n *  convertYUVToRGB()\n *\n *      Input:  yval, uval, vval\n *              &rval, &gval, &bval (<return> RGB values)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The range of valid input values is:\n *            Y [16 ... 235]\n *            U [16 ... 240]\n *            V [16 ... 240]\n *      (2) Conversion of RGB --> YUV --> RGB leaves the image unchanged.\n *      (3) The YUV gamut is larger than the RBG gamut; many YUV values\n *          will result in an invalid RGB value.  We clip individual\n *          r,g,b components to the range [0, 255], and do not test input.\n */",
      "file" : "colorspace.c"
   },
   {
      "function" : "countAlignedMatches",
      "comment" : "/*\n *  countAlignedMatches()\n *      Input:  nai1, nai2 (numas of row pairs for matches)\n *              nasx, nasy (numas of x and y shifts for the matches)\n *              n1, n2 (number of rows in images 1 and 2)\n *              delx, dely (allowed difference in shifts of the match,\n *                          compared to the reference match)\n *              nreq (number of required aligned matches)\n *              &same (<return> 1 if @nreq row matches are found; 0 otherwise)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This takes 4 input arrays giving parameters of all the\n *          line matches.  It looks for the maximum set of aligned\n *          matches (matches with approximately the same overall shifts)\n *          that do not use rows from either image more than once.\n */",
      "file" : "classapp.c"
   },
   {
      "function" : "cqcellTreeCreate",
      "comment" : "/*!\n *  cqcellTreeCreate()\n *\n *      Input:  none\n *      Return: cqcell array tree\n */",
      "file" : "colorquant1.c"
   },
   {
      "function" : "cqcellTreeDestroy",
      "comment" : "/*!\n *  cqcellTreeDestroy()\n *\n *      Input:  &cqcaa (<to be nulled>\n *      Return: void\n */",
      "file" : "colorquant1.c"
   },
   {
      "function" : "create2dFloatArray",
      "comment" : "/*!\n *  create2dFloatArray()\n *\n *      Input:  sy (rows == height)\n *              sx (columns == width)\n *      Return: doubly indexed array (i.e., an array of sy row pointers,\n *              each of which points to an array of sx floats)\n *\n *  Notes:\n *      (1) The array[sy][sx] is indexed in standard \"matrix notation\",\n *          with the row index first.\n */",
      "file" : "kernel.c"
   },
   {
      "function" : "create2dIntArray",
      "comment" : "/*!\n *  create2dIntArray()\n *\n *      Input:  sy (rows == height)\n *              sx (columns == width)\n *      Return: doubly indexed array (i.e., an array of sy row pointers,\n *              each of which points to an array of sx ints)\n *\n *  Notes:\n *      (1) The array[sy][sx] is indexed in standard \"matrix notation\",\n *          with the row index first.\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "createMatrix2dRotate",
      "comment" : "/*!\n *  createMatrix2dRotate()\n *\n *      Input:  xc, yc  (location of center of rotation)\n *              angle  (rotation in radians; clockwise is positive)\n *      Return: 3x3 transform matrix, or null on error\n *\n *  Notes;\n *      (1) The rotation is equivalent to:\n *             v' = Av\n *          where v and v' are 1x3 column vectors in the form\n *             v = [x, y, 1]^    (^ denotes transpose)\n *          and the affine rotation matrix is\n *             A = [ cosa   -sina    xc*(1-cosa) + yc*sina\n *                   sina    cosa    yc*(1-cosa) - xc*sina\n *                     0       0                 1         ]\n *\n *          If the rotation is about the origin, (xc, yc) = (0, 0) and\n *          this simplifies to\n *             A = [ cosa   -sina    0\n *                   sina    cosa    0\n *                     0       0     1 ]\n *\n *          These relations follow from the following equations, which\n *          you can convince yourself are correct as follows.  Draw a\n *          circle centered on (xc,yc) and passing through (x,y), with\n *          (x',y') on the arc at an angle 'a' clockwise from (x,y).\n *          [ Hint: cos(a + b) = cosa * cosb - sina * sinb\n *                  sin(a + b) = sina * cosb + cosa * sinb ]\n *\n *            x' - xc =  (x - xc) * cosa - (y - yc) * sina\n *            y' - yc =  (x - xc) * sina + (y - yc) * cosa\n */",
      "file" : "affinecompose.c"
   },
   {
      "function" : "createMatrix2dScale",
      "comment" : "/*!\n *  createMatrix2dScale()\n *\n *      Input:  scalex  (horizontal scale factor)\n *              scaley  (vertical scale factor)\n *      Return: 3x3 transform matrix, or null on error\n *\n *  Notes;\n *      (1) The scaling is equivalent to:\n *             v' = Av\n *          where v and v' are 1x3 column vectors in the form\n *             v = [x, y, 1]^    (^ denotes transpose)\n *          and the affine scaling matrix is\n *             A = [ sx  0    0\n *                   0   sy   0\n *                   0   0    1  ]\n *\n *      (2) We consider scaling as with respect to a fixed origin.\n *          In other words, the origin is the only point that doesn't\n *          move in the scaling transform.\n */",
      "file" : "affinecompose.c"
   },
   {
      "function" : "createMatrix2dTranslate",
      "comment" : "/*!\n *  createMatrix2dTranslate()\n *\n *      Input:  transx  (x component of translation wrt. the origin)\n *              transy  (y component of translation wrt. the origin)\n *      Return: 3x3 transform matrix, or null on error\n *\n *  Notes;\n *      (1) The translation is equivalent to:\n *             v' = Av\n *          where v and v' are 1x3 column vectors in the form\n *             v = [x, y, 1]^    (^ denotes transpose)\n *          and the affine tranlation matrix is\n *             A = [ 1   0   tx\n *                   0   1   ty\n *                   0   0    1  ]\n *\n *      (2) We consider translation as with respect to a fixed origin.\n *          In a clipping operation, the origin moves and the points\n *          are fixed, and you use (-tx, -ty) where (tx, ty) is the\n *          translation vector of the origin.\n */",
      "file" : "affinecompose.c"
   },
   {
      "function" : "debugAddImage1",
      "comment" : "/*\n *  debugAddImage1()\n *\n *      Input:  pixa1 (<optional> for accumulating pairs of images\n *              pix1, pix2\n *              bmf\n *              score (rendered using the bmf)\n *      Return: void\n *\n *  Notes:\n *      (1) If pixa1 is NULL, do nothing.  Otherwise, we add a pair of\n *          images with a score.  This is accumulated for each\n *          corresponding class templates in the two recog.\n */",
      "file" : "recogtrain.c"
   },
   {
      "function" : "debugAddImage2",
      "comment" : "/*\n *  debugAddImage2()\n *\n *      Input:  &pixadb (<optional; possible return>\n *              pixa1 (<optional> accumulated pairs of images)\n *              bmf\n *              index (of recog in recoga)\n *      Return: void\n *\n *  Notes:\n *      (1) If pixa1 is NULL, do nothing.\n *      (2) If this is the first time this function is called, then\n *          *ppixadb == NULL, so we create pixadb (storing the ptr at ppixadb).\n *      (3) Display pixa1 into a pix and add to pixadb.\n *      (4) Subsequent calls, for different recognizers that could be used\n *          for augmenting the instances, add to pixadb.\n */",
      "file" : "recogtrain.c"
   },
   {
      "function" : "debugPrintLUT",
      "comment" : "/* save for re-use */",
      "file" : "watershed.c"
   },
   {
      "function" : "debugWshedMerge",
      "comment" : "/* save for re-use */",
      "file" : "watershed.c"
   },
   {
      "function" : "decodeAscii85",
      "comment" : "/*!\n *  decodeAscii85()\n *\n *      Input:  inarray (ascii85 input data)\n *              insize (number of bytes in input array)\n *              &outsize (<return> number of bytes in output l_uint8 array)\n *      Return: outarray (binary)\n *\n *  Notes:\n *      (1) We assume the data is properly encoded, so we do not check\n *          for invalid characters or the final '>' character.\n *      (2) We permit whitespace to be added to the encoding in an\n *          arbitrary way.\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "dewarpBuildLineModel",
      "comment" : "/*!\n *  dewarpBuildLineModel()\n *\n *      Input:  dew\n *              opensize (size of opening to remove perpendicular lines)\n *              debugfile (use null to skip writing this)\n *      Return: 0 if OK, 1 if unable to build the model or on error\n *\n *  Notes:\n *      (1) This builds the horizontal and vertical disparity arrays\n *          for an input of ruled lines, typically for calibration.\n *          In book scanning, you could lay the ruled paper over a page.\n *          Then for that page and several below it, you can use the\n *          disparity correction of the line model to dewarp the pages.\n *      (2) The dew has been initialized with the image of ruled lines.\n *          These lines must be continuous, but we do a small amount\n *          of pre-processing here to insure that.\n *      (3) @opensize is typically about 8.  It must be larger than\n *          the thickness of the lines to be extracted.  This is the\n *          default value, which is applied if @opensize < 3.\n *      (4) Sets vsuccess = 1 and hsuccess = 1 if the vertical and/or\n *          horizontal disparity arrays build.\n *      (5) Similar to dewarpBuildPageModel(), except here the vertical\n *          and horizontal disparity arrays are both built from ruled lines.\n *          See notes there.\n */",
      "file" : "dewarp2.c"
   },
   {
      "function" : "dewarpBuildPageModel",
      "comment" : "/*!\n *  dewarpBuildPageModel()\n *\n *      Input:  dew\n *              debugfile (use null to skip writing this)\n *      Return: 0 if OK, 1 if unable to build the model or on error\n *\n *  Notes:\n *      (1) This is the basic function that builds the horizontal and\n *          vertical disparity arrays, which allow determination of the\n *          src pixel in the input image corresponding to each\n *          dest pixel in the dewarped image.\n *      (2) Sets vsuccess = 1 if the vertical disparity array builds.\n *          Always attempts to build the horizontal disparity array,\n *          even if it will not be requested (useboth == 0).\n *          Sets hsuccess = 1 if horizontal disparity builds.\n *      (3) The method is as follows:\n *          (a) Estimate the points along the centers of all the\n *              long textlines.  If there are too few lines, no\n *              disparity models are built.\n *          (b) From the vertical deviation of the lines, estimate\n *              the vertical disparity.\n *          (c) From the ends of the lines, estimate the horizontal\n *              disparity, assuming that the text is made of lines\n *              that are left and right justified.\n *          (d) One can also compute an additional contribution to the\n *              horizontal disparity, inferred from slopes of the top\n *              and bottom lines.  We do not do this.\n *      (4) In more detail for the vertical disparity:\n *          (a) Fit a LS quadratic to center locations along each line.\n *              This smooths the curves.\n *          (b) Sample each curve at a regular interval, find the y-value\n *              of the mid-point on each curve, and subtract the sampled\n *              curve value from this value.  This is the vertical\n *              disparity at sampled points along each curve.\n *          (c) Fit a LS quadratic to each set of vertically aligned\n *              disparity samples.  This smooths the disparity values\n *              in the vertical direction.  Then resample at the same\n *              regular interval.  We now have a regular grid of smoothed\n *              vertical disparity valuels.\n *      (5) Once the sampled vertical disparity array is found, it can be\n *          interpolated to get a full resolution vertical disparity map.\n *          This can be applied directly to the src image pixels\n *          to dewarp the image in the vertical direction, making\n *          all textlines horizontal.  Likewise, the horizontal\n *          disparity array is used to left- and right-align the\n *          longest textlines.\n */",
      "file" : "dewarp2.c"
   },
   {
      "function" : "dewarpCreate",
      "comment" : "/*!\n *  dewarpCreate()\n *\n *     Input: pixs (1 bpp)\n *            pageno (page number)\n *     Return: dew (or null on error)\n *\n *  Notes:\n *      (1) The input pixs is either full resolution or 2x reduced.\n *      (2) The page number is typically 0-based.  If scanned from a book,\n *          the even pages are usually on the left.  Disparity arrays\n *          built for even pages should only be applied to even pages.\n */",
      "file" : "dewarp1.c"
   },
   {
      "function" : "dewarpCreateRef",
      "comment" : "/*!\n *  dewarpCreateRef()\n *\n *     Input:  pageno (this page number)\n *             refpage (page number of dewarp disparity arrays to be used)\n *     Return: dew (or null on error)\n *\n *  Notes:\n *      (1) This specifies which dewarp struct should be used for\n *          the given page.  It is placed in dewarpa for pages\n *          for which no model can be built.\n *      (2) This page and the reference page have the same parity and\n *          the reference page is the closest page with a disparity model\n *          to this page.\n */",
      "file" : "dewarp1.c"
   },
   {
      "function" : "dewarpDebug",
      "comment" : "/*!\n *  dewarpDebug()\n *\n *      Input:  dew\n *              subdir (a subdirectory of /tmp; e.g., \"dew1\")\n *              index (to help label output images; e.g., the page number)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Prints dewarp fields and generates disparity array contour images.\n *          The contour images are written to file:\n *                /tmp/[subdir]/pixv_[index].png\n */",
      "file" : "dewarp4.c"
   },
   {
      "function" : "dewarpDestroy",
      "comment" : "/*!\n *  dewarpDestroy()\n *\n *      Input:  &dew (<will be set to null before returning>)\n *      Return: void\n */",
      "file" : "dewarp1.c"
   },
   {
      "function" : "dewarpFindHorizDisparity",
      "comment" : "/*!\n *  dewarpFindHorizDisparity()\n *\n *      Input:  dew\n *              ptaa (unsmoothed lines, not vertically ordered)\n *      Return: 0 if OK, 1 if vertical disparity array is no built or on error\n *\n *      (1) This is not required for a successful model; only the vertical\n *          disparity is required.  This will not be called if the\n *          function to build the vertical disparity fails.\n *      (2) Debug output goes to /tmp/dewmod/ for collection into a pdf.\n */",
      "file" : "dewarp2.c"
   },
   {
      "function" : "dewarpFindLongLines",
      "comment" : "/*!\n *  dewarpFindLongLines()\n *\n *      Input:  ptal (left end points of lines)\n *              ptar (right end points of lines)\n *              minfract (minimum allowed fraction of longest line)\n *              &ptald (<return> left end points of longest lines)\n *              &ptard (<return> right end points of longest lines)\n *      Return: 0 if OK, 1 on error or if there aren't enough long lines\n *\n *  Notes:\n *      (1) We do the following:\n *         (a) Sort the lines from top to bottom, and divide equally\n *             into Top and Bottom sets.\n *         (b) For each set, select the lines that are at least @minfract\n *             of the length of the longest line in the set.\n *             Typically choose @minfract between 0.9 and 0.95.\n *         (c) Accumulate the left and right end points from both\n *             sets into the two returned ptas.\n */",
      "file" : "dewarp2.c"
   },
   {
      "function" : "dewarpFindVertDisparity",
      "comment" : "/*!\n *  dewarpFindVertDisparity()\n *\n *      Input:  dew\n *              ptaa (unsmoothed lines, not vertically ordered)\n *              rotflag (0 if using dew->pixs; 1 if rotated by 90 degrees cw)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This starts with points along the centers of textlines.\n *          It does quadratic fitting (and smoothing), first along the\n *          lines and then in the vertical direction, to generate\n *          the sampled vertical disparity map.  This can then be\n *          interpolated to full resolution and used to remove\n *          the vertical line warping.\n *      (2) Use @rotflag == 1 if you are dewarping vertical lines, as\n *          is done in dewarpBuildLineModel().  The usual case is for\n *          @rotflag == 0.\n *      (3) The model fails to build if the vertical disparity fails.\n *          This sets the vsuccess flag to 1 on success.\n *      (4) Pix debug output goes to /tmp/dewvert/ for collection into\n *          a pdf.  Non-pix debug output goes to /tmp.\n */",
      "file" : "dewarp2.c"
   },
   {
      "function" : "dewarpGetLineEndpoints",
      "comment" : "/*!\n *  dewarpGetLineEndpoints()\n *\n *      Input:  h (height of pixs)\n *              ptaa (lines)\n *              &ptal (<return> left end points of each line)\n *              &ptar (<return> right end points of each line)\n *      Return: 0 if OK, 1 on error.\n *\n *  Notes:\n *      (1) We require that the set of end points extends over 45% of the\n *          height of the input image, to insure good coverage and\n *          avoid extrapolating the curvature too far beyond the\n *          actual textlines.  Large extrapolations are particularly\n *          dangerous if used as a reference model.\n *      (2) For fitting the endpoints, x = f(y), we transpose x and y.\n *          Thus all these ptas have x and y swapped!\n */",
      "file" : "dewarp2.c"
   },
   {
      "function" : "dewarpGetMeanVerticals",
      "comment" : "/*!\n *  dewarpGetMeanVerticals()\n *\n *      Input:  pixs (1 bpp, single c.c.)\n *              x,y (location of UL corner of pixs with respect to page image\n *      Return: pta (mean y-values in component for each x-value,\n *                   both translated by (x,y)\n */",
      "file" : "dewarp2.c"
   },
   {
      "function" : "dewarpGetTextlineCenters",
      "comment" : "/*!\n *  dewarpGetTextlineCenters()\n *\n *      Input:  pixs (1 bpp)\n *              debugflag (1 for debug output)\n *      Return: ptaa (of center values of textlines)\n *\n *  Notes:\n *      (1) This in general does not have a point for each value\n *          of x, because there will be gaps between words.\n *          It doesn't matter because we will fit a quadratic to the\n *          points that we do have.\n */",
      "file" : "dewarp2.c"
   },
   {
      "function" : "dewarpMinimize",
      "comment" : "/*!\n *  dewarpMinimize()\n *\n *      Input:  dew\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This removes all data that is not needed for serialization.\n *          It keeps the subsampled disparity array(s), so the full\n *          resolution arrays can be reconstructed.\n */",
      "file" : "dewarp3.c"
   },
   {
      "function" : "dewarpPopulateFullRes",
      "comment" : "/*!\n *  dewarpPopulateFullRes()\n *\n *      Input:  dew\n *              pix (<optional>, to give size of actual image)\n *              x, y (origin for generation of disparity arrays)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If the full resolution vertical and horizontal disparity\n *          arrays do not exist, they are built from the subsampled ones.\n *      (2) If pixs is not given, the size of the arrays is determined\n *          by the original image from which the sampled version was\n *          generated.  Any values of (x,y) are ignored.\n *      (3) If pixs is given, the full resolution disparity arrays must\n *          be large enough to accommodate it.\n *          (a) If the arrays do not exist, the value of (x,y) determines\n *              the origin of the full resolution arrays without extension,\n *              relative to pixs.  Thus, (x,y) gives the amount of\n *              slope extension in (left, top).  The (right, bottom)\n *              extension is then determined by the size of pixs and\n *              (x,y); the values should never be < 0.\n *          (b) If the arrays exist and pixs is too large, the existing\n *              full res arrays are destroyed and new ones are made,\n *              again using (x,y) to determine the extension in the\n *              four directions.\n */",
      "file" : "dewarp3.c"
   },
   {
      "function" : "dewarpQuadraticLSF",
      "comment" : "/*!\n *  dewarpQuadraticLSF()\n *\n *      Input:  ptad (left or right end points of longest lines)\n *              &a  (<return> coeff a of LSF: y = ax^2 + bx + c)\n *              &b  (<return> coeff b of LSF: y = ax^2 + bx + c)\n *              &c  (<return> coeff c of LSF: y = ax^2 + bx + c)\n *              &mederr (<optional return> median error)\n *      Return: 0 if OK, 1 on error.\n *\n *  Notes:\n *      (1) This is used for finding the left or right sides of\n *          the text block, computed as a quadratic curve.\n *          Only the longest lines are input, so there are\n *          no outliers.\n *      (2) The ptas for the end points all have x and y swapped.\n */",
      "file" : "dewarp2.c"
   },
   {
      "function" : "dewarpRead",
      "comment" : "/*!\n *  dewarpRead()\n *\n *      Input:  filename\n *      Return: dew, or null on error\n */",
      "file" : "dewarp1.c"
   },
   {
      "function" : "dewarpReadStream",
      "comment" : "/*!\n *  dewarpReadStream()\n *\n *      Input:  stream\n *      Return: dew, or null on error\n *\n *  Notes:\n *      (1) The dewarp struct is stored in minimized format, with only\n *          subsampled disparity arrays.\n *      (2) The sampling and extra horizontal disparity parameters are\n *          stored here.  During generation of the dewarp struct, they\n *          are passed in from the dewarpa.  In readback, it is assumed\n *          that they are (a) the same for each page and (b) the same\n *          as the values used to create the dewarpa.\n */",
      "file" : "dewarp1.c"
   },
   {
      "function" : "dewarpRemoveShortLines",
      "comment" : "/*!\n *  dewarpRemoveShortLines()\n *\n *      Input:  pixs (1 bpp)\n *              ptaas (input lines)\n *              fract (minimum fraction of longest line to keep)\n *              debugflag\n *      Return: ptaad (containing only lines of sufficient length),\n *                     or null on error\n */",
      "file" : "dewarp2.c"
   },
   {
      "function" : "dewarpShowResults",
      "comment" : "/*!\n *  dewarpShowResults()\n *\n *      Input:  dewa\n *              sarray (of indexed input images)\n *              boxa (crop boxes for input images; can be null)\n *              firstpage, lastpage\n *              pdfout (filename)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This generates a pdf of image pairs (before, after) for\n *          the designated set of input pages.\n *      (2) If the boxa exists, its elements are aligned with numbers\n *          in the filenames in @sa.  It is used to crop the input images.\n *          It is assumed that the dewa was generated from the cropped\n *          images.  No undercropping is applied before rendering.\n */",
      "file" : "dewarp4.c"
   },
   {
      "function" : "dewarpSinglePage",
      "comment" : "/*!\n *  dewarpSinglePage()\n *\n *      Input:  pixs (with text, any depth)\n *              thresh (for binarization)\n *              adaptive (1 for adaptive thresholding; 0 for global threshold)\n *              both (1 for horizontal and vertical; 0 for vertical only)\n *              &pixd (<return> dewarped result)\n *              &dewa (<optional return> dewa with single page; NULL to skip)\n *              debug (1 for debugging output, 0 otherwise)\n *      Return: 0 if OK, 1 on error (list of page numbers), or null on error\n *\n *  Notes:\n *      (1) Dewarps pixs and returns the result in &pixd.\n *      (2) This uses default values for all model parameters.\n *      (3) If pixs is 1 bpp, the parameters @adaptive and @thresh are ignored.\n *      (4) If it can't build a model, returns a copy of pixs in &pixd.\n */",
      "file" : "dewarp4.c"
   },
   {
      "function" : "dewarpWrite",
      "comment" : "/*!\n *  dewarpWrite()\n *\n *      Input:  filename\n *              dew\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "dewarp1.c"
   },
   {
      "function" : "dewarpWriteStream",
      "comment" : "/*!\n *  dewarpWriteStream()\n *\n *      Input:  stream (opened for \"wb\")\n *              dew\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This should not be written if there is no sampled\n *          vertical disparity array, which means that no model has\n *          been built for this page.\n */",
      "file" : "dewarp1.c"
   },
   {
      "function" : "dewarpaApplyDisparity",
      "comment" : "/*!\n *  dewarpaApplyDisparity()\n *\n *      Input:  dewa\n *              pageno (of page model to be used; may be a ref model)\n *              pixs (image to be modified; can be 1, 8 or 32 bpp)\n *              grayin (gray value, from 0 to 255, for pixels brought in;\n *                      use -1 to use pixels on the boundary of pixs)\n *              x, y (origin for generation of disparity arrays)\n *              &pixd (<return> disparity corrected image)\n *              debugfile (use null to skip writing this)\n *      Return: 0 if OK, 1 on error (no models or ref models available)\n *\n *  Notes:\n *      (1) This applies the disparity arrays to the specified image.\n *      (2) Specify gray color for pixels brought in from the outside:\n *          0 is black, 255 is white.  Use -1 to select pixels from the\n *          boundary of the source image.\n *      (3) If the models and ref models have not been validated, this\n *          will do so by calling dewarpaInsertRefModels().\n *      (4) This works with both stripped and full resolution page models.\n *          If the full res disparity array(s) are missing, they are remade.\n *      (5) The caller must handle errors that are returned because there\n *          are no valid models or ref models for the page -- typically\n *          by using the input pixs.\n *      (6) If there is no model for @pageno, this will use the model for\n *          'refpage' and put the result in the dew for @pageno.\n *      (7) This populates the full resolution disparity arrays if\n *          necessary.  If x and/or y are positive, they are used,\n *          in conjunction with pixs, to determine the required\n *          slope-based extension of the full resolution disparity\n *          arrays in each direction.  When (x,y) == (0,0), all\n *          extension is to the right and down.  Nonzero values of (x,y)\n *          are useful for dewarping when pixs is deliberately undercropped.\n *      (8) Important: when applying disparity to a number of images,\n *          after calling this function and saving the resulting pixd,\n *          you should call dewarpMinimize(dew) on the dew for @pageno.\n *          This will remove pixs and pixd (or their clones) stored in dew,\n *          as well as the full resolution disparity arrays.  Together,\n *          these hold approximately 16 bytes for each pixel in pixs.\n */",
      "file" : "dewarp3.c"
   },
   {
      "function" : "dewarpaCreate",
      "comment" : "/*!\n *  dewarpaCreate()\n *\n *     Input: nptrs (number of dewarp page ptrs; typically the number of pages)\n *            sampling (use 0 for default value; the minimum allowed is 8)\n *            redfactor (of input images: 1 is full resolution; 2 is 2x reduced)\n *            minlines (minimum number of lines to accept; use 0 for default)\n *            maxdist (for locating reference disparity; use -1 for default)\n *     Return: dewa (or null on error)\n *\n *  Notes:\n *      (1) The sampling, minlines and maxdist parameters will be\n *          applied to all images.\n *      (2) The sampling factor is used for generating the disparity arrays\n *          from the input image.  For 2x reduced input, use a sampling\n *          factor that is half the sampling you want on the full resolution\n *          images.\n *      (3) Use @redfactor = 1 for full resolution; 2 for 2x reduction.\n *          All input images must be at one of these two resolutions.\n *      (4) @minlines is the minimum number of nearly full-length lines\n *          required to generate a vertical disparity array.  The default\n *          number is 15.  Use a smaller number to accept a questionable\n *          array, but not smaller than 4.\n *      (5) When a model can't be built for a page, it looks up to @maxdist\n *          in either direction for a valid model with the same page parity.\n *          Use -1 for the default value of @maxdist; use 0 to avoid using\n *          a ref model.\n *      (6) The ptr array is expanded as necessary to accommodate page images.\n */",
      "file" : "dewarp1.c"
   },
   {
      "function" : "dewarpaCreateFromPixacomp",
      "comment" : "/*!\n *  dewarpaCreateFromPixacomp()\n *\n *     Input: pixac (pixacomp of G4, 1 bpp images; with 1x1x1 placeholders)\n *            useboth (0 for vert disparity; 1 for both vert and horiz)\n *            sampling (use -1 or 0 for default value; otherwise minimum of 5)\n *            minlines (minimum number of lines to accept; e.g., 10)\n *            maxdist (for locating reference disparity; use -1 for default)\n *     Return: dewa (or null on error)\n *\n *  Notes:\n *      (1) The returned dewa has disparity arrays calculated and\n *          is ready for serialization or for use in dewarping.\n *      (2) The sampling, minlines and maxdist parameters are\n *          applied to all images.  See notes in dewarpaCreate() for details.\n *      (3) The pixac is full.  Placeholders, if any, are w=h=d=1 images,\n *          and the real input images are 1 bpp at full resolution.\n *          They are assumed to be cropped to the actual page regions,\n *          and may be arbitrarily sparse in the array.\n *      (4) The output dewarpa is indexed by the page number.\n *          The offset in the pixac gives the mapping between the\n *          array index in the pixac and the page number.\n *      (5) This adds the ref page models.\n *      (6) This can be used to make models for any desired set of pages.\n *          The direct models are only made for pages with images in\n *          the pixacomp; the ref models are made for pages of the\n *          same parity within @maxdist of the nearest direct model.\n */",
      "file" : "dewarp1.c"
   },
   {
      "function" : "dewarpaDestroy",
      "comment" : "/*!\n *  dewarpaDestroy()\n *\n *      Input:  &dewa (<will be set to null before returning>)\n *      Return: void\n */",
      "file" : "dewarp1.c"
   },
   {
      "function" : "dewarpaDestroyDewarp",
      "comment" : "/*!\n *  dewarpaDestroyDewarp()\n *\n *      Input:  dewa\n *              pageno (of dew to be destroyed)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "dewarp1.c"
   },
   {
      "function" : "dewarpaExtendArraysToSize",
      "comment" : "/*!\n *  dewarpaExtendArraysToSize()\n *\n *      Input:  dewa\n *              size (new size of dewarpa array)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) If necessary, reallocs main and cache dewarpa ptr arrays to @size.\n */",
      "file" : "dewarp1.c"
   },
   {
      "function" : "dewarpaGetDewarp",
      "comment" : "/*!\n *  dewarpaGetDewarp()\n *\n *      Input:  dewa (populated with dewarp structs for pages)\n *              index (into dewa: this is the pageno)\n *      Return: dew (handle; still owned by dewa), or null on error\n */",
      "file" : "dewarp1.c"
   },
   {
      "function" : "dewarpaInfo",
      "comment" : "/*!\n *  dewarpaInfo()\n *\n *      Input:  fp\n *              dewa\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "dewarp4.c"
   },
   {
      "function" : "dewarpaInsertDewarp",
      "comment" : "/*!\n *  dewarpaInsertDewarp()\n *\n *      Input:  dewarpa\n *              dewarp  (to be added)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This inserts the dewarp into the array, which now owns it.\n *          It also keeps track of the largest page number stored.\n *          It must be done before the disparity model is built.\n *      (2) Note that this differs from the usual method of filling out\n *          arrays in leptonica, where the arrays are compact and\n *          new elements are typically added to the end.  Here,\n *          the dewarp can be added anywhere, even beyond the initial\n *          allocation.\n */",
      "file" : "dewarp1.c"
   },
   {
      "function" : "dewarpaInsertRefModels",
      "comment" : "/*!\n *  dewarpaInsertRefModels()\n *\n *      Input:  dewa\n *              notests (if 1, ignore curvature constraints on model)\n *              debug (1 to output information on invalid page models)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This destroys all dewarp models that are invalid, and then\n *          inserts reference models where possible.\n *      (2) If @notests == 1, this ignores the curvature constraints\n *          and assumes that all successfully built models are valid.\n *      (3) If useboth == 0, it uses the closest valid model within the\n *          distance and parity constraints.  If useboth == 1, it tries\n *          to use the closest allowed hvalid model; if it doesn't find\n *          an hvalid model, it uses the closest valid model.\n *      (4) For all pages without a model, this clears out any existing\n *          invalid and reference dewarps, finds the nearest valid model\n *          with the same parity, and inserts an empty dewarp with the\n *          reference page.\n *      (5) Then if it is requested to use both vertical and horizontal\n *          disparity arrays (useboth == 1), it tries to replace any\n *          hvalid == 0 model or reference with an hvalid == 1 reference.\n *      (6) The distance constraint is that any reference model must\n *          be within maxdist.  Note that with the parity constraint,\n *          no reference models will be used if maxdist < 2.\n *      (7) This function must be called, even if reference models will\n *          not be used.  It should be called after building models on all\n *          available pages, and after setting the rendering parameters.\n *      (8) If the dewa has been serialized, this function is called by\n *          dewarpaRead() when it is read back.  It is also called\n *          any time the rendering parameters are changed.\n *      (9) Note: if this has been called with useboth == 1, and useboth\n *          is reset to 0, you should first call dewarpRestoreModels()\n *          to bring real models from the cache back to the primary array.\n */",
      "file" : "dewarp4.c"
   },
   {
      "function" : "dewarpaListPages",
      "comment" : "/*!\n *  dewarpaListPages()\n *\n *      Input:  dewa (populated with dewarp structs for pages)\n *      Return: 0 if OK, 1 on error (list of page numbers), or null on error\n *\n *  Notes:\n *      (1) This generates two numas, stored in the dewarpa, that give:\n *          (a) the page number for each dew that has a page model.\n *          (b) the page number for each dew that has either a page\n *              model or a reference model.\n *          It can be called at any time.\n *      (2) It is called by the dewarpa serializer before writing.\n */",
      "file" : "dewarp4.c"
   },
   {
      "function" : "dewarpaModelStats",
      "comment" : "/*!\n *  dewarpaModelStats()\n *\n *      Input:  dewa\n *              &nnone (<optional return> number without any model)\n *              &nvsuccess (<optional return> number with a vert model)\n *              &nvvalid (<optional return> number with a valid vert model)\n *              &nhsuccess (<optional return> number with both models)\n *              &nhvalid (<optional return> number with both models valid)\n *              &nref (<optional return> number with a reference model)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) A page without a model has no dew.  It most likely failed to\n *          generate a vertical model, and has not been assigned a ref\n *          model from a neighboring page with a valid vertical model.\n *      (2) A page has vsuccess == 1 if there is at least a model of the\n *          vertical disparity.  The model may be invalid, in which case\n *          dewarpaInsertRefModels() will stash it in the cache and\n *          attempt to replace it by a valid ref model.\n *      (3) A vvvalid model is a vertical disparity model whose parameters\n *          satisfy the constraints given in dewarpaSetValidModels().\n *      (4) A page has hsuccess == 1 if both the vertical and horizontal\n *          disparity arrays have been constructed.\n *      (5) An  hvalid model has vertical and horizontal disparity\n *          models whose parameters satisfy the constraints given\n *          in dewarpaSetValidModels().\n *      (6) A page has a ref model if it failed to generate a valid\n *          model but was assigned a vvalid or hvalid model on another\n *          page (within maxdist) by dewarpaInsertRefModel().\n *      (7) This calls dewarpaTestForValidModel(); it ignores the vvalid\n *          and hvalid fields.\n */",
      "file" : "dewarp4.c"
   },
   {
      "function" : "dewarpaModelStatus",
      "comment" : "/*!\n *  dewarpaModelStatus()\n *\n *      Input:  dewa\n *              pageno\n *              &vsuccess (<optional return> 1 on success)\n *              &hsuccess (<optional return> 1 on success)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This tests if a model has been built, not if it is valid.\n */",
      "file" : "dewarp2.c"
   },
   {
      "function" : "dewarpaRead",
      "comment" : "/*!\n *  dewarpaRead()\n *\n *      Input:  filename\n *      Return: dewa, or null on error\n */",
      "file" : "dewarp1.c"
   },
   {
      "function" : "dewarpaReadStream",
      "comment" : "/*!\n *  dewarpaReadStream()\n *\n *      Input:  stream\n *      Return: dewa, or null on error\n *\n *  Notes:\n *      (1) The serialized dewarp contains a Numa that gives the\n *          (increasing) page number of the dewarp structs that are\n *          contained.\n *      (2) Reference pages are added in after readback.\n */",
      "file" : "dewarp1.c"
   },
   {
      "function" : "dewarpaRestoreModels",
      "comment" : "/*!\n *  dewarpaRestoreModels()\n *\n *      Input:  dewa (populated with dewarp structs for pages)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This puts all real models (and only real models) in the\n *          primary dewarp array.  First remove all dewarps that are\n *          only references to other page models.  Then move all models\n *          that had been cached back into the primary dewarp array.\n *      (2) After this is done, we still need to recompute and insert\n *          the reference models before dewa->modelsready is true.\n */",
      "file" : "dewarp4.c"
   },
   {
      "function" : "dewarpaSetCurvatures",
      "comment" : "/*!\n *  dewarpaSetCurvatures()\n *\n *      Input:  dewa\n *              max_linecurv (-1 for default)\n *              min_diff_linecurv (-1 for default; 0 to accept all models)\n *              max_diff_linecurv (-1 for default)\n *              max_edgecurv (-1 for default)\n *              max_diff_edgecurv (-1 for default)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Approximating the line by a quadratic, the coefficent\n *          of the quadratic term is the curvature, and distance\n *          units are in pixels (of course).  The curvature is very\n *          small, so we multiply by 10^6 and express the constraints\n *          on the model curvatures in micro-units.\n *      (2) This sets five curvature thresholds:\n *          * the maximum absolute value of the vertical disparity\n *            line curvatures\n *          * the minimum absolute value of the largest difference in\n *            vertical disparity line curvatures (Use a value of 0\n *            to accept all models.)\n *          * the maximum absolute value of the largest difference in\n *            vertical disparity line curvatures\n *          * the maximum absolute value of the left and right edge\n *            curvature for the horizontal disparity\n *          * the maximum absolute value of the difference between\n *            left and right edge curvature for the horizontal disparity\n *          all in micro-units, for dewarping to take place.\n *          Use -1 for default values.\n *      (3) An image with a line curvature less than about 0.00001\n *          has fairly straight textlines.  This is 10 micro-units.\n *      (4) For example, if @max_linecurv == 100, this would prevent dewarping\n *          if any of the lines has a curvature exceeding 100 micro-units.\n *          A model having maximum line curvature larger than about 150\n *          micro-units should probably not be used.\n *      (5) A model having a left or right edge curvature larger than\n *          about 100 micro-units should probably not be used.\n */",
      "file" : "dewarp1.c"
   },
   {
      "function" : "dewarpaSetMaxDistance",
      "comment" : "/*!\n *  dewarpaSetMaxDistance()\n *\n *      Input:  dewa\n *              maxdist (for using ref models)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This sets the maxdist field.\n */",
      "file" : "dewarp1.c"
   },
   {
      "function" : "dewarpaSetValidModels",
      "comment" : "/*!\n *  dewarpaSetValidModels()\n *\n *      Input:  dewa\n *              notests\n *              debug (1 to output information on invalid page models)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) A valid model must meet the rendering requirements, which\n *          include whether or not a vertical disparity model exists\n *          and conditions on curvatures for vertical and horizontal\n *          disparity models.\n *      (2) If @notests == 1, this ignores the curvature constraints\n *          and assumes that all successfully built models are valid.\n *      (3) This function does not need to be called by the application.\n *          It is called by dewarpaInsertRefModels(), which\n *          will destroy all invalid dewarps.  Consequently, to inspect\n *          an invalid dewarp model, it must be done before calling\n *          dewarpaInsertRefModels().\n */",
      "file" : "dewarp4.c"
   },
   {
      "function" : "dewarpaShowArrays",
      "comment" : "/*!\n *  dewarpaShowArrays()\n *\n *      Input:  dewa\n *              scalefact (on contour images; typ. 0.5)\n *              first (first page model to render)\n *              last (last page model to render; use 0 to go to end)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Generates a pdf of contour plots of the disparity arrays.\n *      (2) This only shows actual models; not ref models\n */",
      "file" : "dewarp4.c"
   },
   {
      "function" : "dewarpaStripRefModels",
      "comment" : "/*!\n *  dewarpaStripRefModels()\n *\n *      Input:  dewa (populated with dewarp structs for pages)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This examines each dew in a dewarpa, and removes\n *          all that don't have their own page model (i.e., all\n *          that have \"references\" to nearby pages with valid models).\n *          These references were generated by dewarpaInsertRefModels(dewa).\n */",
      "file" : "dewarp4.c"
   },
   {
      "function" : "dewarpaTestForValidModel",
      "comment" : "/*!\n *  dewarpaTestForValidModel()\n *\n *      Input:  dewa\n *              dew\n *              notests\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Computes validity of vertical (vvalid) model and both\n *          vertical and horizontal (hvalid) models.\n *      (2) If @notests == 1, this ignores the curvature constraints\n *          and assumes that all successfully built models are valid.\n *      (3) This is just about the models, not the rendering process,\n *          so the value of useboth is not considered here.\n */",
      "file" : "dewarp4.c"
   },
   {
      "function" : "dewarpaUseBothArrays",
      "comment" : "/*!\n *  dewarpaUseBothArrays()\n *\n *      Input:  dewa\n *              useboth (0 for false, 1 for true)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This sets the useboth field.  If set, this will attempt\n *          to apply both vertical and horizontal disparity arrays.\n *          Note that a model with only a vertical disparity array will\n *          always be valid.\n */",
      "file" : "dewarp1.c"
   },
   {
      "function" : "dewarpaWrite",
      "comment" : "/*!\n *  dewarpaWrite()\n *\n *      Input:  filename\n *              dewa\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "dewarp1.c"
   },
   {
      "function" : "dewarpaWriteStream",
      "comment" : "/*!\n *  dewarpaWriteStream()\n *\n *      Input:  stream (opened for \"wb\")\n *              dewa\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "dewarp1.c"
   },
   {
      "function" : "dilateGrayLow",
      "comment" : "/*!\n *  dilateGrayLow()\n *\n *    Input:  datad, w, h, wpld (8 bpp image)\n *            datas, wpls  (8 bpp image, of same dimensions)\n *            size  (full length of SEL; restricted to odd numbers)\n *            direction  (L_HORIZ or L_VERT)\n *            buffer  (holds full line or column of src image pixels)\n *            maxarray  (array of dimension 2*size+1)\n *    Return: void\n *\n *    Notes:\n *        (1) To eliminate border effects on the actual image, these images\n *            are prepared with an additional border of dimensions:\n *               leftpix = 0.5 * size\n *               rightpix = 1.5 * size\n *               toppix = 0.5 * size\n *               bottompix = 1.5 * size\n *            and we initialize the src border pixels to 0.\n *            This allows full processing over the actual image; at\n *            the end the border is removed.\n *        (2) Uses algorithm of van Herk, Gil and Werman\n */",
      "file" : "graymorphlow.c"
   },
   {
      "function" : "displayHSVColorRange",
      "comment" : "/*!\n *  displayHSVColorRange()\n *\n *      Input:  hval (hue center value; in range [0 ... 240]\n *              sval (saturation center value; in range [0 ... 255]\n *              vval (max intensity value; in range [0 ... 255]\n *              huehw (half-width of hue range; > 0)\n *              sathw (half-width of saturation range; > 0)\n *              nsamp (number of samplings in each half-width in hue and sat)\n *              factor (linear size of each color square, in pixels; > 3)\n *      Return: pixd (32 bpp set of color squares over input range),\n *                     or null on error\n *\n *  Notes:\n *      (1) The total number of color samplings in each of the hue\n *          and saturation directions is 2 * nsamp + 1.\n */",
      "file" : "colorspace.c"
   },
   {
      "function" : "distanceFunctionLow",
      "comment" : "/*!\n *  distanceFunctionLow()\n */",
      "file" : "seedfilllow.c"
   },
   {
      "function" : "ditherTo2bppLineLow",
      "comment" : "/*\n *  ditherTo2bppLineLow()\n *\n *      Input:  lined  (ptr to beginning of dest line\n *              w   (width of image in pixels)\n *              bufs1 (buffer of current source line)\n *              bufs2 (buffer of next source line)\n *              tabval (value to assign for current pixel)\n *              tab38 (excess value to give to neighboring 3/8 pixels)\n *              tab14 (excess value to give to neighboring 1/4 pixel)\n *              lastlineflag  (0 if not last dest line, 1 if last dest line)\n *      Return: void\n *\n *  Dispatches error diffusion dithering for\n *  a single line of the image.  If lastlineflag == 0,\n *  both source buffers are used; otherwise, only bufs1\n *  is used.  We use source buffers because the error\n *  is propagated into them, and we don't want to change\n *  the input src image.\n *\n *  We break dithering out line by line to make it\n *  easier to combine functions like interpolative\n *  scaling and error diffusion dithering, as such a\n *  combination of operations obviates the need to\n *  generate a 2x grayscale image as an intermediary.\n */",
      "file" : "grayquantlow.c"
   },
   {
      "function" : "ditherTo2bppLow",
      "comment" : "/*\n *  ditherTo2bppLow()\n *\n *  Low-level function for doing Floyd-Steinberg error diffusion\n *  dithering from 8 bpp (datas) to 2 bpp (datad).  Two source\n *  line buffers, bufs1 and bufs2, are provided, along with three\n *  256-entry lookup tables: tabval gives the output pixel value,\n *  tab38 gives the extra (plus or minus) transferred to the pixels\n *  directly to the left and below, and tab14 gives the extra\n *  transferred to the diagonal below.  The choice of 3/8 and 1/4\n *  is traditional but arbitrary when you use a lookup table; the\n *  only constraint is that the sum is 1.  See other comments\n *  below and in grayquant.c.\n */",
      "file" : "grayquantlow.c"
   },
   {
      "function" : "ditherToBinaryLUTLow",
      "comment" : "/*!\n *  ditherToBinaryLUTLow()\n *\n *  Low-level function for doing Floyd-Steinberg error diffusion\n *  dithering from 8 bpp (datas) to 1 bpp (datad).  Two source\n *  line buffers, bufs1 and bufs2, are provided, along with three\n *  256-entry lookup tables: tabval gives the output pixel value,\n *  tab38 gives the extra (plus or minus) transferred to the pixels\n *  directly to the left and below, and tab14 gives the extra\n *  transferred to the diagonal below.  The choice of 3/8 and 1/4\n *  is traditional but arbitrary when you use a lookup table; the\n *  only constraint is that the sum is 1.  See other comments below.\n */",
      "file" : "grayquantlow.c"
   },
   {
      "function" : "ditherToBinaryLineLUTLow",
      "comment" : "/*!\n *  ditherToBinaryLineLUTLow()\n *\n *      Input:  lined  (ptr to beginning of dest line\n *              w   (width of image in pixels)\n *              bufs1 (buffer of current source line)\n *              bufs2 (buffer of next source line)\n *              tabval (value to assign for current pixel)\n *              tab38 (excess value to give to neighboring 3/8 pixels)\n *              tab14 (excess value to give to neighboring 1/4 pixel)\n *              lastlineflag  (0 if not last dest line, 1 if last dest line)\n *      Return: void\n */",
      "file" : "grayquantlow.c"
   },
   {
      "function" : "ditherToBinaryLineLow",
      "comment" : "/*\n *  ditherToBinaryLineLow()\n *\n *      Input:  lined  (ptr to beginning of dest line\n *              w   (width of image in pixels)\n *              bufs1 (buffer of current source line)\n *              bufs2 (buffer of next source line)\n *              lowerclip (lower clip distance to black)\n *              upperclip (upper clip distance to white)\n *              lastlineflag  (0 if not last dest line, 1 if last dest line)\n *      Return: void\n *\n *  Dispatches FS error diffusion dithering for\n *  a single line of the image.  If lastlineflag == 0,\n *  both source buffers are used; otherwise, only bufs1\n *  is used.  We use source buffers because the error\n *  is propagated into them, and we don't want to change\n *  the input src image.\n *\n *  We break dithering out line by line to make it\n *  easier to combine functions like interpolative\n *  scaling and error diffusion dithering, as such a\n *  combination of operations obviates the need to\n *  generate a 2x grayscale image as an intermediary.\n */",
      "file" : "grayquantlow.c"
   },
   {
      "function" : "ditherToBinaryLow",
      "comment" : "/*\n *  ditherToBinaryLow()\n *\n *  See comments in pixDitherToBinary() in binarize.c\n */",
      "file" : "grayquantlow.c"
   },
   {
      "function" : "dpixAddMultConstant",
      "comment" : "/*!\n *  dpixAddMultConstant()\n *\n *      Input:  dpix\n *              addc  (use 0.0 to skip the operation)\n *              multc (use 1.0 to skip the operation)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is an in-place operation.\n *      (2) It can be used to multiply each pixel by a constant,\n *          and also to add a constant to each pixel.  Multiplication\n *          is done first.\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "dpixChangeRefcount",
      "comment" : "/*!\n *  dpixSetDimensions()\n *\n *      Input:  dpix\n *              w, h\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "dpixClone",
      "comment" : "/*!\n *  dpixClone()\n *\n *      Input:  dpix\n *      Return: same dpix (ptr), or null on error\n *\n *  Notes:\n *      (1) See pixClone() for definition and usage.\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "dpixConvertToFPix",
      "comment" : "/*!\n *  dpixConvertToFPix()\n *\n *      Input:  dpix\n *      Return: fpix, or null on error\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "dpixConvertToPix",
      "comment" : "/*!\n *  dpixConvertToPix()\n *\n *      Input:  dpixs\n *              outdepth (0, 8, 16 or 32 bpp)\n *              negvals (L_CLIP_TO_ZERO, L_TAKE_ABSVAL)\n *              errorflag (1 to output error stats; 0 otherwise)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Use @outdepth = 0 to programmatically determine the\n *          output depth.  If no values are greater than 255,\n *          it will set outdepth = 8; otherwise to 16 or 32.\n *      (2) Because we are converting a float to an unsigned int\n *          with a specified dynamic range (8, 16 or 32 bits), errors\n *          can occur.  If errorflag == TRUE, output the number\n *          of values out of range, both negative and positive.\n *      (3) If a pixel value is positive and out of range, clip to\n *          the maximum value represented at the outdepth of 8, 16\n *          or 32 bits.\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "dpixCopy",
      "comment" : "/*!\n *  dpixCopy()\n *\n *      Input:  dpixd (<optional>; can be null, or equal to dpixs,\n *                    or different from dpixs)\n *              dpixs\n *      Return: dpixd, or null on error\n *\n *  Notes:\n *      (1) There are three cases:\n *            (a) dpixd == null  (makes a new dpix; refcount = 1)\n *            (b) dpixd == dpixs  (no-op)\n *            (c) dpixd != dpixs  (data copy; no change in refcount)\n *          If the refcount of dpixd > 1, case (c) will side-effect\n *          these handles.\n *      (2) The general pattern of use is:\n *             dpixd = dpixCopy(dpixd, dpixs);\n *          This will work for all three cases.\n *          For clarity when the case is known, you can use:\n *            (a) dpixd = dpixCopy(NULL, dpixs);\n *            (c) dpixCopy(dpixd, dpixs);\n *      (3) For case (c), we check if dpixs and dpixd are the same size.\n *          If so, the data is copied directly.\n *          Otherwise, the data is reallocated to the correct size\n *          and the copy proceeds.  The refcount of dpixd is unchanged.\n *      (4) This operation, like all others that may involve a pre-existing\n *          dpixd, will side-effect any existing clones of dpixd.\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "dpixCopyResolution",
      "comment" : "/*!\n *  dpixSetDimensions()\n *\n *      Input:  dpix\n *              w, h\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "dpixCreate",
      "comment" : "/*!\n *  dpixCreate()\n *\n *      Input:  width, height\n *      Return: dpix (with data allocated and initialized to 0),\n *                     or null on error\n *\n *  Notes:\n *      (1) Makes a DPix of specified size, with the data array\n *          allocated and initialized to 0.\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "dpixCreateTemplate",
      "comment" : "/*!\n *  dpixCreateTemplate()\n *\n *      Input:  dpixs\n *      Return: dpixd, or null on error\n *\n *  Notes:\n *      (1) Makes a DPix of the same size as the input DPix, with the\n *          data array allocated and initialized to 0.\n *      (2) Copies the resolution.\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "dpixDestroy",
      "comment" : "/*!\n *  dpixDestroy()\n *\n *      Input:  &dpix <will be nulled>\n *      Return: void\n *\n *  Notes:\n *      (1) Decrements the ref count and, if 0, destroys the dpix.\n *      (2) Always nulls the input ptr.\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "dpixEndianByteSwap",
      "comment" : "/*!\n *  dpixEndianByteSwap()\n *\n *      Input:  dpixd (can be equal to dpixs or NULL)\n *              dpixs\n *      Return: dpixd always\n *\n *  Notes:\n *      (1) On big-endian hardware, this does byte-swapping on each of\n *          the 4-byte words in the dpix data.  On little-endians,\n *          the data is unchanged.  This is used for serialization\n *          of dpix; the data is serialized in little-endian byte\n *          order because most hardware is little-endian.\n *      (2) The operation can be either in-place or, if dpixd == NULL,\n *          a new dpix is made.  If not in-place, caller must catch\n *          the returned pointer.\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "dpixGetData",
      "comment" : "/*!\n *  dpixSetDimensions()\n *\n *      Input:  dpix\n *              w, h\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "dpixGetDimensions",
      "comment" : "/*!\n *  dpixGetDimensions()\n *\n *      Input:  dpix\n *              &w, &h (<optional return>; each can be null)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "dpixGetMax",
      "comment" : "/*!\n *  dpixGetMax()\n *\n *      Input:  dpix\n *              &maxval (<optional return> max value)\n *              &xmaxloc (<optional return> x location of max)\n *              &ymaxloc (<optional return> y location of max)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "dpixGetMin",
      "comment" : "/*!\n *  dpixGetMin()\n *\n *      Input:  dpix\n *              &minval (<optional return> min value)\n *              &xminloc (<optional return> x location of min)\n *              &yminloc (<optional return> y location of min)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "dpixGetPixel",
      "comment" : "/*!\n *  dpixGetPixel()\n *\n *      Input:  dpix\n *              (x,y) pixel coords\n *              &val (<return> pixel value)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "dpixGetRefcount",
      "comment" : "/*!\n *  dpixSetDimensions()\n *\n *      Input:  dpix\n *              w, h\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "dpixGetResolution",
      "comment" : "/*!\n *  dpixSetDimensions()\n *\n *      Input:  dpix\n *              w, h\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "dpixGetWpl",
      "comment" : "/*!\n *  dpixSetDimensions()\n *\n *      Input:  dpix\n *              w, h\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "dpixLinearCombination",
      "comment" : "/*!\n *  dpixLinearCombination()\n *\n *      Input:  dpixd (<optional>; this can be null, equal to dpixs1, or\n *                     different from dpixs1)\n *              dpixs1 (can be == to dpixd)\n *              dpixs2\n *              a, b (multiplication factors on dpixs1 and dpixs2, rsp.)\n *      Return: dpixd always\n *\n *  Notes:\n *      (1) Computes pixelwise linear combination: a * src1 + b * src2\n *      (2) Alignment is to UL corner.\n *      (3) There are 3 cases.  The result can go to a new dest,\n *          in-place to dpixs1, or to an existing input dest:\n *          * dpixd == null:   (src1 + src2) --> new dpixd\n *          * dpixd == dpixs1:  (src1 + src2) --> src1  (in-place)\n *          * dpixd != dpixs1: (src1 + src2) --> input dpixd\n *      (4) dpixs2 must be different from both dpixd and dpixs1.\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "dpixRead",
      "comment" : "/*!\n *  dpixRead()\n *\n *      Input:  filename\n *      Return: dpix, or null on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "dpixReadStream",
      "comment" : "/*!\n *  dpixReadStream()\n *\n *      Input:  stream\n *      Return: dpix, or null on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "dpixResizeImageData",
      "comment" : "/*!\n *  dpixResizeImageData()\n *\n *      Input:  dpixd, dpixs\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "dpixScaleByInteger",
      "comment" : "/*!\n *  dpixScaleByInteger()\n *\n *      Input:  dpixs (low resolution, subsampled)\n *              factor (scaling factor)\n *      Return: dpixd (interpolated result), or null on error\n *\n *  Notes:\n *      (1) The width wd of dpixd is related to ws of dpixs by:\n *              wd = factor * (ws - 1) + 1   (and ditto for the height)\n *          We avoid special-casing boundary pixels in the interpolation\n *          by constructing fpixd by inserting (factor - 1) interpolated\n *          pixels between each pixel in fpixs.  Then\n *               wd = ws + (ws - 1) * (factor - 1)    (same as above)\n *          This also has the advantage that if we subsample by @factor,\n *          throwing out all the interpolated pixels, we regain the\n *          original low resolution dpix.\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "dpixSetAllArbitrary",
      "comment" : "/*!\n *  dpixSetAllArbitrary()\n *\n *      Input:  dpix\n *              val (to set at each pixel)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "dpixSetData",
      "comment" : "/*!\n *  dpixSetDimensions()\n *\n *      Input:  dpix\n *              w, h\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "dpixSetDimensions",
      "comment" : "/*!\n *  dpixSetDimensions()\n *\n *      Input:  dpix\n *              w, h\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "dpixSetPixel",
      "comment" : "/*!\n *  dpixSetPixel()\n *\n *      Input:  dpix\n *              (x,y) pixel coords\n *              val (pixel value)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "dpixSetResolution",
      "comment" : "/*!\n *  dpixSetDimensions()\n *\n *      Input:  dpix\n *              w, h\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "dpixSetWpl",
      "comment" : "/*!\n *  dpixSetDimensions()\n *\n *      Input:  dpix\n *              w, h\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "dpixWrite",
      "comment" : "/*!\n *  dpixWrite()\n *\n *      Input:  filename\n *              dpix\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "dpixWriteStream",
      "comment" : "/*!\n *  dpixWriteStream()\n *\n *      Input:  stream (opened for \"wb\")\n *              dpix\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "encodeAscii85",
      "comment" : "/*!\n *  encodeAscii85()\n *\n *      Input:  inarray (input data)\n *              insize (number of bytes in input array)\n *              &outsize (<return> number of bytes in output char array)\n *      Return: chara (with 64 characters + \\n in each line)\n *\n *  Notes:\n *      (1) Ghostscript has a stack break if the last line of\n *          data only has a '>', so we avoid the problem by\n *          always putting '~>' on the last line.\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "erodeGrayLow",
      "comment" : "/*!\n *  erodeGrayLow()\n *\n *    Input:  datad, w, h, wpld (8 bpp image)\n *            datas, wpls  (8 bpp image, of same dimensions)\n *            size  (full length of SEL; restricted to odd numbers)\n *            direction  (L_HORIZ or L_VERT)\n *            buffer  (holds full line or column of src image pixels)\n *            minarray  (array of dimension 2*size+1)\n *    Return: void\n *\n *    Notes:\n *        (1) See notes in dilateGrayLow()\n */",
      "file" : "graymorphlow.c"
   },
   {
      "function" : "extractG4DataFromFile",
      "comment" : "/*!\n *  extractG4DataFromFile()\n *\n *      Input:  filein\n *              &data (<return> binary data of ccitt g4 encoded stream)\n *              &nbytes (<return> size of binary data)\n *              &w (<return optional> image width)\n *              &h (<return optional> image height)\n *              &minisblack (<return optional> boolean)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "tiffio.c"
   },
   {
      "function" : "extractJpegDataFromArray",
      "comment" : "/*!\n *  extractJpegDataFromArray()\n *\n *      Input:  data (binary data consisting of the entire jpeg file)\n *              nbytes (size of binary data)\n *              &w (<optional return> image width)\n *              &h (<optional return> image height)\n *              &bps (<optional return> bits/sample; should be 8)\n *              &spp (<optional return> samples/pixel; should be 1, 3 or 4)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "jpegio.c"
   },
   {
      "function" : "extractJpegDataFromFile",
      "comment" : "/*!\n *  extractJpegDataFromFile()\n *\n *      Input:  filein\n *              &data (<optional return> binary jpeg compressed file data)\n *              &nbytes (<optional return> size of binary jpeg data)\n *              &w (<optional return> image width)\n *              &h (<optional return> image height)\n *              &bps (<optional return> bits/sample; should be 8)\n *              &spp (<optional return> samples/pixel; should be 1 or 3)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "jpegio.c"
   },
   {
      "function" : "extractJpegHeaderDataFallback",
      "comment" : "/*!\n *  extractJpegHeaderDataFallback()\n *\n *      Input:  data (binary data consisting of the entire jpeg file)\n *              nbytes (size of binary data)\n *              &w (<optional return> image width)\n *              &h (<optional return> image height)\n *              &bps (<optional return> bits/sample; should be 8)\n *              &spp (<optional return> samples/pixel; should be 1 or 3)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This gets the header data by uncompressing the jpeg\n *          data into a pix.  It can be used when header parsing fails.\n *      (2) This cannot distinguish between 3 and 4 spp, so it returns 3.\n */",
      "file" : "jpegio.c"
   },
   {
      "function" : "extractMinMaxComponent",
      "comment" : "/*!\n *  extractMinMaxComponent()\n *\n *      Input:  pixel (32 bpp RGB)\n *              type (L_CHOOSE_MIN or L_CHOOSE_MAX)\n *      Return: component (in range [0 ... 255], or null on error\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "extractNumberFromFilename",
      "comment" : "/*!\n *  extractNumberFromFilename()\n *\n *      Input:  fname\n *              numpre (number of characters before the digits to be found)\n *              numpost (number of characters after the digits to be found)\n *      Return: num (number embedded in the filename); -1 on error or if\n *                   not found\n *\n *  Notes:\n *      (1) The number is to be found in the basename, which is the\n *          filename without either the directory or the last extension.\n *      (2) When a number is found, it is non-negative.  If no number\n *          is found, this returns -1, without an error message.  The\n *          caller needs to check.\n */",
      "file" : "utils.c"
   },
   {
      "function" : "extractRGBAValues",
      "comment" : "/*!\n *  extractRGBAValues()\n *\n *      Input:  pixel (32 bit)\n *              &rval (<optional return> red component)\n *              &gval (<optional return> green component)\n *              &bval (<optional return> blue component)\n *              &aval (<optional return> alpha component)\n *      Return: void\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "extractRGBValues",
      "comment" : "/*!\n *  extractRGBValues()\n *\n *      Input:  pixel (32 bit)\n *              &rval (<optional return> red component)\n *              &gval (<optional return> green component)\n *              &bval (<optional return> blue component)\n *      Return: void\n *\n *  Notes:\n *      (1) A slower implementation uses macros:\n *             *prval = GET_DATA_BYTE(&pixel, COLOR_RED);\n *             *pgval = GET_DATA_BYTE(&pixel, COLOR_GREEN);\n *             *pbval = GET_DATA_BYTE(&pixel, COLOR_BLUE);\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "fdilate_1_0",
      "comment" : "/*\n *  N.B.  In all the low-level routines, the part of the image\n *        that is accessed has been clipped by 32 pixels on\n *        all four sides.  This is done in the higher level\n *        code by redefining w and h smaller and by moving the\n *        start-of-image pointers up to the beginning of this\n *        interior rectangle.\n */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_1",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_10",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_11",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_12",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_13",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_14",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_15",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_16",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_17",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_18",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_19",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_2",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_20",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_21",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_22",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_23",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_24",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_25",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_26",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_27",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_28",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_29",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_3",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_30",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_31",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_32",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_33",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_34",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_35",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_36",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_37",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_38",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_39",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_4",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_40",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_41",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_42",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_43",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_44",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_45",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_46",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_47",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_48",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_49",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_5",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_50",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_51",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_52",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_53",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_54",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_55",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_56",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_57",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_6",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_7",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_8",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_1_9",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fdilate_2_0",
      "comment" : "/*\n *  N.B.  In all the low-level routines, the part of the image\n *        that is accessed has been clipped by 32 pixels on\n *        all four sides.  This is done in the higher level\n *        code by redefining w and h smaller and by moving the\n *        start-of-image pointers up to the beginning of this\n *        interior rectangle.\n */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_1",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_10",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_11",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_12",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_13",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_14",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_15",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_16",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_17",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_18",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_19",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_2",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_20",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_21",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_22",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_23",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_24",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_25",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_26",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_27",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_28",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_29",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_3",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_30",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_31",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_32",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_33",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_34",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_35",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_36",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_37",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_38",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_39",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_4",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_40",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_41",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_42",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_43",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_44",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_45",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_46",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_47",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_48",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_49",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_5",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_50",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_51",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_52",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_53",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_54",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_55",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_56",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_57",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_58",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_59",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_6",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_60",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_61",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_62",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_63",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_64",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_65",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_66",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_67",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_68",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_69",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_7",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_70",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_71",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_72",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_73",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_74",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_75",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_8",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fdilate_2_9",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_1_0",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_1",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_10",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_11",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_12",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_13",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_14",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_15",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_16",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_17",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_18",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_19",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_2",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_20",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_21",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_22",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_23",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_24",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_25",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_26",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_27",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_28",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_29",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_3",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_30",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_31",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_32",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_33",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_34",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_35",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_36",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_37",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_38",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_39",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_4",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_40",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_41",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_42",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_43",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_44",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_45",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_46",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_47",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_48",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_49",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_5",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_50",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_51",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_52",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_53",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_54",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_55",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_56",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_57",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_6",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_7",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_8",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_1_9",
      "comment" : "/* proper wpl of src */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "ferode_2_0",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_1",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_10",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_11",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_12",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_13",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_14",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_15",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_16",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_17",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_18",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_19",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_2",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_20",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_21",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_22",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_23",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_24",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_25",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_26",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_27",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_28",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_29",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_3",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_30",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_31",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_32",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_33",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_34",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_35",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_36",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_37",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_38",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_39",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_4",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_40",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_41",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_42",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_43",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_44",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_45",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_46",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_47",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_48",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_49",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_5",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_50",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_51",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_52",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_53",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_54",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_55",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_56",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_57",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_58",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_59",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_6",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_60",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_61",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_62",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_63",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_64",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_65",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_66",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_67",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_68",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_69",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_7",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_70",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_71",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_72",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_73",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_74",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_75",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_8",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "ferode_2_9",
      "comment" : "/* proper wpl of src */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fgetJpegComment",
      "comment" : "/*\n *  fgetJpegComment()\n *\n *      Input:  stream (opened for read)\n *              &comment (<return> comment)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) Side-effect: this rewinds the stream.\n */",
      "file" : "jpegio.c"
   },
   {
      "function" : "fgetJpegResolution",
      "comment" : "/*\n *  fgetJpegResolution()\n *\n *      Input:  stream (opened for read)\n *              &xres, &yres (<return> resolution in ppi)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) If neither resolution field is set, this is not an error;\n *          the returned resolution values are 0 (designating 'unknown').\n *      (2) Side-effect: this rewinds the stream.\n */",
      "file" : "jpegio.c"
   },
   {
      "function" : "fgetPngResolution",
      "comment" : "/*\n *  fgetPngResolution()\n *\n *      Input:  stream (opened for read)\n *              &xres, &yres (<return> resolution in ppi)\n *      Return: 0 if OK; 0 on error\n *\n *  Notes:\n *      (1) If neither resolution field is set, this is not an error;\n *          the returned resolution values are 0 (designating 'unknown').\n *      (2) Side-effect: this rewinds the stream.\n */",
      "file" : "pngio.c"
   },
   {
      "function" : "fhmt_1_0",
      "comment" : "/*\n *  N.B.  In all the low-level routines, the part of the image\n *        that is accessed has been clipped by 32 pixels on\n *        all four sides.  This is done in the higher level\n *        code by redefining w and h smaller and by moving the\n *        start-of-image pointers up to the beginning of this\n *        interior rectangle.\n */",
      "file" : "fhmtgenlow.1.c"
   },
   {
      "function" : "fhmt_1_0",
      "comment" : "/*\n *  N.B.  in all the low-level routines, the part of the image\n *        that is accessed has been clipped by ADDED_BORDER pixels\n *        on all four sides.  This is done in the higher level\n *        code by redefining w and h smaller and by moving the\n *        start-of-image pointers up to the beginning of this\n *        interior rectangle.\n */",
      "file" : "fliphmtgen.c"
   },
   {
      "function" : "fhmt_1_1",
      "comment" : "/* proper wpl of src */",
      "file" : "fhmtgenlow.1.c"
   },
   {
      "function" : "fhmt_1_1",
      "comment" : "/* proper wpl of src */",
      "file" : "fliphmtgen.c"
   },
   {
      "function" : "fhmt_1_2",
      "comment" : "/* proper wpl of src */",
      "file" : "fhmtgenlow.1.c"
   },
   {
      "function" : "fhmt_1_2",
      "comment" : "/* proper wpl of src */",
      "file" : "fliphmtgen.c"
   },
   {
      "function" : "fhmt_1_3",
      "comment" : "/* proper wpl of src */",
      "file" : "fhmtgenlow.1.c"
   },
   {
      "function" : "fhmt_1_3",
      "comment" : "/* proper wpl of src */",
      "file" : "fliphmtgen.c"
   },
   {
      "function" : "fhmt_1_4",
      "comment" : "/* proper wpl of src */",
      "file" : "fhmtgenlow.1.c"
   },
   {
      "function" : "fhmt_1_5",
      "comment" : "/* proper wpl of src */",
      "file" : "fhmtgenlow.1.c"
   },
   {
      "function" : "fhmt_1_6",
      "comment" : "/* proper wpl of src */",
      "file" : "fhmtgenlow.1.c"
   },
   {
      "function" : "fhmt_1_7",
      "comment" : "/* proper wpl of src */",
      "file" : "fhmtgenlow.1.c"
   },
   {
      "function" : "fhmt_1_8",
      "comment" : "/* proper wpl of src */",
      "file" : "fhmtgenlow.1.c"
   },
   {
      "function" : "fhmt_1_9",
      "comment" : "/* proper wpl of src */",
      "file" : "fhmtgenlow.1.c"
   },
   {
      "function" : "fhmtautogen",
      "comment" : "/*!\n *  fhmtautogen()\n *\n *      Input:  sela\n *              fileindex\n *              filename (<optional>; can be null)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This function generates all the code for implementing\n *          dwa morphological operations using all the sels in the sela.\n *      (2) See fhmtautogen1() and fhmtautogen2() for details.\n */",
      "file" : "fhmtauto.c"
   },
   {
      "function" : "fhmtautogen1",
      "comment" : "/*!\n *  fhmtautogen1()\n *\n *      Input:  sel array\n *              fileindex\n *              filename (<optional>; can be null)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This function uses hmttemplate1.txt to create a\n *          top-level file that contains two functions that carry\n *          out the hit-miss transform for any of the sels in\n *          the input sela.\n *      (2) The fileindex parameter is inserted into the output\n *          filename, as described below.\n *      (3) If filename == NULL, the output file is fhmtgen.<n>.c,\n *          where <n> is equal to the 'fileindex' parameter.\n *      (4) If filename != NULL, the output file is <filename>.<n>.c.\n *      (5) Each sel must have at least one hit.  A sel with only misses\n *          generates code that will abort the operation if it is called.\n */",
      "file" : "fhmtauto.c"
   },
   {
      "function" : "fhmtautogen2",
      "comment" : "/*!\n *  fhmtautogen2()\n *\n *      Input:  sel array\n *              fileindex\n *              filename (<optional>; can be null)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This function uses hmttemplate2.txt to create a\n *          low-level file that contains the low-level functions for\n *          implementing the hit-miss transform for every sel\n *          in the input sela.\n *      (2) The fileindex parameter is inserted into the output\n *          filename, as described below.\n *      (3) If filename == NULL, the output file is fhmtgenlow.<n>.c,\n *          where <n> is equal to the 'fileindex' parameter.\n *      (4) If filename != NULL, the output file is <filename>low.<n>.c.\n */",
      "file" : "fhmtauto.c"
   },
   {
      "function" : "fhmtgen_low_1",
      "comment" : "/*!\n *  fhmtgen_low_1()\n *\n *       a dispatcher to appropriate low-level code\n */",
      "file" : "fhmtgenlow.1.c"
   },
   {
      "function" : "fileAppendString",
      "comment" : "/*!\n *  fileAppendString()\n *\n *      Input:  filename\n *              str (string to append to file)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "utils.c"
   },
   {
      "function" : "fileConcatenate",
      "comment" : "/*!\n *  fileConcatenate()\n *\n *      Input:  srcfile (file to append)\n *              destfile (file to add to)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "utils.c"
   },
   {
      "function" : "fileCopy",
      "comment" : "/*!\n *  fileCopy()\n *\n *      Input:  srcfile (copy this file)\n *              newfile (to this file)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "utils.c"
   },
   {
      "function" : "fileCorruptByDeletion",
      "comment" : "/*!\n *  fileCorruptByDeletion()\n *\n *      Input:  filein\n *              loc (fractional location of start of deletion)\n *              size (fractional size of deletion)\n *              fileout (corrupted file)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is useful for testing robustness of I/O wrappers with image\n *          file corruption.\n *      (2) Deletion size adjusts automatically to avoid array transgressions.\n */",
      "file" : "utils.c"
   },
   {
      "function" : "fileFormatIsTiff",
      "comment" : "/*!\n *  fileFormatIsTiff()\n *\n *      Input:  fp (file stream)\n *      Return: 1 if file is tiff; 0 otherwise or on error\n */",
      "file" : "readfile.c"
   },
   {
      "function" : "filesAreIdentical",
      "comment" : "/*!\n *  filesAreIdentical()\n *\n *      Input:  fname1\n *              fname2\n *              &same (<return> 1 if identical; 0 if different)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "utils.c"
   },
   {
      "function" : "finalPositioningForAlignment",
      "comment" : "/*!\n *  finalPositioningForAlignment()\n *\n *      Input:  pixs (input page image)\n *              x, y (location of UL corner of bb of component in pixs)\n *              idelx, idely (compensation to match centroids of component\n *                            and template)\n *              pixt (template, with JB_ADDED_PIXELS of padding on all sides)\n *              sumtab (for summing fg pixels in an image)\n *              &dx, &dy (return delta on position for best match; each\n *                        one is in the set {-1, 0, 1})\n *      Return: 0 if OK, 1 on error\n *\n */",
      "file" : "jbclass.c"
   },
   {
      "function" : "findFileFormat",
      "comment" : "/*!\n *  findFileFormat()\n *\n *      Input:  filename\n *              &format (<return>)\n *      Return: 0 if OK, 1 on error or if format is not recognized\n */",
      "file" : "readfile.c"
   },
   {
      "function" : "findFileFormatBuffer",
      "comment" : "/*!\n *  findFileFormatBuffer()\n *\n *      Input:  byte buffer (at least 12 bytes in size; we can't check)\n *              &format (<return>)\n *      Return: 0 if OK, 1 on error or if format is not recognized\n *\n *  Notes:\n *      (1) This determines the file format from the first 12 bytes in\n *          the compressed data stream, which are stored in memory.\n *      (2) For tiff files, this returns IFF_TIFF.  The specific tiff\n *          compression is then determined using findTiffCompression().\n */",
      "file" : "readfile.c"
   },
   {
      "function" : "findFileFormatStream",
      "comment" : "/*!\n *  findFileFormatStream()\n *\n *      Input:  fp (file stream)\n *              &format (<return>)\n *      Return: 0 if OK, 1 on error or if format is not recognized\n *\n *  Notes:\n *      (1) Important: Side effect -- this resets fp to BOF.\n */",
      "file" : "readfile.c"
   },
   {
      "function" : "findNextBorderPixel",
      "comment" : "/*!\n *  findNextBorderPixel()\n *\n *      Input:  w, h, data, wpl\n *              (px, py),     (current P)\n *              &qpos (input current Q; <return> new Q)\n *              (&npx, &npy)    (<return> new P)\n *      Return: 0 if next pixel found; 1 otherwise\n *\n *  Notes:\n *      (1) qpos increases clockwise from 0 to 7, with 0 at\n *          location with Q to left of P:   Q P\n *      (2) this is a low-level function that does not check input\n *          parameters.  All calling functions should check them.\n */",
      "file" : "ccbord.c"
   },
   {
      "function" : "findSimilarSizedTemplatesDestroy",
      "comment" : "/*!\n *  findSimilarSizedTemplatesInit()\n *\n *      Input:  classer\n *              pixs (instance to be matched)\n *      Return: Allocated context to be used with findSimilar*\n */",
      "file" : "jbclass.c"
   },
   {
      "function" : "findSimilarSizedTemplatesInit",
      "comment" : "/*!\n *  findSimilarSizedTemplatesInit()\n *\n *      Input:  classer\n *              pixs (instance to be matched)\n *      Return: Allocated context to be used with findSimilar*\n */",
      "file" : "jbclass.c"
   },
   {
      "function" : "findSimilarSizedTemplatesNext",
      "comment" : "/*!\n *  findSimilarSizedTemplatesNext()\n *\n *      Input:  state (from findSimilarSizedTemplatesInit)\n *      Return: Next template number, or -1 when finished\n *\n *  We have a hash table mapping template area to a list of template\n *  numbers with that area.  We wish to find similar sized templates,\n *  so we first look for templates with the same width and height, and\n *  then with width + 1, etc.  This walk is guided by the\n *  two_by_two_walk array, above.\n *\n *  We don't want to have to collect the whole list of templates first because\n *  (we hope) to find it quickly.  So we keep the context for this walk in an\n *  explictit state structure and this function acts like a generator.\n */",
      "file" : "jbclass.c"
   },
   {
      "function" : "findTiffCompression",
      "comment" : "/*!\n *  findTiffCompression()\n *\n *      Input:  stream (must be rewound to BOF)\n *              &comptype (<return> compression type)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The returned compression type is that defined in\n *          the enum in imageio.h.  It is not the tiff flag value.\n *      (2) The compression type is initialized to IFF_UNKNOWN.\n *          If it is not one of the specified types, the returned\n *          type is IFF_TIFF, which indicates no compression.\n *      (3) When this function is called, the stream must be at BOF.\n *          If the opened stream is to be used again to read the\n *          file, it must be rewound to BOF after calling this function.\n */",
      "file" : "tiffio.c"
   },
   {
      "function" : "findTilePatchCenter",
      "comment" : "/*!\n *  findTilePatchCenter()\n *\n *      Input:  pixs (8 or 16 bpp; distance function of a binary mask)\n *              box (region of pixs to search around)\n *              searchdir (L_HORIZ or L_VERT; direction to search)\n *              targdist (desired distance of selected patch center from fg)\n *              &dist (<return> actual distance of selected location)\n *              &xc, &yc (<return> location of selected patch center)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This looks for a patch of non-masked image, that is outside\n *          but near the input box.  The input pixs is a distance\n *          function giving the distance from the fg in a binary mask.\n *      (2) The target distance implicitly specifies a desired size\n *          for the patch.  The location of the center of the patch,\n *          and the actual distance from fg are returned.\n *      (3) If the target distance is larger than 255, a 16-bit distance\n *          transform is input.\n *      (4) It is assured that a square centered at (xc, yc) and of\n *          size 'dist' will not intersect with the fg of the binary\n *          mask that was used to generate pixs.\n *      (5) We search away from the component, in approximately\n *          the center 1/3 of its dimension.  This gives a better chance\n *          of finding patches that are close to the component.\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "flipLRLow",
      "comment" : "/*!\n *  flipLRLow()\n *\n *  Notes:\n *      (1) The pixel access routines allow a trivial implementation.\n *          However, for d < 8, it is more efficient to right-justify\n *          each line to a 32-bit boundary and then extract bytes and\n *          do pixel reversing.   In those cases, as in the 180 degree\n *          rotation, we right-shift the data (if necessary) to\n *          right-justify on the 32 bit boundary, and then read the\n *          bytes off each raster line in reverse order, reversing\n *          the pixels in each byte using a table.  These functions\n *          for 1, 2 and 4 bpp were tested against the \"trivial\"\n *          version (shown here for 4 bpp):\n *              for (i = 0; i < h; i++) {\n *                  line = data + i * wpl;\n *                  memcpy(buffer, line, bpl);\n *                    for (j = 0; j < w; j++) {\n *                      val = GET_DATA_QBIT(buffer, w - 1 - j);\n *                        SET_DATA_QBIT(line, j, val);\n *                  }\n *              }\n *      (2) This operation is in-place.\n */",
      "file" : "rotateorthlow.c"
   },
   {
      "function" : "flipTBLow",
      "comment" : "/*!\n *  flipTBLow()\n *\n *  Notes:\n *      (1) This is simple and fast.  We use the memcpy function\n *          to do all the work on aligned data, regardless of pixel\n *          depth.\n *      (2) This operation is in-place.\n */",
      "file" : "rotateorthlow.c"
   },
   {
      "function" : "flipfhmtgen_low",
      "comment" : "/*\n *  flipfhmtgen_low()\n *\n *       A dispatcher to appropriate low-level code for flip hmt ops\n */",
      "file" : "fliphmtgen.c"
   },
   {
      "function" : "fmorphautogen",
      "comment" : "/*!\n *  fmorphautogen()\n *\n *      Input:  sela\n *              fileindex\n *              filename (<optional>; can be null)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This function generates all the code for implementing\n *          dwa morphological operations using all the sels in the sela.\n *      (2) See fmorphautogen1() and fmorphautogen2() for details.\n */",
      "file" : "fmorphauto.c"
   },
   {
      "function" : "fmorphautogen1",
      "comment" : "/*!\n *  fmorphautogen1()\n *\n *      Input:  sela\n *              fileindex\n *              filename (<optional>; can be null)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This function uses morphtemplate1.txt to create a\n *          top-level file that contains two functions.  These\n *          functions will carry out dilation, erosion,\n *          opening or closing for any of the sels in the input sela.\n *      (2) The fileindex parameter is inserted into the output\n *          filename, as described below.\n *      (3) If filename == NULL, the output file is fmorphgen.<n>.c,\n *          where <n> is equal to the 'fileindex' parameter.\n *      (4) If filename != NULL, the output file is <filename>.<n>.c.\n */",
      "file" : "fmorphauto.c"
   },
   {
      "function" : "fmorphautogen2",
      "comment" : "/*\n *  fmorphautogen2()\n *\n *      Input:  sela\n *              fileindex\n *              filename (<optional>; can be null)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This function uses morphtemplate2.txt to create a\n *          low-level file that contains the low-level functions for\n *          implementing dilation and erosion for every sel\n *          in the input sela.\n *      (2) The fileindex parameter is inserted into the output\n *          filename, as described below.\n *      (3) If filename == NULL, the output file is fmorphgenlow.<n>.c,\n *          where <n> is equal to the 'fileindex' parameter.\n *      (4) If filename != NULL, the output file is <filename>low.<n>.c.\n */",
      "file" : "fmorphauto.c"
   },
   {
      "function" : "fmorphopgen_low_1",
      "comment" : "/*!\n *  fmorphopgen_low_1()\n *\n *       a dispatcher to appropriate low-level code\n */",
      "file" : "fmorphgenlow.1.c"
   },
   {
      "function" : "fmorphopgen_low_2",
      "comment" : "/*!\n *  fmorphopgen_low_2()\n *\n *       a dispatcher to appropriate low-level code\n */",
      "file" : "dwacomblow.2.c"
   },
   {
      "function" : "fnbytesInFile",
      "comment" : "/*!\n *  fnbytesInFile()\n *\n *      Input:  file stream\n *      Return: nbytes in file; 0 on error\n */",
      "file" : "utils.c"
   },
   {
      "function" : "fopenReadStream",
      "comment" : "/*!\n *  fopenReadStream()\n *\n *      Input:  filename\n *      Return: stream, or null on error\n *\n *  Notes:\n *      (1) This wrapper also handles pathname conversions for Windows.\n *          It should be used whenever you want to run fopen() to\n *          read from a stream.\n */",
      "file" : "utils.c"
   },
   {
      "function" : "fopenTiff",
      "comment" : "/*!\n *  fopenTiff()\n *\n *      Input:  stream\n *              modestring (\"r\", \"w\", ...)\n *      Return: tiff (data structure, opened for a file descriptor)\n *\n *  Notes:\n *      (1) Why is this here?  Leffler did not provide a function that\n *          takes a stream and gives a TIFF.  He only gave one that\n *          generates a TIFF starting with a file descriptor.  So we\n *          need to make it here, because it is useful to have functions\n *          that take a stream as input.\n *      (2) Requires lseek to rewind to BOF; fseek won't hack it.\n *      (3) When linking with windows, suggest you use tif_unix.c\n *          instead of tif_win32.c, because it has been reported that\n *          the file descriptor returned from fileno() does not work\n *          with TIFFFdOpen() in tif_win32.c.  (win32 requires a\n *          \"handle\", which is an integer returned by _get_osfhandle(fd).)\n */",
      "file" : "tiffio.c"
   },
   {
      "function" : "fopenTiffMemstream",
      "comment" : "/*!\n *  fopenTiffMemstream()\n *\n *      Input:  filename (for error output; can be \"\")\n *              operation (\"w\" for write, \"r\" for read)\n *              &data (<return> written data)\n *              &datasize (<return> size of written data)\n *      Return: tiff (data structure, opened for write to memory)\n *\n *  Notes:\n *      (1) This wraps up a number of callbacks for either:\n *            * reading from tiff in memory buffer --> pix\n *            * writing from pix --> tiff in memory buffer\n *      (2) After use, the memstream is automatically destroyed when\n *          TIFFClose() is called.  TIFFCleanup() doesn't free the memstream.\n */",
      "file" : "tiffio.c"
   },
   {
      "function" : "fopenWriteStream",
      "comment" : "/*!\n *  fopenWriteStream()\n *\n *      Input:  filename\n *              modestring\n *      Return: stream, or null on error\n *\n *  Notes:\n *      (1) This wrapper also handles pathname conversions for Windows.\n *          It should be used whenever you want to run fopen() to\n *          write or append to a stream.\n */",
      "file" : "utils.c"
   },
   {
      "function" : "fpixAddBorder",
      "comment" : "/*!\n *  fpixAddBorder()\n *\n *      Input:  fpixs\n *              left, right, top, bot (pixels on each side to be added)\n *      Return: fpixd, or null on error\n *\n *  Notes:\n *      (1) Adds border of '0' 32-bit pixels\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "fpixAddContinuedBorder",
      "comment" : "/*!\n *  fpixAddContinuedBorder()\n *\n *      Input:  fpixs\n *              left, right, top, bot (pixels on each side to be added)\n *      Return: fpixd, or null on error\n *\n *  Notes:\n *      (1) This adds pixels on each side whose values are equal to\n *          the value on the closest boundary pixel.\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "fpixAddMirroredBorder",
      "comment" : "/*!\n *  fpixAddMirroredBorder()\n *\n *      Input:  fpixs\n *              left, right, top, bot (pixels on each side to be added)\n *      Return: fpixd, or null on error\n *\n *  Notes:\n *      (1) See pixAddMirroredBorder() for situations of usage.\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "fpixAddMultConstant",
      "comment" : "/*!\n *  fpixAddMultConstant()\n *\n *      Input:  fpix\n *              addc  (use 0.0 to skip the operation)\n *              multc (use 1.0 to skip the operation)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is an in-place operation.\n *      (2) It can be used to multiply each pixel by a constant,\n *          and also to add a constant to each pixel.  Multiplication\n *          is done first.\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "fpixAddSlopeBorder",
      "comment" : "/*!\n *  fpixAddSlopeBorder()\n *\n *      Input:  fpixs\n *              left, right, top, bot (pixels on each side to be added)\n *      Return: fpixd, or null on error\n *\n *  Notes:\n *      (1) This adds pixels on each side whose values have a normal\n *          derivative equal to the normal derivative at the boundary\n *          of fpixs.\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "fpixAffine",
      "comment" : "/*!\n *  fpixAffine()\n *\n *      Input:  fpixs (8 bpp)\n *              vc  (vector of 8 coefficients for projective transformation)\n *              inval (value brought in; typ. 0)\n *      Return: fpixd, or null on error\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "fpixAffinePta",
      "comment" : "/*!\n *  fpixAffinePta()\n *\n *      Input:  fpixs (8 bpp)\n *              ptad  (4 pts of final coordinate space)\n *              ptas  (4 pts of initial coordinate space)\n *              border (size of extension with constant normal derivative)\n *              inval (value brought in; typ. 0)\n *      Return: fpixd, or null on error\n *\n *  Notes:\n *      (1) If @border > 0, all four sides are extended by that distance,\n *          and removed after the transformation is finished.  Pixels\n *          that would be brought in to the trimmed result from outside\n *          the extended region are assigned @inval.  The purpose of\n *          extending the image is to avoid such assignments.\n *      (2) On the other hand, you may want to give all pixels that\n *          are brought in from outside fpixs a specific value.  In that\n *          case, set @border == 0.\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "fpixAutoRenderContours",
      "comment" : "/*!\n *  fpixAutoRenderContours()\n *\n *      Input:  fpix\n *              ncontours (> 1, < 500, typ. about 50)\n *      Return: pixd (8 bpp), or null on error\n *\n *  Notes:\n *      (1) The increment is set to get approximately @ncontours.\n *      (2) The proximity to the target value for contour display\n *          is set to 0.15.\n *      (3) Negative values are rendered in red; positive values as black.\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "fpixChangeRefcount",
      "comment" : "/*!\n *  fpixSetDimensions()\n *\n *      Input:  fpix\n *              w, h\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixClone",
      "comment" : "/*!\n *  fpixClone()\n *\n *      Input:  fpix\n *      Return: same fpix (ptr), or null on error\n *\n *  Notes:\n *      (1) See pixClone() for definition and usage.\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixConvertToDPix",
      "comment" : "/*!\n *  fpixConvertToDPix()\n *\n *      Input:  fpix\n *      Return: dpix, or null on error\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "fpixConvertToPix",
      "comment" : "/*!\n *  fpixConvertToPix()\n *\n *      Input:  fpixs\n *              outdepth (0, 8, 16 or 32 bpp)\n *              negvals (L_CLIP_TO_ZERO, L_TAKE_ABSVAL)\n *              errorflag (1 to output error stats; 0 otherwise)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Use @outdepth = 0 to programmatically determine the\n *          output depth.  If no values are greater than 255,\n *          it will set outdepth = 8; otherwise to 16 or 32.\n *      (2) Because we are converting a float to an unsigned int\n *          with a specified dynamic range (8, 16 or 32 bits), errors\n *          can occur.  If errorflag == TRUE, output the number\n *          of values out of range, both negative and positive.\n *      (3) If a pixel value is positive and out of range, clip to\n *          the maximum value represented at the outdepth of 8, 16\n *          or 32 bits.\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "fpixConvolve",
      "comment" : "/*!\n *  fpixConvolve()\n *\n *      Input:  fpixs (32 bit float array)\n *              kernel\n *              normflag (1 to normalize kernel to unit sum; 0 otherwise)\n *      Return: fpixd (32 bit float array)\n *\n *  Notes:\n *      (1) This gives a float convolution with an arbitrary kernel.\n *      (2) If normflag == 1, the result is normalized by scaling all\n *          kernel values for a unit sum.  If the sum of kernel values\n *          is very close to zero, the kernel can not be normalized and\n *          the convolution will not be performed.  A warning is issued.\n *      (3) With the FPix, there are no issues about negative\n *          array or kernel values.  The convolution is performed\n *          with single precision arithmetic.\n *      (4) To get a subsampled output, call l_setConvolveSampling().\n *          The time to make a subsampled output is reduced by the\n *          product of the sampling factors.\n *      (5) This uses a mirrored border to avoid special casing on\n *          the boundaries.\n */",
      "file" : "convolve.c"
   },
   {
      "function" : "fpixConvolveSep",
      "comment" : "/*!\n *  fpixConvolveSep()\n *\n *      Input:  fpixs (32 bit float array)\n *              kelx (x-dependent kernel)\n *              kely (y-dependent kernel)\n *              normflag (1 to normalize kernel to unit sum; 0 otherwise)\n *      Return: fpixd (32 bit float array)\n *\n *  Notes:\n *      (1) This does a convolution with a separable kernel that is\n *          is a sequence of convolutions in x and y.  The two\n *          one-dimensional kernel components must be input separately;\n *          the full kernel is the product of these components.\n *          The support for the full kernel is thus a rectangular region.\n *      (2) The normflag parameter is used as in fpixConvolve().\n *      (3) Warning: if you use l_setConvolveSampling() to get a\n *          subsampled output, and the sampling factor is larger than\n *          the kernel half-width, it is faster to use the non-separable\n *          version pixConvolve().  This is because the first convolution\n *          here must be done on every raster line, regardless of the\n *          vertical sampling factor.  If the sampling factor is smaller\n *          than kernel half-width, it's faster to use the separable\n *          convolution.\n *      (4) This uses mirrored borders to avoid special casing on\n *          the boundaries.\n */",
      "file" : "convolve.c"
   },
   {
      "function" : "fpixCopy",
      "comment" : "/*!\n *  fpixCopy()\n *\n *      Input:  fpixd (<optional>; can be null, or equal to fpixs,\n *                    or different from fpixs)\n *              fpixs\n *      Return: fpixd, or null on error\n *\n *  Notes:\n *      (1) There are three cases:\n *            (a) fpixd == null  (makes a new fpix; refcount = 1)\n *            (b) fpixd == fpixs  (no-op)\n *            (c) fpixd != fpixs  (data copy; no change in refcount)\n *          If the refcount of fpixd > 1, case (c) will side-effect\n *          these handles.\n *      (2) The general pattern of use is:\n *             fpixd = fpixCopy(fpixd, fpixs);\n *          This will work for all three cases.\n *          For clarity when the case is known, you can use:\n *            (a) fpixd = fpixCopy(NULL, fpixs);\n *            (c) fpixCopy(fpixd, fpixs);\n *      (3) For case (c), we check if fpixs and fpixd are the same size.\n *          If so, the data is copied directly.\n *          Otherwise, the data is reallocated to the correct size\n *          and the copy proceeds.  The refcount of fpixd is unchanged.\n *      (4) This operation, like all others that may involve a pre-existing\n *          fpixd, will side-effect any existing clones of fpixd.\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixCopyResolution",
      "comment" : "/*!\n *  fpixSetDimensions()\n *\n *      Input:  fpix\n *              w, h\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixCreate",
      "comment" : "/*!\n *  fpixCreate()\n *\n *      Input:  width, height\n *      Return: fpixd (with data allocated and initialized to 0),\n *                     or null on error\n *\n *  Notes:\n *      (1) Makes a FPix of specified size, with the data array\n *          allocated and initialized to 0.\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixCreateTemplate",
      "comment" : "/*!\n *  fpixCreateTemplate()\n *\n *      Input:  fpixs\n *      Return: fpixd, or null on error\n *\n *  Notes:\n *      (1) Makes a FPix of the same size as the input FPix, with the\n *          data array allocated and initialized to 0.\n *      (2) Copies the resolution.\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixDestroy",
      "comment" : "/*!\n *  fpixDestroy()\n *\n *      Input:  &fpix <will be nulled>\n *      Return: void\n *\n *  Notes:\n *      (1) Decrements the ref count and, if 0, destroys the fpix.\n *      (2) Always nulls the input ptr.\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixDisplayMaxDynamicRange",
      "comment" : "/*!\n *  fpixDisplayMaxDynamicRange()\n *\n *      Input:  fpixs\n *      Return: pixd (8 bpp), or null on error\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "fpixEndianByteSwap",
      "comment" : "/*!\n *  fpixEndianByteSwap()\n *\n *      Input:  fpixd (can be equal to fpixs or NULL)\n *              fpixs\n *      Return: fpixd always\n *\n *  Notes:\n *      (1) On big-endian hardware, this does byte-swapping on each of\n *          the 4-byte floats in the fpix data.  On little-endians,\n *          the data is unchanged.  This is used for serialization\n *          of fpix; the data is serialized in little-endian byte\n *          order because most hardware is little-endian.\n *      (2) The operation can be either in-place or, if fpixd == NULL,\n *          a new fpix is made.  If not in-place, caller must catch\n *          the returned pointer.\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixFlipLR",
      "comment" : "/*!\n *  pixFlipLR()\n *\n *      Input:  fpixd (<optional>; can be null, equal to fpixs,\n *                     or different from fpixs)\n *              fpixs\n *      Return: fpixd, or null on error\n *\n *  Notes:\n *      (1) This does a left-right flip of the image, which is\n *          equivalent to a rotation out of the plane about a\n *          vertical line through the image center.\n *      (2) There are 3 cases for input:\n *          (a) fpixd == null (creates a new fpixd)\n *          (b) fpixd == fpixs (in-place operation)\n *          (c) fpixd != fpixs (existing fpixd)\n *      (3) For clarity, use these three patterns, respectively:\n *          (a) fpixd = fpixFlipLR(NULL, fpixs);\n *          (b) fpixFlipLR(fpixs, fpixs);\n *          (c) fpixFlipLR(fpixd, fpixs);\n *      (4) If an existing fpixd is not the same size as fpixs, the\n *          image data will be reallocated.\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "fpixFlipTB",
      "comment" : "/*!\n *  fpixFlipTB()\n *\n *      Input:  fpixd (<optional>; can be null, equal to fpixs,\n *                     or different from fpixs)\n *              fpixs\n *      Return: fpixd, or null on error\n *\n *  Notes:\n *      (1) This does a top-bottom flip of the image, which is\n *          equivalent to a rotation out of the plane about a\n *          horizontal line through the image center.\n *      (2) There are 3 cases for input:\n *          (a) fpixd == null (creates a new fpixd)\n *          (b) fpixd == fpixs (in-place operation)\n *          (c) fpixd != fpixs (existing fpixd)\n *      (3) For clarity, use these three patterns, respectively:\n *          (a) fpixd = fpixFlipTB(NULL, fpixs);\n *          (b) fpixFlipTB(fpixs, fpixs);\n *          (c) fpixFlipTB(fpixd, fpixs);\n *      (4) If an existing fpixd is not the same size as fpixs, the\n *          image data will be reallocated.\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "fpixGetData",
      "comment" : "/*!\n *  fpixSetDimensions()\n *\n *      Input:  fpix\n *              w, h\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixGetDimensions",
      "comment" : "/*!\n *  fpixGetDimensions()\n *\n *      Input:  fpix\n *              &w, &h (<optional return>; each can be null)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixGetMax",
      "comment" : "/*!\n *  fpixGetMax()\n *\n *      Input:  fpix\n *              &maxval (<optional return> max value)\n *              &xmaxloc (<optional return> x location of max)\n *              &ymaxloc (<optional return> y location of max)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "fpixGetMin",
      "comment" : "/*!\n *  fpixGetMin()\n *\n *      Input:  fpix\n *              &minval (<optional return> min value)\n *              &xminloc (<optional return> x location of min)\n *              &yminloc (<optional return> y location of min)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "fpixGetPixel",
      "comment" : "/*!\n *  fpixGetPixel()\n *\n *      Input:  fpix\n *              (x,y) pixel coords\n *              &val (<return> pixel value)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixGetRefcount",
      "comment" : "/*!\n *  fpixSetDimensions()\n *\n *      Input:  fpix\n *              w, h\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixGetResolution",
      "comment" : "/*!\n *  fpixSetDimensions()\n *\n *      Input:  fpix\n *              w, h\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixGetWpl",
      "comment" : "/*!\n *  fpixSetDimensions()\n *\n *      Input:  fpix\n *              w, h\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixLinearCombination",
      "comment" : "/*!\n *  fpixLinearCombination()\n *\n *      Input:  fpixd (<optional>; this can be null, equal to fpixs1, or\n *                     different from fpixs1)\n *              fpixs1 (can be == to fpixd)\n *              fpixs2\n *              a, b (multiplication factors on fpixs1 and fpixs2, rsp.)\n *      Return: fpixd always\n *\n *  Notes:\n *      (1) Computes pixelwise linear combination: a * src1 + b * src2\n *      (2) Alignment is to UL corner.\n *      (3) There are 3 cases.  The result can go to a new dest,\n *          in-place to fpixs1, or to an existing input dest:\n *          * fpixd == null:   (src1 + src2) --> new fpixd\n *          * fpixd == fpixs1:  (src1 + src2) --> src1  (in-place)\n *          * fpixd != fpixs1: (src1 + src2) --> input fpixd\n *      (4) fpixs2 must be different from both fpixd and fpixs1.\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "fpixPrintStream",
      "comment" : "/*!\n *  fpixPrintStream()\n *\n *      Input:  stream\n *              fpix\n *              factor (subsampled)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Subsampled printout of fpix for debugging.\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixProjective",
      "comment" : "/*!\n *  fpixProjective()\n *\n *      Input:  fpixs (8 bpp)\n *              vc  (vector of 8 coefficients for projective transformation)\n *              inval (value brought in; typ. 0)\n *      Return: fpixd, or null on error\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "fpixProjectivePta",
      "comment" : "/*!\n *  fpixProjectivePta()\n *\n *      Input:  fpixs (8 bpp)\n *              ptad  (4 pts of final coordinate space)\n *              ptas  (4 pts of initial coordinate space)\n *              border (size of extension with constant normal derivative)\n *              inval (value brought in; typ. 0)\n *      Return: fpixd, or null on error\n *\n *  Notes:\n *      (1) If @border > 0, all four sides are extended by that distance,\n *          and removed after the transformation is finished.  Pixels\n *          that would be brought in to the trimmed result from outside\n *          the extended region are assigned @inval.  The purpose of\n *          extending the image is to avoid such assignments.\n *      (2) On the other hand, you may want to give all pixels that\n *          are brought in from outside fpixs a specific value.  In that\n *          case, set @border == 0.\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "fpixRasterop",
      "comment" : "/*!\n *  fpixRasterop()\n *\n *      Input:  fpixd  (dest fpix)\n *              dx     (x val of UL corner of dest rectangle)\n *              dy     (y val of UL corner of dest rectangle)\n *              dw     (width of dest rectangle)\n *              dh     (height of dest rectangle)\n *              fpixs  (src fpix)\n *              sx     (x val of UL corner of src rectangle)\n *              sy     (y val of UL corner of src rectangle)\n *      Return: 0 if OK; 1 on error.\n *\n *  Notes:\n *      (1) This is similiar in structure to pixRasterop(), except\n *          it only allows copying from the source into the destination.\n *          For that reason, no op code is necessary.  Additionally,\n *          all pixels are 32 bit words (float values), which makes\n *          the copy very simple.\n *      (2) Clipping of both src and dest fpix are done automatically.\n *      (3) This allows in-place copying, without checking to see if\n *          the result is valid:  use for in-place with caution!\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "fpixRead",
      "comment" : "/*!\n *  fpixRead()\n *\n *      Input:  filename\n *      Return: fpix, or null on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixReadStream",
      "comment" : "/*!\n *  fpixReadStream()\n *\n *      Input:  stream\n *      Return: fpix, or null on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixRemoveBorder",
      "comment" : "/*!\n *  fpixRemoveBorder()\n *\n *      Input:  fpixs\n *              left, right, top, bot (pixels on each side to be removed)\n *      Return: fpixd, or null on error\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "fpixRenderContours",
      "comment" : "/*!\n *  fpixRenderContours()\n *\n *      Input:  fpixs\n *              incr  (increment between contours; must be > 0.0)\n *              proxim (required proximity to target value; default 0.15)\n *      Return: pixd (8 bpp), or null on error\n *\n *  Notes:\n *      (1) Values are displayed when val/incr is within +-proxim\n *          to an integer.  The default value is 0.15; smaller values\n *          result in thinner contour lines.\n *      (2) Negative values are rendered in red; positive values as black.\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "fpixResizeImageData",
      "comment" : "/*!\n *  fpixResizeImageData()\n *\n *      Input:  fpixd, fpixs\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If the data sizes differ, this destroys the existing\n *          data in fpixd and allocates a new, uninitialized, data array\n *          of the same size as the data in fpixs.  Otherwise, this\n *          doesn't do anything.\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixRotate180",
      "comment" : "/*!\n *  fpixRotate180()\n *\n *      Input:  fpixd  (<optional>; can be null, equal to fpixs,\n *                      or different from fpixs)\n *              fpixs\n *      Return: fpixd, or null on error\n *\n *  Notes:\n *      (1) This does a 180 rotation of the image about the center,\n *          which is equivalent to a left-right flip about a vertical\n *          line through the image center, followed by a top-bottom\n *          flip about a horizontal line through the image center.\n *      (2) There are 3 cases for input:\n *          (a) fpixd == null (creates a new fpixd)\n *          (b) fpixd == fpixs (in-place operation)\n *          (c) fpixd != fpixs (existing fpixd)\n *      (3) For clarity, use these three patterns, respectively:\n *          (a) fpixd = fpixRotate180(NULL, fpixs);\n *          (b) fpixRotate180(fpixs, fpixs);\n *          (c) fpixRotate180(fpixd, fpixs);\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "fpixRotate90",
      "comment" : "/*!\n *  fpixRotate90()\n *\n *      Input:  fpixs\n *              direction (1 = clockwise,  -1 = counter-clockwise)\n *      Return: fpixd, or null on error\n *\n *  Notes:\n *      (1) This does a 90 degree rotation of the image about the center,\n *          either cw or ccw, returning a new pix.\n *      (2) The direction must be either 1 (cw) or -1 (ccw).\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "fpixRotateOrth",
      "comment" : "/*!\n *  fpixRotateOrth()\n *\n *      Input:  fpixs\n *              quads (0-3; number of 90 degree cw rotations)\n *      Return: fpixd, or null on error\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "fpixScaleByInteger",
      "comment" : "/*!\n *  fpixScaleByInteger()\n *\n *      Input:  fpixs (low resolution, subsampled)\n *              factor (scaling factor)\n *      Return: fpixd (interpolated result), or null on error\n *\n *  Notes:\n *      (1) The width wd of fpixd is related to ws of fpixs by:\n *              wd = factor * (ws - 1) + 1   (and ditto for the height)\n *          We avoid special-casing boundary pixels in the interpolation\n *          by constructing fpixd by inserting (factor - 1) interpolated\n *          pixels between each pixel in fpixs.  Then\n *               wd = ws + (ws - 1) * (factor - 1)    (same as above)\n *          This also has the advantage that if we subsample by @factor,\n *          throwing out all the interpolated pixels, we regain the\n *          original low resolution fpix.\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "fpixSetAllArbitrary",
      "comment" : "/*!\n *  fpixSetAllArbitrary()\n *\n *      Input:  fpix\n *              val (to set at each pixel)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "fpixSetData",
      "comment" : "/*!\n *  fpixSetDimensions()\n *\n *      Input:  fpix\n *              w, h\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixSetDimensions",
      "comment" : "/*!\n *  fpixSetDimensions()\n *\n *      Input:  fpix\n *              w, h\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixSetPixel",
      "comment" : "/*!\n *  fpixSetPixel()\n *\n *      Input:  fpix\n *              (x,y) pixel coords\n *              val (pixel value)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixSetResolution",
      "comment" : "/*!\n *  fpixSetDimensions()\n *\n *      Input:  fpix\n *              w, h\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixSetWpl",
      "comment" : "/*!\n *  fpixSetDimensions()\n *\n *      Input:  fpix\n *              w, h\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixThresholdToPix",
      "comment" : "/*!\n *  fpixThresholdToPix()\n *\n *      Input:  fpix\n *              thresh\n *      Return: pixd (1 bpp), or null on error\n *\n *  Notes:\n *      (1) For all values of fpix that are <= thresh, sets the pixel\n *          in pixd to 1.\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "fpixWrite",
      "comment" : "/*!\n *  fpixWrite()\n *\n *      Input:  filename\n *              fpix\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixWriteStream",
      "comment" : "/*!\n *  fpixWriteStream()\n *\n *      Input:  stream (opened for \"wb\")\n *              fpix\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixaAddFPix",
      "comment" : "/*!\n *  fpixaAddFPix()\n *\n *      Input:  fpixa\n *              fpix  (to be added)\n *              copyflag (L_INSERT, L_COPY, L_CLONE)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixaChangeRefcount",
      "comment" : "/*!\n *  fpixaChangeRefcount()\n *\n *      Input:  fpixa\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixaCopy",
      "comment" : "/*!\n *  fpixaCopy()\n *\n *      Input:  fpixas\n *              copyflag:\n *                L_COPY makes a new fpixa and copies each fpix\n *                L_CLONE gives a new ref-counted handle to the input fpixa\n *                L_COPY_CLONE makes a new fpixa with clones of all fpix\n *      Return: new fpixa, or null on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixaCreate",
      "comment" : "/*!\n *  fpixaCreate()\n *\n *      Input:  n  (initial number of ptrs)\n *      Return: fpixa, or null on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixaDestroy",
      "comment" : "/*!\n *  fpixaDestroy()\n *\n *      Input:  &fpixa (<can be nulled>)\n *      Return: void\n *\n *  Notes:\n *      (1) Decrements the ref count and, if 0, destroys the fpixa.\n *      (2) Always nulls the input ptr.\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixaDisplayQuadtree",
      "comment" : "/*!\n *  fpixaDisplayQuadtree()\n *\n *      Input:  fpixa (mean, variance or root variance)\n *              factor (replication factor at lowest level)\n *      Return: pixd (8 bpp, mosaic of quadtree images), or null on error\n *\n *  Notes:\n *      (1) The mean and root variance fall naturally in the 8 bpp range,\n *          but the variance is typically outside the range.  This\n *          function displays 8 bpp pix clipped to 255, so the image\n *          pixels will mostly be 255 (white).\n */",
      "file" : "quadtree.c"
   },
   {
      "function" : "fpixaExtendArray",
      "comment" : "/*!\n *  fpixaExtendArray()\n *\n *      Input:  fpixa\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) Doubles the size of the fpixa ptr array.\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixaExtendArrayToSize",
      "comment" : "/*!\n *  fpixaExtendArrayToSize()\n *\n *      Input:  fpixa\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) If necessary, reallocs new fpixa ptrs array to @size.\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixaGetCount",
      "comment" : "/*!\n *  fpixaGetCount()\n *\n *      Input:  fpixa\n *      Return: count, or 0 if no pixa\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixaGetFPix",
      "comment" : "/*!\n *  fpixaGetFPix()\n *\n *      Input:  fpixa\n *              index  (to the index-th fpix)\n *              accesstype  (L_COPY or L_CLONE)\n *      Return: fpix, or null on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixaGetFPixDimensions",
      "comment" : "/*!\n *  fpixaGetFPixDimensions()\n *\n *      Input:  fpixa\n *              index  (to the index-th box)\n *              &w, &h (<optional return>; each can be null)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixaGetPixel",
      "comment" : "/*!\n *  fpixaGetPixel()\n *\n *      Input:  fpixa\n *              index (into fpixa array)\n *              (x,y) pixel coords\n *              &val (<return> pixel value)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fpixaSetPixel",
      "comment" : "/*!\n *  fpixaSetPixel()\n *\n *      Input:  fpixa\n *              index (into fpixa array)\n *              (x,y) pixel coords\n *              val (pixel value)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "fpix1.c"
   },
   {
      "function" : "fprintTiffInfo",
      "comment" : "/*\n *  fprintTiffInfo()\n *\n *      Input:  stream (for output of tag data)\n *              tiffile (input)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "tiffio.c"
   },
   {
      "function" : "freadHeaderJp2k",
      "comment" : "/*!\n *  freadHeaderJp2k()\n *\n *      Input:  stream opened for read\n *              &w (<optional return>)\n *              &h (<optional return>)\n *              &spp (<optional return>, samples/pixel)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "jp2kio.c"
   },
   {
      "function" : "freadHeaderJpeg",
      "comment" : "/*!\n *  freadHeaderJpeg()\n *\n *      Input:  stream\n *              &w (<optional return>)\n *              &h (<optional return>)\n *              &spp (<optional return>, samples/pixel)\n *              &ycck (<optional return>, 1 if ycck color space; 0 otherwise)\n *              &cmyk (<optional return>, 1 if cmyk color space; 0 otherwise)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "jpegio.c"
   },
   {
      "function" : "freadHeaderPng",
      "comment" : "/*!\n *  freadHeaderPng()\n *\n *      Input:  stream\n *              &w (<optional return>)\n *              &h (<optional return>)\n *              &bps (<optional return>, bits/sample)\n *              &spp (<optional return>, samples/pixel)\n *              &iscmap (<optional return>)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) See readHeaderPng().\n */",
      "file" : "pngio.c"
   },
   {
      "function" : "freadHeaderPnm",
      "comment" : "/*!\n *  freadHeaderPnm()\n *\n *      Input:  stream opened for read\n *              &w (<optional return>)\n *              &h (<optional return>)\n *              &d (<optional return>)\n *              &type (<optional return> pnm type)\n *              &bps (<optional return>, bits/sample)\n *              &spp (<optional return>, samples/pixel)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pnmio.c"
   },
   {
      "function" : "freadHeaderSpix",
      "comment" : "/*!\n *  freadHeaderSpix()\n *\n *      Input:  stream\n *              &width (<return>)\n *              &height (<return>)\n *              &bps (<return>, bits/sample)\n *              &spp (<return>, samples/pixel)\n *              &iscmap (<optional return>; input NULL to ignore)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If there is a colormap, iscmap is returned as 1; else 0.\n */",
      "file" : "spixio.c"
   },
   {
      "function" : "freadHeaderTiff",
      "comment" : "/*!\n *  freadHeaderTiff()\n *\n *      Input:  stream\n *              n (page image number: 0-based)\n *              &width (<return>)\n *              &height (<return>)\n *              &bps (<return> bits per sample -- 1, 2, 4 or 8)\n *              &spp (<return>; samples per pixel -- 1 or 3)\n *              &res (<optional return>; resolution in x dir; NULL to ignore)\n *              &cmap (<optional return>; colormap exists; input NULL to ignore)\n *              &format (<optional return>; tiff format; input NULL to ignore)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If there is a colormap, cmap is returned as 1; else 0.\n *      (2) If @n is equal to or greater than the number of images, returns 1.\n */",
      "file" : "tiffio.c"
   },
   {
      "function" : "ftDrawBitmap",
      "comment" : "/* }}} */",
      "file" : "freetype.c"
   },
   {
      "function" : "ftInitLibrary",
      "comment" : "/* Mix 2 colors using level as alpha */",
      "file" : "freetype.c"
   },
   {
      "function" : "ftShutdownLibrary",
      "comment" : "/* Mix 2 colors using level as alpha */",
      "file" : "freetype.c"
   },
   {
      "function" : "ftUtfToUniChar",
      "comment" : "/*\n * freetype.c\n *      static l_int32       ftUtfToUniChar()\n *      static PIX          *ftDrawBitmap()\n *             FT_LIBRARY   *ftInitLibrary()\n *             void          ftShutdownLibrary()\n *             PIX          *pixWriteTTFText()\n */",
      "file" : "freetype.c"
   },
   {
      "function" : "gaussDistribSampling",
      "comment" : "/*!\n *  gaussDistribSampling()\n *\n *      Return: gaussian distributed variable with zero mean and unit stdev\n *\n *  Notes:\n *      (1) For an explanation of the Box-Muller method for generating\n *          a normally distributed random variable with zero mean and\n *          unit standard deviation, see Numerical Recipes in C,\n *          2nd edition, p. 288ff.\n *      (2) This can be called sequentially to get samples that can be\n *          used for adding noise to each pixel of an image, for example.\n */",
      "file" : "convolve.c"
   },
   {
      "function" : "gaussjordan",
      "comment" : "/*!\n *  gaussjordan()\n *\n *      Input:   a  (n x n matrix)\n *               b  (rhs column vector)\n *               n  (dimension)\n *      Return:  0 if ok, 1 on error\n *\n *      Note side effects:\n *            (1) the matrix a is transformed to its inverse\n *            (2) the vector b is transformed to the solution X to the\n *                linear equation AX = B\n *\n *      Adapted from \"Numerical Recipes in C, Second Edition\", 1992\n *      pp. 36-41 (gauss-jordan elimination)\n */",
      "file" : "affine.c"
   },
   {
      "function" : "genPathname",
      "comment" : "/*!\n *  genPathname()\n *\n *      Input:  dir (directory name, with or without trailing '/')\n *              fname (<optional> file name within the directory)\n *      Return: pathname (either a directory or full path), or null on error\n *\n *  Notes:\n *      (1) Use unix-style pathname separators ('/').\n *      (2) This function can be used in several ways:\n *            * to generate a full path from a directory and a file name\n *            * to convert a unix pathname to a windows pathname\n *            * to convert from the unix '/tmp' directory to the\n *              equivalent windows temp directory.\n *          The windows name translation is:\n *                   /tmp  -->   <Temp>/leptonica\n *      (3) There are three cases for the input:\n *          (a) @dir is a directory and @fname is null: result is a directory\n *          (b) @dir is a full path and @fname is null: result is a full path\n *          (c) @dir is a directory and @fname is defined: result is a full path\n *      (4) In all cases, the resulting pathname is not terminated with a slash\n *      (5) The caller is responsible for freeing the pathname.\n */",
      "file" : "utils.c"
   },
   {
      "function" : "genRandomIntegerInRange",
      "comment" : "/*!\n *  genRandomIntegerInRange()\n *\n *      Input:  range (size of range; must be >= 2)\n *              seed (use 0 to skip; otherwise call srand)\n *              val (<return> random integer in range {0 ... range-1}\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) For example, to choose a rand integer between 0 and 99,\n *          use @range = 100.\n */",
      "file" : "utils.c"
   },
   {
      "function" : "genTempFilename",
      "comment" : "/*!\n *  genTempFilename()\n *\n *      Input:  dir (directory name; use '.' for local dir;\n *                   no trailing '/' and @dir == \"/\" is invalid)\n *              tail (<optional>  tailname, including extension if any;\n *                    can be null or empty but can't contain '/')\n *              usetime (1 to include current time in microseconds in\n *                       the filename; 0 to omit.\n *              usepid (1 to include pid in filename; 0 to omit.\n *      Return: temp filename, or null on error\n *\n *  Notes:\n *      (1) Use unix-style pathname separators ('/').\n *      (2) Specifying the root directory (@dir == \"/\") is invalid.\n *      (3) Specifying a @tail containing '/' is invalid.\n *      (4) The most general form (@usetime = @usepid = 1) is:\n *              <dir>/<usec>_<pid>_<tail>\n *          When @usetime = 1, @usepid = 0, the output filename is:\n *              <dir>/<usec>_<tail>\n *          When @usepid = 0, @usepid = 1, the output filename is:\n *              <dir>/<pid>_<tail>\n *          When @usetime = @usepid = 0, the output filename is:\n *              <dir>/<tail>\n *          Note: It is not valid to have @tail = null or empty and have\n *          both @usetime = @usepid = 0.  That is, there must be\n *          some non-empty tail name.\n *      (5) N.B. The caller is responsible for freeing the returned filename.\n *          For windows, to avoid C-runtime boundary crossing problems\n *          when using DLLs, you must use lept_free() to free the name.\n *      (6) For windows, if the caller requests the directory '/tmp',\n *          this uses GetTempPath() to select the actual directory,\n *          avoiding platform-conditional code in use.  The directory\n *          selected is <Temp>/leptonica, where <Temp> is the Windows\n *          temp directory.\n *      (7) Set @usetime = @usepid = 1 when\n *          (a) more than one process is writing and reading temp files, or\n *          (b) multiple threads from a single process call this function, or\n *          (c) there is the possiblity of an attack where the intruder\n *              is logged onto the server and might try to guess filenames.\n */",
      "file" : "utils.c"
   },
   {
      "function" : "generateBinaryMaze",
      "comment" : "/*!\n *  generateBinaryMaze()\n *\n *      Input:  w, h  (size of maze)\n *              xi, yi  (initial location)\n *              wallps (probability that a pixel to the side is ON)\n *              ranis (ratio of prob that pixel in forward direction\n *                     is a wall to the probability that pixel in\n *                     side directions is a wall)\n *      Return: pix, or null on error\n *\n *  Notes:\n *      (1) We have two input probability factors that determine the\n *          density of walls and average length of straight passages.\n *          When ranis < 1.0, you are more likely to generate a wall\n *          to the side than going forward.  Enter 0.0 for either if\n *          you want to use the default values.\n *      (2) This is a type of percolation problem, and exhibits\n *          different phases for different parameters wallps and ranis.\n *          For larger values of these parameters, regions in the maze\n *          are not explored because the maze generator walls them\n *          off and cannot get through.  The boundary between the\n *          two phases in this two-dimensional parameter space goes\n *          near these values:\n *                wallps       ranis\n *                0.35         1.00\n *                0.40         0.85\n *                0.45         0.70\n *                0.50         0.50\n *                0.55         0.40\n *                0.60         0.30\n *                0.65         0.25\n *                0.70         0.19\n *                0.75         0.15\n *                0.80         0.11\n *      (3) Because there is a considerable amount of overhead in calling\n *          pixGetPixel() and pixSetPixel(), this function can be sped\n *          up with little effort using raster line pointers and the\n *          GET_DATA* and SET_DATA* macros.\n */",
      "file" : "maze.c"
   },
   {
      "function" : "generateColormapStringsPdf",
      "comment" : "/* filter */",
      "file" : "pdfio.c"
   },
   {
      "function" : "generateContentStringPdf",
      "comment" : "/* Allocate 1000 bytes for the boilerplate text, and\n         * 50 bytes for each reference to an image in the\n         * ProcSet array.  */",
      "file" : "pdfio.c"
   },
   {
      "function" : "generateFixedStringsPdf",
      "comment" : "/*!\n *  l_generatePdf()\n *\n *      Input:  &data (<return> pdf array)\n *              &nbytes (<return> number of bytes in pdf array)\n *              lpd (all the required input image data)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) On error, no data is returned.\n *      (2) The objects are:\n *            1: Catalog\n *            2: Info\n *            3: Pages\n *            4: Page\n *            5: Contents  (rendering command)\n *            6 to 6+n-1: n XObjects\n *            6+n to 6+n+m-1: m colormaps\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "generateFlatePS",
      "comment" : "/*!\n *  generateFlatePS()\n *\n *      Input:  filein (<optional> input filename; can be null)\n *              cid (flate compressed image data)\n *              xpt, ypt (location of LL corner of image, in pts, relative\n *                        to the PostScript origin (0,0) at the LL corner\n *                        of the page)\n *              wpt, hpt (rendered image size in pts)\n *              pageno (page number; must start with 1; you can use 0\n *                      if there is only one page)\n *              endpage (boolean: use TRUE if this is the last image to be\n *                       added to the page; FALSE otherwise)\n *      Return: PS string, or null on error\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "generateG4PS",
      "comment" : "/*!\n *  generateG4PS()\n *\n *      Input:  filein (<optional> input tiff g4 file; can be null)\n *              cid (g4 compressed image data)\n *              xpt, ypt (location of LL corner of image, in pts, relative\n *                        to the PostScript origin (0,0) at the LL corner\n *                        of the page)\n *              wpt, hpt (rendered image size in pts)\n *              maskflag (boolean: use TRUE if just painting through fg;\n *                        FALSE if painting both fg and bg.\n *              pageno (page number; must start with 1; you can use 0\n *                      if there is only one page.)\n *              endpage (boolean: use TRUE if this is the last image to be\n *                       added to the page; FALSE otherwise)\n *      Return: PS string, or null on error\n *\n *  Notes:\n *      (1) Low-level function.\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "generateJpegPS",
      "comment" : "/*!\n *  generateJpegPS()\n *\n *      Input:  filein (<optional> input jpeg filename; can be null)\n *              cid (jpeg compressed image data)\n *              xpt, ypt (location of LL corner of image, in pts, relative\n *                        to the PostScript origin (0,0) at the LL corner\n *                        of the page)\n *              wpt, hpt (rendered image size in pts)\n *              pageno (page number; must start with 1; you can use 0\n *                      if there is only one page.)\n *              endpage (boolean: use TRUE if this is the last image to be\n *                       added to the page; FALSE otherwise)\n *      Return: PS string, or null on error\n *\n *  Notes:\n *      (1) Low-level function.\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "generateMediaboxPdf",
      "comment" : "/* Do the post-datastream string */",
      "file" : "pdfio.c"
   },
   {
      "function" : "generateOutputDataPdf",
      "comment" : "/*!\n *  generateOutputDataPdf()\n *\n *      Input:  &data (<return> pdf data array)\n *              &nbytes (<return> size of pdf data array)\n *              lpd (input data used to make pdf)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Only called from l_generatePdf().  On error, no data is returned.\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "generatePageStringPdf",
      "comment" : "/* ypt is in standard image coordinates: the location of\n         * the UL image corner with respect to the UL media box corner.\n         * Rewrite each ypt for PostScript coordinates: the location of\n         * the LL image corner with respect to the LL media box corner. */",
      "file" : "pdfio.c"
   },
   {
      "function" : "generatePagesObjStringPdf",
      "comment" : "/* If the trailer is broken, reconstruct the correct obj locations */",
      "file" : "pdfio.c"
   },
   {
      "function" : "generatePlotPtaFromNuma",
      "comment" : "/*!\n *  generatePlotPtaFromNuma()\n *\n *      Input:  numa\n *              orient (L_HORIZONTAL_LINE, L_VERTICAL_LINE)\n *              width (width of \"line\" that is drawn; between 1 and 7)\n *              refpos (reference position: y for horizontal and x for vertical)\n *              max (maximum excursion in pixels from baseline)\n *              drawref (1 to draw the reference line and the normal to it)\n *      Return: ptad, or null on error\n *\n *  Notes:\n *      (1) This generates points from a numa representing y(x) or x(y)\n *          with respect to a pix.  For y(x), we draw a horizontal line\n *          at the reference position and a vertical line at the edge; then\n *          we draw the values of the numa, scaled so that the maximum\n *          excursion from the reference position is @max pixels.\n *      (2) The width is chosen in the interval [1 ... 7].\n *      (3) @refpos should be chosen so the plot is entirely within the pix\n *          that it will be painted onto.\n *      (4) This would typically be used to plot, in place, a function\n *          computed along pixels rows or columns.\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "generatePreXStringsPdf",
      "comment" : "/* Allocate 1000 bytes for the boilerplate text, and\n         * 50 bytes for each reference to an image in the\n         * ProcSet array.  */",
      "file" : "pdfio.c"
   },
   {
      "function" : "generatePtaBox",
      "comment" : "/*!\n *  generatePtaBox()\n *\n *      Input:  box\n *              width (of line)\n *      Return: ptad, or null on error\n *\n *  Notes:\n *      (1) Because the box is constructed so that we don't have any\n *          overlapping lines, there is no need to remove duplicates.\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "generatePtaBoxa",
      "comment" : "/*!\n *  generatePtaBoxa()\n *\n *      Input:  boxa\n *              width\n *              removedups  (1 to remove, 0 to leave)\n *      Return: ptad, or null on error\n *\n *  Notes:\n *      (1) If the boxa has overlapping boxes, and if blending will\n *          be used to give a transparent effect, transparency\n *          artifacts at line intersections can be removed using\n *          removedups = 1.\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "generatePtaFilledCircle",
      "comment" : "/*!\n *  generatePtaFilledCircle()\n *\n *      Input:  radius\n *      Return: pta, or null on error\n *\n *  Notes:\n *      (1) The circle is has diameter = 2 * radius + 1.\n *      (2) It is located with the center of the circle at the\n *          point (radius, radius).\n *      (3) Consequently, it typically must be translated if\n *          it is to represent a set of pixels in an image.\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "generatePtaFilledSquare",
      "comment" : "/*!\n *  generatePtaFilledSquare()\n *\n *      Input:  side\n *      Return: pta, or null on error\n *\n *  Notes:\n *      (1) The center of the square can be chosen to be at\n *          (side / 2, side / 2).  It must be translated by this amount\n *          when used for replication.\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "generatePtaHashBox",
      "comment" : "/*!\n *  generatePtaHashBox()\n *\n *      Input:  box\n *              spacing (spacing between lines; must be > 1)\n *              width  (of line)\n *              orient  (orientation of lines: L_HORIZONTAL_LINE, ...)\n *              outline  (0 to skip drawing box outline)\n *      Return: ptad, or null on error\n *\n *  Notes:\n *      (1) The orientation takes on one of 4 orientations (horiz, vertical,\n *          slope +1, slope -1).\n *      (2) The full outline is also drawn if @outline = 1.\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "generatePtaHashBoxa",
      "comment" : "/*!\n *  generatePtaHashBoxa()\n *\n *      Input:  boxa\n *              spacing (spacing between lines; must be > 1)\n *              width  (of line)\n *              orient  (orientation of lines: L_HORIZONTAL_LINE, ...)\n *              outline  (0 to skip drawing box outline)\n *              removedups  (1 to remove, 0 to leave)\n *      Return: ptad, or null on error\n *\n *  Notes:\n *      (1) The orientation takes on one of 4 orientations (horiz, vertical,\n *          slope +1, slope -1).\n *      (2) The full outline is also drawn if @outline = 1.\n *      (3) If the boxa has overlapping boxes, and if blending will\n *          be used to give a transparent effect, transparency\n *          artifacts at line intersections can be removed using\n *          removedups = 1.\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "generatePtaLine",
      "comment" : "/*!\n *  generatePtaLine()\n *\n *      Input:  x1, y1  (end point 1)\n *              x2, y2  (end point 2)\n *      Return: pta, or null on error\n *\n *  Notes:\n *      (1) Uses Bresenham line drawing, which results in an 8-connected line.\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "generatePtaLineFromPt",
      "comment" : "/*!\n *  generatePtaLineFromPt()\n *\n *      Input:  x, y  (point of origination)\n *              length (of line, including starting point)\n *              radang (angle in radians, CW from horizontal)\n *      Return: pta, or null on error\n *\n *  Notes:\n *      (1) The @length of the line is 1 greater than the distance\n *          used in locatePtRadially().  Example: a distance of 1\n *          gives rise to a length of 2.\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "generatePtaPolyline",
      "comment" : "/*!\n *  generatePtaPolyline()\n *\n *      Input:  pta (vertices of polyline)\n *              width\n *              closeflag (1 to close the contour; 0 otherwise)\n *              removedups  (1 to remove, 0 to leave)\n *      Return: ptad, or null on error\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "generatePtaWideLine",
      "comment" : "/*!\n *  generatePtaWideLine()\n *\n *      Input:  x1, y1  (end point 1)\n *              x2, y2  (end point 2)\n *              width\n *      Return: ptaj, or null on error\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "generatePtaaBoxa",
      "comment" : "/*!\n *  generatePtaaBoxa()\n *\n *      Input:  boxa\n *      Return: ptaa, or null on error\n *\n *  Notes:\n *      (1) This generates a pta of the four corners for each box in\n *          the boxa.\n *      (2) Each of these pta can be rendered onto a pix with random colors,\n *          by using pixRenderRandomCmapPtaa() with closeflag = 1.\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "generatePtaaHashBoxa",
      "comment" : "/*!\n *  generatePtaaHashBoxa()\n *\n *      Input:  boxa\n *              spacing (spacing between hash lines; must be > 1)\n *              width  (hash line width)\n *              orient  (orientation of lines: L_HORIZONTAL_LINE, ...)\n *              outline  (0 to skip drawing box outline)\n *      Return: ptaa, or null on error\n *\n *  Notes:\n *      (1) The orientation takes on one of 4 orientations (horiz, vertical,\n *          slope +1, slope -1).\n *      (2) The full outline is also drawn if @outline = 1.\n *      (3) Each of these pta can be rendered onto a pix with random colors,\n *          by using pixRenderRandomCmapPtaa() with closeflag = 1.\n *\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "generateRandomNumberArray",
      "comment" : "/*----------------------------------------------------------------------*\n *                         Static helper functions                      *\n *----------------------------------------------------------------------*/",
      "file" : "warper.c"
   },
   {
      "function" : "generateTrailerPdf",
      "comment" : "/* starting value */",
      "file" : "pdfio.c"
   },
   {
      "function" : "generateUncompressedPS",
      "comment" : "/*!\n *  generateUncompressedPS()\n *\n *      Input:  hexdata\n *              w, h  (raster image size in pixels)\n *              d (image depth in bpp; rgb is 32)\n *              psbpl (raster bytes/line, when packed to the byte boundary)\n *              bps (bits/sample: either 1 or 8)\n *              xpt, ypt (location of LL corner of image, in pts, relative\n *                    to the PostScript origin (0,0) at the LL corner\n *                    of the page)\n *              wpt, hpt (rendered image size in pts)\n *              boxflag (1 to print out bounding box hint; 0 to skip)\n *      Return: PS string, or null on error\n *\n *  Notes:\n *      (1) Low-level function.\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "getAffineXformCoeffs",
      "comment" : "/*!\n *  getAffineXformCoeffs()\n *\n *      Input:  ptas  (source 3 points; unprimed)\n *              ptad  (transformed 3 points; primed)\n *              &vc   (<return> vector of coefficients of transform)\n *      Return: 0 if OK; 1 on error\n *\n *  We have a set of six equations, describing the affine\n *  transformation that takes 3 points (ptas) into 3 other\n *  points (ptad).  These equations are:\n *\n *          x1' = c[0]*x1 + c[1]*y1 + c[2]\n *          y1' = c[3]*x1 + c[4]*y1 + c[5]\n *          x2' = c[0]*x2 + c[1]*y2 + c[2]\n *          y2' = c[3]*x2 + c[4]*y2 + c[5]\n *          x3' = c[0]*x3 + c[1]*y3 + c[2]\n *          y3' = c[3]*x3 + c[4]*y3 + c[5]\n *\n *  This can be represented as\n *\n *          AC = B\n *\n *  where B and C are column vectors\n *\n *          B = [ x1' y1' x2' y2' x3' y3' ]\n *          C = [ c[0] c[1] c[2] c[3] c[4] c[5] c[6] ]\n *\n *  and A is the 6x6 matrix\n *\n *          x1   y1   1   0    0    0\n *           0    0   0   x1   y1   1\n *          x2   y2   1   0    0    0\n *           0    0   0   x2   y2   1\n *          x3   y3   1   0    0    0\n *           0    0   0   x3   y3   1\n *\n *  These six equations are solved here for the coefficients C.\n *\n *  These six coefficients can then be used to find the dest\n *  point (x',y') corresponding to any src point (x,y), according\n *  to the equations\n *\n *           x' = c[0]x + c[1]y + c[2]\n *           y' = c[3]x + c[4]y + c[5]\n *\n *  that are implemented in affineXformPt().\n *\n *  !!!!!!!!!!!!!!!!!!   Very important   !!!!!!!!!!!!!!!!!!!!!!\n *\n *  When the affine transform is composed from a set of simple\n *  operations such as translation, scaling and rotation,\n *  it is built in a form to convert from the un-transformed src\n *  point to the transformed dest point.  However, when an\n *  affine transform is used on images, it is used in an inverted\n *  way: it converts from the transformed dest point to the\n *  un-transformed src point.  So, for example, if you transform\n *  a boxa using transform A, to transform an image in the same\n *  way you must use the inverse of A.\n *\n *  For example, if you transform a boxa with a 3x3 affine matrix\n *  'mat', the analogous image transformation must use 'matinv':\n *\n *     boxad = boxaAffineTransform(boxas, mat);\n *     affineInvertXform(mat, &matinv);\n *     pixd = pixAffine(pixs, matinv, L_BRING_IN_WHITE);\n *\n *  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n */",
      "file" : "affine.c"
   },
   {
      "function" : "getBilinearXformCoeffs",
      "comment" : "/*!\n *  getBilinearXformCoeffs()\n *\n *      Input:  ptas  (source 4 points; unprimed)\n *              ptad  (transformed 4 points; primed)\n *              &vc   (<return> vector of coefficients of transform)\n *      Return: 0 if OK; 1 on error\n *\n *  We have a set of 8 equations, describing the bilinear\n *  transformation that takes 4 points (ptas) into 4 other\n *  points (ptad).  These equations are:\n *\n *          x1' = c[0]*x1 + c[1]*y1 + c[2]*x1*y1 + c[3]\n *          y1' = c[4]*x1 + c[5]*y1 + c[6]*x1*y1 + c[7]\n *          x2' = c[0]*x2 + c[1]*y2 + c[2]*x2*y2 + c[3]\n *          y2' = c[4]*x2 + c[5]*y2 + c[6]*x2*y2 + c[7]\n *          x3' = c[0]*x3 + c[1]*y3 + c[2]*x3*y3 + c[3]\n *          y3' = c[4]*x3 + c[5]*y3 + c[6]*x3*y3 + c[7]\n *          x4' = c[0]*x4 + c[1]*y4 + c[2]*x4*y4 + c[3]\n *          y4' = c[4]*x4 + c[5]*y4 + c[6]*x4*y4 + c[7]\n *\n *  This can be represented as\n *\n *           AC = B\n *\n *  where B and C are column vectors\n *\n *         B = [ x1' y1' x2' y2' x3' y3' x4' y4' ]\n *         C = [ c[0] c[1] c[2] c[3] c[4] c[5] c[6] c[7] ]\n *\n *  and A is the 8x8 matrix\n *\n *             x1   y1   x1*y1   1   0    0      0     0\n *              0    0     0     0   x1   y1   x1*y1   1\n *             x2   y2   x2*y2   1   0    0      0     0\n *              0    0     0     0   x2   y2   x2*y2   1\n *             x3   y3   x3*y3   1   0    0      0     0\n *              0    0     0     0   x3   y3   x3*y3   1\n *             x4   y4   x4*y4   1   0    0      0     0\n *              0    0     0     0   x4   y4   x4*y4   1\n *\n *  These eight equations are solved here for the coefficients C.\n *\n *  These eight coefficients can then be used to find the mapping\n *  (x,y) --> (x',y'):\n *\n *           x' = c[0]x + c[1]y + c[2]xy + c[3]\n *           y' = c[4]x + c[5]y + c[6]xy + c[7]\n *\n *  that are implemented in bilinearXformSampledPt() and\n *  bilinearXFormPt().\n */",
      "file" : "bilinear.c"
   },
   {
      "function" : "getColorIndexMedianCut",
      "comment" : "/*!\n *  getColorIndexMedianCut()\n *\n *      Input:  pixel (32 bit rgb)\n *              rshift (of component: 8 - sigbits)\n *              mask (over sigbits)\n *              sigbits\n *              &index (<return> rgb index value)\n *      Return: void\n *\n *  Notes:\n *      (1) This is used on each pixel in the source image.  No checking\n *          is done on input values.\n */",
      "file" : "colorquant2.c"
   },
   {
      "function" : "getCompositeParameters",
      "comment" : "/*!\n *  getCompositeParameters()\n *\n *      Input:  size\n *              &size1 (<optional return> brick factor size)\n *              &size2 (<optional return> comb factor size)\n *              &nameh1 (<optional return> name of horiz brick)\n *              &nameh2 (<optional return> name of horiz comb)\n *              &namev1 (<optional return> name of vert brick)\n *              &namev2 (<optional return> name of vert comb)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This uses the big lookup table at the top of this file.\n *      (2) All returned strings are copies that must be freed.\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "getCutPathForHole",
      "comment" : "/*!\n *  getCutPathForHole()\n *\n *      Input:  pix  (of c.c.)\n *              pta  (of outer border)\n *              boxinner (b.b. of hole path)\n *              &dir  (direction (0-3), returned; only needed for debug)\n *              &len  (length of path, returned)\n *      Return: pta of pts on cut path from the hole border\n *              to the outer border, including end points on\n *              both borders; or null on error\n *\n *  Notes:\n *      (1) If we don't find a path, we return a pta with no pts\n *          in it and len = 0.\n *      (2) The goal is to get a reasonably short path between the\n *          inner and outer borders, that goes entirely within the fg of\n *          the pix.  This function is cheap-and-dirty, may fail for some\n *          holes in complex topologies such as those you might find in a\n *          moderately dark scanned halftone.  If it fails to find a\n *          path to any particular hole, it gives a warning, and because\n *          that hole path is not included, the hole will not be rendered.\n */",
      "file" : "ccbord.c"
   },
   {
      "function" : "getExtendedCompositeParameters",
      "comment" : "/*!\n *  getExtendedCompositeParameters()\n *\n *      Input:  size (of linear Sel)\n *              &pn (<return> number of 63 wide convolutions)\n *              &pextra (<return> size of extra Sel)\n *              &actualsize (<optional return> actual size used in operation)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The DWA implementation allows Sels to be used with hits\n *          up to 31 pixels from the origin, either horizontally or\n *          vertically.  Larger Sels can be used if decomposed into\n *          a set of operations with Sels not exceeding 63 pixels\n *          in either width or height (and with the origin as close\n *          to the center of the Sel as possible).\n *      (2) This returns the decomposition of a linear Sel of length\n *          @size into a set of @n Sels of length 63 plus an extra\n *          Sel of length @extra.\n *      (3) For notation, let w == @size, n == @n, and e == @extra.\n *          We have 1 < e < 63.\n *\n *          Then if w < 64, we have n = 0 and e = w.\n *          The general formula for w > 63 is:\n *             w = 63 + (n - 1) * 62 + (e - 1)\n *\n *          Where did this come from?  Each successive convolution with\n *          a Sel of length L adds a total length (L - 1) to w.\n *          This accounts for using 62 for each additional Sel of size 63,\n *          and using (e - 1) for the additional Sel of size e.\n *\n *          Solving for n and e for w > 63:\n *             n = 1 + Int((w - 63) / 62)\n *             e = w - 63 - (n - 1) * 62 + 1\n *\n *          The extra part is decomposed into two factors f1 and f2,\n *          and the actual size of the extra part is\n *             e' = f1 * f2\n *          Then the actual width is:\n *             w' = 63 + (n - 1) * 62 + f1 * f2 - 1\n */",
      "file" : "morphdwa.c"
   },
   {
      "function" : "getFilenamesInDirectory",
      "comment" : "/*!\n *  getFilenamesInDirectory()\n *\n *      Input:  directory name\n *      Return: sarray of file names, or NULL on error\n *\n *  Notes:\n *      (1) The versions compiled under unix and cygwin use the POSIX C\n *          library commands for handling directories.  For windows,\n *          there is a separate implementation.\n *      (2) It returns an array of filename tails; i.e., only the part of\n *          the path after the last slash.\n *      (3) Use of the d_type field of dirent is not portable:\n *          \"According to POSIX, the dirent structure contains a field\n *          char d_name[] of unspecified size, with at most NAME_MAX\n *          characters preceding the terminating null character.  Use\n *          of other fields will harm the portability of your programs.\"\n *      (4) As a consequence of (3), we note several things:\n *           - MINGW doesn't have a d_type member.\n *           - Older versions of gcc (e.g., 2.95.3) return DT_UNKNOWN\n *             for d_type from all files.\n *          On these systems, this function will return directories\n *          (except for '.' and '..', which are eliminated using\n *          the d_name field).\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "getFilenamesInDirectory",
      "comment" : "/* http://msdn2.microsoft.com/en-us/library/aa365200(VS.85).aspx */",
      "file" : "sarray.c"
   },
   {
      "function" : "getFormatExtension",
      "comment" : "/*!\n *  getFormatExtension()\n *\n *      Input:  format (integer)\n *      Return: extension (string), or null if format is out of range\n *\n *  Notes:\n *      (1) This string is NOT owned by the caller; it is just a pointer\n *          to a global string.  Do not free it.\n */",
      "file" : "writefile.c"
   },
   {
      "function" : "getImagelibVersions",
      "comment" : "/*!\n *  getImagelibVersions()\n *\n *      Return: string of version numbers (e.g.,\n *               libgif 5.0.3\n *               libjpeg 8b\n *               libpng 1.4.3\n *               libtiff 3.9.5\n *               zlib 1.2.5\n *               webp 0.3.0\n *\n *  Notes:\n *      (1) The caller has responsibility to free the memory.\n */",
      "file" : "libversions.c"
   },
   {
      "function" : "getImpliedFileFormat",
      "comment" : "/*!\n *  getImpliedFileFormat()\n *\n *      Input:  filename\n *      Return: output format, or IFF_UNKNOWN on error or invalid extension.\n *\n *  Notes:\n *      (1) This determines the output file format from the extension\n *          of the input filename.\n */",
      "file" : "writefile.c"
   },
   {
      "function" : "getLeptonicaVersion",
      "comment" : "/*!\n *  getLeptonicaVersion()\n *\n *      Return: string of version number (e.g., 'leptonica-1.68')\n *\n *  Notes:\n *      (1) The caller has responsibility to free the memory.\n */",
      "file" : "utils.c"
   },
   {
      "function" : "getLogBase2",
      "comment" : "/*\n * getLogBase2()\n *\n *     Input:  val\n *             logtab (256-entry table of logs)\n *     Return: logdist, or 0 on error\n */",
      "file" : "pixarith.c"
   },
   {
      "function" : "getMorphBorderPixelColor",
      "comment" : "/*!\n *  getMorphBorderPixelColor()\n *\n *      Input:  type (L_MORPH_DILATE, L_MORPH_ERODE)\n *              depth (of pix)\n *      Return: color of border pixels for this operation\n */",
      "file" : "morph.c"
   },
   {
      "function" : "getNextJpegMarker",
      "comment" : "/*\n *  getNextJpegMarker()\n *\n *      Input:  array (jpeg data)\n *              size (from current point to the end)\n *              &index (input current and <return> the last position searched.\n *                      If it is not at the end of the array, we return\n *                      the first byte that is not 0xff, after\n *                      having encountered at least one 0xff.)\n *      Return: 0 if a marker is found, 1 if the end of the array is reached\n *\n *  Notes:\n *      (1) In jpeg, 0xff is used to mark the end of a data segment.\n *          There may be more than one 0xff in succession.  But not every\n *          0xff marks the end of a segment.  It is possible, though\n *          rare, that 0xff can occur within some data.  In that case,\n *          the marker is \"escaped\", by following it with 0x00.\n *      (2) This function parses a jpeg data stream.  It doesn't\n *          _really_ get the next marker, because it doesn't check if\n *          the 0xff is escaped.  But the caller checks for this escape\n *          condition, and ignores the marker if escaped.\n */",
      "file" : "jpegio.c"
   },
   {
      "function" : "getNextNonBlankLine",
      "comment" : "/*\n *  getNextNonBlankLine()\n *\n *      Input:  sa (output from cpp, by line)\n *              start (starting index to search)\n *              &next (<return> index of first nonblank line after\n *                     the start line)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Skips over all consecutive blank lines, beginning at 'start'\n *      (2) A blank line has only whitespace characters (' ', '\\t', '\\n', '\\r')\n *      (3) If all lines to the end are blank, return next = -1\n */",
      "file" : "parseprotos.c"
   },
   {
      "function" : "getNextNonCommentLine",
      "comment" : "/*\n *  getNextNonCommentLine()\n *\n *      Input:  sa (output from cpp, by line)\n *              start (starting index to search)\n *              &next (<return> index of first uncommented line after\n *                     the start line)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Skips over all consecutive comment lines, beginning at 'start'\n *      (2) If all lines to the end are '#' comments, return next = -1\n */",
      "file" : "parseprotos.c"
   },
   {
      "function" : "getNextNonDoubleSlashLine",
      "comment" : "/*\n *  getNextNonDoubleSlashLine()\n *\n *      Input:  sa (output from cpp, by line)\n *              start (starting index to search)\n *              &next (<return> index of first uncommented line after\n *                     the start line)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Skips over all consecutive '//' lines, beginning at 'start'\n *      (2) If all lines to the end start with '//', return next = -1\n */",
      "file" : "parseprotos.c"
   },
   {
      "function" : "getNumberedPathnamesInDirectory",
      "comment" : "/*!\n *  getNumberedPathnamesInDirectory()\n *\n *      Input:  directory name\n *              substr (<optional> substring filter on filenames; can be NULL)\n *              numpre (number of characters in name before number)\n *              numpost (number of characters in name after the number,\n *                       up to a dot before an extension)\n *              maxnum (only consider page numbers up to this value)\n *      Return: sarray of numbered pathnames, or NULL on error\n *\n *  Notes:\n *      (1) Returns the full pathnames of the numbered filenames in\n *          the directory.  The number in the filename is the index\n *          into the sarray.  For indices for which there are no filenames,\n *          an empty string (\"\") is placed into the sarray.\n *          This makes reading numbered files very simple.  For example,\n *          the image whose filename includes number N can be retrieved using\n *               pixReadIndexed(sa, N);\n *      (2) If @substr is not NULL, only filenames that contain\n *          the substring can be included.  If @substr is NULL,\n *          all matching filenames are used.\n *      (3) If no numbered files are found, it returns an empty sarray,\n *          with no initialized strings.\n *      (4) It is assumed that the page number is contained within\n *          the basename (the filename without directory or extension).\n *          @numpre is the number of characters in the basename\n *          preceeding the actual page number; @numpost is the number\n *          following the page number, up to either the end of the\n *          basename or a \".\", whichever comes first.\n *      (5) This is useful when all filenames contain numbers that are\n *          not necessarily consecutive.  0-padding is not required.\n *      (6) To use a O(n) matching algorithm, the largest page number\n *          is found and two internal arrays of this size are created.\n *          This maximum is constrained not to exceed @maxsum,\n *          to make sure that an unrealistically large number is not\n *          accidentally used to determine the array sizes.\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "getOctcubeIndexFromRGB",
      "comment" : "/*!\n *  getOctcubeIndexFromRGB()\n *\n *      Input:  rval, gval, bval\n *              rtab, gtab, btab  (generated with makeRGBToIndexTables())\n *              &index (<return>)\n *      Return: void\n *\n *  Note: no error checking!\n */",
      "file" : "colorquant1.c"
   },
   {
      "function" : "getOctcubeIndices",
      "comment" : "/*!\n *  getOctcubeIndices()\n *\n *     Input:  rgbindex\n *             octree level (0, 1, 2, 3, 4, 5)\n *             &octcube base index (<return> index at the octree level)\n *             &octcube sub index (<return> index at the next lower level)\n *     Return: 0 if OK, 1 on error\n *\n *  for CQ_NLEVELS = 6, the full RGB index is in the form:\n *     index = (0[13] 0 r7 g7 b7 r6 g6 b6 r5 g5 b5 r4 g4 b4 r3 g3 b3 r2 g2 b2)\n *  for CQ_NLEVELS = 5, the full RGB index is in the form:\n *     index = (0[16] 0 r7 g7 b7 r6 g6 b6 r5 g5 b5 r4 g4 b4 r3 g3 b3)\n *  for CQ_NLEVELS = 4, the full RGB index is in the form:\n *     index = (0[19] 0 r7 g7 b7 r6 g6 b6 r5 g5 b5 r4 g4 b4)\n *\n *  The base index is the index of the octcube at the level given,\n *  whereas the sub index is the index at the next level down.\n *\n *  For level 0: base index = 0\n *               sub index is the 3 bit number (r7 g7 b7)\n *  For level 1: base index = (r7 g7 b7)\n *               sub index = (r7 g7 b7 r6 g6 b6)\n *  For level 2: base index = (r7 g7 b7 r6 g6 b6)\n *               sub index = (r7 g7 b7 r6 g6 b6 r5 g5 b5)\n *  For level 3: base index = (r7 g7 b7 r6 g6 b6 r5 g5 b5)\n *               sub index = (r7 g7 b7 r6 g6 b6 r5 g5 b5 r4 g4 b4)\n *  For level 4: base index = (r7 g7 b7 r6 g6 b6 r5 g5 b5 r4 g4 b4)\n *               sub index = (r7 g7 b7 r6 g6 b6 r5 g5 b5 r4 g4 b4 r3 g3 b3)\n *  For level 5: base index = (r7 g7 b7 r6 g6 b6 r5 g5 b5 r4 g4 b4 r3 g3 b3)\n *               sub index = (r7 g7 b7 r6 g6 b6 r5 g5 b5 r4 g4 b4 r3 g3 b3\n *                            r2 g2 b2)\n */",
      "file" : "colorquant1.c"
   },
   {
      "function" : "getOffsetForCharacter",
      "comment" : "/*\n *  getOffsetForCharacter()\n *\n *      Input:  sa (output from cpp, by line)\n *              start (starting index in sa to search; never a comment line)\n *              tchar (we are searching for the first instance of this)\n *              &soffset (<return> offset in strings from start index)\n *              &boffset (<return> offset in bytes within string in which\n *                        the character is first found)\n *              &toffset (<return> offset in total bytes from beginning of\n *                        string indexed by 'start' to the location where\n *                        the character is first found)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) We are searching for the first instance of 'tchar', starting\n *          at the beginning of the string indexed by start.\n *      (2) If the character is not found, soffset is returned as -1,\n *          and the other offsets are set to very large numbers.  The\n *          caller must check the value of soffset.\n *      (3) This is only used in contexts where it is not necessary to\n *          consider if the character is inside a string.\n */",
      "file" : "parseprotos.c"
   },
   {
      "function" : "getOffsetForMatchingRP",
      "comment" : "/*\n *  getOffsetForMatchingRP()\n *\n *      Input:  sa (output from cpp, by line)\n *              start (starting index in sa to search; never a comment line)\n *              soffsetlp (string offset to first LP)\n *              boffsetlp (byte offset within string to first LP)\n *              toffsetlp (total byte offset to first LP)\n *              &soffset (<return> offset in strings from start index)\n *              &boffset (<return> offset in bytes within string in which\n *                        the matching RP is found)\n *              &toffset (<return> offset in total bytes from beginning of\n *                        string indexed by 'start' to the location where\n *                        the matching RP is found);\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) We are searching for the matching right parenthesis (RP) that\n *          corresponds to the first LP found beginning at the string\n *          indexed by start.\n *      (2) If the matching RP is not found, soffset is returned as -1,\n *          and the other offsets are set to very large numbers.  The\n *          caller must check the value of soffset.\n *      (3) This is only used in contexts where it is not necessary to\n *          consider if the character is inside a string.\n *      (4) We must do this because although most arg lists have a single\n *          left and right parenthesis, it is possible to construct\n *          more complicated prototype declarations, such as those\n *          where functions are passed in.  The C++ rules for prototypes\n *          are strict, and require that for functions passed in as args,\n *          the function name arg be placed in parenthesis, as well\n *          as its arg list, thus incurring two extra levels of parentheses.\n */",
      "file" : "parseprotos.c"
   },
   {
      "function" : "getProjectiveXformCoeffs",
      "comment" : "/*!\n *  getProjectiveXformCoeffs()\n *\n *      Input:  ptas  (source 4 points; unprimed)\n *              ptad  (transformed 4 points; primed)\n *              &vc   (<return> vector of coefficients of transform)\n *      Return: 0 if OK; 1 on error\n *\n *  We have a set of 8 equations, describing the projective\n *  transformation that takes 4 points (ptas) into 4 other\n *  points (ptad).  These equations are:\n *\n *          x1' = (c[0]*x1 + c[1]*y1 + c[2]) / (c[6]*x1 + c[7]*y1 + 1)\n *          y1' = (c[3]*x1 + c[4]*y1 + c[5]) / (c[6]*x1 + c[7]*y1 + 1)\n *          x2' = (c[0]*x2 + c[1]*y2 + c[2]) / (c[6]*x2 + c[7]*y2 + 1)\n *          y2' = (c[3]*x2 + c[4]*y2 + c[5]) / (c[6]*x2 + c[7]*y2 + 1)\n *          x3' = (c[0]*x3 + c[1]*y3 + c[2]) / (c[6]*x3 + c[7]*y3 + 1)\n *          y3' = (c[3]*x3 + c[4]*y3 + c[5]) / (c[6]*x3 + c[7]*y3 + 1)\n *          x4' = (c[0]*x4 + c[1]*y4 + c[2]) / (c[6]*x4 + c[7]*y4 + 1)\n *          y4' = (c[3]*x4 + c[4]*y4 + c[5]) / (c[6]*x4 + c[7]*y4 + 1)\n *\n *  Multiplying both sides of each eqn by the denominator, we get\n *\n *           AC = B\n *\n *  where B and C are column vectors\n *\n *         B = [ x1' y1' x2' y2' x3' y3' x4' y4' ]\n *         C = [ c[0] c[1] c[2] c[3] c[4] c[5] c[6] c[7] ]\n *\n *  and A is the 8x8 matrix\n *\n *             x1   y1     1     0   0    0   -x1*x1'  -y1*x1'\n *              0    0     0    x1   y1   1   -x1*y1'  -y1*y1'\n *             x2   y2     1     0   0    0   -x2*x2'  -y2*x2'\n *              0    0     0    x2   y2   1   -x2*y2'  -y2*y2'\n *             x3   y3     1     0   0    0   -x3*x3'  -y3*x3'\n *              0    0     0    x3   y3   1   -x3*y3'  -y3*y3'\n *             x4   y4     1     0   0    0   -x4*x4'  -y4*x4'\n *              0    0     0    x4   y4   1   -x4*y4'  -y4*y4'\n *\n *  These eight equations are solved here for the coefficients C.\n *\n *  These eight coefficients can then be used to find the mapping\n *  (x,y) --> (x',y'):\n *\n *           x' = (c[0]x + c[1]y + c[2]) / (c[6]x + c[7]y + 1)\n *           y' = (c[3]x + c[4]y + c[5]) / (c[6]x + c[7]y + 1)\n *\n *  that is implemented in projectiveXformSampled() and\n *  projectiveXFormInterpolated().\n */",
      "file" : "projective.c"
   },
   {
      "function" : "getRGBFromIndex",
      "comment" : "/*!\n *  getRGBFromIndex()\n *\n *      Input:  index (rgbindex)\n *              sigbits (2-6, significant bits retained in the quantizer\n *                       for each component of the input image)\n *              &rval, &gval, &bval (<return> rgb values)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The @index is expressed in bits, based on the the\n *          @sigbits of the r, g and b components, as\n *             r7 r6 ... g7 g6 ... b7 b6 ...\n *      (2) The computed rgb values are in the center of the quantized cube.\n *          The extra bit that is OR'd accomplishes this.\n */",
      "file" : "colorcontent.c"
   },
   {
      "function" : "getRGBFromOctcube",
      "comment" : "/*!\n *  getRGBFromOctcube()\n *\n *      Input:  octcube index\n *              level (at which index is expressed)\n *              &rval  (<return> r val of this cube)\n *              &gval  (<return> g val of this cube)\n *              &bval  (<return> b val of this cube)\n *      Return: void\n *\n *  Notes:\n *      (1) We can consider all octcube indices to represent a\n *          specific point in color space: namely, the location\n *          of the 'upper-left' corner of the cube, where indices\n *          increase down and to the right.  The upper left corner\n *          of the color space is then 00000....\n *      (2) The 'rgbindex' is a 24-bit representation of the location,\n *          in octcube notation, at the center of the octcube.\n *          To get to the center of an octcube, you choose the 111\n *          octcube at the next lower level.\n *      (3) For example, if the octcube index = 110101 (binary),\n *          which is a level 2 expression, then the rgbindex\n *          is the 24-bit representation of 110101111 (at level 3);\n *          namely, 000110101111000000000000.  The number is padded\n *          with 3 leading 0s (because the representation uses\n *          only 21 bits) and 12 trailing 0s (the default for\n *          levels 4-7, which are contained within each of the level3\n *          octcubes.  Then the rgb values for the center of the\n *          octcube are: rval = 11100000, gval = 10100000, bval = 01100000\n */",
      "file" : "colorquant1.c"
   },
   {
      "function" : "getResA4Page",
      "comment" : "/*!\n *  getResA4Page()\n *\n *      Input:  w (image width, pixels)\n *              h (image height, pixels)\n *              fillfract (fraction in linear dimension of full page, not\n *                        to be exceeded; use 0 for default)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "getResLetterPage",
      "comment" : "/*!\n *  getResLetterPage()\n *\n *      Input:  w (image width, pixels)\n *              h (image height, pixels)\n *              fillfract (fraction in linear dimension of full page, not\n *                         to be exceeded; use 0 for default)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "getRootNameFromArgv0",
      "comment" : "/*!\n *  getRootNameFromArgv0()\n *\n *      Input:  argv0\n *      Return: root name (without the '_reg'), or null on error\n *\n *  Notes:\n *      (1) For example, from psioseg_reg, we want to extract\n *          just 'psioseg' as the root.\n *      (2) In unix with autotools, the executable is not X,\n *          but ./.libs/lt-X.   So in addition to stripping out the\n *          last 4 characters of the tail, we have to check for\n *          the '-' and strip out the \"lt-\" prefix if we find it.\n */",
      "file" : "regutils.c"
   },
   {
      "function" : "getScaledParametersPS",
      "comment" : "/*!\n *  getScaledParametersPS()\n *\n *      Input:  box (<optional> location of image in mils; with\n *                   (x,y) being the LL corner)\n *              wpix (pix width in pixels)\n *              hpix (pix height in pixels)\n *              res (of printer; use 0 for default)\n *              scale (use 1.0 or 0.0 for no scaling)\n *              &xpt (location of llx in pts)\n *              &ypt (location of lly in pts)\n *              &wpt (image width in pts)\n *              &hpt (image height in pts)\n *      Return: void (no arg checking)\n *\n *  Notes:\n *      (1) The image is always scaled, depending on res and scale.\n *      (2) If no box, the image is centered on the page.\n *      (3) If there is a box, the image is placed within it.\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "getSinFromLUT",
      "comment" : "/*!\n *  applyWarpTransformLUT()\n *\n *  Notes:\n *      (1) Uses an LUT for computing sin(theta).  There is little speed\n *          advantage to using the LUT.\n */",
      "file" : "warper.c"
   },
   {
      "function" : "getSortedPathnamesInDirectory",
      "comment" : "/*!\n *  getSortedPathnamesInDirectory()\n *\n *      Input:  directory name\n *              substr (<optional> substring filter on filenames; can be NULL)\n *              first (0-based)\n *              nfiles (use 0 for all to the end)\n *      Return: sarray of sorted pathnames, or NULL on error\n *\n *  Notes:\n *      (1) Use @substr to filter filenames in the directory.  If\n *          @substr == NULL, this takes all files.\n *      (2) The files in the directory, after optional filtering by\n *          the substring, are lexically sorted in increasing order.\n *          Use @first and @nfiles to select a contiguous set of files.\n *      (3) The full pathnames are returned for the requested sequence.\n *          If no files are found after filtering, returns an empty sarray.\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "getTiffCompressedFormat",
      "comment" : "/*!\n *  getTiffCompressedFormat()\n *\n *      Input:  tiffcomp (defined in tiff.h)\n *      Return: compression format (defined in imageio.h)\n *\n *  Notes:\n *      (1) The input must be the actual tiff compression type\n *          returned by a tiff library call.  It should always be\n *          a valid tiff type.\n *      (2) The return type is defined in the enum in imageio.h.\n */",
      "file" : "tiffio.c"
   },
   {
      "function" : "getTiffResolution",
      "comment" : "/*\n *  getTiffResolution()\n *\n *      Input:  stream (opened for read)\n *              &xres, &yres (<return> resolution in ppi)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) If neither resolution field is set, this is not an error;\n *          the returned resolution values are 0 (designating 'unknown').\n */",
      "file" : "tiffio.c"
   },
   {
      "function" : "getTiffStreamResolution",
      "comment" : "/*\n *  getTiffStreamResolution()\n *\n *      Input:  tiff stream (opened for read)\n *              &xres, &yres (<return> resolution in ppi)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) If neither resolution field is set, this is not an error;\n *          the returned resolution values are 0 (designating 'unknown').\n */",
      "file" : "tiffio.c"
   },
   {
      "function" : "getTwoByteParameter",
      "comment" : "/* skip repeated 0xff */",
      "file" : "jpegio.c"
   },
   {
      "function" : "gplotAddPlot",
      "comment" : "/*!\n *  gplotAddPlot()\n *\n *      Input:  gplot\n *              nax (<optional> numa: set to null for Y_VS_I;\n *                   required for Y_VS_X)\n *              nay (numa: required for both Y_VS_I and Y_VS_X)\n *              plotstyle (GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES,\n *                         GPLOT_LINESPOINTS, GPLOT_DOTS)\n *              plottitle  (<optional> title for individual plot)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) There are 2 options for (x,y) values:\n *            o  To plot an array vs the index, set nax = NULL.\n *            o  To plot one array vs another, use both nax and nay.\n *      (2) If nax is defined, it must be the same size as nay.\n *      (3) The 'plottitle' string can have spaces, double\n *          quotes and backquotes, but not single quotes.\n */",
      "file" : "gplot.c"
   },
   {
      "function" : "gplotCreate",
      "comment" : "/*!\n *  gplotCreate()\n *\n *      Input:  rootname (root for all output files)\n *              outformat (GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_X11,\n *                         GPLOT_LATEX)\n *              title  (<optional> overall title)\n *              xlabel (<optional> x axis label)\n *              ylabel (<optional> y axis label)\n *      Return: gplot, or null on error\n *\n *  Notes:\n *      (1) This initializes the plot.\n *      (2) The 'title', 'xlabel' and 'ylabel' strings can have spaces,\n *          double quotes and backquotes, but not single quotes.\n */",
      "file" : "gplot.c"
   },
   {
      "function" : "gplotDestroy",
      "comment" : "/*!\n *   gplotDestroy()\n *\n *        Input: &gplot (<to be nulled>)\n *        Return: void\n */",
      "file" : "gplot.c"
   },
   {
      "function" : "gplotGenCommandFile",
      "comment" : "/*!\n *  gplotGenCommandFile()\n *\n *      Input:  gplot\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "gplot.c"
   },
   {
      "function" : "gplotGenDataFiles",
      "comment" : "/*!\n *  gplotGenDataFiles()\n *\n *      Input:  gplot\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "gplot.c"
   },
   {
      "function" : "gplotMakeOutput",
      "comment" : "/*!\n *  gplotMakeOutput()\n *\n *      Input:  gplot\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This uses gplot and the new arrays to add a plot\n *          to the output, by writing a new data file and appending\n *          the appropriate plot commands to the command file.\n *      (2) The gnuplot program for windows is wgnuplot.exe.  The\n *          standard gp426win32 distribution does not have a X11 terminal.\n */",
      "file" : "gplot.c"
   },
   {
      "function" : "gplotRead",
      "comment" : "/*!\n *  gplotRead()\n *\n *      Input:  filename\n *      Return: gplot, or NULL on error\n */",
      "file" : "gplot.c"
   },
   {
      "function" : "gplotSetScaling",
      "comment" : "/*!\n *  gplotSetScaling()\n *\n *      Input:  gplot\n *              scaling (GPLOT_LINEAR_SCALE, GPLOT_LOG_SCALE_X,\n *                       GPLOT_LOG_SCALE_Y, GPLOT_LOG_SCALE_X_Y)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) By default, the x and y axis scaling is linear.\n *      (2) Call this function to set semi-log or log-log scaling.\n */",
      "file" : "gplot.c"
   },
   {
      "function" : "gplotSimple1",
      "comment" : "/*!\n *  gplotSimple1()\n *\n *      Input:  na (numa; plot Y_VS_I)\n *              outformat (GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_X11,\n *                         GPLOT_LATEX)\n *              outroot (root of output files)\n *              title  (<optional>, can be NULL)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This gives a line plot of a numa, where the array value\n *          is plotted vs the array index.  The plot is generated\n *          in the specified output format; the title  is optional.\n *      (2) When calling this function more than once, be sure the\n *          outroot strings are different; otherwise, you will\n *          overwrite the output files.\n */",
      "file" : "gplot.c"
   },
   {
      "function" : "gplotSimple2",
      "comment" : "/*!\n *  gplotSimple2()\n *\n *      Input:  na1 (numa; we plot Y_VS_I)\n *              na2 (ditto)\n *              outformat (GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_X11,\n *                         GPLOT_LATEX)\n *              outroot (root of output files)\n *              title  (<optional>)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This gives a line plot of two numa, where the array values\n *          are each plotted vs the array index.  The plot is generated\n *          in the specified output format; the title  is optional.\n *      (2) When calling this function more than once, be sure the\n *          outroot strings are different; otherwise, you will\n *          overwrite the output files.\n */",
      "file" : "gplot.c"
   },
   {
      "function" : "gplotSimpleN",
      "comment" : "/*!\n *  gplotSimpleN()\n *\n *      Input:  naa (numaa; we plot Y_VS_I for each numa)\n *              outformat (GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_X11,\n *                         GPLOT_LATEX)\n *              outroot (root of output files)\n *              title (<optional>)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This gives a line plot of all numas in a numaa (array of numa),\n *          where the array values are each plotted vs the array index.\n *          The plot is generated in the specified output format;\n *          the title  is optional.\n *      (2) When calling this function more than once, be sure the\n *          outroot strings are different; otherwise, you will\n *          overwrite the output files.\n */",
      "file" : "gplot.c"
   },
   {
      "function" : "gplotWrite",
      "comment" : "/*!\n *  gplotWrite()\n *\n *      Input:  filename\n *              gplot\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "gplot.c"
   },
   {
      "function" : "iaaGetLinearTRC",
      "comment" : "/*!\n *  iaaGetLinearTRC()\n *\n *      Input:  iaa (bare array of ptrs to l_int32)\n *              diff (between min and max pixel values that are\n *                    to be mapped to 0 and 255)\n *      Return: ia (LUT with input (val - minval) and output a\n *                  value between 0 and 255)\n */",
      "file" : "adaptmap.c"
   },
   {
      "function" : "identifyWatershedBasin",
      "comment" : "/*!\n *  identifyWatershedBasin()\n *\n *      Input:  wshed\n *              index (index of basin to be located)\n *              level (of basin at point at which the two basins met)\n *              &box (<return> bounding box of basin)\n *              &pixd (<return> pix of basin, cropped to its bounding box)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is a static function, so we assume pixlab, pixs and pixt\n *          exist and are the same size.\n *      (2) It selects all pixels that have the label @index in pixlab\n *          and that have a value in pixs that is less than @level.\n *      (3) It is used whenever two seeded basins meet (typically at a saddle),\n *          or when one seeded basin meets a 'filler'.  All identified\n *          basins are saved as a watershed.\n */",
      "file" : "watershed.c"
   },
   {
      "function" : "ioFormatTest",
      "comment" : "/*!\n *  ioFormatTest()\n *\n *      Input:  filename (input file)\n *      Return: 0 if OK; 1 on error or if the test fails\n *\n *  Notes:\n *      (1) This writes and reads a set of output files losslessly\n *          in different formats to /tmp, and tests that the\n *          result before and after is unchanged.\n *      (2) This should work properly on input images of any depth,\n *          with and without colormaps.\n *      (3) All supported formats are tested for bmp, png, tiff and\n *          non-ascii pnm.  Ascii pnm also works (but who'd ever want\n *          to use it?)   We allow 2 bpp bmp, although it's not\n *          supported elsewhere.  And we don't support reading\n *          16 bpp png, although this can be turned on in pngio.c.\n *      (4) This silently skips png or tiff testing if HAVE_LIBPNG\n *          or HAVE_LIBTIFF are 0, respectively.\n */",
      "file" : "readfile.c"
   },
   {
      "function" : "jbAccumulateComposites",
      "comment" : "/*!\n *  jbAccumulateComposites()\n *\n *      Input:  pixaa (one pixa for each class)\n *              &pna (<return> number of samples used to build each composite)\n *              &ptat (<return> centroids of bordered composites)\n *      Return: pixad (accumulated sum of samples in each class),\n *                     or null on error\n *\n */",
      "file" : "jbclass.c"
   },
   {
      "function" : "jbAddPage",
      "comment" : "/*!\n *  jbAddPage()\n *\n *      Input:  jbclasser\n *              pixs (of input page)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "jbclass.c"
   },
   {
      "function" : "jbAddPageComponents",
      "comment" : "/*!\n *  jbAddPageComponents()\n *\n *      Input:  jbclasser\n *              pixs (of input page)\n *              boxas (b.b. of components for this page)\n *              pixas (components for this page)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) If there are no components on the page, we don't require input\n *          of empty boxas or pixas, although that's the typical situation.\n */",
      "file" : "jbclass.c"
   },
   {
      "function" : "jbAddPages",
      "comment" : "/*!\n *  jbAddPages()\n *\n *      Input:  jbclasser\n *              safiles (of page image file names)\n *      Return: 0 if OK; 1 on error\n *\n *  Note:\n *      (1) jbclasser makes a copy of the array of file names.\n *      (2) The caller is still responsible for destroying the input array.\n */",
      "file" : "jbclass.c"
   },
   {
      "function" : "jbClasserCreate",
      "comment" : "/*!\n *  jbClasserCreate()\n *\n *      Input:  method (JB_RANKHAUS, JB_CORRELATION)\n *              components (JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS)\n *      Return: jbclasser, or null on error\n */",
      "file" : "jbclass.c"
   },
   {
      "function" : "jbClasserDestroy",
      "comment" : "/*\n *  jbClasserDestroy()\n *\n *      Input: &classer (<to be nulled>)\n *      Return: void\n */",
      "file" : "jbclass.c"
   },
   {
      "function" : "jbClassifyCorrelation",
      "comment" : "/*!\n *  jbClassifyCorrelation()\n *\n *      Input:  jbclasser\n *              boxa (of new components for classification)\n *              pixas (of new components for classification)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "jbclass.c"
   },
   {
      "function" : "jbClassifyRankHaus",
      "comment" : "/*!\n *  jbClassifyRankHaus()\n *\n *      Input:  jbclasser\n *              boxa (of new components for classification)\n *              pixas (of new components for classification)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "jbclass.c"
   },
   {
      "function" : "jbCorrelation",
      "comment" : "/*!\n *  jbCorrelation()\n *\n *       Input:  dirin (directory of input images)\n *               thresh (typically ~0.8)\n *               weight (typically ~0.6)\n *               components (JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS)\n *               rootname (for output files)\n *               firstpage (0-based)\n *               npages (use 0 for all pages in dirin)\n *               renderflag (1 to render from templates; 0 to skip)\n *       Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The images must be 1 bpp.  If they are not, you can convert\n *          them using convertFilesTo1bpp().\n *      (2) See prog/jbcorrelation for generating more output (e.g.,\n *          for debugging)\n */",
      "file" : "classapp.c"
   },
   {
      "function" : "jbCorrelationInit",
      "comment" : "/*!\n *  jbCorrelationInit()\n *\n *      Input:  components (JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS)\n *              maxwidth (of component; use 0 for default)\n *              maxheight (of component; use 0 for default)\n *              thresh (value for correlation score: in [0.4 - 0.98])\n *              weightfactor (corrects thresh for thick characters [0.0 - 1.0])\n *      Return: jbclasser if OK; NULL on error\n *\n *  Notes:\n *      (1) For scanned text, suggested input values are:\n *            thresh ~ [0.8 - 0.85]\n *            weightfactor ~ [0.5 - 0.6]\n *      (2) For electronically generated fonts (e.g., rasterized pdf),\n *          a very high thresh (e.g., 0.95) will not cause a significant\n *          increase in the number of classes.\n */",
      "file" : "jbclass.c"
   },
   {
      "function" : "jbCorrelationInitInternal",
      "comment" : "/*!\n *  jbCorrelationInitWithoutComponents()\n *\n *      Input:  same as jbCorrelationInit\n *      Output: same as jbCorrelationInit\n *\n *  Note: acts the same as jbCorrelationInit(), but the resulting\n *        object doesn't keep a list of all the components.\n */",
      "file" : "jbclass.c"
   },
   {
      "function" : "jbCorrelationInitWithoutComponents",
      "comment" : "/*!\n *  jbCorrelationInitWithoutComponents()\n *\n *      Input:  same as jbCorrelationInit\n *      Output: same as jbCorrelationInit\n *\n *  Note: acts the same as jbCorrelationInit(), but the resulting\n *        object doesn't keep a list of all the components.\n */",
      "file" : "jbclass.c"
   },
   {
      "function" : "jbDataDestroy",
      "comment" : "/*\n *  jbDataDestroy()\n *\n *      Input: &data (<to be nulled>)\n *      Return: void\n */",
      "file" : "jbclass.c"
   },
   {
      "function" : "jbDataRead",
      "comment" : "/*!\n *  jbDataRead()\n *\n *      Input:  rootname (for template and data files)\n *      Return: jbdata, or NULL on error\n */",
      "file" : "jbclass.c"
   },
   {
      "function" : "jbDataRender",
      "comment" : "/*!\n *  jbDataRender()\n *\n *      Input:  jbdata\n *              debugflag (if TRUE, writes into 2 bpp pix and adds\n *                         component outlines in color)\n *      Return: pixa (reconstruction of original images, using templates) or\n *              null on error\n */",
      "file" : "jbclass.c"
   },
   {
      "function" : "jbDataSave",
      "comment" : "/*!\n *  jbDataSave()\n *\n *      Input:  jbclasser\n *              latticew, latticeh (cell size used to store each\n *                  connected component in the composite)\n *      Return: jbdata, or null on error\n *\n *  Notes:\n *      (1) This routine stores the jbig2-type data required for\n *          generating a lossy jbig2 version of the image.\n *          It can be losslessly written to (and read from) two files.\n *      (2) It generates and stores the mosaic of templates.\n *      (3) It clones the Numa and Pta arrays, so these must all\n *          be destroyed by the caller.\n *      (4) Input 0 to use the default values for latticew and/or latticeh,\n */",
      "file" : "jbclass.c"
   },
   {
      "function" : "jbDataWrite",
      "comment" : "/*!\n *  jbDataWrite()\n *\n *      Input:  rootname (for output files; everything but the extension)\n *              jbdata\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Serialization function that writes data in jbdata to file.\n */",
      "file" : "jbclass.c"
   },
   {
      "function" : "jbGetComponents",
      "comment" : "/*!\n *  jbGetComponents()\n *\n *      Input:  pixs (1 bpp)\n *              components (JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS)\n *              maxwidth, maxheight (of saved components; larger are discarded)\n *              &pboxa (<return> b.b. of component items)\n *              &ppixa (<return> component items)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "jbclass.c"
   },
   {
      "function" : "jbGetLLCorners",
      "comment" : "/*!\n *  jbGetLLCorners()\n *\n *      Input:  jbclasser\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This computes the ptall field, which has the global LL corners,\n *          adjusted for each specific component, so that each component\n *          can be replaced by the template for its class and have the\n *          centroid in the template in the same position as the\n *          centroid of the original connected component. It is important\n *          that this be done properly to avoid a wavy baseline in the result.\n *      (2) It is computed here from the corresponding UL corners, where\n *          the input templates and stored instances are all bordered.\n *          This should be done after all pages have been processed.\n *      (3) For proper substitution, the templates whose LL corners are\n *          placed in these locations must be UN-bordered.\n *          This is available for a realistic jbig2 encoder, which would\n *          (1) encode each template without a border, and (2) encode\n *          the position using the LL corner (rather than the UL\n *          corner) because the difference between y-values\n *          of successive instances is typically close to zero.\n */",
      "file" : "jbclass.c"
   },
   {
      "function" : "jbGetULCorners",
      "comment" : "/*!\n *  jbGetULCorners()\n *\n *      Input:  jbclasser\n *              pixs (full res image)\n *              boxa (of c.c. bounding rectangles for this page)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This computes the ptaul field, which has the global UL corners,\n *          adjusted for each specific component, so that each component\n *          can be replaced by the template for its class and have the\n *          centroid in the template in the same position as the\n *          centroid of the original connected component.  It is important\n *          that this be done properly to avoid a wavy baseline in the\n *          result.\n *      (2) The array fields ptac and ptact give the centroids of\n *          those components relative to the UL corner of each component.\n *          Here, we compute the difference in each component, round to\n *          nearest integer, and correct the box->x and box->y by\n *          the appropriate integral difference.\n *      (3) The templates and stored instances are all bordered.\n */",
      "file" : "jbclass.c"
   },
   {
      "function" : "jbRankHaus",
      "comment" : "/*!\n *  jbRankHaus()\n *\n *       Input:  dirin (directory of input images)\n *               size (of Sel used for dilation; typ. 2)\n *               rank (rank value of match; typ. 0.97)\n *               components (JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS)\n *               rootname (for output files)\n *               firstpage (0-based)\n *               npages (use 0 for all pages in dirin)\n *               renderflag (1 to render from templates; 0 to skip)\n *       Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) See prog/jbrankhaus for generating more output (e.g.,\n *          for debugging)\n */",
      "file" : "classapp.c"
   },
   {
      "function" : "jbRankHausInit",
      "comment" : "/*!\n *  jbRankHausInit()\n *\n *      Input:  components (JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS)\n *              maxwidth (of component; use 0 for default)\n *              maxheight (of component; use 0 for default)\n *              size  (of square structuring element; 2, representing\n *                     2x2 sel, is necessary for reasonable accuracy of\n *                     small components; combine this with rank ~ 0.97\n *                     to avoid undue class expansion)\n *              rank (rank val of match, each way; in [0.5 - 1.0];\n *                    when using size = 2, 0.97 is a reasonable value)\n *      Return: jbclasser if OK; NULL on error\n */",
      "file" : "jbclass.c"
   },
   {
      "function" : "jbTemplatesFromComposites",
      "comment" : "/*!\n *  jbTemplatesFromComposites()\n *\n *      Input:  pixac (one pix of composites for each class)\n *              na (number of samples used for each class composite)\n *      Return: pixad (8 bpp templates for each class), or null on error\n *\n */",
      "file" : "jbclass.c"
   },
   {
      "function" : "jbWordsInTextlines",
      "comment" : "/*!\n *  jbWordsInTextlines()\n *\n *      Input:  dirin (directory of input pages)\n *              reduction (1 for full res; 2 for half-res)\n *              maxwidth (of word mask components, to be kept)\n *              maxheight (of word mask components, to be kept)\n *              thresh (on correlation; 0.80 is reasonable)\n *              weight (for handling thick text; 0.6 is reasonable)\n *              natl (<return> numa with textline index for each component)\n *              firstpage (0-based)\n *              npages (use 0 for all pages in dirin)\n *      Return: classer (for the set of pages)\n *\n *  Notes:\n *      (1) This is a high-level function.  See prog/jbwords for example\n *          of usage.\n *      (2) Typically, words can be found reasonably well at a resolution\n *          of about 150 ppi.  For highest accuracy, you should use 300 ppi.\n *          Assuming that the input images are 300 ppi, use reduction = 1\n *          for finding words at full res, and reduction = 2 for finding\n *          them at 150 ppi.\n */",
      "file" : "classapp.c"
   },
   {
      "function" : "jpeg_comment_callback",
      "comment" : "/*!\n *  jpeg_comment_callback()\n *\n *  Notes:\n *      (1) This is used to read the jpeg comment (JPEG_COM).\n *          See the note above the declaration for why it returns\n *          a \"boolean\".\n */",
      "file" : "jpegio.c"
   },
   {
      "function" : "jpeg_error_catch_all_1",
      "comment" : "/*!\n *  jpeg_error_catch_all_1()\n *\n *  Notes:\n *      (1) The default jpeg error_exit() kills the process, but we\n *          never want a call to leptonica to kill a process.  If you\n *          do want this behavior, remove the calls to these error handlers.\n *      (2) This is used where cinfo->client_data holds only jmpbuf.\n */",
      "file" : "jpegio.c"
   },
   {
      "function" : "jpeg_error_catch_all_2",
      "comment" : "/*!\n *  jpeg_error_catch_all_2()\n *\n *  Notes:\n *      (1) This is used where cinfo->client_data needs to hold both\n *          the jmpbuf and the jpeg comment data.\n *      (2) On error, the comment data will be freed by the caller.\n */",
      "file" : "jpegio.c"
   },
   {
      "function" : "jpeg_getc",
      "comment" : "/* This function was borrowed from libjpeg */",
      "file" : "jpegio.c"
   },
   {
      "function" : "kernelCopy",
      "comment" : "/*!\n *  kernelCopy()\n *\n *      Input:  kels (source kernel)\n *      Return: keld (copy of kels), or null on error\n */",
      "file" : "kernel.c"
   },
   {
      "function" : "kernelCreate",
      "comment" : "/*!\n *  kernelCreate()\n *\n *      Input:  height, width\n *      Return: kernel, or null on error\n *\n *  Notes:\n *      (1) kernelCreate() initializes all values to 0.\n *      (2) After this call, (cy,cx) and nonzero data values must be\n *          assigned.\n */",
      "file" : "kernel.c"
   },
   {
      "function" : "kernelCreateFromFile",
      "comment" : "/*!\n *  kernelCreateFromFile()\n *\n *      Input:  filename\n *      Return: kernel, or null on error\n *\n *  Notes:\n *      (1) The file contains, in the following order:\n *           - Any number of comment lines starting with '#' are ignored\n *           - The height and width of the kernel\n *           - The y and x values of the kernel origin\n *           - The kernel data, formatted as lines of numbers (integers\n *             or floats) for the kernel values in row-major order,\n *             and with no other punctuation.\n *             (Note: this differs from kernelCreateFromString(),\n *             where each line must begin and end with a double-quote\n *             to tell the compiler it's part of a string.)\n *           - The kernel specification ends when a blank line,\n *             a comment line, or the end of file is reached.\n *      (2) All lines must be left-justified.\n *      (3) See kernelCreateFromString() for a description of the string\n *          format for the kernel data.  As an example, here are the lines\n *          of a valid kernel description file  In the file, all lines\n *          are left-justified:\n *                    # small 3x3 kernel\n *                    3 3\n *                    1 1\n *                    25.5   51    24.3\n *                    70.2  146.3  73.4\n *                    20     50.9  18.4\n */",
      "file" : "kernel.c"
   },
   {
      "function" : "kernelCreateFromPix",
      "comment" : "/*!\n *  kernelCreateFromPix()\n *\n *      Input:  pix\n *              cy, cx (origin of kernel)\n *      Return: kernel, or null on error\n *\n *  Notes:\n *      (1) The origin must be positive and within the dimensions of the pix.\n */",
      "file" : "kernel.c"
   },
   {
      "function" : "kernelCreateFromString",
      "comment" : "/*!\n *  kernelCreateFromString()\n *\n *      Input:  height, width\n *              cy, cx   (origin)\n *              kdata\n *      Return: kernel of the given size, or null on error\n *\n *  Notes:\n *      (1) The data is an array of chars, in row-major order, giving\n *          space separated integers in the range [-255 ... 255].\n *      (2) The only other formatting limitation is that you must\n *          leave space between the last number in each row and\n *          the double-quote.  If possible, it's also nice to have each\n *          line in the string represent a line in the kernel; e.g.,\n *              static const char *kdata =\n *                  \" 20   50   20 \"\n *                  \" 70  140   70 \"\n *                  \" 20   50   20 \";\n */",
      "file" : "kernel.c"
   },
   {
      "function" : "kernelDestroy",
      "comment" : "/*!\n *  kernelDestroy()\n *\n *      Input:  &kel (<to be nulled>)\n *      Return: void\n */",
      "file" : "kernel.c"
   },
   {
      "function" : "kernelDisplayInPix",
      "comment" : "/*!\n *  kernelDisplayInPix()\n *\n *      Input:  kernel\n *              size (of grid interiors; odd; either 1 or a minimum size\n *                    of 17 is enforced)\n *              gthick (grid thickness; either 0 or a minimum size of 2\n *                      is enforced)\n *      Return: pix (display of kernel), or null on error\n *\n *  Notes:\n *      (1) This gives a visual representation of a kernel.\n *      (2) There are two modes of display:\n *          (a) Grid lines of minimum width 2, surrounding regions\n *              representing kernel elements of minimum size 17,\n *              with a \"plus\" mark at the kernel origin, or\n *          (b) A pix without grid lines and using 1 pixel per kernel element.\n *      (3) For both cases, the kernel absolute value is displayed,\n *          normalized such that the maximum absolute value is 255.\n *      (4) Large 2D separable kernels should be used for convolution\n *          with two 1D kernels.  However, for the bilateral filter,\n *          the computation time is independent of the size of the\n *          2D content kernel.\n */",
      "file" : "kernel.c"
   },
   {
      "function" : "kernelGetElement",
      "comment" : "/*!\n *  kernelGetElement()\n *\n *      Input:  kel\n *              row\n *              col\n *              &val\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "kernel.c"
   },
   {
      "function" : "kernelGetMinMax",
      "comment" : "/*!\n *  kernelGetMinMax()\n *\n *      Input:  kernel\n *              &min (<optional return> minimum value)\n *              &max (<optional return> maximum value)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "kernel.c"
   },
   {
      "function" : "kernelGetParameters",
      "comment" : "/*!\n *  kernelGetParameters()\n *\n *      Input:  kernel\n *              &sy, &sx, &cy, &cx (<optional return>; each can be null)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "kernel.c"
   },
   {
      "function" : "kernelGetSum",
      "comment" : "/*!\n *  kernelGetSum()\n *\n *      Input:  kernel\n *              &sum (<return> sum of all kernel values)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "kernel.c"
   },
   {
      "function" : "kernelInvert",
      "comment" : "/*!\n *  kernelInvert()\n *\n *      Input:  kels (source kel, to be inverted)\n *      Return: keld (spatially inverted, about the origin), or null on error\n *\n *  Notes:\n *      (1) For convolution, the kernel is spatially inverted before\n *          a \"correlation\" operation is done between the kernel and the image.\n */",
      "file" : "kernel.c"
   },
   {
      "function" : "kernelNormalize",
      "comment" : "/*!\n *  kernelNormalize()\n *\n *      Input:  kels (source kel, to be normalized)\n *              normsum (desired sum of elements in keld)\n *      Return: keld (normalized version of kels), or null on error\n *                   or if sum of elements is very close to 0)\n *\n *  Notes:\n *      (1) If the sum of kernel elements is close to 0, do not\n *          try to calculate the normalized kernel.  Instead,\n *          return a copy of the input kernel, with a warning.\n */",
      "file" : "kernel.c"
   },
   {
      "function" : "kernelRead",
      "comment" : "/*!\n *  kernelRead()\n *\n *      Input:  filename\n *      Return: kernel, or null on error\n */",
      "file" : "kernel.c"
   },
   {
      "function" : "kernelReadStream",
      "comment" : "/*!\n *  kernelReadStream()\n *\n *      Input:  stream\n *      Return: kernel, or null on error\n */",
      "file" : "kernel.c"
   },
   {
      "function" : "kernelSetElement",
      "comment" : "/*!\n *  kernelSetElement()\n *\n *      Input:  kernel\n *              row\n *              col\n *              val\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "kernel.c"
   },
   {
      "function" : "kernelSetOrigin",
      "comment" : "/*!\n *  kernelSetOrigin()\n *\n *      Input:  kernel\n *              cy, cx\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "kernel.c"
   },
   {
      "function" : "kernelWrite",
      "comment" : "/*!\n *  kernelWrite()\n *\n *      Input:  fname (output file)\n *              kernel\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "kernel.c"
   },
   {
      "function" : "kernelWriteStream",
      "comment" : "/*!\n *  kernelWriteStream()\n *\n *      Input:  stream\n *              kel\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "kernel.c"
   },
   {
      "function" : "l_angleBetweenVectors",
      "comment" : "/*!\n *  l_angleBetweenVectors()\n *\n *      Input:  x1, y1 (end point of first vector)\n *              x2, y2 (end point of second vector)\n *      Return: angle (radians), or 0.0 on error\n *\n *  Notes:\n *      (1) This gives the angle between two vectors, going between\n *          vector1 (x1,y1) and vector2 (x2,y2).  The angle is swept\n *          out from 1 --> 2.  If this is clockwise, the angle is\n *          positive, but the result is folded into the interval [-pi, pi].\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "l_binaryCopy",
      "comment" : "/*!\n *  l_binaryCopy()\n *\n *      Input:  datas\n *              size (of data array)\n *      Return: datad (on heap), or null on error\n *\n *  Notes:\n *      (1) We add 4 bytes to the zeroed output because in some cases\n *          (e.g., string handling) it is important to have the data\n *          be null terminated.  This guarantees that after the memcpy,\n *          the result is automatically null terminated.\n */",
      "file" : "utils.c"
   },
   {
      "function" : "l_binaryRead",
      "comment" : "/*!\n *  l_binaryRead()\n *\n *      Input:  filename\n *              &nbytes (<return> number of bytes read)\n *      Return: data, or null on error\n */",
      "file" : "utils.c"
   },
   {
      "function" : "l_binaryReadStream",
      "comment" : "/*!\n *  l_binaryReadStream()\n *\n *      Input:  stream\n *              &nbytes (<return> number of bytes read)\n *      Return: null-terminated array, or null on error\n *              (reading 0 bytes is not an error)\n *\n *  Notes:\n *      (1) The returned array is terminated with a null byte so that\n *          it can be used to read ascii data into a proper C string.\n *      (2) Side effect: this re-positions the stream ptr to the\n *          beginning of the file.\n */",
      "file" : "utils.c"
   },
   {
      "function" : "l_binaryWrite",
      "comment" : "/*!\n *  l_binaryWrite()\n *\n *      Input:  filename (output)\n *              operation  (\"w\" for write; \"a\" for append)\n *              data  (binary data to be written)\n *              nbytes  (size of data array)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "utils.c"
   },
   {
      "function" : "l_byteaAppendData",
      "comment" : "/*!\n *  l_byteaAppendData()\n *\n *      Input:  ba\n *              newdata (byte array to be appended)\n *              size (size of data array)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "bytearray.c"
   },
   {
      "function" : "l_byteaAppendString",
      "comment" : "/*!\n *  l_byteaAppendString()\n *\n *      Input:  ba\n *              str (null-terminated string to be appended)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "bytearray.c"
   },
   {
      "function" : "l_byteaCopy",
      "comment" : "/*!\n *  l_byteaCopy()\n *\n *      Input:  bas  (source lba)\n *              copyflag (L_COPY, L_CLONE)\n *      Return: clone or copy of bas, or null on error\n *\n *  Notes:\n *      (1) If cloning, up the refcount and return a ptr to @bas.\n */",
      "file" : "bytearray.c"
   },
   {
      "function" : "l_byteaCopyData",
      "comment" : "/*!\n *  l_byteaCopyData()\n *\n *      Input:  ba\n *              &size (<returned> size of data in lba)\n *      Return: copy of data in use in the data array, or null on error.\n *\n *  Notes:\n *      (1) The returned data is owned by the caller.  The input @ba\n *          still owns the original data array.\n */",
      "file" : "bytearray.c"
   },
   {
      "function" : "l_byteaCreate",
      "comment" : "/*!\n *  l_byteaCreate()\n *\n *      Input:  n (determines initial size of data array)\n *      Return: l_bytea, or null on error\n *\n *  Notes:\n *      (1) The allocated array is n + 1 bytes.  This allows room\n *          for null termination.\n */",
      "file" : "bytearray.c"
   },
   {
      "function" : "l_byteaDestroy",
      "comment" : "/*!\n *  l_byteaDestroy()\n *\n *      Input:  &ba (<will be set to null before returning>)\n *      Return: void\n *\n *  Notes:\n *      (1) Decrements the ref count and, if 0, destroys the lba.\n *      (2) Always nulls the input ptr.\n *      (3) If the data has been previously removed, the lba will\n *          have been nulled, so this will do nothing.\n */",
      "file" : "bytearray.c"
   },
   {
      "function" : "l_byteaExtendArrayToSize",
      "comment" : "/*!\n *  l_byteaExtendArrayToSize()\n *\n *      Input:  ba\n *              size (new size of lba data array)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "bytearray.c"
   },
   {
      "function" : "l_byteaFindEachSequence",
      "comment" : "/*!\n *  l_byteaFindEachSequence()\n *\n *      Input:  ba\n *              sequence (subarray of bytes to find in data)\n *              seqlen (length of sequence, in bytes)\n *              &da (<return> byte positions of each occurrence of @sequence)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "bytearray.c"
   },
   {
      "function" : "l_byteaGetData",
      "comment" : "/*!\n *  l_byteaGetData()\n *\n *      Input:  ba\n *              &size (<returned> size of data in lba)\n *      Return: ptr to existing data array, or NULL on error\n *\n *  Notes:\n *      (1) The returned ptr is owned by @ba.  Do not free it!\n */",
      "file" : "bytearray.c"
   },
   {
      "function" : "l_byteaGetSize",
      "comment" : "/*!\n *  l_byteaGetSize()\n *\n *      Input:  ba\n *      Return: size of stored byte array, or 0 on error\n */",
      "file" : "bytearray.c"
   },
   {
      "function" : "l_byteaInitFromFile",
      "comment" : "/*!\n *  l_byteaInitFromFile()\n *\n *      Input:  fname\n *      Return: l_bytea, or null on error\n */",
      "file" : "bytearray.c"
   },
   {
      "function" : "l_byteaInitFromMem",
      "comment" : "/*!\n *  l_byteaInitFromMem()\n *\n *      Input:  data (to be copied to the array)\n *              size (amount of data)\n *      Return: l_bytea, or null on error\n */",
      "file" : "bytearray.c"
   },
   {
      "function" : "l_byteaInitFromStream",
      "comment" : "/*!\n *  l_byteaInitFromStream()\n *\n *      Input:  stream\n *      Return: l_bytea, or null on error\n */",
      "file" : "bytearray.c"
   },
   {
      "function" : "l_byteaJoin",
      "comment" : "/*!\n *  l_byteaJoin()\n *\n *      Input:  ba1\n *              &ba2 (data array is added to the one in ba1, and\n *                     then ba2 is destroyed)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) It is a no-op, not an error, for @ba2 to be null.\n */",
      "file" : "bytearray.c"
   },
   {
      "function" : "l_byteaSplit",
      "comment" : "/*!\n *  l_byteaSplit()\n *\n *      Input:  ba1 (lba to split; array bytes nulled beyond the split loc)\n *              splitloc (location in ba1 to split; ba2 begins there)\n *              &ba2 (<return> with data starting at splitloc)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "bytearray.c"
   },
   {
      "function" : "l_byteaWrite",
      "comment" : "/*!\n *  l_byteaWrite()\n *\n *      Input:  fname (output file)\n *              ba\n *              startloc (first byte to output)\n *              endloc (last byte to output; use 0 to write to the\n *                      end of the data array)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "bytearray.c"
   },
   {
      "function" : "l_byteaWriteStream",
      "comment" : "/*!\n *  l_byteaWriteStream()\n *\n *      Input:  stream (opened for binary write)\n *              ba\n *              startloc (first byte to output)\n *              endloc (last byte to output; use 0 to write to the\n *                      end of the data array)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "bytearray.c"
   },
   {
      "function" : "l_charToString",
      "comment" : "/*------------------------------------------------------------------------*\n *                             Static helpers                             *\n *------------------------------------------------------------------------*/",
      "file" : "recogtrain.c"
   },
   {
      "function" : "l_chooseDisplayProg",
      "comment" : "/*!\n *  pixSaveTiledWithText()\n *\n *      Input:  pixs (1, 2, 4, 8, 32 bpp)\n *              pixa (the pix are accumulated here; as 32 bpp)\n *              outwidth (in pixels; use 0 to disable entirely)\n *              newrow (1 to start a new row; 0 to go on same row as previous)\n *              space (horizontal and vertical spacing, in pixels)\n *              linewidth (width of added outline for image; 0 for no outline)\n *              bmf (<optional> font struct)\n *              textstr (<optional> text string to be added)\n *              val (color to set the text)\n *              location (L_ADD_ABOVE, L_ADD_AT_TOP, L_ADD_AT_BOT, L_ADD_BELOW)\n *      Return: 0 if OK, 1 on error.\n *\n *  Notes:\n *      (1) Before calling this function for the first time, use\n *          pixaCreate() to make the @pixa that will accumulate the pix.\n *          This is passed in each time pixSaveTiled() is called.\n *      (2) @outwidth is the scaled width.  After scaling, the image is\n *          saved in the input pixa, along with a box that specifies\n *          the location to place it when tiled later.  Disable saving\n *          the pix by setting @outwidth == 0.\n *      (3) @newrow and @space specify the location of the new pix\n *          with respect to the last one(s) that were entered.\n *      (4) All pix are saved as 32 bpp RGB.\n *      (5) If both @bmf and @textstr are defined, this generates a pix\n *          with the additional text; otherwise, no text is written.\n *      (6) The text is written before scaling, so it is properly\n *          antialiased in the scaled pix.  However, if the pix on\n *          different calls have different widths, the size of the\n *          text will vary.\n *      (7) See pixSaveTiledOutline() for other implementation details.\n */",
      "file" : "writefile.c"
   },
   {
      "function" : "l_clearDataBit",
      "comment" : "/*!\n *  l_clearDataBit()\n *\n *      Input:  line  (ptr to beginning of data line)\n *              n     (pixel index)\n *      Return: void\n *\n *  Action: sets the (1-bit) pixel to 0\n */",
      "file" : "arrayaccess.c"
   },
   {
      "function" : "l_clearDataDibit",
      "comment" : "/*!\n *  l_clearDataDibit()\n *\n *      Input:  line  (ptr to beginning of data line)\n *              n     (pixel index)\n *      Return: void\n *\n *  Action: sets the (2-bit) pixel to 0\n */",
      "file" : "arrayaccess.c"
   },
   {
      "function" : "l_clearDataQbit",
      "comment" : "/*!\n *  l_clearDataQbit()\n *\n *      Input:  line  (ptr to beginning of data line)\n *              n     (pixel index)\n *      Return: void\n *\n *  Action: sets the (4-bit) pixel to 0\n */",
      "file" : "arrayaccess.c"
   },
   {
      "function" : "l_compdataDestroy",
      "comment" : "/*!\n *  l_compdataDestroy()\n *\n *      Input:  &cid (<will be set to null before returning>)\n *      Return: void\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "l_convertCharstrToInt",
      "comment" : "/*!\n *  l_convertCharstrToInt()\n *\n *      Input:  str (input string representing one UTF-8 character;\n *                   not more than 4 bytes)\n *              &val (<return> integer value for the input.  Think of it\n *                    as a 1-to-1 hash code.)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "l_dnaAddNumber",
      "comment" : "/*!\n *  l_dnaAddNumber()\n *\n *      Input:  da\n *              val  (float or int to be added; stored as a float)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaChangeRefcount",
      "comment" : "/*!\n *  l_dnaChangeRefCount()\n *\n *      Input:  da\n *              delta (change to be applied)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaClone",
      "comment" : "/*!\n *  l_dnaClone()\n *\n *      Input:  da\n *      Return: ptr to same l_dna, or null on error\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaConvertToNuma",
      "comment" : "/*!\n *  l_dnaConvertToNuma()\n *\n *      Input:  da\n *      Return: na, or null on error\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaCopy",
      "comment" : "/*!\n *  l_dnaCopy()\n *\n *      Input:  da\n *      Return: copy of l_dna, or null on error\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaCopyParameters",
      "comment" : "/*!\n *  l_dnaCopyParameters()\n *\n *      Input:  dad (destination DNuma)\n *              das (source DNuma)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaCreate",
      "comment" : "/*!\n *  l_dnaCreate()\n *\n *      Input:  size of number array to be alloc'd (0 for default)\n *      Return: da, or null on error\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaCreateFromDArray",
      "comment" : "/*!\n *  l_dnaCreateFromDArray()\n *\n *      Input:  da (float)\n *              size (of the array)\n *              copyflag (L_INSERT or L_COPY)\n *      Return: da, or null on error\n *\n *  Notes:\n *      (1) With L_INSERT, ownership of the input array is transferred\n *          to the returned l_dna, and all @size elements are considered\n *          to be valid.\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaCreateFromIArray",
      "comment" : "/*!\n *  l_dnaCreateFromIArray()\n *\n *      Input:  iarray (integer)\n *              size (of the array)\n *      Return: da, or null on error\n *\n *  Notes:\n *      (1) We can't insert this int array into the l_dna, because a l_dna\n *          takes a double array.  So this just copies the data from the\n *          input array into the l_dna.  The input array continues to be\n *          owned by the caller.\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaDestroy",
      "comment" : "/*!\n *  l_dnaDestroy()\n *\n *      Input:  &da (<to be nulled if it exists>)\n *      Return: void\n *\n *  Notes:\n *      (1) Decrements the ref count and, if 0, destroys the l_dna.\n *      (2) Always nulls the input ptr.\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaEmpty",
      "comment" : "/*!\n *  l_dnaEmpty()\n *\n *      Input:  da\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This does not change the allocation of the array.\n *          It just clears the number of stored numbers, so that\n *          the array appears to be empty.\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaExtendArray",
      "comment" : "/*!\n *  l_dnaExtendArray()\n *\n *      Input:  da\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaGetCount",
      "comment" : "/*!\n *  l_dnaGetCount()\n *\n *      Input:  da\n *      Return: count, or 0 if no numbers or on error\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaGetDArray",
      "comment" : "/*!\n *  l_dnaGetDArray()\n *\n *      Input:  da\n *              copyflag (L_NOCOPY or L_COPY)\n *      Return: either the bare internal array or a copy of it,\n *              or null on error\n *\n *  Notes:\n *      (1) If copyflag == L_COPY, it makes a copy which the caller\n *          is responsible for freeing.  Otherwise, it operates\n *          directly on the bare array of the l_dna.\n *      (2) Very important: for L_NOCOPY, any writes to the array\n *          will be in the l_dna.  Do not write beyond the size of\n *          the count field, because it will not be accessable\n *          from the l_dna!  If necessary, be sure to set the count\n *          field to a larger number (such as the alloc size)\n *          BEFORE calling this function.  Creating with l_dnaMakeConstant()\n *          is another way to insure full initialization.\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaGetDValue",
      "comment" : "/*!\n *  l_dnaGetDValue()\n *\n *      Input:  da\n *              index (into l_dna)\n *              &val  (<return> double value; 0.0 on error)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) Caller may need to check the function return value to\n *          decide if a 0.0 in the returned ival is valid.\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaGetIArray",
      "comment" : "/*!\n *  l_dnaGetIArray()\n *\n *      Input:  da\n *      Return: a copy of the bare internal array, integerized\n *              by rounding, or null on error\n *  Notes:\n *      (1) A copy of the array is made, because we need to\n *          generate an integer array from the bare double array.\n *          The caller is responsible for freeing the array.\n *      (2) The array size is determined by the number of stored numbers,\n *          not by the size of the allocated array in the l_dna.\n *      (3) This function is provided to simplify calculations\n *          using the bare internal array, rather than continually\n *          calling accessors on the l_dna.  It is typically used\n *          on an array of size 256.\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaGetIValue",
      "comment" : "/*!\n *  l_dnaGetIValue()\n *\n *      Input:  da\n *              index (into l_dna)\n *              &ival  (<return> integer value; 0 on error)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) Caller may need to check the function return value to\n *          decide if a 0 in the returned ival is valid.\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaGetParameters",
      "comment" : "/*!\n *  l_dnaGetParameters()\n *\n *      Input:  da\n *              &startx (<optional return> startx)\n *              &delx (<optional return> delx)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaGetRefcount",
      "comment" : "/*!\n *  l_dnaGetRefCount()\n *\n *      Input:  da\n *      Return: refcount, or UNDEF on error\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaInsertNumber",
      "comment" : "/*!\n *  l_dnaInsertNumber()\n *\n *      Input:  da\n *              index (location in da to insert new value)\n *              val  (float64 or integer to be added)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This shifts da[i] --> da[i + 1] for all i >= index,\n *          and then inserts val as da[index].\n *      (2) It should not be used repeatedly on large arrays,\n *          because the function is O(n).\n *\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaJoin",
      "comment" : "/*!\n *  l_dnaJoin()\n *\n *      Input:  dad  (dest dma; add to this one)\n *              das  (<optional> source dna; add from this one)\n *              istart  (starting index in das)\n *              iend  (ending index in das; use -1 to cat all)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) istart < 0 is taken to mean 'read from the start' (istart = 0)\n *      (2) iend < 0 means 'read to the end'\n *      (3) if das == NULL, this is a no-op\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaMakeDelta",
      "comment" : "/*!\n *  l_dnaMakeDelta()\n *\n *      Input:  das (input l_dna)\n *      Return: dad (of difference values val[i+1] - val[i]),\n *                   or null on error\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaMakeSequence",
      "comment" : "/*!\n *  l_dnaMakeSequence()\n *\n *      Input:  startval\n *              increment\n *              size (of sequence)\n *      Return: l_dna of sequence of evenly spaced values, or null on error\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaRead",
      "comment" : "/*!\n *  l_dnaRead()\n *\n *      Input:  filename\n *      Return: da, or null on error\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaReadStream",
      "comment" : "/*!\n *  l_dnaReadStream()\n *\n *      Input:  stream\n *      Return: da, or null on error\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaRemoveNumber",
      "comment" : "/*!\n *  l_dnaRemoveNumber()\n *\n *      Input:  da\n *              index (element to be removed)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This shifts da[i] --> da[i - 1] for all i > index.\n *      (2) It should not be used repeatedly on large arrays,\n *          because the function is O(n).\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaReplaceNumber",
      "comment" : "/*!\n *  l_dnaReplaceNumber()\n *\n *      Input:  da\n *              index (element to be replaced)\n *              val (new value to replace old one)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaSetCount",
      "comment" : "/*!\n *  l_dnaSetCount()\n *\n *      Input:  da\n *              newcount\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If newcount <= da->nalloc, this resets da->n.\n *          Using newcount = 0 is equivalent to l_dnaEmpty().\n *      (2) If newcount > da->nalloc, this causes a realloc\n *          to a size da->nalloc = newcount.\n *      (3) All the previously unused values in da are set to 0.0.\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaSetParameters",
      "comment" : "/*!\n *  l_dnaSetParameters()\n *\n *      Input:  da\n *              startx (x value corresponding to da[0])\n *              delx (difference in x values for the situation where the\n *                    elements of da correspond to the evaulation of a\n *                    function at equal intervals of size @delx)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaSetValue",
      "comment" : "/*!\n *  l_dnaSetValue()\n *\n *      Input:  da\n *              index  (to element to be set)\n *              val  (to set element)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaShiftValue",
      "comment" : "/*!\n *  l_dnaShiftValue()\n *\n *      Input:  da\n *              index (to element to change relative to the current value)\n *              diff  (increment if diff > 0 or decrement if diff < 0)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaWrite",
      "comment" : "/*!\n *  l_dnaWrite()\n *\n *      Input:  filename, da\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaWriteStream",
      "comment" : "/*!\n *  l_dnaWriteStream()\n *\n *      Input:  stream, da\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaaAddDna",
      "comment" : "/*!\n *  l_dnaaAddDna()\n *\n *      Input:  daa\n *              da   (to be added)\n *              copyflag  (L_INSERT, L_COPY, L_CLONE)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaaAddNumber",
      "comment" : "/*!\n *  l_dnaaAddNumber()\n *\n *      Input:  daa\n *              index (of l_dna within l_dnaa)\n *              val  (number to be added; stored as a double)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Adds to an existing l_dna only.\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaaCreate",
      "comment" : "/*!\n *  l_dnaaCreate()\n *\n *      Input:  size of l_dna ptr array to be alloc'd (0 for default)\n *      Return: daa, or null on error\n *\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaaDestroy",
      "comment" : "/*!\n *  l_dnaaDestroy()\n *\n *      Input: &dnaa <to be nulled if it exists>\n *      Return: void\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaaExtendArray",
      "comment" : "/*!\n *  l_dnaaExtendArray()\n *\n *      Input:  daa\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaaGetCount",
      "comment" : "/*!\n *  l_dnaaGetCount()\n *\n *      Input:  daa\n *      Return: count (number of l_dna), or 0 if no l_dna or on error\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaaGetDna",
      "comment" : "/*!\n *  l_dnaaGetDna()\n *\n *      Input:  daa\n *              index  (to the index-th l_dna)\n *              accessflag   (L_COPY or L_CLONE)\n *      Return: l_dna, or null on error\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaaGetDnaCount",
      "comment" : "/*!\n *  l_dnaaGetDnaCount()\n *\n *      Input:  daa\n *              index (of l_dna in daa)\n *      Return: count of numbers in the referenced l_dna, or 0 on error.\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaaGetNumberCount",
      "comment" : "/*!\n *  l_dnaaGetNumberCount()\n *\n *      Input:  daa\n *      Return: count (total number of numbers in the l_dnaa),\n *                     or 0 if no numbers or on error\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaaGetValue",
      "comment" : "/*!\n *  l_dnaaGetValue()\n *\n *      Input:  daa\n *              i (index of l_dna within l_dnaa)\n *              j (index into l_dna)\n *              val (<return> double value)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaaRead",
      "comment" : "/*!\n *  l_dnaaRead()\n *\n *      Input:  filename\n *      Return: daa, or null on error\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaaReadStream",
      "comment" : "/*!\n *  l_dnaaReadStream()\n *\n *      Input:  stream\n *      Return: daa, or null on error\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaaReplaceDna",
      "comment" : "/*!\n *  l_dnaaReplaceDna()\n *\n *      Input:  daa\n *              index  (to the index-th l_dna)\n *              l_dna (insert and replace any existing one)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Any existing l_dna is destroyed, and the input one\n *          is inserted in its place.\n *      (2) If the index is invalid, return 1 (error)\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaaWrite",
      "comment" : "/*!\n *  l_dnaaWrite()\n *\n *      Input:  filename, daa\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_dnaaWriteStream",
      "comment" : "/*!\n *  l_dnaaWriteStream()\n *\n *      Input:  stream, daa\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "l_generateCIData",
      "comment" : "/*!\n *  l_generateCIData()\n *\n *      Input:  fname\n *              type (L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE)\n *              quality (used for jpeg only; 0 for default (75))\n *              ascii85 (0 for binary; 1 for ascii85-encoded)\n *              &cid (<return> compressed data)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Set ascii85:\n *           - 0 for binary data (not permitted in PostScript)\n *           - 1 for ascii85 (5 for 4) encoded binary data\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "l_generateFlateData",
      "comment" : "/*!\n *  l_generateFlateData()\n *\n *      Input:  fname\n *              ascii85flag (0 for gzipped; 1 for ascii85-encoded gzipped)\n *      Return: cid (flate compressed image data), or null on error\n *\n *  Notes:\n *      (1) The input image is converted to one of these 4 types:\n *           - 1 bpp\n *           - 8 bpp, no colormap\n *           - 8 bpp, colormap\n *           - 32 bpp rgb\n *      (2) Set ascii85flag:\n *           - 0 for binary data (not permitted in PostScript)\n *           - 1 for ascii85 (5 for 4) encoded binary data\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "l_generateG4Data",
      "comment" : "/*!\n *  l_generateG4Data()\n *\n *      Input:  fname (of g4 compressed file)\n *              ascii85flag (0 for g4 compressed; 1 for ascii85-encoded g4)\n *      Return: cid (g4 compressed image data), or null on error\n *\n *  Notes:\n *      (1) Set ascii85flag:\n *           - 0 for binary data (not permitted in PostScript)\n *           - 1 for ascii85 (5 for 4) encoded binary data\n *             (not permitted in pdf)\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "l_generateJp2kData",
      "comment" : "/*!\n *  l_generateJp2kData()\n *\n *      Input:  fname (of jp2k file)\n *      Return: cid (containing jp2k data), or null on error\n *\n *  Notes:\n *      (1) This is only called after the file is verified to be jp2k.\n *      (2) It is here and not in psio2.c because jp2k can't be wrapped\n *          in PostScript.\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "l_generateJpegData",
      "comment" : "/*!\n *  l_generateJpegData()\n *\n *      Input:  fname (of jpeg file)\n *              ascii85flag (0 for jpeg; 1 for ascii85-encoded jpeg)\n *      Return: cid (containing jpeg data), or null on error\n *\n *  Notes:\n *      (1) Set ascii85flag:\n *           - 0 for binary data (not permitted in PostScript)\n *           - 1 for ascii85 (5 for 4) encoded binary data\n *               (not permitted in pdf)\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "l_generatePdf",
      "comment" : "/*!\n *  l_generatePdf()\n *\n *      Input:  &data (<return> pdf array)\n *              &nbytes (<return> number of bytes in pdf array)\n *              lpd (all the required input image data)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) On error, no data is returned.\n *      (2) The objects are:\n *            1: Catalog\n *            2: Info\n *            3: Pages\n *            4: Page\n *            5: Contents  (rendering command)\n *            6 to 6+n-1: n XObjects\n *            6+n to 6+n+m-1: m colormaps\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "l_getCurrentTime",
      "comment" : "/*!\n *  l_getCurrentTime()\n *\n *      Input:  &sec (<optional return> in seconds since birth of Unix)\n *              &usec (<optional return> in microseconds since birth of Unix)\n *      Return: void\n */",
      "file" : "utils.c"
   },
   {
      "function" : "l_getCurrentTime",
      "comment" : "/* in units of 100 ns intervals */",
      "file" : "utils.c"
   },
   {
      "function" : "l_getDataBit",
      "comment" : "/*!\n *  l_getDataBit()\n *\n *      Input:  line  (ptr to beginning of data line)\n *              n     (pixel index)\n *      Return: val of the nth (1-bit) pixel.\n */",
      "file" : "arrayaccess.c"
   },
   {
      "function" : "l_getDataByte",
      "comment" : "/*!\n *  l_getDataByte()\n *\n *      Input:  line  (ptr to beginning of data line)\n *              n     (pixel index)\n *      Return: value of the n-th (byte) pixel\n */",
      "file" : "arrayaccess.c"
   },
   {
      "function" : "l_getDataDibit",
      "comment" : "/*!\n *  l_getDataDibit()\n *\n *      Input:  line  (ptr to beginning of data line)\n *              n     (pixel index)\n *      Return: val of the nth (2-bit) pixel.\n */",
      "file" : "arrayaccess.c"
   },
   {
      "function" : "l_getDataFourBytes",
      "comment" : "/*!\n *  l_getDataFourBytes()\n *\n *      Input:  line  (ptr to beginning of data line)\n *              n     (pixel index)\n *      Return: value of the n-th (4-byte) pixel\n */",
      "file" : "arrayaccess.c"
   },
   {
      "function" : "l_getDataQbit",
      "comment" : "/*!\n *  l_getDataQbit()\n *\n *      Input:  line  (ptr to beginning of data line)\n *              n     (pixel index)\n *      Return: val of the nth (4-bit) pixel.\n */",
      "file" : "arrayaccess.c"
   },
   {
      "function" : "l_getDataTwoBytes",
      "comment" : "/*!\n *  l_getDataTwoBytes()\n *\n *      Input:  line  (ptr to beginning of data line)\n *              n     (pixel index)\n *      Return: value of the n-th (2-byte) pixel\n */",
      "file" : "arrayaccess.c"
   },
   {
      "function" : "l_getFormattedDate",
      "comment" : "/*!\n *  l_getFormattedDate()\n *\n *      Input:  (none)\n *      Return: formatted date string, or null on error\n */",
      "file" : "utils.c"
   },
   {
      "function" : "l_pdfSetDateAndVersion",
      "comment" : "/*!\n *  l_pdfSetDateAndVersion()\n *\n *      Input:  flag (1 for writing date/time and leptonica version;\n *                    0 for omitting this from the metadata)\n *      Return: void\n *\n *  Notes:\n *      (1) The default is for writing this data.  For regression tests\n *          that compare output against golden files, it is useful to omit.\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "l_pdfSetG4ImageMask",
      "comment" : "/*!\n *  l_pdfSetG4ImageMask()\n *\n *      Input:  flag (1 for writing g4 data as fg only through a mask;\n *                    0 for writing fg and bg)\n *      Return: void\n *\n *  Notes:\n *      (1) The default is for writing only the fg (through the mask).\n *          That way when you write a 1 bpp image, the bg is transparent,\n *          so any previously written image remains visible behind it.\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "l_pngSetReadStrip16To8",
      "comment" : "/*!\n *  l_pngSetReadStrip16To8()\n *\n *      Input:  flag (1 for stripping 16 bpp to 8 bpp on reading;\n *                    0 for leaving 16 bpp)\n *      Return: void\n */",
      "file" : "pngio.c"
   },
   {
      "function" : "l_productMat2",
      "comment" : "/*!\n *  l_productMat2()\n *\n *      Input:  mat1  (square matrix, as a 1-dimensional size^2 array)\n *              mat2  (square matrix, as a 1-dimensional size^2 array)\n *              matd  (square matrix; product stored here)\n *              size (of matrices)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "affinecompose.c"
   },
   {
      "function" : "l_productMat3",
      "comment" : "/*!\n *  l_productMat3()\n *\n *      Input:  mat1  (square matrix, as a 1-dimensional size^2 array)\n *              mat2  (square matrix, as a 1-dimensional size^2 array)\n *              mat3  (square matrix, as a 1-dimensional size^2 array)\n *              matd  (square matrix; product stored here)\n *              size  (of matrices)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "affinecompose.c"
   },
   {
      "function" : "l_productMat4",
      "comment" : "/*!\n *  l_productMat4()\n *\n *      Input:  mat1  (square matrix, as a 1-dimensional size^2 array)\n *              mat2  (square matrix, as a 1-dimensional size^2 array)\n *              mat3  (square matrix, as a 1-dimensional size^2 array)\n *              mat4  (square matrix, as a 1-dimensional size^2 array)\n *              matd  (square matrix; product stored here)\n *              size  (of matrices)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "affinecompose.c"
   },
   {
      "function" : "l_productMatVec",
      "comment" : "/*!\n *  l_productMatVec()\n *\n *      Input:  mat  (square matrix, as a 1-dimensional @size^2 array)\n *              vecs (input column vector of length @size)\n *              vecd (result column vector)\n *              size (matrix is @size x @size; vectors are length @size)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "affinecompose.c"
   },
   {
      "function" : "l_psWriteBoundingBox",
      "comment" : "/*-------------------------------------------------------------*\n *           Setting flag for writing bounding box hint        *\n *-------------------------------------------------------------*/",
      "file" : "psio2.c"
   },
   {
      "function" : "l_setAlphaMaskBorder",
      "comment" : "/*!\n *  l_setAlphaMaskBorder()\n *\n *      Input:  val1, val2 (in [0.0 ... 1.0])\n *      Return: void\n *\n *  Notes:\n *      (1) This sets the opacity values used to generate the two outer\n *          boundary rings in the alpha mask associated with geometric\n *          transforms such as pixRotateWithAlpha().\n *      (2) The default values are val1 = 0.0 (completely transparent\n *          in the outermost ring) and val2 = 0.5 (half transparent\n *          in the second ring).  When the image is blended, this\n *          completely removes the outer ring (shrinking the image by\n *          2 in each direction), and alpha-blends with 0.5 the second ring.\n *          Using val1 = 0.25 and val2 = 0.75 gives a slightly more\n *          blurred border, with no perceptual difference at screen resolution.\n *      (3) The actual mask values are found by multiplying these\n *          normalized opacity values by 255.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "l_setConvolveSampling",
      "comment" : "/*!\n *  l_setConvolveSampling()\n\n *\n *      Input:  xfact, yfact (integer >= 1)\n *      Return: void\n *\n *  Notes:\n *      (1) This sets the x and y output subsampling factors for generic pix\n *          and fpix convolution.  The default values are 1 (no subsampling).\n */",
      "file" : "convolve.c"
   },
   {
      "function" : "l_setDataBit",
      "comment" : "/*!\n *  l_setDataBit()\n *\n *      Input:  line  (ptr to beginning of data line)\n *              n     (pixel index)\n *      Return: void\n *\n *  Action: sets the pixel to 1\n */",
      "file" : "arrayaccess.c"
   },
   {
      "function" : "l_setDataBitVal",
      "comment" : "/*!\n *  l_setDataBitVal()\n *\n *      Input:  line  (ptr to beginning of data line)\n *              n     (pixel index)\n *              val   (val to be inserted: 0 or 1)\n *      Return: void\n *\n *  Notes:\n *      (1) This is an accessor for a 1 bpp pix.\n *      (2) It is actually a little slower than using:\n *            if (val == 0)\n *                l_ClearDataBit(line, n);\n *            else\n *                l_SetDataBit(line, n);\n */",
      "file" : "arrayaccess.c"
   },
   {
      "function" : "l_setDataByte",
      "comment" : "/*!\n *  l_setDataByte()\n *\n *      Input:  line  (ptr to beginning of data line)\n *              n     (pixel index)\n *              val   (val to be inserted: 0 - 0xff)\n *      Return: void\n */",
      "file" : "arrayaccess.c"
   },
   {
      "function" : "l_setDataDibit",
      "comment" : "/*!\n *  l_setDataDibit()\n *\n *      Input:  line  (ptr to beginning of data line)\n *              n     (pixel index)\n *              val   (val to be inserted: 0 - 3)\n *      Return: void\n */",
      "file" : "arrayaccess.c"
   },
   {
      "function" : "l_setDataFourBytes",
      "comment" : "/*!\n *  l_setDataFourBytes()\n *\n *      Input:  line  (ptr to beginning of data line)\n *              n     (pixel index)\n *              val   (val to be inserted: 0 - 0xffffffff)\n *      Return: void\n */",
      "file" : "arrayaccess.c"
   },
   {
      "function" : "l_setDataQbit",
      "comment" : "/*!\n *  l_setDataQbit()\n *\n *      Input:  line  (ptr to beginning of data line)\n *              n     (pixel index)\n *              val   (val to be inserted: 0 - 0xf)\n *      Return: void\n */",
      "file" : "arrayaccess.c"
   },
   {
      "function" : "l_setDataTwoBytes",
      "comment" : "/*!\n *  l_setDataTwoBytes()\n *\n *      Input:  line  (ptr to beginning of data line)\n *              n     (pixel index)\n *              val   (val to be inserted: 0 - 0xffff)\n *      Return: void\n */",
      "file" : "arrayaccess.c"
   },
   {
      "function" : "l_showIndicatorSplitValues",
      "comment" : "/*!\n *  l_showIndicatorSplitValues()\n *\n *      Input:  7 indicator array\n *\n *  Notes:\n *      (1) The values indicate that specific criteria has been met\n *          for component removal by pre-splitting filter..\n *          The 'result' line shows which components have been removed.\n */",
      "file" : "recogident.c"
   },
   {
      "function" : "lept_calloc",
      "comment" : "/*!\n *  lept_calloc()\n *\n *      Input:  nmemb (number of members)\n *              size (of each member)\n *      Return: void ptr, or null on error\n *\n *  Notes:\n *      (1) For safety with windows DLLs, this can be used in conjunction\n *          with lept_free() to avoid C-runtime boundary problems.\n *          Just use these two functions throughout your application.\n */",
      "file" : "utils.c"
   },
   {
      "function" : "lept_cp",
      "comment" : "/*!\n *  lept_cp()\n *\n *      Input:  srcfile\n *              newfile\n *      Return: 0 on success, non-zero on failure\n *\n *  Notes:\n *      (1) This copies a file to /tmp or a subdirectory of /tmp.\n *      (2) The input srcfile name is the complete pathname.\n *          The input newfile is either in /tmp or a subdirectory\n *          of /tmp, and newfile can be specified either as the\n *          full path or without the leading '/tmp'.\n *      (3) Use unix pathname separators.\n *      (4) On Windows, the source and target filename are altered\n *          internally if necessary to conform to the Windows temp file.\n *      (5) Alternatively, you can use fileCopy().  This avoids\n *          forking a new process and has no restrictions on the\n *          destination directory.\n */",
      "file" : "utils.c"
   },
   {
      "function" : "lept_direxists",
      "comment" : "/*!\n *  lept_direxists()\n *\n *      Input:  dirname\n *              &exists (<return> 1 on success, 0 on failure)\n *      Return: void\n *\n *  Notes:\n *      (1) For Windows, use windows pathname separators.\n */",
      "file" : "utils.c"
   },
   {
      "function" : "lept_fclose",
      "comment" : "/*!\n *  lept_fclose()\n *\n *      Input:  fp (stream handle)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This should be used by any application that accepts\n *          a file handle generated by a leptonica Windows DLL.\n */",
      "file" : "utils.c"
   },
   {
      "function" : "lept_fopen",
      "comment" : "/*!\n *  lept_fopen()\n *\n *      Input:  filename\n *              mode (same as for fopen(); e.g., \"rb\")\n *      Return: stream or null on error\n *\n *  Notes:\n *      (1) This must be used by any application that passes\n *          a file handle to a leptonica Windows DLL.\n */",
      "file" : "utils.c"
   },
   {
      "function" : "lept_free",
      "comment" : "/*!\n *  lept_free()\n *\n *      Input:  void ptr\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This should be used by any application that accepts\n *          heap data allocated by a leptonica Windows DLL.\n */",
      "file" : "utils.c"
   },
   {
      "function" : "lept_mkdir",
      "comment" : "/*!\n *  lept_mkdir()\n *\n *      Input:  subdir (of /tmp or its equivalent on Windows)\n *      Return: 0 on success, non-zero on failure\n *\n *  Notes:\n *      (1) This makes a subdirectory of /tmp/.\n *      (2) Use unix pathname separators.\n *      (3) On Windows, it makes a subdirectory of <Temp>/leptonica,\n *          where <Temp> is the Windows temp dir.  The name translation is:\n *                 /tmp  -->   <Temp>/leptonica\n */",
      "file" : "utils.c"
   },
   {
      "function" : "lept_mv",
      "comment" : "/*!\n *  lept_mv()\n *\n *      Input:  srcfile, newfile\n *      Return: 0 on success, non-zero on failure\n *\n *  Notes:\n *      (1) This moves a srcfile to /tmp or to a subdirectory of /tmp.\n *      (2) The input srcfile name is the complete pathname.\n *          The input newfile is either in /tmp or a subdirectory\n *          of /tmp, and newfile can be specified either as the\n *          full path or without the leading '/tmp'.\n *      (3) Use unix pathname separators.\n *      (4) On Windows, the source and target filename are altered\n *          internally if necessary to conform to the Windows temp file.\n *          The name translation is: /tmp  -->   <Temp>/leptonica\n */",
      "file" : "utils.c"
   },
   {
      "function" : "lept_rm",
      "comment" : "/*!\n *  lept_rm()\n *\n *      Input:  subdir (can be NULL, in which case the removed file is\n *                      in /tmp)\n *              filename (with or without the directory)\n *      Return: 0 on success, non-zero on failure\n *\n *  Notes:\n *      (1) This removes the named file in /tmp or a subdirectory of /tmp.\n *          If the file is in /tmp, use NULL for the subdir.\n *      (2) @filename can include directories in the path, but they are ignored.\n *      (3) Use unix pathname separators.\n *      (4) On Windows, the file is in either <Temp>/leptonica, or\n *          a subdirectory of this, where <Temp> is the Windows temp dir.\n *          The name translation is: /tmp  -->   <Temp>/leptonica\n */",
      "file" : "utils.c"
   },
   {
      "function" : "lept_rmdir",
      "comment" : "/*!\n *  lept_rmdir()\n *\n *      Input:  subdir (of /tmp or its equivalent on Windows)\n *      Return: 0 on success, non-zero on failure\n *\n *  Notes:\n *      (1) On unix, this removes all the files in the named\n *          subdirectory of /tmp.  It then removes the subdirectory.\n *      (2) Use unix pathname separators.\n *      (3) On Windows, the affected directory is a subdirectory\n *          of <Temp>/leptonica, where <Temp> is the Windows temp dir.\n */",
      "file" : "utils.c"
   },
   {
      "function" : "lept_roundftoi",
      "comment" : "/*!\n *  lept_roundftoi()\n *\n *      Input:  fval\n *      Return: value rounded to int\n *\n *  Notes:\n *      (1) For fval >= 0, fval --> round(fval) == floor(fval + 0.5)\n *          For fval < 0, fval --> -round(-fval))\n *          This is symmetric around 0.\n *          e.g., for fval in (-0.5 ... 0.5), fval --> 0\n */",
      "file" : "utils.c"
   },
   {
      "function" : "lheapAdd",
      "comment" : "/*!\n *  lheapAdd()\n *\n *      Input:  lheap\n *              item to be added to the tail of the heap\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "heap.c"
   },
   {
      "function" : "lheapCreate",
      "comment" : "/*!\n *  lheapCreate()\n *\n *      Input:  size of ptr array to be alloc'd (0 for default)\n *              direction (L_SORT_INCREASING, L_SORT_DECREASING)\n *      Return: lheap, or null on error\n */",
      "file" : "heap.c"
   },
   {
      "function" : "lheapDestroy",
      "comment" : "/*!\n *  lheapDestroy()\n *\n *      Input:  &lheap  (<to be nulled>)\n *              freeflag (TRUE to free each remaining struct in the array)\n *      Return: void\n *\n *  Notes:\n *      (1) Use freeflag == TRUE when the items in the array can be\n *          simply destroyed using free.  If those items require their\n *          own destroy function, they must be destroyed before\n *          calling this function, and then this function is called\n *          with freeflag == FALSE.\n *      (2) To destroy the lheap, we destroy the ptr array, then\n *          the lheap, and then null the contents of the input ptr.\n */",
      "file" : "heap.c"
   },
   {
      "function" : "lheapExtendArray",
      "comment" : "/*!\n *  lheapExtendArray()\n *\n *      Input:  lheap\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "heap.c"
   },
   {
      "function" : "lheapGetCount",
      "comment" : "/*!\n *  lheapGetCount()\n *\n *      Input:  lheap\n *      Return: count, or 0 on error\n */",
      "file" : "heap.c"
   },
   {
      "function" : "lheapPrint",
      "comment" : "/*!\n *  lheapPrint()\n *\n *      Input:  stream\n *              lheap\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "heap.c"
   },
   {
      "function" : "lheapRemove",
      "comment" : "/*!\n *  lheapRemove()\n *\n *      Input:  lheap\n *      Return: ptr to item popped from the root of the heap,\n *              or null if the heap is empty or on error\n */",
      "file" : "heap.c"
   },
   {
      "function" : "lheapSort",
      "comment" : "/*!\n *  lheapSort()\n *\n *      Input:  lh (heap, with internal array)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This sorts an array into heap order.  If the heap is already\n *          in heap order for the direction given, this has no effect.\n */",
      "file" : "heap.c"
   },
   {
      "function" : "lheapSortStrictOrder",
      "comment" : "/*!\n *  lheapSortStrictOrder()\n *\n *      Input:  lh (heap, with internal array)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This sorts a heap into strict order.\n *      (2) For each element, starting at the end of the array and\n *          working forward, the element is swapped with the head\n *          element and then allowed to swap down onto a heap of\n *          size reduced by one.  The result is that the heap is\n *          reversed but in strict order.  The array elements are\n *          then reversed to put it in the original order.\n */",
      "file" : "heap.c"
   },
   {
      "function" : "lheapSwapDown",
      "comment" : "/*!\n *  lheapSwapDown()\n *\n *      Input:  lh (heap)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is called after an item has been popped off the\n *          root of the heap, and the last item in the heap has\n *          been placed at the root.\n *      (2) To regain the heap order, we let it bubble down,\n *          iteratively swapping with one of its children.  For a\n *          decreasing sort, it swaps with the largest child; for\n *          an increasing sort, the smallest.  This continues until\n *          it either reaches the lowest level in the heap, or the\n *          parent finds that neither child should swap with it\n *          (e.g., for a decreasing heap, the parent is larger\n *          than or equal to both children).\n */",
      "file" : "heap.c"
   },
   {
      "function" : "lheapSwapUp",
      "comment" : "/*!\n *  lheapSwapUp()\n *\n *      Input:  lh (heap)\n *              index (of array corresponding to node to be swapped up)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is called after a new item is put on the heap, at the\n *          bottom of a complete tree.\n *      (2) To regain the heap order, we let it bubble up,\n *          iteratively swapping with its parent, until it either\n *          reaches the root of the heap or it finds a parent that\n *          is in the correct position already vis-a-vis the child.\n */",
      "file" : "heap.c"
   },
   {
      "function" : "lineEndianByteSwap",
      "comment" : "/*!\n *  lineEndianByteSwap()\n *\n *      Input   datad (dest byte array data, reordered on little-endians)\n *              datas (a src line of pix data)\n *              wpl (number of 32 bit words in the line)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is used on little-endian platforms to swap\n *          the bytes within each word in the line of image data.\n *          Bytes 0 <==> 3 and 1 <==> 2 are swapped in the dest\n *          byte array data8d, relative to the pix data in datas.\n *      (2) The bytes represent 8 bit pixel values.  They are swapped\n *          for little endians so that when the dest array (char *)datad\n *          is addressed by bytes, the pixels are chosen sequentially\n *          from left to right in the image.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "linearInterpolatePixelColor",
      "comment" : "/*!\n *  linearInterpolatePixelColor()\n *\n *      Input:  datas (ptr to beginning of image data)\n *              wpls (32-bit word/line for this data array)\n *              w, h (of image)\n *              x, y (floating pt location for evaluation)\n *              colorval (color brought in from the outside when the\n *                        input x,y location is outside the image;\n *                        in 0xrrggbb00 format))\n *              &val (<return> interpolated color value)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is a standard linear interpolation function.  It is\n *          equivalent to area weighting on each component, and\n *          avoids \"jaggies\" when rendering sharp edges.\n */",
      "file" : "affine.c"
   },
   {
      "function" : "linearInterpolatePixelFloat",
      "comment" : "/*!\n *  linearInterpolatePixelFloat()\n *\n *      Input:  datas (ptr to beginning of float image data)\n *              wpls (32-bit word/line for this data array)\n *              w, h (of image)\n *              x, y (floating pt location for evaluation)\n *              inval (float value brought in from the outside when the\n *                     input x,y location is outside the image)\n *              &val (<return> interpolated float value)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is a standard linear interpolation function.  It is\n *          equivalent to area weighting on each component, and\n *          avoids \"jaggies\" when rendering sharp edges.\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "linearInterpolatePixelGray",
      "comment" : "/*!\n *  linearInterpolatePixelGray()\n *\n *      Input:  datas (ptr to beginning of image data)\n *              wpls (32-bit word/line for this data array)\n *              w, h (of image)\n *              x, y (floating pt location for evaluation)\n *              grayval (color brought in from the outside when the\n *                       input x,y location is outside the image)\n *              &val (<return> interpolated gray value)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is a standard linear interpolation function.  It is\n *          equivalent to area weighting on each component, and\n *          avoids \"jaggies\" when rendering sharp edges.\n */",
      "file" : "affine.c"
   },
   {
      "function" : "listAddToHead",
      "comment" : "/*!\n *  listAddToHead()\n *\n *      Input:  &head  (<optional> input head)\n *              data  (void* ptr, to be added)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This makes a new cell, attaches the data, and adds the\n *          cell to the head of the list.\n *      (2) When consing from NULL, be sure to initialize head to NULL\n *          before calling this function.\n */",
      "file" : "list.c"
   },
   {
      "function" : "listAddToTail",
      "comment" : "/*!\n *  listAddToTail()\n *\n *      Input:  &head  (<may be updated>, head can be null)\n *              &tail  (<updated>, tail can be null)\n *              data  (void* ptr, to be hung on tail cons cell)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This makes a new cell, attaches the data, and adds the\n *          cell to the tail of the list.\n *      (2) &head is input to allow the list to be \"cons'd\" up from NULL.\n *      (3) &tail is input to allow the tail to be updated\n *          for efficient sequential operation with this function.\n *      (4) We assume that if *phead and/or *ptail are not NULL,\n *          then they are valid addresses.  Therefore:\n *           (a) when consing from NULL, be sure to initialize both\n *               head and tail to NULL.\n *           (b) when tail == NULL for an existing list, the tail\n *               will be found and updated.\n */",
      "file" : "list.c"
   },
   {
      "function" : "listDestroy",
      "comment" : "/*!\n *  listDestroy()\n *\n *      Input:  &head   (<to be nulled> head of list)\n *      Return: void\n *\n *  Notes:\n *      (1) This only destroys the cons cells.  Before destroying\n *          the list, it is necessary to remove all data and set the\n *          data pointers in each cons cell to NULL.\n *      (2) listDestroy() will give a warning message for each data\n *          ptr that is not NULL.\n */",
      "file" : "list.c"
   },
   {
      "function" : "listFindElement",
      "comment" : "/*!\n *  listFindElement()\n *\n *      Input:  head  (list head)\n *              data  (void*  address, to be searched for)\n *      Return: cell  (the containing cell, or null if not found or on error)\n *\n *  Notes:\n *      (1) This returns a ptr to the cell, which is still embedded in\n *          the list.\n *      (2) This handle and the attached data have not been copied or\n *          reference counted, so they must not be destroyed.  This\n *          violates our basic rule that every handle returned from a\n *          function is owned by that function and must be destroyed,\n *          but if rules aren't there to be broken, why have them?\n */",
      "file" : "list.c"
   },
   {
      "function" : "listFindTail",
      "comment" : "/*!\n *  listFindTail()\n *\n *      Input:  head\n *      Return: tail, or null on error\n */",
      "file" : "list.c"
   },
   {
      "function" : "listGetCount",
      "comment" : "/*!\n *  listGetCount()\n *\n *      Input:  head  (of list)\n *      Return: number of elements; 0 if no list or on error\n */",
      "file" : "list.c"
   },
   {
      "function" : "listInsertAfter",
      "comment" : "/*!\n *  listInsertAfter()\n *\n *      Input:  &head  (<optional> input head)\n *               elem  (list element to be inserted after;\n *                      must be null if head is null)\n *               data  (void*  ptr, to be added)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This can be called on a null list, in which case both\n *          head and elem must be null.  The head is included\n *          in the call to allow \"consing\" up from NULL.\n *      (2) If you are searching through a list, looking for a condition\n *          to add an element, you can do something like this:\n *            L_BEGIN_LIST_FORWARD(head, elem)\n *                <identify an elem to insert after>\n *                listInsertAfter(&head, elem, data);\n *            L_END_LIST\n */",
      "file" : "list.c"
   },
   {
      "function" : "listInsertBefore",
      "comment" : "/*!\n *  listInsertBefore()\n *\n *      Input:  &head  (<optional> input head)\n *               elem  (list element to be inserted in front of;\n *                      must be null if head is null)\n *               data  (void*  address, to be added)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This can be called on a null list, in which case both\n *          head and elem must be null.\n *      (2) If you are searching through a list, looking for a condition\n *          to add an element, you can do something like this:\n *            L_BEGIN_LIST_FORWARD(head, elem)\n *                <identify an elem to insert before>\n *                listInsertBefore(&head, elem, data);\n *            L_END_LIST\n *\n */",
      "file" : "list.c"
   },
   {
      "function" : "listJoin",
      "comment" : "/*!\n *  listJoin()\n *\n *      Input:  &head1  (<may be changed> head of first list)\n *              &head2  (<to be nulled> head of second list)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The concatenated list is returned with head1 as the new head.\n *      (2) Both input ptrs must exist, though either can have the value NULL.\n */",
      "file" : "list.c"
   },
   {
      "function" : "listRemoveElement",
      "comment" : "/*!\n *  listRemoveElement()\n *\n *      Input:  &head (<can be changed> input head)\n *              elem (list element to be removed)\n *      Return: data  (void* struct on cell)\n *\n *  Notes:\n *      (1) in ANSI C, it is not necessary to cast return to actual type; e.g.,\n *             pix = listRemoveElement(&head, elem);\n *          but in ANSI C++, it is necessary to do the cast:\n *             pix = (Pix *)listRemoveElement(&head, elem);\n */",
      "file" : "list.c"
   },
   {
      "function" : "listRemoveFromHead",
      "comment" : "/*!\n *  listRemoveFromHead()\n *\n *      Input:  &head (<to be updated> head of list)\n *      Return: data  (void* struct on cell), or null on error\n *\n *  Notes:\n *      (1) in ANSI C, it is not necessary to cast return to actual type; e.g.,\n *            pix = listRemoveFromHead(&head);\n *          but in ANSI C++, it is necessary to do the cast; e.g.,\n *            pix = (Pix *)listRemoveFromHead(&head);\n */",
      "file" : "list.c"
   },
   {
      "function" : "listRemoveFromTail",
      "comment" : "/*!\n *  listRemoveFromTail()\n *\n *      Input:  &head (<may be changed>, head must NOT be null)\n *              &tail (<always updated>, tail may be null)\n *      Return: data  (void* struct on cell) or null on error\n *\n *  Notes:\n *      (1) We include &head so that it can be set to NULL if\n *          if the only element in the list is removed.\n *      (2) The function is relying on the fact that if tail is\n *          not NULL, then is is a valid address.  You can use\n *          this function with tail == NULL for an existing list, in\n *          which case  the tail is found and updated, and the\n *          removed element is returned.\n *      (3) In ANSI C, it is not necessary to cast return to actual type; e.g.,\n *            pix = listRemoveFromTail(&head, &tail);\n *          but in ANSI C++, it is necessary to do the cast; e.g.,\n *            pix = (Pix *)listRemoveFromTail(&head, &tail);\n */",
      "file" : "list.c"
   },
   {
      "function" : "listReverse",
      "comment" : "/*!\n *  listReverse()\n *\n *      Input:  &head  (<may be changed> list head)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This reverses the list in-place.\n */",
      "file" : "list.c"
   },
   {
      "function" : "localSearchForBackground",
      "comment" : "/*!\n *  localSearchForBackground()\n *\n *      Input:  &x, &y (starting position for search; return found position)\n *              maxrad (max distance to search from starting location)\n *      Return: 0 if bg pixel found; 1 if not found\n */",
      "file" : "maze.c"
   },
   {
      "function" : "locateJpegImageParameters",
      "comment" : "/*\n *  locateJpegImageParameters()\n *\n *      Input:  inarray (binary jpeg)\n *              size (of the data array)\n *              &index (<return> location of image metadata)\n *      Return: 0 if OK, 1 on error.  Caller must check this!\n *\n *  Notes:\n *      (1) The metadata in jpeg files is a mess.  There are markers\n *          for the chunks that are always preceeded by 0xff.\n *          It is possible to have 0xff in the binary data that is\n *          not a marker, and this is always 'escaped' by a following\n *          0x0 byte.  The two bytes following the marker give the\n *          chunk size, inclusive of those two bytes.  The jpeg parser\n *          runs through the file, looking for special markers such\n *          as 0xc0 and 0xc2 that indicate the beginning of a metadata\n *          frame that gives the image size, depth, etc.\n *      (2) The markers listed here appear to be the only ones that\n *          we need to worry about.  It would have been nice to have\n *          avoided the switch with all these markers, but\n *          unfortunately the parser for the jpeg header is set\n *          to accept any byte marker that's not on the approved list!\n *          So we have to look for a flag that's not on the list\n *          (and is not 0 or followed by 0xff), and then interpret\n *          the size of the data chunk and skip it.  Why do this?\n *          Such a chunk may contain a thumbnail version of the image,\n *          so if we don't skip it, we will find a pair of bytes such\n *          as 0xffc0 within the chunk, followed by the metadata\n *          (e.g., w and h dimensions) for the thumbnail.  Not what we want.\n *      (3) There exist jpeg files with the sequence 0xffXXff, where XX\n *          is apparently a random marker not on the 'approved' list.\n *          These clearly need to be escaped, because there are no\n *          chunks of size as great as 0xff00 that can be skipped\n *          (remember: for chunks that must be skipped, the 2 bytes\n *          after the marker give the chunk size).\n *      (4) For marker definitions, see, e.g.:\n *               http://www.digicamsoft.com/itu/itu-t81-36.html\n */",
      "file" : "jpegio.c"
   },
   {
      "function" : "locateOutsideSeedPixel",
      "comment" : "/*!\n *  locateOutsideSeedPixel()\n *\n *      Input: fpx, fpy    (location of first pixel)\n *             spx, spy    (location of second pixel)\n *             &xs, &xy    (seed pixel to be returned)\n *\n *  Notes:\n *      (1) the first and second pixels must be 8-adjacent,\n *          so |dx| <= 1 and |dy| <= 1 and both dx and dy\n *          cannot be 0.  There are 8 possible cases.\n *      (2) the seed pixel is OUTSIDE the foreground of the c.c.\n *      (3) these rules are for the situation where the INSIDE\n *          of the c.c. is on the right as you follow the border:\n *          cw for an exterior border and ccw for a hole border.\n */",
      "file" : "ccbord.c"
   },
   {
      "function" : "locatePtRadially",
      "comment" : "/*!\n *  locatePtRadially()\n *\n *      Input:  xr, yr  (reference point)\n *              radang (angle in radians, CW from horizontal)\n *              dist (distance of point from reference point along line\n *                    given by the specified angle)\n *              &x, &y (<return> location of point)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "lqueueAdd",
      "comment" : "/*!\n *  lqueueAdd()\n *\n *      Input:  lqueue\n *              item to be added to the tail of the queue\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The algorithm is as follows.  If the queue is populated\n *          to the end of the allocated array, shift all ptrs toward\n *          the beginning of the array, so that the head of the queue\n *          is at the beginning of the array.  Then, if the array is\n *          more than 0.75 full, realloc with double the array size.\n *          Finally, add the item to the tail of the queue.\n */",
      "file" : "queue.c"
   },
   {
      "function" : "lqueueCreate",
      "comment" : "/*!\n *  lqueueCreate()\n *\n *      Input:  size of ptr array to be alloc'd (0 for default)\n *      Return: lqueue, or null on error\n *\n *  Notes:\n *      (1) Allocates a ptr array of given size, and initializes counters.\n */",
      "file" : "queue.c"
   },
   {
      "function" : "lqueueDestroy",
      "comment" : "/*!\n *  lqueueDestroy()\n *\n *      Input:  &lqueue  (<to be nulled>)\n *              freeflag (TRUE to free each remaining struct in the array)\n *      Return: void\n *\n *  Notes:\n *      (1) If freeflag is TRUE, frees each struct in the array.\n *      (2) If freeflag is FALSE but there are elements on the array,\n *          gives a warning and destroys the array.  This will\n *          cause a memory leak of all the items that were on the queue.\n *          So if the items require their own destroy function, they\n *          must be destroyed before the queue.  The same applies to the\n *          auxiliary stack, if it is used.\n *      (3) To destroy the L_Queue, we destroy the ptr array, then\n *          the lqueue, and then null the contents of the input ptr.\n */",
      "file" : "queue.c"
   },
   {
      "function" : "lqueueExtendArray",
      "comment" : "/*!\n *  lqueueExtendArray()\n *\n *      Input:  lqueue\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "queue.c"
   },
   {
      "function" : "lqueueGetCount",
      "comment" : "/*!\n *  lqueueGetCount()\n *\n *      Input:  lqueue\n *      Return: count, or 0 on error\n */",
      "file" : "queue.c"
   },
   {
      "function" : "lqueuePrint",
      "comment" : "/*!\n *  lqueuePrint()\n *\n *      Input:  stream\n *              lqueue\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "queue.c"
   },
   {
      "function" : "lqueueRemove",
      "comment" : "/*!\n *  lqueueRemove()\n *\n *      Input:  lqueue\n *      Return: ptr to item popped from the head of the queue,\n *              or null if the queue is empty or on error\n *\n *  Notes:\n *      (1) If this is the last item on the queue, so that the queue\n *          becomes empty, nhead is reset to the beginning of the array.\n */",
      "file" : "queue.c"
   },
   {
      "function" : "lstackAdd",
      "comment" : "/*!\n *  lstackAdd()\n *\n *      Input:  lstack\n *              item to be added to the lstack\n *      Return: 0 if OK; 1 on error.\n */",
      "file" : "stack.c"
   },
   {
      "function" : "lstackCreate",
      "comment" : "/*!\n *  lstackCreate()\n *\n *      Input:  nalloc (initial ptr array size; use 0 for default)\n *      Return: lstack, or null on error\n */",
      "file" : "stack.c"
   },
   {
      "function" : "lstackDestroy",
      "comment" : "/*!\n *  lstackDestroy()\n *\n *      Input:  &lstack (<to be nulled>)\n *              freeflag (TRUE to free each remaining struct in the array)\n *      Return: void\n *\n *  Notes:\n *      (1) If freeflag is TRUE, frees each struct in the array.\n *      (2) If freeflag is FALSE but there are elements on the array,\n *          gives a warning and destroys the array.  This will\n *          cause a memory leak of all the items that were on the lstack.\n *          So if the items require their own destroy function, they\n *          must be destroyed before the lstack.\n *      (3) To destroy the lstack, we destroy the ptr array, then\n *          the lstack, and then null the contents of the input ptr.\n */",
      "file" : "stack.c"
   },
   {
      "function" : "lstackExtendArray",
      "comment" : "/*!\n *  lstackExtendArray()\n *\n *      Input:  lstack\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "stack.c"
   },
   {
      "function" : "lstackGetCount",
      "comment" : "/*!\n *  lstackGetCount()\n *\n *      Input:  lstack\n *      Return: count, or 0 on error\n */",
      "file" : "stack.c"
   },
   {
      "function" : "lstackPrint",
      "comment" : "/*!\n *  lstackPrint()\n *\n *      Input:  stream\n *              lstack\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "stack.c"
   },
   {
      "function" : "lstackRemove",
      "comment" : "/*!\n *  lstackRemove()\n *\n *      Input:  lstack\n *      Return: ptr to item popped from the top of the lstack,\n *              or null if the lstack is empty or on error\n */",
      "file" : "stack.c"
   },
   {
      "function" : "main",
      "comment" : "/*\n *    endiantest.c\n *\n *    This test was contributed by Bill Janssen.  When used with the\n *    gnu compiler, it allows efficient computation of the endian\n *    flag as part of the normal compilation process.  As a result,\n *    it is not necessary to set this flag either manually or\n *    through the configure Makefile generator.\n */",
      "file" : "endiantest.c"
   },
   {
      "function" : "main",
      "comment" : "/* Cygwin needs an extension to prevent it from appending\n     * \".exe\" to the filename */",
      "file" : "xtractprotos.c"
   },
   {
      "function" : "make8To1DitherTables",
      "comment" : "/*!\n *  make8To1DitherTables()\n *\n *      Input: &tabval (value assigned to output pixel; 0 or 1)\n *             &tab38  (amount propagated to pixels left and below)\n *             &tab14  (amount propagated to pixel to left and down)\n *             lowerclip (values near 0 where the excess is not propagated)\n *             upperclip (values near 255 where the deficit is not propagated)\n *\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "grayquantlow.c"
   },
   {
      "function" : "make8To2DitherTables",
      "comment" : "/*!\n *  make8To2DitherTables()\n *\n *      Input: &tabval (value assigned to output pixel; 0, 1, 2 or 3)\n *             &tab38  (amount propagated to pixels left and below)\n *             &tab14  (amount propagated to pixel to left and down)\n *             cliptoblack (values near 0 where the excess is not propagated)\n *             cliptowhite (values near 255 where the deficit is not propagated)\n *\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "grayquantlow.c"
   },
   {
      "function" : "makeBarrelshiftString",
      "comment" : "/*!\n *  makeBarrelshiftString()\n */",
      "file" : "fhmtauto.c"
   },
   {
      "function" : "makeBarrelshiftString",
      "comment" : "/*!\n *  makeBarrelshiftString()\n */",
      "file" : "fmorphauto.c"
   },
   {
      "function" : "makeDoGKernel",
      "comment" : "/*!\n *  makeDoGKernel()\n *\n *      Input:  halfheight, halfwidth (sx = 2 * halfwidth + 1, etc)\n *              stdev (standard deviation of narrower gaussian)\n *              ratio (of stdev for wide filter to stdev for narrow one)\n *      Return: kernel, or null on error\n *\n *  Notes:\n *      (1) The DoG (difference of gaussians) is a wavelet mother\n *          function with null total sum.  By subtracting two blurred\n *          versions of the image, it acts as a bandpass filter for\n *          frequencies passed by the narrow gaussian but stopped\n *          by the wide one.See:\n *               http://en.wikipedia.org/wiki/Difference_of_Gaussians\n *      (2) The kernel size (sx, sy) = (2 * halfwidth + 1, 2 * halfheight + 1).\n *      (3) The kernel center (cx, cy) = (halfwidth, halfheight).\n *      (4) The halfwidth and halfheight are typically equal, and\n *          are typically several times larger than the standard deviation.\n *      (5) The ratio is the ratio of standard deviations of the wide\n *          to narrow gaussian.  It must be >= 1.0; 1.0 is a no-op.\n *      (6) Because the kernel is a null sum, it must be invoked without\n *          normalization in pixConvolve().\n */",
      "file" : "kernel.c"
   },
   {
      "function" : "makeExpandTab2x",
      "comment" : "/*-------------------------------------------------------------------*\n *             Expansion tables for 2x, 4x and 8x expansion          *\n *-------------------------------------------------------------------*/",
      "file" : "binexpand.c"
   },
   {
      "function" : "makeExpandTab4x",
      "comment" : "/*-------------------------------------------------------------------*\n *             Expansion tables for 2x, 4x and 8x expansion          *\n *-------------------------------------------------------------------*/",
      "file" : "binexpand.c"
   },
   {
      "function" : "makeExpandTab8x",
      "comment" : "/*-------------------------------------------------------------------*\n *             Expansion tables for 2x, 4x and 8x expansion          *\n *-------------------------------------------------------------------*/",
      "file" : "binexpand.c"
   },
   {
      "function" : "makeFlatKernel",
      "comment" : "/*!\n *  makeFlatKernel()\n *\n *      Input:  height, width\n *              cy, cx (origin of kernel)\n *      Return: kernel, or null on error\n *\n *  Notes:\n *      (1) This is the same low-pass filtering kernel that is used\n *          in the block convolution functions.\n *      (2) The kernel origin (@cy, @cx) is typically placed as near\n *          the center of the kernel as possible.  If height and\n *          width are odd, then using cy = height / 2 and\n *          cx = width / 2 places the origin at the exact center.\n *      (3) This returns a normalized kernel.\n */",
      "file" : "kernel.c"
   },
   {
      "function" : "makeGaussianKernel",
      "comment" : "/*!\n *  makeGaussianKernel()\n *\n *      Input:  halfheight, halfwidth (sx = 2 * halfwidth + 1, etc)\n *              stdev (standard deviation)\n *              max (value at (cx,cy))\n *      Return: kernel, or null on error\n *\n *  Notes:\n *      (1) The kernel size (sx, sy) = (2 * halfwidth + 1, 2 * halfheight + 1).\n *      (2) The kernel center (cx, cy) = (halfwidth, halfheight).\n *      (3) The halfwidth and halfheight are typically equal, and\n *          are typically several times larger than the standard deviation.\n *      (4) If pixConvolve() is invoked with normalization (the sum of\n *          kernel elements = 1.0), use 1.0 for max (or any number that's\n *          not too small or too large).\n */",
      "file" : "kernel.c"
   },
   {
      "function" : "makeGaussianKernelSep",
      "comment" : "/*!\n *  makeGaussianKernelSep()\n *\n *      Input:  halfheight, halfwidth (sx = 2 * halfwidth + 1, etc)\n *              stdev (standard deviation)\n *              max (value at (cx,cy))\n *              &kelx (<return> x part of kernel)\n *              &kely (<return> y part of kernel)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) See makeGaussianKernel() for description of input parameters.\n *      (2) These kernels are constructed so that the result of both\n *          normalized and un-normalized convolution will be the same\n *          as when convolving with pixConvolve() using the full kernel.\n *      (3) The trick for the un-normalized convolution is to have the\n *          product of the two kernel elemets at (cx,cy) be equal to max,\n *          not max**2.  That's why the max for kely is 1.0.  If instead\n *          we use sqrt(max) for both, the results are slightly less\n *          accurate, when compared to using the full kernel in\n *          makeGaussianKernel().\n */",
      "file" : "kernel.c"
   },
   {
      "function" : "makeGrayQuantColormapArb",
      "comment" : "/*!\n *  makeGrayQuantColormapArb()\n *\n *      Input:  pixs (8 bpp)\n *              tab (table mapping input gray level to cmap index)\n *              outdepth (of colormap: 1, 2, 4 or 8)\n *              &cmap (<return> colormap)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The table is a 256-entry inverse colormap: it maps input gray\n *          level to colormap index (the bin number).  It is computed\n *          using makeGrayQuantTableArb().\n *      (2) The colormap generated here has quantized values at the\n *          average gray value of the pixels that are in each bin.\n *      (3) Returns an error if there are not enough levels in the\n *          output colormap for the number of bins.  The number\n *          of bins must not exceed 2^outdepth.\n */",
      "file" : "grayquant.c"
   },
   {
      "function" : "makeGrayQuantIndexTable",
      "comment" : "/*!\n *  makeGrayQuantIndexTable()\n *\n *      Input:  nlevels (number of output levels)\n *      Return: table (maps input gray level to colormap index,\n *                     or null on error)\n *  Notes:\n *      (1) 'nlevels' is some number between 2 and 256 (typically 8 or less).\n *      (2) The table is typically used for quantizing 2, 4 and 8 bpp\n *          grayscale src pix, and generating a colormapped dest pix.\n */",
      "file" : "grayquant.c"
   },
   {
      "function" : "makeGrayQuantTableArb",
      "comment" : "/*!\n *  makeGrayQuantTableArb()\n *\n *      Input:  na (numa of bin boundaries)\n *              outdepth (of colormap: 1, 2, 4 or 8)\n *              &tab (<return> table mapping input gray level to cmap index)\n *              &cmap (<return> colormap)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The number of bins is the count of @na + 1.\n *      (2) The bin boundaries in na must be sorted in increasing order.\n *      (3) The table is an inverse colormap: it maps input gray level\n *          to colormap index (the bin number).\n *      (4) The colormap generated here has quantized values at the\n *          center of each bin.  If you want to use the average gray\n *          value of pixels within the bin, discard the colormap and\n *          compute it using makeGrayQuantColormapArb().\n *      (5) Returns an error if there are not enough levels in the\n *          output colormap for the number of bins.  The number\n *          of bins must not exceed 2^outdepth.\n */",
      "file" : "grayquant.c"
   },
   {
      "function" : "makeGrayQuantTargetTable",
      "comment" : "/*!\n *  makeGrayQuantTargetTable()\n *\n *      Input:  nlevels (number of output levels)\n *              depth (of dest pix, in bpp; 2, 4 or 8 bpp)\n *      Return: table (maps input gray level to thresholded gray level,\n *                     or null on error)\n *\n *  Notes:\n *      (1) nlevels is some number between 2 and 2^(depth)\n *      (2) The table is used in two similar ways:\n *           - for 8 bpp, it quantizes to a given number of target levels\n *           - for 2 and 4 bpp, it thresholds to appropriate target values\n *             that will use the full dynamic range of the dest pix.\n *      (3) For depth = 8, the number of thresholds chosen is\n *          ('nlevels' - 1), and the 'nlevels' values stored in the\n *          table are at the two at the extreme ends, (0, 255), plus\n *          plus ('nlevels' - 2) values chosen at equal intervals between.\n *          For example, for depth = 8 and 'nlevels' = 3, the two\n *          threshold values are 3f and bf, and the three target pixel\n *          values are 0, 7f and ff.\n *      (4) For depth < 8, we ignore nlevels, and always use the maximum\n *          number of levels, which is 2^(depth).\n *          If you want nlevels < the maximum number, you should always\n *          use a colormap.\n */",
      "file" : "grayquant.c"
   },
   {
      "function" : "makeLogBase2Tab",
      "comment" : "/*\n *  makeLogBase2Tab()\n *\n *      Input: void\n *      Return: table (giving the log[base 2] of val)\n */",
      "file" : "pixarith.c"
   },
   {
      "function" : "makeMSBitLocTab",
      "comment" : "/*!\n *  makeMSBitLocTab()\n *\n *      Input:  bitval (either 0 or 1)\n *      Return: table (giving, for an input byte, the MS bit location,\n *                     starting at 0 with the MSBit in the byte),\n *                     or null on error.\n *\n *  Notes:\n *      (1) If bitval == 1, it finds the leftmost ON pixel in a byte;\n *          otherwise if bitval == 0, it finds the leftmost OFF pixel.\n *      (2) If there are no pixels of the indicated color in the byte,\n *          this returns 8.\n */",
      "file" : "runlength.c"
   },
   {
      "function" : "makeOrientDecision",
      "comment" : "/*!\n *  makeOrientDecision()\n *\n *      Input:  upconf (nonzero)\n *              leftconf (nonzero)\n *              minupconf (minimum value for which a decision can be made)\n *              minratio (minimum conf ratio required for a decision)\n *              &orient (<return> text orientation enum {0,1,2,3,4})\n *              debug (1 for debug output; 0 otherwise)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This can be run after pixOrientDetect()\n *      (2) Both upconf and leftconf must be nonzero; otherwise the\n *          orientation cannot be determined.\n *      (3) The abs values of the input confidences are compared to\n *          minupconf.\n *      (4) The abs value of the largest of (upconf/leftconf) and\n *          (leftconf/upconf) is compared with minratio.\n *      (5) Input 0.0 for the default values for minupconf and minratio.\n *      (6) The return value of orient is interpreted thus:\n *            L_TEXT_ORIENT_UNKNOWN:  not enough evidence to determine\n *            L_TEXT_ORIENT_UP:       text rightside-up\n *            L_TEXT_ORIENT_LEFT:     landscape, text up facing left\n *            L_TEXT_ORIENT_DOWN:     text upside-down\n *            L_TEXT_ORIENT_RIGHT:    landscape, text up facing right\n */",
      "file" : "flipdetect.c"
   },
   {
      "function" : "makePixelCentroidTab8",
      "comment" : "/*!\n *  makePixelCentroidTab8()\n *\n *      Input:  void\n *      Return: table of 256 l_int32, or null on error\n *\n *  Notes:\n *      (1) This table of integers gives the centroid weight of the 1 bits\n *          in the 8 bit index.  In other words, if sumtab is obtained by\n *          makePixelSumTab8, and centroidtab is obtained by\n *          makePixelCentroidTab8, then, for 1 <= i <= 255,\n *          centroidtab[i] / (float)sumtab[i]\n *          is the centroid of the 1 bits in the 8-bit index i, where the\n *          MSB is considered to have position 0 and the LSB is considered\n *          to have position 7.\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "makePixelSumTab8",
      "comment" : "/*!\n *  makePixelSumTab8()\n *\n *      Input:  void\n *      Return: table of 256 l_int32, or null on error\n *\n *  Notes:\n *      (1) This table of integers gives the number of 1 bits\n *          in the 8 bit index.\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "makeRGBIndexTables",
      "comment" : "/*!\n *  makeRGBIndexTables()\n *\n *      Input:  &rtab, &gtab, &btab (<return> 256-entry index tables)\n *              sigbits (2-6, significant bits retained in the quantizer\n *                       for each component of the input image)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) These tables are used to map from rgb sample values to\n *          an rgb index, using\n *             rgbindex = rtab[rval] | gtab[gval] | btab[bval]\n *          where, e.g., if sigbits = 3, the index is a 9 bit integer:\n *             r7 r6 r5 g7 g6 g5 b7 b6 b5\n */",
      "file" : "colorcontent.c"
   },
   {
      "function" : "makeRGBToIndexTables",
      "comment" : "/*!\n *  makeRGBToIndexTables()\n *\n *      Input:  &rtab, &gtab, &btab  (<return> tables)\n *              cqlevels (can be 1, 2, 3, 4, 5 or 6)\n *      Return: 0 if OK; 1 on error\n *\n *  Set up tables.  e.g., for cqlevels = 5, we need an integer 0 < i < 2^15:\n *      rtab = (0  i7  0   0  i6  0   0  i5  0   0   i4  0   0   i3  0   0)\n *      gtab = (0  0   i7  0   0  i6  0   0  i5  0   0   i4  0   0   i3  0)\n *      btab = (0  0   0   i7  0  0   i6  0  0   i5  0   0   i4  0   0   i3)\n *\n *  The tables are then used to map from rbg --> index as follows:\n *      index = (0  r7  g7  b7  r6  g6  b6  r5  g5  b5  r4  g4  b4  r3  g3  b3)\n *\n *    e.g., for cqlevels = 4, we map to\n *      index = (0  0   0   0   r7  g7  b7  r6  g6  b6  r5  g5  b5  r4  g4  b4)\n *\n *  This may look a bit strange.  The notation 'r7' means the MSBit of\n *  the r value (which has 8 bits, going down from r7 to r0).\n *  Keep in mind that r7 is actually the r component bit for level 1 of\n *  the octtree.  Level 1 is composed of 8 octcubes, represented by\n *  the bits (r7 g7 b7), which divide the entire color space into\n *  8 cubes.  At level 2, each of these 8 octcubes is further divided into\n *  8 cubes, each labeled by the second most significant bits (r6 g6 b6)\n *  of the rgb color.\n */",
      "file" : "colorquant1.c"
   },
   {
      "function" : "makeRangeKernel",
      "comment" : "/*!\n *  makeRangeKernel()\n *\n *      Input:  range_stdev (> 0)\n *      Return: kel, or null on error\n *\n *  Notes:\n *      (1) Creates a one-sided Gaussian kernel with the given\n *          standard deviation.  At grayscale difference of one stdev,\n *          the kernel falls to 0.6, and to 0.01 at three stdev.\n *      (2) A typical input number might be 20.  Then pixels whose\n *          value differs by 60 from the center pixel have their\n *          weight in the convolution reduced by a factor of about 0.01.\n */",
      "file" : "bilateral.c"
   },
   {
      "function" : "makeReverseByteTab1",
      "comment" : "/*!\n *  makeReverseByteTab1()\n *\n *  Notes:\n *      (1) This generates an 8 bit lookup table for reversing\n *          the order of eight 1-bit pixels.\n */",
      "file" : "rotateorthlow.c"
   },
   {
      "function" : "makeReverseByteTab2",
      "comment" : "/*!\n *  makeReverseByteTab2()\n *\n *  Notes:\n *      (1) This generates an 8 bit lookup table for reversing\n *          the order of four 2-bit pixels.\n */",
      "file" : "rotateorthlow.c"
   },
   {
      "function" : "makeReverseByteTab4",
      "comment" : "/*!\n *  makeReverseByteTab4()\n *\n *  Notes:\n *      (1) This generates an 8 bit lookup table for reversing\n *          the order of two 4-bit pixels.\n */",
      "file" : "rotateorthlow.c"
   },
   {
      "function" : "makeSinLUT",
      "comment" : "/*!\n *  applyWarpTransformLUT()\n *\n *  Notes:\n *      (1) Uses an LUT for computing sin(theta).  There is little speed\n *          advantage to using the LUT.\n */",
      "file" : "warper.c"
   },
   {
      "function" : "makeSubsampleTab2x",
      "comment" : "/*!\n *  makeSubsampleTab2x()\n *\n *  This table permutes the bits in a byte, from\n *      0 4 1 5 2 6 3 7\n *  to\n *      0 1 2 3 4 5 6 7\n */",
      "file" : "binreduce.c"
   },
   {
      "function" : "makeSumTabSG2",
      "comment" : "/*!\n *  makeSumTabSG2()\n *\n *  Returns a table of 256 l_uint32s, giving the four output\n *  8-bit grayscale sums corresponding to 8 input bits of a binary\n *  image, for a 2x scale-to-gray op.  The sums from two\n *  adjacent scanlines are then added and transformed to\n *  output four 8 bpp pixel values, using makeValTabSG2().\n */",
      "file" : "scalelow.c"
   },
   {
      "function" : "makeSumTabSG3",
      "comment" : "/*!\n *  makeSumTabSG3()\n *\n *  Returns a table of 64 l_uint32s, giving the two output\n *  8-bit grayscale sums corresponding to 6 input bits of a binary\n *  image, for a 3x scale-to-gray op.  In practice, this would\n *  be used three times (on adjacent scanlines), and the sums would\n *  be added and then transformed to output 8 bpp pixel values,\n *  using makeValTabSG3().\n */",
      "file" : "scalelow.c"
   },
   {
      "function" : "makeSumTabSG4",
      "comment" : "/*!\n *  makeSumTabSG4()\n *\n *  Returns a table of 256 l_uint32s, giving the two output\n *  8-bit grayscale sums corresponding to 8 input bits of a binary\n *  image, for a 4x scale-to-gray op.  The sums from four\n *  adjacent scanlines are then added and transformed to\n *  output 8 bpp pixel values, using makeValTabSG4().\n */",
      "file" : "scalelow.c"
   },
   {
      "function" : "makeTrailerStringPdf",
      "comment" : "/* Now make the actual trailer string */",
      "file" : "pdfio.c"
   },
   {
      "function" : "makeValTabSG2",
      "comment" : "/*!\n *  makeValTabSG2()\n *\n *  Returns an 8 bit value for the sum of ON pixels\n *  in a 2x2 square, according to\n *\n *         val = 255 - (255 * sum)/4\n *\n *  where sum is in set {0,1,2,3,4}\n */",
      "file" : "scalelow.c"
   },
   {
      "function" : "makeValTabSG3",
      "comment" : "/*!\n *  makeValTabSG3()\n *\n *  Returns an 8 bit value for the sum of ON pixels\n *  in a 3x3 square, according to\n *      val = 255 - (255 * sum)/9\n *  where sum is in set {0, ... ,9}\n */",
      "file" : "scalelow.c"
   },
   {
      "function" : "makeValTabSG4",
      "comment" : "/*!\n *  makeValTabSG4()\n *\n *  Returns an 8 bit value for the sum of ON pixels\n *  in a 4x4 square, according to\n *\n *         val = 255 - (255 * sum)/16\n *\n *  where sum is in set {0, ... ,16}\n */",
      "file" : "scalelow.c"
   },
   {
      "function" : "makeValTabSG6",
      "comment" : "/*!\n *  makeValTabSG6()\n *\n *  Returns an 8 bit value for the sum of ON pixels\n *  in a 6x6 square, according to\n *      val = 255 - (255 * sum)/36\n *  where sum is in set {0, ... ,36}\n */",
      "file" : "scalelow.c"
   },
   {
      "function" : "makeValTabSG8",
      "comment" : "/*!\n *  makeValTabSG8()\n *\n *  Returns an 8 bit value for the sum of ON pixels\n *  in an 8x8 square, according to\n *      val = 255 - (255 * sum)/64\n *  where sum is in set {0, ... ,64}\n */",
      "file" : "scalelow.c"
   },
   {
      "function" : "mazeelCreate",
      "comment" : "/* not a wall */",
      "file" : "maze.c"
   },
   {
      "function" : "medianCutApply",
      "comment" : "/*!\n *  medianCutApply()\n *\n *      Input:  histo  (array; in rgb colorspace)\n *              sigbits\n *              vbox (input 3D box)\n *              &vbox1, vbox2 (<return> vbox split in two parts)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "colorquant2.c"
   },
   {
      "function" : "memstreamCreateForRead",
      "comment" : "/* These are static functions for memory I/O */",
      "file" : "tiffio.c"
   },
   {
      "function" : "memstreamCreateForWrite",
      "comment" : "/* offset always starts at 0 */",
      "file" : "tiffio.c"
   },
   {
      "function" : "mergeLookup",
      "comment" : "/*!\n *  mergeLookup()\n *\n *      Input:  wshed\n *              sindex (primary index being changed in the merge)\n *              dindex (index that @sindex will point to after the merge)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The links are a sparse array of Numas showing current back-links.\n *          The lut gives the current index (of the seed or the minima\n *          for the wshed  in which it is located.\n *      (2) Think of each entry in the lut.  There are two types:\n *             owner:     lut[index] = index\n *             redirect:  lut[index] != index\n *      (3) This is called each time a merge occurs.  It puts the lut\n *          and backlinks in a canonical form after the merge, where\n *          all entries in the lut point to the current \"owner\", which\n *          has all backlinks.  That is, every \"redirect\" in the lut\n *          points to an \"owner\".  The lut always gives the index of\n *          the current owner.\n */",
      "file" : "watershed.c"
   },
   {
      "function" : "morphSequenceVerify",
      "comment" : "/*!\n *  morphSequenceVerify()\n *\n *      Input:  sarray (of operation sequence)\n *      Return: TRUE if valid; FALSE otherwise or on error\n *\n *  Notes:\n *      (1) This does verification of valid binary morphological\n *          operation sequences.\n *      (2) See pixMorphSequence() for notes on valid operations\n *          in the sequence.\n */",
      "file" : "morphseq.c"
   },
   {
      "function" : "nbytesInFile",
      "comment" : "/*!\n *  nbytesInFile()\n *\n *      Input:  filename\n *      Return: nbytes in file; 0 on error\n */",
      "file" : "utils.c"
   },
   {
      "function" : "nextOnPixelInRaster",
      "comment" : "/*!\n *  nextOnPixelInRaster()\n *\n *      Input:  pixs (1 bpp)\n *              xstart, ystart  (starting point for search)\n *              &x, &y  (<return> coord value of next ON pixel)\n *      Return: 1 if a pixel is found; 0 otherwise or on error\n */",
      "file" : "conncomp.c"
   },
   {
      "function" : "nextOnPixelInRasterLow",
      "comment" : "/*!\n *  nextOnPixelInRaster()\n *\n *      Input:  pixs (1 bpp)\n *              xstart, ystart  (starting point for search)\n *              &x, &y  (<return> coord value of next ON pixel)\n *      Return: 1 if a pixel is found; 0 otherwise or on error\n */",
      "file" : "conncomp.c"
   },
   {
      "function" : "normalizeAngleForShear",
      "comment" : "/*-------------------------------------------------------------------------*\n *                           Angle normalization                           *\n *-------------------------------------------------------------------------*/",
      "file" : "shear.c"
   },
   {
      "function" : "numa2dAddNumber",
      "comment" : "/*!\n *  numa2dAddNumber()\n *\n *      Input:  na2d\n *              row of 2d array\n *              col of 2d array\n *              val  (float or int to be added; stored as a float)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numa2dCreate",
      "comment" : "/*!\n *  numa2dCreate()\n *\n *      Input:  nrows (of 2d array)\n *              ncols (of 2d array)\n *              initsize (initial size of each allocated numa)\n *      Return: numa2d, or null on error\n *\n *  Notes:\n *      (1) The numa2d holds a doubly-indexed array of numa.\n *      (2) The numa ptr array is initialized with all ptrs set to NULL.\n *      (3) The numas are created only when a number is to be stored\n *          at an index (i,j) for which a numa has not yet been made.\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numa2dDestroy",
      "comment" : "/*!\n *  numa2dDestroy()\n *\n *      Input:  &numa2d (<to be nulled if it exists>)\n *      Return: void\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numa2dGetCount",
      "comment" : "/*!\n *  numa2dGetCount()\n *\n *      Input:  na2d\n *              row of 2d array\n *              col of 2d array\n *      Return: size of numa at [row][col], or 0 if the numa doesn't exist\n *              or on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numa2dGetFValue",
      "comment" : "/*!\n *  numa2dGetFValue()\n *\n *      Input:  na2d\n *              row of 2d array\n *              col of 2d array\n *              index (into numa)\n *              &val (<return> float value)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numa2dGetIValue",
      "comment" : "/*!\n *  numa2dGetIValue()\n *\n *      Input:  na2d\n *              row of 2d array\n *              col of 2d array\n *              index (into numa)\n *              &val (<return> integer value)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numa2dGetNuma",
      "comment" : "/*!\n *  numa2dGetNuma()\n *\n *      Input:  na2d\n *              row of 2d array\n *              col of 2d array\n *      Return: na (a clone of the numa if it exists) or null if it doesn't\n *\n *  Notes:\n *      (1) This does not give an error if the index is out of bounds.\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaAddBorder",
      "comment" : "/*!\n *  numaAddBorder()\n *\n *      Input:  nas\n *              left, right (number of elements to add on each side)\n *              val (initialize border elements)\n *      Return: nad (with added elements at left and right), or null on error\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaAddNumber",
      "comment" : "/*!\n *  numaAddNumber()\n *\n *      Input:  na\n *              val  (float or int to be added; stored as a float)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaAddSpecifiedBorder",
      "comment" : "/*!\n *  numaAddSpecifiedBorder()\n *\n *      Input:  nas\n *              left, right (number of elements to add on each side)\n *              type (L_CONTINUED_BORDER, L_MIRRORED_BORDER)\n *      Return: nad (with added elements at left and right), or null on error\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaAddToNumber",
      "comment" : "/*!\n *  numaAddToNumber()\n *\n *      Input:  na\n *              index (element to be changed)\n *              val (new value to be added)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is useful for accumulating sums, regardless of the index\n *          order in which the values are made available.\n *      (2) Before use, the numa has to be filled up to @index.  This would\n *          typically be used by creating the numa with the full sized\n *          array, initialized to 0.0, using numaMakeConstant().\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaArithOp",
      "comment" : "/*!\n *  numaArithOp()\n *\n *      Input:  nad (<optional> can be null or equal to na1 (in-place)\n *              na1\n *              na2\n *              op (L_ARITH_ADD, L_ARITH_SUBTRACT,\n *                  L_ARITH_MULTIPLY, L_ARITH_DIVIDE)\n *      Return: nad (always: operation applied to na1 and na2)\n *\n *  Notes:\n *      (1) The sizes of na1 and na2 must be equal.\n *      (2) nad can only null or equal to na1.\n *      (3) To add a constant to a numa, or to multipy a numa by\n *          a constant, use numaTransform().\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaBinSort",
      "comment" : "/*!\n *  numaBinSort()\n *\n *      Input:  nas (of non-negative integers with a max that is\n *                   typically less than 50,000)\n *              sortorder (L_SORT_INCREASING or L_SORT_DECREASING)\n *      Return: na (sorted), or null on error\n *\n *  Notes:\n *      (1) Because this uses a bin sort with buckets of size 1, it\n *          is not appropriate for sorting either small arrays or\n *          arrays containing very large integer values.  For such\n *          arrays, use a standard general sort function like\n *          numaSort().\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaChangeRefcount",
      "comment" : "/*!\n *  numaChangeRefCount()\n *\n *      Input:  na\n *              delta (change to be applied)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaChooseSortType",
      "comment" : "/*!\n *  numaChooseSortType()\n *\n *      Input:  na (to be sorted)\n *      Return: sorttype (L_SHELL_SORT or L_BIN_SORT), or UNDEF on error.\n *\n *  Notes:\n *      (1) This selects either a shell sort or a bin sort, depending on\n *          the number of elements in nas and the dynamic range.\n *      (2) If there are negative values in nas, it selects shell sort.\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaClipToInterval",
      "comment" : "/*!\n *  numaClipToInterval()\n *\n *      Input:  numa\n *              first, last (clipping interval)\n *      Return: numa with the same values as the input, but clipped\n *              to the specified interval\n *\n *  Note: If you want the indices of the array values to be unchanged,\n *        use first = 0.\n *  Usage: This is useful to clip a histogram that has a few nonzero\n *         values to its nonzero range.\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaClone",
      "comment" : "/*!\n *  numaClone()\n *\n *      Input:  na\n *      Return: ptr to same numa, or null on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaClose",
      "comment" : "/*!\n *  numaClose()\n *\n *      Input:  nas\n *              size (of sel; greater than 0, odd; origin implicitly in center)\n *      Return: nad (opened), or null on error\n *\n *  Notes:\n *      (1) The structuring element (sel) is linear, all \"hits\"\n *      (2) If size == 1, this returns a copy\n *      (3) We add a border before doing this operation, for the same\n *          reason that we add a border to a pix before doing a safe closing.\n *          Without the border, a small component near the border gets\n *          clipped at the border on dilation, and can be entirely removed\n *          by the following erosion, violating the basic extensivity\n *          property of closing.\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaContrastTRC",
      "comment" : "/*!\n *  numaContrastTRC()\n *\n *      Input:  factor (generally between 0.0 (no enhancement)\n *              and 1.0, but can be larger than 1.0)\n *      Return: na, or null on error\n *\n *  Notes:\n *      (1) The mapping is monotonic increasing, where 0 is mapped\n *          to 0 and 255 is mapped to 255.\n *      (2) As 'factor' is increased from 0.0 (where the mapping is linear),\n *          the map gets closer to its limit as a step function that\n *          jumps from 0 to 255 at the center (input value = 127).\n */",
      "file" : "enhance.c"
   },
   {
      "function" : "numaConvertToDna",
      "comment" : "/*!\n *  numaConvertToDna\n *\n *      Input:  na\n *      Return: da, or null on error\n */",
      "file" : "dnabasic.c"
   },
   {
      "function" : "numaConvertToInt",
      "comment" : "/*!\n *  numaConvertToInt()\n *\n *      Input:  na\n *      Return: na with all values rounded to nearest integer, or\n *              null on error\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaConvertToSarray",
      "comment" : "/*!\n *  numaConvertToSarray()\n *\n *      Input:  na\n *              size1 (size of conversion field)\n *              size2 (for float conversion: size of field to the right\n *                     of the decimal point)\n *              addzeros (for integer conversion: to add lead zeros)\n *              type (L_INTEGER_VALUE, L_FLOAT_VALUE)\n *      Return: a sarray of the float values converted to strings\n *              representing either integer or float values; or null on error.\n *\n *  Notes:\n *      (1) For integer conversion, size2 is ignored.\n *          For float conversion, addzeroes is ignored.\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaCopy",
      "comment" : "/*!\n *  numaCopy()\n *\n *      Input:  na\n *      Return: copy of numa, or null on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaCopyParameters",
      "comment" : "/*!\n *  numaCopyParameters()\n *\n *      Input:  nad (destination Numa)\n *              nas (source Numa)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaCountReversals",
      "comment" : "/*!\n *  numaCountReversals()\n *\n *      Input:  nas (input values)\n *              minreversal (relative amount to resolve peaks and valleys)\n *              &nr (<optional return> number of reversals\n *              &nrpl (<optional return> reversal density: reversals/length)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The input numa is can be generated from pixExtractAlongLine().\n *          If so, the x parameters can be used to find the reversal\n *          frequency along a line.\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaCreate",
      "comment" : "/*!\n *  numaCreate()\n *\n *      Input:  size of number array to be alloc'd (0 for default)\n *      Return: na, or null on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaCreateFromFArray",
      "comment" : "/*!\n *  numaCreateFromFArray()\n *\n *      Input:  farray (float)\n *              size (of the array)\n *              copyflag (L_INSERT or L_COPY)\n *      Return: na, or null on error\n *\n *  Notes:\n *      (1) With L_INSERT, ownership of the input array is transferred\n *          to the returned numa, and all @size elements are considered\n *          to be valid.\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaCreateFromIArray",
      "comment" : "/*!\n *  numaCreateFromIArray()\n *\n *      Input:  iarray (integer)\n *              size (of the array)\n *      Return: na, or null on error\n *\n *  Notes:\n *      (1) We can't insert this int array into the numa, because a numa\n *          takes a float array.  So this just copies the data from the\n *          input array into the numa.  The input array continues to be\n *          owned by the caller.\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaCrossingsByPeaks",
      "comment" : "/*!\n *  numaCrossingsByPeaks()\n *\n *      Input:  nax (<optional> numa of abscissa values)\n *              nay (numa of ordinate values, corresponding to nax)\n *              delta (parameter used to identify when a new peak can be found)\n *      Return: nad (abscissa pts at threshold), or null on error\n *\n *  Notes:\n *      (1) If nax == NULL, we use startx and delx from nay to compute\n *          the crossing values in nad.\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaCrossingsByThreshold",
      "comment" : "/*!\n *  numaCrossingsByThreshold()\n *\n *      Input:  nax (<optional> numa of abscissa values; can be NULL)\n *              nay (numa of ordinate values, corresponding to nax)\n *              thresh (threshold value for nay)\n *      Return: nad (abscissa pts at threshold), or null on error\n *\n *  Notes:\n *      (1) If nax == NULL, we use startx and delx from nay to compute\n *          the crossing values in nad.\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaDestroy",
      "comment" : "/*!\n *  numaDestroy()\n *\n *      Input:  &na (<to be nulled if it exists>)\n *      Return: void\n *\n *  Notes:\n *      (1) Decrements the ref count and, if 0, destroys the numa.\n *      (2) Always nulls the input ptr.\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaDifferentiateInterval",
      "comment" : "/*!\n *  numaDifferentiateInterval()\n *\n *      Input:  nax (numa of abscissa values)\n *              nay (numa of ordinate values, corresponding to nax)\n *              x0 (start value of interval)\n *              x1 (end value of interval)\n *              npts (number of points to evaluate function in interval)\n *              &nadx (<optional return> array of x values in interval)\n *              &nady (<return> array of derivatives in interval)\n *      Return: 0 if OK, 1 on error (e.g., if x0 or x1 is outside range)\n *\n *  Notes:\n *      (1) The values in nax must be sorted in increasing order.\n *          If they are not sorted, it is done in the interpolation\n *          step, and a warning is issued.\n *      (2) Caller should check for valid return.\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaDilate",
      "comment" : "/*!\n *  numaDilate()\n *\n *      Input:  nas\n *              size (of sel; greater than 0, odd; origin implicitly in center)\n *      Return: nad (dilated), or null on error\n *\n *  Notes:\n *      (1) The structuring element (sel) is linear, all \"hits\"\n *      (2) If size == 1, this returns a copy\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaDiscretizeRankAndIntensity",
      "comment" : "/*!\n *  numaDiscretizeRankAndIntensity()\n *\n *      Input:  na (normalized histogram of probability density vs intensity)\n *              nbins (number of bins at which the rank is divided)\n *              &pnarbin (<optional return> rank bin value vs intensity)\n *              &pnam (<optional return> median intensity in a bin vs\n *                     rank bin value, with @nbins of discretized rank values)\n *              &pnar (<optional return> rank vs intensity; this is\n *                     a cumulative norm histogram)\n *              &pnabb (<optional return> intensity at the right bin boundary\n *                      vs rank bin)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) We are inverting the rank(intensity) function to get\n *          the intensity(rank) function at @nbins equally spaced\n *          values of rank between 0.0 and 1.0.  We save integer values\n *          for the intensity.\n *      (2) We are using the word \"intensity\" to describe the type of\n *          array values, but any array of non-negative numbers will work.\n *      (3) The output arrays give the following mappings, where the\n *          input is a normalized histogram of array values:\n *             array values     -->  rank bin number  (narbin)\n *             rank bin number  -->  median array value in bin (nam)\n *             array values     -->  cumulative norm = rank  (nar)\n *             rank bin number  -->  array value at right bin edge (nabb)\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaEarthMoverDistance",
      "comment" : "/*!\n *  numaEarthMoverDistance()\n *\n *      Input:  na1, na2 (two numas of the same size, typically histograms)\n *              &dist (<return> EM distance)\n *      Return: 0 if OK, 1 on error\n *\n * Notes:\n *     (1) The two numas must have the same size.  They do not need to be\n *         normalized to the same sum before applying the function.\n *     (2) For a 1D discrete function, the implementation of the EMD\n *         is trivial.  Just keep filling or emptying buckets in one numa\n *         to match the amount in the other, moving sequentially along\n *         both arrays.\n *     (3) We divide the sum of the absolute value of everything moved\n *         (by 1 unit at a time) by the sum of the numa (amount of \"earth\")\n *         to get the average distance that the \"earth\" was moved.\n *         Further normalization, by the number of buckets (minus 1),\n *         gives the distance as a fraction of the maximum possible\n *         distance, which is n-1.  This fraction is 1.0 for the situation\n *         where all the 'earth' in the first array is at one end, and\n *         all in the second array is at the other end.\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaEmpty",
      "comment" : "/*!\n *  numaEmpty()\n *\n *      Input:  na\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This does not change the allocation of the array.\n *          It just clears the number of stored numbers, so that\n *          the array appears to be empty.\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaEqualizeTRC",
      "comment" : "/*!\n *  numaEqualizeTRC()\n *\n *      Input:  pix (8 bpp, no colormap)\n *              fract (fraction of equalization movement of pixel values)\n *              factor (subsampling factor; integer >= 1)\n *      Return: nad, or null on error\n *\n *  Notes:\n *      (1) If fract == 0.0, no equalization will be performed.\n *          If fract == 1.0, equalization is complete.\n *      (2) Set the subsampling factor > 1 to reduce the amount of computation.\n *      (3) The map is returned as a numa with 256 values, specifying\n *          the equalized value (array value) for every input value\n *          (the array index).\n */",
      "file" : "enhance.c"
   },
   {
      "function" : "numaErode",
      "comment" : "/*!\n *  numaErode()\n *\n *      Input:  nas\n *              size (of sel; greater than 0, odd; origin implicitly in center)\n *      Return: nad (eroded), or null on error\n *\n *  Notes:\n *      (1) The structuring element (sel) is linear, all \"hits\"\n *      (2) If size == 1, this returns a copy\n *      (3) General comment.  The morphological operations are equivalent\n *          to those that would be performed on a 1-dimensional fpix.\n *          However, because we have not implemented morphological\n *          operations on fpix, we do this here.  Because it is only\n *          1 dimensional, there is no reason to use the more\n *          complicated van Herk/Gil-Werman algorithm, and we do it\n *          by brute force.\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaEvalBestHaarParameters",
      "comment" : "/*!\n *  numaEvalBestHaarParameters()\n *\n *      Input:  nas (numa of non-negative signal values)\n *              relweight (relative weight of (-1 comb) / (+1 comb)\n *                         contributions to the 'convolution'.  In effect,\n *                         the convolution kernel is a comb consisting of\n *                         alternating +1 and -weight.)\n *              nwidth (number of widths to consider)\n *              nshift (number of shifts to consider for each width)\n *              minwidth (smallest width to consider)\n *              maxwidth (largest width to consider)\n *              &bestwidth (<return> width giving largest score)\n *              &bestshift (<return> shift giving largest score)\n *              &bestscore (<optional return> convolution with\n *                          \"Haar\"-like comb)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This does a linear sweep of widths, evaluating at @nshift\n *          shifts for each width, computing the score from a convolution\n *          with a long comb, and finding the (width, shift) pair that\n *          gives the maximum score.  The best width is the \"half-wavelength\"\n *          of the signal.\n *      (2) The convolving function is a comb of alternating values\n *          +1 and -1 * relweight, separated by the width and phased by\n *          the shift.  This is similar to a Haar transform, except\n *          there the convolution is performed with a square wave.\n *      (3) The function is useful for finding the line spacing\n *          and strength of line signal from pixel sum projections.\n *      (4) The score is normalized to the size of nas divided by\n *          the number of half-widths.  For image applications, the input is\n *          typically an array of pixel projections, so one should\n *          normalize by dividing the score by the image width in the\n *          pixel projection direction.\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaEvalBestWidthAndShift",
      "comment" : "/*!\n *  numaEvalBestWidthAndShift()\n *\n *      Input:  nas (numa of crossing locations)\n *              nwidth (number of widths to consider)\n *              nshift (number of shifts to consider for each width)\n *              minwidth (smallest width to consider)\n *              maxwidth (largest width to consider)\n *              &bestwidth (<return> best size of window)\n *              &bestshift (<return> best shift for the window)\n *              &bestscore (<optional return> average squared error of dist\n *                          of crossing signal from the center of the window)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This does a linear sweep of widths, evaluating at @nshift\n *          shifts for each width, finding the (width, shift) pair that\n *          gives the minimum score.\n */",
      "file" : "readbarcode.c"
   },
   {
      "function" : "numaEvalHaarSum",
      "comment" : "/*!\n *  numaEvalHaarSum()\n *\n *      Input:  nas (numa of non-negative signal values)\n *              width (distance between +1 and -1 in convolution comb)\n *              shift (phase of the comb: location of first +1)\n *              relweight (relative weight of (-1 comb) / (+1 comb)\n *                         contributions to the 'convolution'.  In effect,\n *                         the convolution kernel is a comb consisting of\n *                         alternating +1 and -weight.)\n *              &score (<return> convolution with \"Haar\"-like comb)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This does a convolution with a comb of alternating values\n *          +1 and -relweight, separated by the width and phased by the shift.\n *          This is similar to a Haar transform, except that for Haar,\n *            (1) the convolution kernel is symmetric about 0, so the\n *                relweight is 1.0, and\n *            (2) the convolution is performed with a square wave.\n *      (2) The score is normalized to the size of nas divided by\n *          twice the \"width\".  For image applications, the input is\n *          typically an array of pixel projections, so one should\n *          normalize by dividing the score by the image width in the\n *          pixel projection direction.\n *      (3) To get a Haar-like result, use relweight = 1.0.  For detecting\n *          signals where you expect every other sample to be close to\n *          zero, as with barcodes or filtered text lines, you can\n *          use relweight > 1.0.\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaEvalSyncError",
      "comment" : "/*!\n *  numaEvalSyncError()\n *\n *      Input:  nas (numa of crossing locations)\n *              ifirst (first crossing to use)\n *              ilast (last crossing to use; use 0 for all crossings)\n *              width (size of window)\n *              shift (of center of window w/rt first crossing)\n *              &score (<optional return> average squared error of dist\n *                      of crossing signal from the center of the window)\n *              &nad (<optional return> numa of 1s and 0s for crossings)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The score is computed only on the part of the signal from the\n *          @ifirst to @ilast crossings.  Use 0 for both of these to\n *          use all the crossings.  The score is normalized for\n *          the number of crossings and with half-width of the window.\n *      (2) The optional return @nad is a sequence of 0s and 1s, where a '1'\n *          indicates a crossing in the window.\n */",
      "file" : "readbarcode.c"
   },
   {
      "function" : "numaExtendArray",
      "comment" : "/*!\n *  numaExtendArray()\n *\n *      Input:  na\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaFillCmapFromHisto",
      "comment" : "/*!\n *  numaFillCmapFromHisto()\n *\n *      Input:  na (histogram of gray values)\n *              cmap (8 bpp cmap, possibly initialized with color value)\n *              minfract (minimum fraction of pixels in a set of adjacent\n *                        histo bins that causes the set to be automatically\n *                        set aside as a color in the colormap; must be\n *                        at least 0.01)\n *              maxsize (maximum number of adjacent bins allowed to represent\n *                       a color, regardless of the population of pixels\n *                       in the bins; must be at least 2)\n *             &lut (<return> lookup table from gray value to colormap index)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This static function must be called from pixGrayQuantFromHisto()\n */",
      "file" : "grayquant.c"
   },
   {
      "function" : "numaFindExtrema",
      "comment" : "/*!\n *  numaFindExtrema()\n *\n *      Input:  nas (input values)\n *              delta (relative amount to resolve peaks and valleys)\n *      Return: nad (locations of extrema), or null on error\n *\n *  Notes:\n *      (1) This returns a sequence of extrema (peaks and valleys).\n *      (2) The algorithm is analogous to that for determining\n *          mountain peaks.  Suppose we have a local peak, with\n *          bumps on the side.  Under what conditions can we consider\n *          those 'bumps' to be actual peaks?  The answer: if the\n *          bump is separated from the peak by a saddle that is at\n *          least 500 feet below the bump.\n *      (3) Operationally, suppose we are looking for a peak.\n *          We are keeping the largest value we've seen since the\n *          last valley, and are looking for a value that is delta\n *          BELOW our current peak.  When we find such a value,\n *          we label the peak, use the current value to label the\n *          valley, and then do the same operation in reverse (looking\n *          for a valley).\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaFindPeaks",
      "comment" : "/*!\n *  numaFindPeaks()\n *\n *      Input:  source na\n *              max number of peaks to be found\n *              fract1  (min fraction of peak value)\n *              fract2  (min slope)\n *      Return: peak na, or null on error.\n *\n * Notes:\n *     (1) The returned na consists of sets of four numbers representing\n *         the peak, in the following order:\n *            left edge; peak center; right edge; normalized peak area\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaFitMax",
      "comment" : "/*!\n *  numaFitMax()\n *\n *      Input:  na  (numa of ordinate values, to fit a max to)\n *              &maxval (<return> max value)\n *              naloc (<optional> associated numa of abscissa values)\n *              &maxloc (<return> abscissa value that gives max value in na;\n *                   if naloc == null, this is given as an interpolated\n *                   index value)\n *      Return: 0 if OK; 1 on error\n *\n *  Note: if naloc is given, there is no requirement that the\n *        data points are evenly spaced.  Lagrangian interpolation\n *        handles that.  The only requirement is that the\n *        data points are ordered so that the values in naloc\n *        are either increasing or decreasing.  We test to make\n *        sure that the sizes of na and naloc are equal, and it\n *        is assumed that the correspondences na[i] as a function\n *        of naloc[i] are properly arranged for all i.\n *\n *  The formula for Lagrangian interpolation through 3 data pts is:\n *       y(x) = y1(x-x2)(x-x3)/((x1-x2)(x1-x3)) +\n *              y2(x-x1)(x-x3)/((x2-x1)(x2-x3)) +\n *              y3(x-x1)(x-x2)/((x3-x1)(x3-x2))\n *\n *  Then the derivative, using the constants (c1,c2,c3) defined below,\n *  is set to 0:\n *       y'(x) = 2x(c1+c2+c3) - c1(x2+x3) - c2(x1+x3) - c3(x1+x2) = 0\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaGammaTRC",
      "comment" : "/*!\n *  numaGammaTRC()\n *\n *      Input:  gamma   (gamma factor; must be > 0.0)\n *              minval  (input value that gives 0 for output)\n *              maxval  (input value that gives 255 for output)\n *      Return: na, or null on error\n *\n *  Notes:\n *      (1) The map is returned as a numa; values are clipped to [0, 255].\n *      (2) To force all intensities into a range within fraction delta\n *          of white, use: minval = -256 * (1 - delta) / delta\n *                         maxval = 255\n *      (3) To force all intensities into a range within fraction delta\n *          of black, use: minval = 0\n *                         maxval = 256 * (1 - delta) / delta\n */",
      "file" : "enhance.c"
   },
   {
      "function" : "numaGetBinSortIndex",
      "comment" : "/*!\n *  numaGetBinSortIndex()\n *\n *      Input:  na (of non-negative integers with a max that is typically\n *                  less than 1,000,000)\n *              sortorder (L_SORT_INCREASING or L_SORT_DECREASING)\n *      Return: na (sorted), or null on error\n *\n *  Notes:\n *      (1) This creates an array (or lookup table) that contains\n *          the sorted position of the elements in the input Numa.\n *      (2) Because it uses a bin sort with buckets of size 1, it\n *          is not appropriate for sorting either small arrays or\n *          arrays containing very large integer values.  For such\n *          arrays, use a standard general sort function like\n *          numaGetSortIndex().\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaGetBinnedMedian",
      "comment" : "/*!\n *  numaGetBinnedMedian()\n *\n *      Input:  na\n *              &val  (<return> integer median value)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) Computes the median value of the numbers in the numa,\n *          using bin sort and finding the middle value in the sorted array.\n *      (2) See numaGetRankValue() for conditions on na for which\n *          this should be used.  Otherwise, use numaGetMedian().\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaGetCount",
      "comment" : "/*!\n *  numaGetCount()\n *\n *      Input:  na\n *      Return: count, or 0 if no numbers or on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaGetCountRelativeToZero",
      "comment" : "/*!\n *  numaGetCountRelativeToZero()\n *\n *      Input:  numa\n *              type (L_LESS_THAN_ZERO, L_EQUAL_TO_ZERO, L_GREATER_THAN_ZERO)\n *              &count (<return> count of values of given type)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaGetCrossingDistances",
      "comment" : "/*!\n *  numaGetCrossingDistances()\n *\n *      Input:  nas (numa of crossing locations)\n *              &naedist (<optional return> even distances between crossings)\n *              &naodist (<optional return> odd distances between crossings)\n *              &mindist (<optional return> min distance between crossings)\n *              &maxdist (<optional return> max distance between crossings)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "readbarcode.c"
   },
   {
      "function" : "numaGetEdgeValues",
      "comment" : "/*!\n *  numaGetEdgeValues()\n *\n *      Input:  na (numa that is output of numaThresholdEdges())\n *              edge (edge number, zero-based)\n *              &start (<optional return> location of start of transition)\n *              &end (<optional return> location of end of transition)\n *              &sign (<optional return> transition sign: +1 is rising,\n *                     -1 is falling)\n *      Output: 0 if OK, 1 on error\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaGetFArray",
      "comment" : "/*!\n *  numaGetFArray()\n *\n *      Input:  na\n *              copyflag (L_NOCOPY or L_COPY)\n *      Return: either the bare internal array or a copy of it,\n *              or null on error\n *\n *  Notes:\n *      (1) If copyflag == L_COPY, it makes a copy which the caller\n *          is responsible for freeing.  Otherwise, it operates\n *          directly on the bare array of the numa.\n *      (2) Very important: for L_NOCOPY, any writes to the array\n *          will be in the numa.  Do not write beyond the size of\n *          the count field, because it will not be accessable\n *          from the numa!  If necessary, be sure to set the count\n *          field to a larger number (such as the alloc size)\n *          BEFORE calling this function.  Creating with numaMakeConstant()\n *          is another way to insure full initialization.\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaGetFValue",
      "comment" : "/*!\n *  numaGetFValue()\n *\n *      Input:  na\n *              index (into numa)\n *              &val  (<return> float value; 0.0 on error)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) Caller may need to check the function return value to\n *          decide if a 0.0 in the returned ival is valid.\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaGetHistogramStats",
      "comment" : "/*!\n *  numaGetHistogramStats()\n *\n *      Input:  nahisto (histogram: y(x(i)), i = 0 ... nbins - 1)\n *              startx (x value of first bin: x(0))\n *              deltax (x increment between bins; the bin size; x(1) - x(0))\n *              &xmean (<optional return> mean value of histogram)\n *              &xmedian (<optional return> median value of histogram)\n *              &xmode (<optional return> mode value of histogram:\n *                     xmode = x(imode), where y(xmode) >= y(x(i)) for\n *                     all i != imode)\n *              &xvariance (<optional return> variance of x)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If the histogram represents the relation y(x), the\n *          computed values that are returned are the x values.\n *          These are NOT the bucket indices i; they are related to the\n *          bucket indices by\n *                x(i) = startx + i * deltax\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaGetHistogramStatsOnInterval",
      "comment" : "/*!\n *  numaGetHistogramStatsOnInterval()\n *\n *      Input:  nahisto (histogram: y(x(i)), i = 0 ... nbins - 1)\n *              startx (x value of first bin: x(0))\n *              deltax (x increment between bins; the bin size; x(1) - x(0))\n *              ifirst (first bin to use for collecting stats)\n *              ilast (last bin for collecting stats; use 0 to go to the end)\n *              &xmean (<optional return> mean value of histogram)\n *              &xmedian (<optional return> median value of histogram)\n *              &xmode (<optional return> mode value of histogram:\n *                     xmode = x(imode), where y(xmode) >= y(x(i)) for\n *                     all i != imode)\n *              &xvariance (<optional return> variance of x)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If the histogram represents the relation y(x), the\n *          computed values that are returned are the x values.\n *          These are NOT the bucket indices i; they are related to the\n *          bucket indices by\n *                x(i) = startx + i * deltax\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaGetIArray",
      "comment" : "/*!\n *  numaGetIArray()\n *\n *      Input:  na\n *      Return: a copy of the bare internal array, integerized\n *              by rounding, or null on error\n *  Notes:\n *      (1) A copy of the array is always made, because we need to\n *          generate an integer array from the bare float array.\n *          The caller is responsible for freeing the array.\n *      (2) The array size is determined by the number of stored numbers,\n *          not by the size of the allocated array in the Numa.\n *      (3) This function is provided to simplify calculations\n *          using the bare internal array, rather than continually\n *          calling accessors on the numa.  It is typically used\n *          on an array of size 256.\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaGetIValue",
      "comment" : "/*!\n *  numaGetIValue()\n *\n *      Input:  na\n *              index (into numa)\n *              &ival  (<return> integer value; 0 on error)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) Caller may need to check the function return value to\n *          decide if a 0 in the returned ival is valid.\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaGetMax",
      "comment" : "/*!\n *  numaGetMax()\n *\n *      Input:  na\n *              &maxval (<optional return> max value)\n *              &imaxloc (<optional return> index of max location)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaGetMedian",
      "comment" : "/*!\n *  numaGetMedian()\n *\n *      Input:  na\n *              &val  (<return> median value)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) Computes the median value of the numbers in the numa, by\n *          sorting and finding the middle value in the sorted array.\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaGetMedianVariation",
      "comment" : "/*!\n *  numaGetMedianVariation()\n *\n *      Input:  na\n *              &medval  (<optional return> median value)\n *              &medvar  (<return> median variation from median val)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) Finds the median of the absolute value of the variation from\n *          the median value in the array.  Why take the absolute value?\n *          Consider the case where you have values equally distributed\n *          about both sides of a median value.  Without taking the absolute\n *          value of the differences, you will get 0 for the variation,\n *          and this is not useful.\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaGetMin",
      "comment" : "/*!\n *  numaGetMin()\n *\n *      Input:  na\n *              &minval (<optional return> min value)\n *              &iminloc (<optional return> index of min location)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaGetMode",
      "comment" : "/*!\n *  numaGetMode()\n *\n *      Input:  na\n *              &val  (<return> mode val)\n *              &count  (<optional return> mode count)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) Computes the mode value of the numbers in the numa, by\n *          sorting and finding the value of the number with the\n *          largest count.\n *      (2) Optionally, also returns that count.\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaGetNonzeroRange",
      "comment" : "/*!\n *  numaGetNonzeroRange()\n *\n *      Input:  numa\n *              eps (largest value considered to be zero)\n *              &first, &last (<return> interval of array indices\n *                             where values are nonzero)\n *      Return: 0 if OK, 1 on error or if no nonzero range is found.\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaGetParameters",
      "comment" : "/*!\n *  numaGetParameters()\n *\n *      Input:  na\n *              &startx (<optional return> startx)\n *              &delx (<optional return> delx)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaGetPartialSums",
      "comment" : "/*!\n *  numaGetPartialSums()\n *\n *      Input:  na\n *      Return: nasum, or null on error\n *\n *  Notes:\n *      (1) nasum[i] is the sum for all j <= i of na[j].\n *          So nasum[0] = na[0].\n *      (2) If you want to generate a rank function, where rank[0] - 0.0,\n *          insert a 0.0 at the beginning of the nasum array.\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaGetPeakCentroids",
      "comment" : "/*!\n *  numaGetPeakCentroids()\n *\n *      Input:  nahist (numa of histogram of crossing widths)\n *              narange (numa of ranges of x-values for the peaks in @nahist)\n *      Return: nad (centroids for each peak found; max of 4, corresponding\n *                   to 4 different barcode line widths), or null on error\n */",
      "file" : "readbarcode.c"
   },
   {
      "function" : "numaGetPeakWidthLUT",
      "comment" : "/*!\n *  numaGetPeakWidthLUT()\n *\n *      Input:  narange (numa of x-val ranges for the histogram width peaks)\n *              nacent (numa of centroids of each peak -- up to 4)\n *      Return: nalut (lookup table from the width of a bar to one of the four\n *                     integerized barcode units), or null on error\n *\n *  Notes:\n *      (1) This generates the lookup table that maps from a sequence of widths\n *          (in some units) to the integerized barcode units (1, 2, 3, 4),\n *          which are the output integer widths between transitions.\n *      (2) The smallest width can be lost in float roundoff.  To avoid\n *          losing it, we expand the peak range of the smallest width.\n */",
      "file" : "readbarcode.c"
   },
   {
      "function" : "numaGetRankBinValues",
      "comment" : "/*!\n *  numaGetRankBinValues()\n *\n *      Input:  na (just an array of values)\n *              nbins (number of bins at which the rank is divided)\n *              &pnarbin (<optional return> rank bin value vs array value)\n *              &pnam (<optional return> median intensity in a bin vs\n *                     rank bin value, with @nbins of discretized rank values)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Simple interface for getting a binned rank representation\n *          of an input array of values.  This returns two mappings:\n *             array value     -->  rank bin number  (narbin)\n *             rank bin number -->  median array value in each rank bin (nam)\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaGetRankValue",
      "comment" : "/*!\n *  numaGetRankValue()\n *\n *      Input:  na\n *              fract (use 0.0 for smallest, 1.0 for largest)\n *              nasort (<optional> increasing sorted version of na)\n *              usebins (0 for general sort; 1 for bin sort)\n *              &val  (<return> rank val)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) Computes the rank value of a number in the @na, which is\n *          the number that is a fraction @fract from the small\n *          end of the sorted version of @na.\n *      (2) If you do this multiple times for different rank values,\n *          sort the array in advance and use that for @nasort;\n *          if you're only calling this once, input @nasort == NULL.\n *      (3) If @usebins == 1, this uses a bin sorting method.\n *          Use this only where:\n *           * the numbers are non-negative integers\n *           * there are over 100 numbers\n *           * the maximum value is less than about 50,000\n *      (4) The advantage of using a bin sort is that it is O(n),\n *          instead of O(nlogn) for general sort routines.\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaGetRefcount",
      "comment" : "/*!\n *  numaGetRefCount()\n *\n *      Input:  na\n *      Return: refcount, or UNDEF on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaGetSortIndex",
      "comment" : "/*!\n *  numaGetSortIndex()\n *\n *      Input:  na\n *              sortorder (L_SORT_INCREASING or L_SORT_DECREASING)\n *      Return: na giving an array of indices that would sort\n *              the input array, or null on error\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaGetSpanValues",
      "comment" : "/*!\n *  numaGetSpanValues()\n *\n *      Input:  na (numa that is output of numaLowPassIntervals())\n *              span (span number, zero-based)\n *              &start (<optional return> location of start of transition)\n *              &end (<optional return> location of end of transition)\n *      Output: 0 if OK, 1 on error\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaGetStatsUsingHistogram",
      "comment" : "/*!\n *  numaGetStatsUsingHistogram()\n *\n *      Input:  na (an arbitrary set of numbers; not ordered and not\n *                  a histogram)\n *              maxbins (the maximum number of bins to be allowed in\n *                       the histogram; use 0 for consecutive integer bins)\n *              &min (<optional return> min value of set)\n *              &max (<optional return> max value of set)\n *              &mean (<optional return> mean value of set)\n *              &variance (<optional return> variance)\n *              &median (<optional return> median value of set)\n *              rank (in [0.0 ... 1.0]; median has a rank 0.5; ignored\n *                    if &rval == NULL)\n *              &rval (<optional return> value in na corresponding to @rank)\n *              &histo (<optional return> Numa histogram; use NULL to prevent)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is a simple interface for gathering statistics\n *          from a numa, where a histogram is used 'under the covers'\n *          to avoid sorting if a rank value is requested.  In that case,\n *          by using a histogram we are trading speed for accuracy, because\n *          the values in @na are quantized to the center of a set of bins.\n *      (2) If the median, other rank value, or histogram are not requested,\n *          the calculation is all performed on the input Numa.\n *      (3) The variance is the average of the square of the\n *          difference from the mean.  The median is the value in na\n *          with rank 0.5.\n *      (4) There are two situations where this gives rank results with\n *          accuracy comparable to computing stastics directly on the input\n *          data, without binning into a histogram:\n *           (a) the data is integers and the range of data is less than\n *               @maxbins, and\n *           (b) the data is floats and the range is small compared to\n *               @maxbins, so that the binsize is much less than 1.\n *      (5) If a histogram is used and the numbers in the Numa extend\n *          over a large range, you can limit the required storage by\n *          specifying the maximum number of bins in the histogram.\n *          Use @maxbins == 0 to force the bin size to be 1.\n *      (6) This optionally returns the median and one arbitrary rank value.\n *          If you need several rank values, return the histogram and use\n *               numaHistogramGetValFromRank(nah, rank, &rval)\n *          multiple times.\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaGetSum",
      "comment" : "/*!\n *  numaGetSum()\n *\n *      Input:  na\n *              &sum (<return> sum of values)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaGetSumOnInterval",
      "comment" : "/*!\n *  numaGetSumOnInterval()\n *\n *      Input:  na\n *              first (beginning index)\n *              last (final index)\n *              &sum (<return> sum of values in the index interval range)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaHasOnlyIntegers",
      "comment" : "/*!\n *  numaHasOnlyIntegers()\n *\n *      Input:  na\n *              maxsamples (maximum number of samples to check)\n *              &allints (<return> 1 if all sampled values are ints; else 0)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Set @maxsamples == 0 to check every integer in na.  Otherwise,\n *          this samples no more than @maxsamples.\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaHashAdd",
      "comment" : "/*!\n *  numaHashAdd()\n *\n *      Input:  nahash\n *              key  (key to be hashed into a bucket number)\n *              value  (float value to be appended to the specific numa)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaHashCreate",
      "comment" : "/*!\n *  numaHashCreate()\n *\n *      Input: nbuckets (the number of buckets in the hash table,\n *                       which should be prime.)\n *             initsize (initial size of each allocated numa; 0 for default)\n *      Return: ptr to new nahash, or null on error\n *\n *  Note: actual numa are created only as required by numaHashAdd()\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaHashDestroy",
      "comment" : "/*!\n *  numaHashDestroy()\n *\n *      Input:  &nahash (<to be nulled, if it exists>)\n *      Return: void\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaHashGetNuma",
      "comment" : "/*!\n *  numaHashGetNuma()\n *\n *      Input:  nahash\n *              key  (key to be hashed into a bucket number)\n *      Return: ptr to numa\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaHistogramGetRankFromVal",
      "comment" : "/*!\n *  numaHistogramGetRankFromVal()\n *\n *      Input:  na (histogram)\n *              rval (value of input sample for which we want the rank)\n *              &rank (<return> fraction of total samples below rval)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If we think of the histogram as a function y(x), normalized\n *          to 1, for a given input value of x, this computes the\n *          rank of x, which is the integral of y(x) from the start\n *          value of x to the input value.\n *      (2) This function only makes sense when applied to a Numa that\n *          is a histogram.  The values in the histogram can be ints and\n *          floats, and are computed as floats.  The rank is returned\n *          as a float between 0.0 and 1.0.\n *      (3) The numa parameters startx and binsize are used to\n *          compute x from the Numa index i.\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaHistogramGetValFromRank",
      "comment" : "/*!\n *  numaHistogramGetValFromRank()\n *\n *      Input:  na (histogram)\n *              rank (fraction of total samples)\n *              &rval (<return> approx. to the bin value)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If we think of the histogram as a function y(x), this returns\n *          the value x such that the integral of y(x) from the start\n *          value to x gives the fraction 'rank' of the integral\n *          of y(x) over all bins.\n *      (2) This function only makes sense when applied to a Numa that\n *          is a histogram.  The values in the histogram can be ints and\n *          floats, and are computed as floats.  The val is returned\n *          as a float, even though the buckets are of integer width.\n *      (3) The numa parameters startx and binsize are used to\n *          compute x from the Numa index i.\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaInsertNumber",
      "comment" : "/*!\n *  numaInsertNumber()\n *\n *      Input:  na\n *              index (location in na to insert new value)\n *              val  (float32 or integer to be added)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This shifts na[i] --> na[i + 1] for all i >= index,\n *          and then inserts val as na[index].\n *      (2) It should not be used repeatedly on large arrays,\n *          because the function is O(n).\n *\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaIntegrateInterval",
      "comment" : "/*!\n *  numaIntegrateInterval()\n *\n *      Input:  nax (numa of abscissa values)\n *              nay (numa of ordinate values, corresponding to nax)\n *              x0 (start value of interval)\n *              x1 (end value of interval)\n *              npts (number of points to evaluate function in interval)\n *              &sum (<return> integral of function over interval)\n *      Return: 0 if OK, 1 on error (e.g., if x0 or x1 is outside range)\n *\n *  Notes:\n *      (1) The values in nax must be sorted in increasing order.\n *          If they are not sorted, it is done in the interpolation\n *          step, and a warning is issued.\n *      (2) Caller should check for valid return.\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaInterpolateArbxInterval",
      "comment" : "/*!\n *  numaInterpolateArbxInterval()\n *\n *      Input:  nax (numa of abscissa values)\n *              nay (numa of ordinate values, corresponding to nax)\n *              type (L_LINEAR_INTERP, L_QUADRATIC_INTERP)\n *              x0 (start value of interval)\n *              x1 (end value of interval)\n *              npts (number of points to evaluate function in interval)\n *              &nadx (<optional return> array of x values in interval)\n *              &nady (<return> array of y values in interval)\n *      Return: 0 if OK, 1 on error (e.g., if x0 or x1 is outside range)\n *\n *  Notes:\n *      (1) The values in nax must be sorted in increasing order.\n *          If they are not sorted, we do it here, and complain.\n *      (2) If the values in nax are equally spaced, you can use\n *          numaInterpolateEqxInterval().\n *      (3) Caller should check for valid return.\n *      (4) We don't call numaInterpolateArbxVal() for each output\n *          point, because that requires an O(n) search for\n *          each point.  Instead, we do a single O(n) pass through\n *          nax, saving the indices to be used for each output yval.\n *      (5) Uses lagrangian interpolation.  See numaInterpolateEqxVal()\n *          for formulas.\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaInterpolateArbxVal",
      "comment" : "/*!\n *  numaInterpolateArbxVal()\n *\n *      Input:  nax (numa of abscissa values)\n *              nay (numa of ordinate values, corresponding to nax)\n *              type (L_LINEAR_INTERP, L_QUADRATIC_INTERP)\n *              xval\n *              &yval (<return> interpolated value)\n *      Return: 0 if OK, 1 on error (e.g., if xval is outside range)\n *\n *  Notes:\n *      (1) The values in nax must be sorted in increasing order.\n *          If, additionally, they are equally spaced, you can use\n *          numaInterpolateEqxVal().\n *      (2) Caller should check for valid return.\n *      (3) Uses lagrangian interpolation.  See numaInterpolateEqxVal()\n *          for formulas.\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaInterpolateEqxInterval",
      "comment" : "/*!\n *  numaInterpolateEqxInterval()\n *\n *      Input:  startx (xval corresponding to first element in nas)\n *              deltax (x increment between array elements in nas)\n *              nasy  (numa of ordinate values, assumed equally spaced)\n *              type (L_LINEAR_INTERP, L_QUADRATIC_INTERP)\n *              x0 (start value of interval)\n *              x1 (end value of interval)\n *              npts (number of points to evaluate function in interval)\n *              &nax (<optional return> array of x values in interval)\n *              &nay (<return> array of y values in interval)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Considering nasy as a function of x, the x values\n *          are equally spaced.\n *      (2) This creates nay (and optionally nax) of interpolated\n *          values over the specified interval (x0, x1).\n *      (3) If the interval (x0, x1) lies partially outside the array\n *          nasy (as interpreted by startx and deltax), it is an\n *          error and returns 1.\n *      (4) Note that deltax is the intrinsic x-increment for the input\n *          array nasy, whereas delx is the intrinsic x-increment for the\n *          output interpolated array nay.\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaInterpolateEqxVal",
      "comment" : "/*!\n *  numaInterpolateEqxVal()\n *\n *      Input:  startx (xval corresponding to first element in array)\n *              deltax (x increment between array elements)\n *              nay  (numa of ordinate values, assumed equally spaced)\n *              type (L_LINEAR_INTERP, L_QUADRATIC_INTERP)\n *              xval\n *              &yval (<return> interpolated value)\n *      Return: 0 if OK, 1 on error (e.g., if xval is outside range)\n *\n *  Notes:\n *      (1) Considering nay as a function of x, the x values\n *          are equally spaced\n *      (2) Caller should check for valid return.\n *\n *  For linear Lagrangian interpolation (through 2 data pts):\n *         y(x) = y1(x-x2)/(x1-x2) + y2(x-x1)/(x2-x1)\n *\n *  For quadratic Lagrangian interpolation (through 3 data pts):\n *         y(x) = y1(x-x2)(x-x3)/((x1-x2)(x1-x3)) +\n *                y2(x-x1)(x-x3)/((x2-x1)(x2-x3)) +\n *                y3(x-x1)(x-x2)/((x3-x1)(x3-x2))\n *\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaInvert",
      "comment" : "/*!\n *  numaInvert()\n *\n *      Input:  nad (<optional> can be null or equal to nas (in-place)\n *              nas\n *      Return: nad (always: 'inverts' nas)\n *\n *  Notes:\n *      (1) This is intended for use with indicator arrays (0s and 1s).\n *          It gives a boolean-type output, taking the input as\n *          an integer and inverting it:\n *              0              -->  1\n *              anything else  -->   0\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaInvertMap",
      "comment" : "/*!\n *  numaInvertMap()\n *\n *      Input:  nas\n *      Return: nad (the inverted map), or null on error or if not invertible\n *\n *  Notes:\n *      (1) This requires that nas contain each integer from 0 to n-1.\n *          The array is typically an index array into a sort or permutation\n *          of another array.\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaIsSorted",
      "comment" : "/*!\n *  numaIsSorted()\n *\n *      Input:  nas\n *              sortorder (L_SORT_INCREASING or L_SORT_DECREASING)\n *              &sorted (<return> 1 if sorted; 0 if not)\n *      Return: 1 if OK; 0 on error\n *\n *  Notes:\n *      (1) This is a quick O(n) test if nas is sorted.  It is useful\n *          in situations where the array is likely to be already\n *          sorted, and a sort operation can be avoided.\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaJoin",
      "comment" : "/*!\n *  numaJoin()\n *\n *      Input:  nad  (dest numa; add to this one)\n *              nas  (<optional> source numa; add from this one)\n *              istart  (starting index in nas)\n *              iend  (ending index in nas; use -1 to cat all)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) istart < 0 is taken to mean 'read from the start' (istart = 0)\n *      (2) iend < 0 means 'read to the end'\n *      (3) if nas == NULL, this is a no-op\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaLocatePeakRanges",
      "comment" : "/*!\n *  numaLocatePeakRanges()\n *\n *      Input:  nas (numa of histogram of crossing widths)\n *              minfirst (min location of center of first peak)\n *              minsep (min separation between peak range centers)\n *              maxmin (max allowed value for min histo value between peaks)\n *      Return: nad (ranges for each peak found, in pairs), or null on error\n *\n *  Notes:\n *      (1) Units of @minsep are the index into nas.\n *          This puts useful constraints on peak-finding.\n *      (2) If maxmin == 0.0, the value of nas[i] must go to 0.0 (or less)\n *          between peaks.\n *      (3) All calculations are done in units of the index into nas.\n *          The resulting ranges are therefore integers.\n *      (4) The output nad gives pairs of range values for successive peaks.\n *          Any location [i] for which maxmin = nas[i] = 0.0 will NOT be\n *          included in a peak range.  This works fine for histograms where\n *          if nas[i] == 0.0, it means that there are no samples at [i].\n *      (5) For barcodes, when this is used on a histogram of barcode\n *          widths, use maxmin = 0.0.  This requires that there is at\n *          least one histogram bin corresponding to a width value between\n *          adjacent peak ranges that is unpopulated, making the separation\n *          of the histogram peaks unambiguous.\n */",
      "file" : "readbarcode.c"
   },
   {
      "function" : "numaLogicalOp",
      "comment" : "/*!\n *  numaLogicalOp()\n *\n *      Input:  nad (<optional> can be null or equal to na1 (in-place)\n *              na1\n *              na2\n *              op (L_UNION, L_INTERSECTION, L_SUBTRACTION, L_EXCLUSIVE_OR)\n *      Return: nad (always: operation applied to na1 and na2)\n *\n *  Notes:\n *      (1) The sizes of na1 and na2 must be equal.\n *      (2) nad can only null or equal to na1.\n *      (3) This is intended for use with indicator arrays (0s and 1s).\n *          Input data is extracted as integers (0 == false, anything\n *          else == true); output results are 0 and 1.\n *      (4) L_SUBTRACTION is subtraction of val2 from val1.  For bit logical\n *          arithmetic this is (val1 & ~val2), but because these values\n *          are integers, we use (val1 && !val2).\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaLowPassIntervals",
      "comment" : "/*!\n *  numaLowPassIntervals()\n *\n *      Input:  nas (input numa)\n *              thresh (threshold fraction of max; in [0.0 ... 1.0])\n *              maxn (for normalizing; set maxn = 0.0 to use the max in nas)\n *      Output: nad (interval abscissa pairs), or null on error\n *\n *  Notes:\n *      (1) For each interval where the value is less than a specified\n *          fraction of the maximum, this records the left and right \"x\"\n *          value.\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaMakeAbsValue",
      "comment" : "/*!\n *  numaMakeAbsValue()\n *\n *      Input:  nad (can be null for new array, or the same as nas for inplace)\n *              nas (input numa)\n *      Return: nad (with all numbers being the absval of the input),\n *              or null on error\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaMakeConstant",
      "comment" : "/*!\n *  numaMakeConstant()\n *\n *      Input:  val\n *              size (of numa)\n *      Return: numa (of given size with all entries equal to 'val'),\n *              or null on error\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaMakeDelta",
      "comment" : "/*!\n *  numaMakeDelta()\n *\n *      Input:  nas (input numa)\n *      Return: numa (of difference values val[i+1] - val[i]),\n *                    or null on error\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaMakeHistogram",
      "comment" : "/*!\n *  numaMakeHistogram()\n *\n *      Input:  na\n *              maxbins (max number of histogram bins)\n *              &binsize  (<return> size of histogram bins)\n *              &binstart (<optional return> start val of minimum bin;\n *                         input NULL to force start at 0)\n *      Return: na consisiting of histogram of integerized values,\n *              or null on error.\n *\n *  Note:\n *      (1) This simple interface is designed for integer data.\n *          The bins are of integer width and start on integer boundaries,\n *          so the results on float data will not have high precision.\n *      (2) Specify the max number of input bins.   Then @binsize,\n *          the size of bins necessary to accommodate the input data,\n *          is returned.  It is one of the sequence:\n *                {1, 2, 5, 10, 20, 50, ...}.\n *      (3) If &binstart is given, all values are accommodated,\n *          and the min value of the starting bin is returned.\n *          Otherwise, all negative values are discarded and\n *          the histogram bins start at 0.\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaMakeHistogramAuto",
      "comment" : "/*!\n *  numaMakeHistogramAuto()\n *\n *      Input:  na (numa of floats; these may be integers)\n *              maxbins (max number of histogram bins; >= 1)\n *      Return: na consisiting of histogram of quantized float values,\n *              or null on error.\n *\n *  Notes:\n *      (1) This simple interface is designed for accurate binning\n *          of both integer and float data.\n *      (2) If the array data is integers, and the range of integers\n *          is smaller than @maxbins, they are binned as they fall,\n *          with binsize = 1.\n *      (3) If the range of data, (maxval - minval), is larger than\n *          @maxbins, or if the data is floats, they are binned into\n *          exactly @maxbins bins.\n *      (4) Unlike numaMakeHistogram(), these bins in general have\n *          non-integer location and width, even for integer data.\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaMakeHistogramClipped",
      "comment" : "/*!\n *  numaMakeHistogramClipped()\n *\n *      Input:  na\n *              binsize (typically 1.0)\n *              maxsize (of histogram ordinate)\n *      Return: na (histogram of bins of size @binsize, starting with\n *                  the na[0] (x = 0.0) and going up to a maximum of\n *                  x = @maxsize, by increments of @binsize), or null on error\n *\n *  Notes:\n *      (1) This simple function generates a histogram of values\n *          from na, discarding all values < 0.0 or greater than\n *          min(@maxsize, maxval), where maxval is the maximum value in na.\n *          The histogram data is put in bins of size delx = @binsize,\n *          starting at x = 0.0.  We use as many bins as are\n *          needed to hold the data.\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaMakeRankFromHistogram",
      "comment" : "/*!\n *  numaMakeRankFromHistogram()\n *\n *      Input:  startx (xval corresponding to first element in nay)\n *              deltax (x increment between array elements in nay)\n *              nasy (input histogram, assumed equally spaced)\n *              npts (number of points to evaluate rank function)\n *              &nax (<optional return> array of x values in range)\n *              &nay (<return> rank array of specified npts)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaMakeSequence",
      "comment" : "/*!\n *  numaMakeSequence()\n *\n *      Input:  startval\n *              increment\n *              size (of sequence)\n *      Return: numa of sequence of evenly spaced values, or null on error\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaMakeThresholdIndicator",
      "comment" : "/*!\n *  numaMakeThresholdIndicator()\n *\n *      Input:  nas (input numa)\n *              thresh (threshold value)\n *              type (L_SELECT_IF_LT, L_SELECT_IF_GT,\n *                    L_SELECT_IF_LTE, L_SELECT_IF_GTE)\n *      Output: nad (indicator array: values are 0 and 1)\n *\n *  Notes:\n *      (1) For each element in nas, if the constraint given by 'type'\n *          correctly specifies its relation to thresh, a value of 1\n *          is recorded in nad.\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaNormalizeHistogram",
      "comment" : "/*!\n *  numaNormalizeHistogram()\n *\n *      Input:  nas (input histogram)\n *              tsum (target sum of all numbers in dest histogram;\n *                    e.g., use @tsum= 1.0 if this represents a\n *                    probability distribution)\n *      Return: nad (normalized histogram), or null on error\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaOpen",
      "comment" : "/*!\n *  numaOpen()\n *\n *      Input:  nas\n *              size (of sel; greater than 0, odd; origin implicitly in center)\n *      Return: nad (opened), or null on error\n *\n *  Notes:\n *      (1) The structuring element (sel) is linear, all \"hits\"\n *      (2) If size == 1, this returns a copy\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaPseudorandomSequence",
      "comment" : "/*!\n *  numaPseudorandomSequence()\n *\n *      Input:  size (of sequence)\n *              seed (for random number generation)\n *      Return: na (pseudorandom on {0,...,size - 1}), or null on error\n *\n *  Notes:\n *      (1) This uses the Durstenfeld shuffle.\n *          See: http://en.wikipedia.org/wiki/FisherYates_shuffle.\n *          Result is a pseudorandom permutation of the sequence of integers\n *          from 0 to size - 1.\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaQuantizeCrossingsByWidth",
      "comment" : "/*!\n *  numaQuantizeCrossingsByWidth()\n *\n *      Input:  nas (numa of crossing locations, in pixel units)\n *              binfract (histo binsize as a fraction of minsize; e.g., 0.25)\n *              &naehist (<optional return> histo of even (black) bar widths)\n *              &naohist (<optional return> histo of odd (white) bar widths)\n *              debugflag (1 to generate plots of histograms of bar widths)\n *      Return: nad (sequence of widths, in unit sizes), or null on error\n *\n *  Notes:\n *      (1) This first computes the histogram of black and white bar widths,\n *          binned in appropriate units.  There should be well-defined\n *          peaks, each corresponding to a specific width.  The sequence\n *          of barcode widths (namely, the integers from the set {1,2,3,4})\n *          is returned.\n *      (2) The optional returned histograms are binned in width units\n *          that are inversely proportional to @binfract.  For example,\n *          if @binfract = 0.25, there are 4.0 bins in the distance of\n *          the width of the narrowest bar.\n */",
      "file" : "readbarcode.c"
   },
   {
      "function" : "numaQuantizeCrossingsByWindow",
      "comment" : "/*!\n *  numaQuantizeCrossingsByWindow()\n *\n *      Input:  nas (numa of crossing locations)\n *              ratio (of max window size over min window size in search;\n *                     typ. 2.0)\n *              &width (<optional return> best window width)\n *              &firstloc (<optional return> center of window for first xing)\n *              &nac (<optional return> array of window crossings (0, 1, 2))\n *              debugflag (1 to generate various plots of intermediate results)\n *      Return: nad (sequence of widths, in unit sizes), or null on error\n *\n *  Notes:\n *      (1) The minimum size of the window is set by the minimum\n *          distance between zero crossings.\n *      (2) The optional return signal @nac is a sequence of 0s, 1s,\n *          and perhaps a few 2s, giving the number of crossings in each window.\n *          On the occasion where there is a '2', it is interpreted as\n *          ending two runs: the previous one and another one that has length 1.\n */",
      "file" : "readbarcode.c"
   },
   {
      "function" : "numaRandomPermutation",
      "comment" : "/*!\n *  numaRandomPermutation()\n *\n *      Input:  nas (input array)\n *              seed (for random number generation)\n *      Return: nas (randomly shuffled array), or null on error\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaRead",
      "comment" : "/*!\n *  numaRead()\n *\n *      Input:  filename\n *      Return: na, or null on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaReadStream",
      "comment" : "/*!\n *  numaReadStream()\n *\n *      Input:  stream\n *      Return: numa, or null on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaRebinHistogram",
      "comment" : "/*!\n *  numaRebinHistogram()\n *\n *      Input:  nas (input histogram)\n *              newsize (number of old bins contained in each new bin)\n *      Return: nad (more coarsely re-binned histogram), or null on error\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaRemoveBorder",
      "comment" : "/*!\n *  numaRemoveBorder()\n *\n *      Input:  nas\n *              left, right (number of elements to remove from each side)\n *      Return: nad (with removed elements at left and right), or null on error\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaRemoveNumber",
      "comment" : "/*!\n *  numaRemoveNumber()\n *\n *      Input:  na\n *              index (element to be removed)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This shifts na[i] --> na[i - 1] for all i > index.\n *      (2) It should not be used repeatedly on large arrays,\n *          because the function is O(n).\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaReplaceNumber",
      "comment" : "/*!\n *  numaReplaceNumber()\n *\n *      Input:  na\n *              index (element to be replaced)\n *              val (new value to replace old one)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaReverse",
      "comment" : "/*!\n *  numaReverse()\n *\n *      Input:  nad (<optional> can be null or equal to nas)\n *              nas (input numa)\n *      Output: nad (reversed), or null on error\n *\n *  Notes:\n *      (1) Usage:\n *            numaReverse(nas, nas);   // in-place\n *            nad = numaReverse(NULL, nas);  // makes a new one\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaSelectCrossingThreshold",
      "comment" : "/*!\n *  numaSelectCrossingThreshold()\n *\n *      Input:  nax (<optional> numa of abscissa values; can be NULL)\n *              nay (signal)\n *              estthresh (estimated pixel threshold for crossing: e.g., for\n *                         images, white <--> black; typ. ~120)\n *              &bestthresh (<return> robust estimate of threshold to use)\n *      Return: 0 if OK, 1 on error\n *\n *  Note:\n *     (1) When a valid threshold is used, the number of crossings is\n *         a maximum, because none are missed.  If no threshold intersects\n *         all the crossings, the crossings must be determined with\n *         numaCrossingsByPeaks().\n *     (2) @estthresh is an input estimate of the threshold that should\n *         be used.  We compute the crossings with 41 thresholds\n *         (20 below and 20 above).  There is a range in which the\n *         number of crossings is a maximum.  Return a threshold\n *         in the center of this stable plateau of crossings.\n *         This can then be used with numaCrossingsByThreshold()\n *         to get a good estimate of crossing locations.\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaSetCount",
      "comment" : "/*!\n *  numaSetCount()\n *\n *      Input:  na\n *              newcount\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If newcount <= na->nalloc, this resets na->n.\n *          Using newcount = 0 is equivalent to numaEmpty().\n *      (2) If newcount > na->nalloc, this causes a realloc\n *          to a size na->nalloc = newcount.\n *      (3) All the previously unused values in na are set to 0.0.\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaSetParameters",
      "comment" : "/*!\n *  numaSetParameters()\n *\n *      Input:  na\n *              startx (x value corresponding to na[0])\n *              delx (difference in x values for the situation where the\n *                    elements of na correspond to the evaulation of a\n *                    function at equal intervals of size @delx)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaSetValue",
      "comment" : "/*!\n *  numaSetValue()\n *\n *      Input:  na\n *              index   (to element to be set)\n *              val  (to set element)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaShiftValue",
      "comment" : "/*!\n *  numaShiftValue()\n *\n *      Input:  na\n *              index (to element to change relative to the current value)\n *              diff  (increment if diff > 0 or decrement if diff < 0)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaSimilar",
      "comment" : "/*!\n *  numaSimilar()\n *\n *      Input:  na1\n *              na2\n *              maxdiff (use 0.0 for exact equality)\n *              &similar (<return> 1 if similar; 0 if different)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Float values can differ slightly due to roundoff and\n *          accumulated errors.  Using @maxdiff > 0.0 allows similar\n *          arrays to be identified.\n*/",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaSort",
      "comment" : "/*!\n *  numaSort()\n *\n *      Input:  naout (output numa; can be NULL or equal to nain)\n *              nain (input numa)\n *              sortorder (L_SORT_INCREASING or L_SORT_DECREASING)\n *      Return: naout (output sorted numa), or null on error\n *\n *  Notes:\n *      (1) Set naout = nain for in-place; otherwise, set naout = NULL.\n *      (2) Source: Shell sort, modified from K&R, 2nd edition, p.62.\n *          Slow but simple O(n logn) sort.\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaSortAutoSelect",
      "comment" : "/*!\n *  numaSortAutoSelect()\n *\n *      Input:  nas (input numa)\n *              sortorder (L_SORT_INCREASING or L_SORT_DECREASING)\n *      Return: naout (output sorted numa), or null on error\n *\n *  Notes:\n *      (1) This does either a shell sort or a bin sort, depending on\n *          the number of elements in nas and the dynamic range.\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaSortByIndex",
      "comment" : "/*!\n *  numaSortByIndex()\n *\n *      Input:  nas\n *              naindex (na that maps from the new numa to the input numa)\n *      Return: nad (sorted), or null on error\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaSortGeneral",
      "comment" : "/*!\n *  numaSortGeneral()\n *\n *      Input:  na (source numa)\n *              nasort (<optional> sorted numa)\n *              naindex (<optional> index of elements in na associated\n *                       with each element of nasort)\n *              nainvert (<optional> index of elements in nasort associated\n *                        with each element of na)\n *              sortorder (L_SORT_INCREASING or L_SORT_DECREASING)\n *              sorttype (L_SHELL_SORT or L_BIN_SORT)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Sorting can be confusing.  Here's an array of five values with\n *          the results shown for the 3 output arrays.\n *\n *          na      nasort   naindex   nainvert\n *          -----------------------------------\n *          3         9         2         3\n *          4         6         3         2\n *          9         4         1         0\n *          6         3         0         1\n *          1         1         4         4\n *\n *          Note that naindex is a LUT into na for the sorted array values,\n *          and nainvert directly gives the sorted index values for the\n *          input array.  It is useful to view naindex is as a map:\n *                 0  -->  2\n *                 1  -->  3\n *                 2  -->  1\n *                 3  -->  0\n *                 4  -->  4\n *          and nainvert, the inverse of this map:\n *                 0  -->  3\n *                 1  -->  2\n *                 2  -->  0\n *                 3  -->  1\n *                 4  -->  4\n *\n *          We can write these relations symbolically as:\n *              nasort[i] = na[naindex[i]]\n *              na[i] = nasort[nainvert[i]]\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaSortIndexAutoSelect",
      "comment" : "/*!\n *  numaSortIndexAutoSelect()\n *\n *      Input:  nas\n *              sortorder (L_SORT_INCREASING or L_SORT_DECREASING)\n *      Return: nad (indices of nas, sorted by value in nas), or null on error\n *\n *  Notes:\n *      (1) This does either a shell sort or a bin sort, depending on\n *          the number of elements in nas and the dynamic range.\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaSortPair",
      "comment" : "/*!\n *  numaSortPair()\n *\n *      Input:  nax, nay (input arrays)\n *              sortorder (L_SORT_INCREASING or L_SORT_DECREASING)\n *              &nasx (<return> sorted)\n *              &naxy (<return> sorted exactly in order of nasx)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This function sorts the two input arrays, nax and nay,\n *          together, using nax as the key for sorting.\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaSplitDistribution",
      "comment" : "/*!\n *  numaSplitDistribution()\n *\n *      Input:  na (histogram)\n *              scorefract (fraction of the max score, used to determine\n *                          the range over which the histogram min is searched)\n *              &splitindex (<optional return> index for splitting)\n *              &ave1 (<optional return> average of lower distribution)\n *              &ave2 (<optional return> average of upper distribution)\n *              &num1 (<optional return> population of lower distribution)\n *              &num2 (<optional return> population of upper distribution)\n *              &nascore (<optional return> for debugging; otherwise use null)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This function is intended to be used on a distribution of\n *          values that represent two sets, such as a histogram of\n *          pixel values for an image with a fg and bg, and the goal\n *          is to determine the averages of the two sets and the\n *          best splitting point.\n *      (2) The Otsu method finds a split point that divides the distribution\n *          into two parts by maximizing a score function that is the\n *          product of two terms:\n *            (a) the square of the difference of centroids, (ave1 - ave2)^2\n *            (b) fract1 * (1 - fract1)\n *          where fract1 is the fraction in the lower distribution.\n *      (3) This works well for images where the fg and bg are\n *          each relatively homogeneous and well-separated in color.\n *          However, if the actual fg and bg sets are very different\n *          in size, and the bg is highly varied, as can occur in some\n *          scanned document images, this will bias the split point\n *          into the larger \"bump\" (i.e., toward the point where the\n *          (b) term reaches its maximum of 0.25 at fract1 = 0.5.\n *          To avoid this, we define a range of values near the\n *          maximum of the score function, and choose the value within\n *          this range such that the histogram itself has a minimum value.\n *          The range is determined by scorefract: we include all abscissa\n *          values to the left and right of the value that maximizes the\n *          score, such that the score stays above (1 - scorefract) * maxscore.\n *          The intuition behind this modification is to try to find\n *          a split point that both has a high variance score and is\n *          at or near a minimum in the histogram, so that the histogram\n *          slope is small at the split point.\n *      (4) We normalize the score so that if the two distributions\n *          were of equal size and at opposite ends of the numa, the\n *          score would be 1.0.\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaSubsample",
      "comment" : "/*!\n *  numaSubsample()\n *\n *      Input:  nas\n *              subfactor (subsample factor, >= 1)\n *      Return: nad (evenly sampled values from nas), or null on error\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaThresholdEdges",
      "comment" : "/*!\n *  numaThresholdEdges()\n *\n *      Input:  nas (input numa)\n *              thresh1 (low threshold as fraction of max; in [0.0 ... 1.0])\n *              thresh2 (high threshold as fraction of max; in [0.0 ... 1.0])\n *              maxn (for normalizing; set maxn = 0.0 to use the max in nas)\n *      Output: nad (edge interval triplets), or null on error\n *\n *  Notes:\n *      (1) For each edge interval, where where the value is less\n *          than @thresh1 on one side, greater than @thresh2 on\n *          the other, and between these thresholds throughout the\n *          interval, this records a triplet of values: the\n *          'left' and 'right' edges, and either +1 or -1, depending\n *          on whether the edge is rising or falling.\n *      (2) No assumption is made about the value outside the array,\n *          so if the value at the array edge is between the threshold\n *          values, it is not considered part of an edge.  We start\n *          looking for edge intervals only after leaving the thresholded\n *          band.\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaTransform",
      "comment" : "/*!\n *  numaTransform()\n *\n *      Input:  nas\n *              shift (add this to each number)\n *              scale (multiply each number by this)\n *      Return: nad (with all values shifted and scaled, or null on error)\n *\n *  Notes:\n *      (1) Each number is shifted before scaling.\n *      (2) The operation sequence is opposite to that for Box and Pta:\n *          scale first, then shift.\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaUniformSampling",
      "comment" : "/*!\n *  numaUniformSampling()\n *\n *      Input:  nas (input numa)\n *              nsamp (number of samples)\n *      Output: nad (resampled array), or null on error\n *\n *  Notes:\n *      (1) This resamples the values in the array, using @nsamp\n *          equal divisions.\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaWindowedMean",
      "comment" : "/*!\n *  numaWindowedMean()\n *\n *      Input:  nas\n *              wc (half width of the convolution window)\n *      Return: nad (after low-pass filtering), or null on error\n *\n *  Notes:\n *      (1) This is a convolution.  The window has width = 2 * @wc + 1.\n *      (2) We add a mirrored border of size @wc to each end of the array.\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaWindowedMeanSquare",
      "comment" : "/*!\n *  numaWindowedMeanSquare()\n *\n *      Input:  nas\n *              wc (half width of the window)\n *      Return: nad (containing windowed mean square values), or null on error\n *\n *  Notes:\n *      (1) The window has width = 2 * @wc + 1.\n *      (2) We add a mirrored border of size @wc to each end of the array.\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaWindowedStats",
      "comment" : "/*!\n *  numaWindowedStats()\n *\n *      Input:  nas (input numa)\n *              wc (half width of the window)\n *              &nam (<optional return> mean value in window)\n *              &nams (<optional return> mean square value in window)\n *              &pnav (<optional return> variance in window)\n *              &pnarv (<optional return> rms deviation from the mean)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is a high-level convenience function for calculating\n *          any or all of these derived arrays.\n *      (2) These statistical measures over the values in the\n *          rectangular window are:\n *            - average value: <x>  (nam)\n *            - average squared value: <x*x> (nams)\n *            - variance: <(x - <x>)*(x - <x>)> = <x*x> - <x>*<x>  (nav)\n *            - square-root of variance: (narv)\n *          where the brackets < .. > indicate that the average value is\n *          to be taken over the window.\n *      (3) Note that the variance is just the mean square difference from\n *          the mean value; and the square root of the variance is the\n *          root mean square difference from the mean, sometimes also\n *          called the 'standard deviation'.\n *      (4) Internally, use mirrored borders to handle values near the\n *          end of each array.\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaWindowedVariance",
      "comment" : "/*!\n *  numaWindowedVariance()\n *\n *      Input:  nam (windowed mean values)\n *              nams (windowed mean square values)\n *              &pnav (<optional return> numa of variance -- the ms deviation\n *                     from the mean)\n *              &pnarv (<optional return> numa of rms deviation from the mean)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The numas of windowed mean and mean square are precomputed,\n *          using numaWindowedMean() and numaWindowedMeanSquare().\n *      (2) Either or both of the variance and square-root of variance\n *          are returned, where the variance is the average over the\n *          window of the mean square difference of the pixel value\n *          from the mean:\n *                <(x - <x>)*(x - <x>)> = <x*x> - <x>*<x>\n */",
      "file" : "numafunc2.c"
   },
   {
      "function" : "numaWrite",
      "comment" : "/*!\n *  numaWrite()\n *\n *      Input:  filename, na\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaWriteStream",
      "comment" : "/*!\n *  numaWriteStream()\n *\n *      Input:  stream, na\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaaAddNuma",
      "comment" : "/*!\n *  numaaAddNuma()\n *\n *      Input:  naa\n *              na   (to be added)\n *              copyflag  (L_INSERT, L_COPY, L_CLONE)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaaAddNumber",
      "comment" : "/*!\n *  numaaAddNumber()\n *\n *      Input:  naa\n *              index (of numa within numaa)\n *              val  (float or int to be added; stored as a float)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Adds to an existing numa only.\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaaCompareImagesByBoxes",
      "comment" : "/*!\n *  numaaCompareImagesByBoxes()\n *\n *      Input:  naa1 (for image 1, formatted by boxaExtractSortedPattern())\n *              naa2 (ditto; for image 2)\n *              nperline (number of box regions to be used in each textline)\n *              nreq (number of complete row matches required)\n *              maxshiftx (max allowed x shift between two patterns, in pixels)\n *              maxshifty (max allowed y shift between two patterns, in pixels)\n *              delx (max allowed difference in x data, after alignment)\n *              dely (max allowed difference in y data, after alignment)\n *              &same (<return> 1 if @nreq row matches are found; 0 otherwise)\n *              debugflag (1 for debug output)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Each input numaa describes a set of sorted bounding boxes\n *          (sorted by textline and, within each textline, from\n *          left to right) in the images from which they are derived.\n *          See boxaExtractSortedPattern() for a description of the data\n *          format in each of the input numaa.\n *      (2) This function does an alignment between the input\n *          descriptions of bounding boxes for two images. The\n *          input parameter @nperline specifies the number of boxes\n *          to consider in each line when testing for a match, and\n *          @nreq is the required number of lines that must be well-aligned\n *          to get a match.\n *      (3) Testing by alignment has 3 steps:\n *          (a) Generating the location of word bounding boxes from the\n *              images (prior to calling this function).\n *          (b) Listing all possible pairs of aligned rows, based on\n *              tolerances in horizontal and vertical positions of\n *              the boxes.  Specifically, all pairs of rows are enumerated\n *              whose first @nperline boxes can be brought into close\n *              alignment, based on the delx parameter for boxes in the\n *              line and within the overall the @maxshiftx and @maxshifty\n *              constraints.\n *          (c) Each pair, starting with the first, is used to search\n *              for a set of @nreq - 1 other pairs that can all be aligned\n *              with a difference in global translation of not more\n *              than (@delx, @dely).\n */",
      "file" : "classapp.c"
   },
   {
      "function" : "numaaCreate",
      "comment" : "/*!\n *  numaaCreate()\n *\n *      Input:  size of numa ptr array to be alloc'd (0 for default)\n *      Return: naa, or null on error\n *\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaaCreateFull",
      "comment" : "/*!\n *  numaaCreateFull()\n *\n *      Input:  ntop: size of numa ptr array to be alloc'd\n *              n: size of individual numa arrays to be alloc'd (0 for default)\n *      Return: naa, or null on error\n *\n *  Notes:\n *      (1) This allocates numaa and fills the array with allocated numas.\n *          In use, after calling this function, use\n *              numaaAddNumber(naa, index, val);\n *          to add val to the index-th numa in naa.\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaaDestroy",
      "comment" : "/*!\n *  numaaDestroy()\n *\n *      Input: &numaa <to be nulled if it exists>\n *      Return: void\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaaExtendArray",
      "comment" : "/*!\n *  numaaExtendArray()\n *\n *      Input:  naa\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaaFlattenToNuma",
      "comment" : "/*!\n *  numaaFlattenToNuma()\n *\n *      Input:  numaa\n *      Return: numa, or null on error\n *\n *  Notes:\n *      (1) This 'flattens' the Numaa to a Numa, by joining successively\n *          each Numa in the Numaa.\n *      (2) It doesn't make any assumptions about the location of the\n *          Numas in the Numaa array, unlike most Numaa functions.\n *      (3) It leaves the input Numaa unchanged.\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaaGetCount",
      "comment" : "/*!\n *  numaaGetCount()\n *\n *      Input:  naa\n *      Return: count (number of numa), or 0 if no numa or on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaaGetNuma",
      "comment" : "/*!\n *  numaaGetNuma()\n *\n *      Input:  naa\n *              index  (to the index-th numa)\n *              accessflag   (L_COPY or L_CLONE)\n *      Return: numa, or null on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaaGetNumaCount",
      "comment" : "/*!\n *  numaaGetNumaCount()\n *\n *      Input:  naa\n *              index (of numa in naa)\n *      Return: count of numbers in the referenced numa, or 0 on error.\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaaGetNumberCount",
      "comment" : "/*!\n *  numaaGetNumberCount()\n *\n *      Input:  naa\n *      Return: count (total number of numbers in the numaa),\n *                     or 0 if no numbers or on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaaGetPtrArray",
      "comment" : "/*!\n *  numaaGetPtrArray()\n *\n *      Input:  naa\n *      Return: the internal array of ptrs to Numa, or null on error\n *\n *  Notes:\n *      (1) This function is convenient for doing direct manipulation on\n *          a fixed size array of Numas.  To do this, it sets the count\n *          to the full size of the allocated array of Numa ptrs.\n *          The originating Numaa owns this array: DO NOT free it!\n *      (2) Intended usage:\n *            Numaa *naa = numaaCreate(n);\n *            Numa **array = numaaGetPtrArray(naa);\n *             ...  [manipulate Numas directly on the array]\n *            numaaDestroy(&naa);\n *      (3) Cautions:\n *           - Do not free this array; it is owned by tne Numaa.\n *           - Do not call any functions on the Numaa, other than\n *             numaaDestroy() when you're finished with the array.\n *             Adding a Numa will force a resize, destroying the ptr array.\n *           - Do not address the array outside its allocated size.\n *             With the bare array, there are no protections.  If the\n *             allocated size is n, array[n] is an error.\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaaGetValue",
      "comment" : "/*!\n *  numaaGetValue()\n *\n *      Input:  naa\n *              i (index of numa within numaa)\n *              j (index into numa)\n *              fval (<optional return> float value)\n *              ival (<optional return> int value)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaaJoin",
      "comment" : "/*!\n *  numaaJoin()\n *\n *      Input:  naad  (dest naa; add to this one)\n *              naas  (<optional> source naa; add from this one)\n *              istart  (starting index in nas)\n *              iend  (ending index in naas; use -1 to cat all)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) istart < 0 is taken to mean 'read from the start' (istart = 0)\n *      (2) iend < 0 means 'read to the end'\n *      (3) if naas == NULL, this is a no-op\n */",
      "file" : "numafunc1.c"
   },
   {
      "function" : "numaaRead",
      "comment" : "/*!\n *  numaaRead()\n *\n *      Input:  filename\n *      Return: naa, or null on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaaReadStream",
      "comment" : "/*!\n *  numaaReadStream()\n *\n *      Input:  stream\n *      Return: naa, or null on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaaReplaceNuma",
      "comment" : "/*!\n *  numaaReplaceNuma()\n *\n *      Input:  naa\n *              index  (to the index-th numa)\n *              numa (insert and replace any existing one)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Any existing numa is destroyed, and the input one\n *          is inserted in its place.\n *      (2) If the index is invalid, return 1 (error)\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaaTruncate",
      "comment" : "/*!\n *  numaaTruncate()\n *\n *      Input:  naa\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This identifies the largest index containing a numa that\n *          has any numbers within it, destroys all numa above that index,\n *          and resets the count.\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaaWrite",
      "comment" : "/*!\n *  numaaWrite()\n *\n *      Input:  filename, naa\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "numaaWriteStream",
      "comment" : "/*!\n *  numaaWriteStream()\n *\n *      Input:  stream, naa\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "numabasic.c"
   },
   {
      "function" : "octcubeGetCount",
      "comment" : "/*!\n *  octcubeGetCount()\n *\n *      Input:  level (valid values are in [1,...6]; there are 2^level\n *                     cubes along each side of the rgb cube)\n *              &size (<return> 2^(3 * level) cubes in the entire rgb cube)\n *      Return:  0 if OK, 1 on error.  Caller must check!\n *\n *         level:   1        2        3        4        5        6\n *         size:    8       64       512     4098     32784   262272\n */",
      "file" : "colorquant1.c"
   },
   {
      "function" : "octreeFindColorCell",
      "comment" : "/*!\n *  octreeFindColorCell()\n *\n *      Input:  octindex\n *              cqcaa\n *              &index   (<return> index of CTE; returned to set pixel value)\n *              &rval    (<return> of CTE)\n *              &gval    (<return> of CTE)\n *              &bval    (<return> of CTE)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) As this is in inner loop, we don't check input pointers!\n *      (2) This traverses from the root (well, actually from level 2,\n *          because the level 2 cubes are the largest CTE cubes),\n *          and finds the index number of the cell and the color values,\n *          which can be used either directly or in a (Floyd-Steinberg)\n *          error-diffusion dithering algorithm.\n */",
      "file" : "colorquant1.c"
   },
   {
      "function" : "octreeGenerateAndPrune",
      "comment" : "/*!\n *  octreeGenerateAndPrune()\n *\n *      Input:  pixs\n *              number of colors to use (between 128 and 256)\n *              number of reserved colors\n *              &cmap  (made and returned)\n *      Return: octree, colormap and number of colors used, or null\n *              on error\n *\n *  Notes:\n *      (1) The number of colors in the cmap may differ from the number\n *          of colors requested, but it will not be larger than 256\n */",
      "file" : "colorquant1.c"
   },
   {
      "function" : "openTiff",
      "comment" : "/*!\n *  openTiff()\n *\n *      Input:  filename\n *              modestring (\"r\", \"w\", ...)\n *      Return: tiff (data structure)\n *\n *  Notes:\n *      (1) This handles multi-platform file naming.\n */",
      "file" : "tiffio.c"
   },
   {
      "function" : "parseForProtos",
      "comment" : "/*\n *  parseForProtos()\n *\n *      Input:  filein (output of cpp)\n *              prestring (<optional> string that prefaces each decl;\n *                        use NULL to omit)\n *      Return: parsestr (string of function prototypes), or NULL on error\n *\n *  Notes:\n *      (1) We parse the output of cpp:\n *              cpp -ansi <filein>\n *          Three plans were attempted, with success on the third.\n *      (2) Plan 1.  A cursory examination of the cpp output indicated that\n *          every function was preceeded by a cpp comment statement.\n *          So we just need to look at statements beginning after comments.\n *          Unfortunately, this is NOT the case.  Some functions start\n *          without cpp comment lines, typically when there are no\n *          comments in the source that immediately precede the function.\n *      (3) Plan 2.  Consider the keywords in the language that start\n *          parts of the cpp file.  Some, like 'typedef', 'enum',\n *          'union' and 'struct', are followed after a while by '{',\n *          and eventually end with '}, plus an optional token and a\n *          final ';'  Others, like 'extern' and 'static', are never\n *          the beginnings of global function definitions.   Function\n *          prototypes have one or more sets of '(' followed eventually\n *          by a ')', and end with ';'.  But function definitions have\n *          tokens, followed by '(', more tokens, ')' and then\n *          immediately a '{'.  We would generate a prototype from this\n *          by adding a ';' to all tokens up to the ')'.  So we use\n *          these special tokens to decide what we are parsing.  And\n *          whenever a function definition is found and the prototype\n *          extracted, we skip through the rest of the function\n *          past the corresponding '}'.  This token ends a line, and\n *          is often on a line of its own.  But as it turns out,\n *          the only keyword we need to consider is 'static'.\n *      (4) Plan 3.  Consider the parentheses and braces for various\n *          declarations.  A struct, enum, or union has a pair of\n *          braces followed by a semicolon.  They cannot have parentheses\n *          before the left brace, but a struct can have lots of parentheses\n *          within the brace set.  A function prototype has no braces.\n *          A function declaration can have sets of left and right\n *          parentheses, but these are followed by a left brace.\n *          So plan 3 looks at the way parentheses and braces are\n *          organized.  Once the beginning of a function definition\n *          is found, the prototype is extracted and we search for\n *          the ending right brace.\n *      (5) To find the ending right brace, it is necessary to do some\n *          careful parsing.  For example, in this file, we have\n *          left and right braces as characters, and these must not\n *          be counted.  Somewhat more tricky, the file fhmtauto.c\n *          generates code, and includes a right brace in a string.\n *          So we must not include braces that are in strings.  But how\n *          do we know if something is inside a string?  Keep state,\n *          starting with not-inside, and every time you hit a double quote\n *          that is not escaped, toggle the condition.  Any brace\n *          found in the state of being within a string is ignored.\n *      (6) When a prototype is extracted, it is put in a canonical\n *          form (i.e., cleaned up).  Finally, we check that it is\n *          not static and save it.  (If static, it is ignored).\n *      (7) The @prestring for unix is NULL; it is included here so that\n *          you can use Microsoft's declaration for importing or\n *          exporting to a dll.  See environ.h for examples of use.\n *          Here, we set: @prestring = \"LEPT_DLL \".  Note in particular\n *          the space character that will separate 'LEPT_DLL' from\n *          the standard unix prototype that follows.\n */",
      "file" : "parseprotos.c"
   },
   {
      "function" : "parseStringForNumbers",
      "comment" : "/*!\n *  parseStringForNumbers()\n *\n *      Input:  string (containing numbers; not changed)\n *              seps (string of characters that can be used between ints)\n *      Return: numa (of numbers found), or null on error\n *\n *  Note:\n *     (1) The numbers can be ints or floats.\n */",
      "file" : "kernel.c"
   },
   {
      "function" : "parseTrailerPdf",
      "comment" : "/*!\n *  parseTrailerPdf()\n *\n *  Input:  bas (lba of a pdf file)\n *          da (<return> byte locations of the beginning of each object)\n *  Return: 0 if OK, 1 on error\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "partelCreate",
      "comment" : "/*!\n *  partelCreate()\n *\n *      Input:  box (region; inserts a copy)\n *      Return: partel, or null on error\n */",
      "file" : "partition.c"
   },
   {
      "function" : "partelDestroy",
      "comment" : "/*!\n *  partelDestroy()\n *\n *      Input:  &partel (<will be set to null before returning>)\n *      Return: void\n */",
      "file" : "partition.c"
   },
   {
      "function" : "partelSetSize",
      "comment" : "/*!\n *  partelSetSize()\n *\n *      Input:  partel\n *              sortflag (L_SORT_BY_WIDTH, L_SORT_BY_HEIGHT,\n *                        L_SORT_BY_MIN_DIMENSION, L_SORT_BY_MAX_DIMENSION,\n *                        L_SORT_BY_PERIMETER, L_SORT_BY_AREA)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "partition.c"
   },
   {
      "function" : "pathJoin",
      "comment" : "/*!\n *  pathJoin()\n *\n *      Input:  dir (<optional> can be null)\n *              fname (<optional> can be null)\n *      Return: specially concatenated path, or null on error\n *\n *  Notes:\n *      (1) Use unix-style pathname separators ('/').\n *      (2) @fname can be the entire path, or part of the path containing\n *          at least one directory, or a tail without a directory, or null.\n *      (3) It produces a path that strips multiple slashes to a single\n *          slash, joins @dir and @fname by a slash, and has no trailing\n *          slashes (except in the cases where @dir == \"/\" and\n *          @fname == NULL, or v.v.).\n *      (4) If both @dir and @fname are null, produces an empty string.\n *      (5) Neither @dir nor @fname can begin with '.'.\n *      (6) The result is not canonicalized or tested for correctness:\n *          garbage in (e.g., /&%), garbage out.\n *      (7) Examples:\n *             //tmp// + //abc/  -->  /tmp/abc\n *             tmp/ + /abc/      -->  tmp/abc\n *             tmp/ + abc/       -->  tmp/abc\n *             /tmp/ + ///       -->  /tmp\n *             /tmp/ + NULL      -->  /tmp\n *             // + /abc//       -->  /abc\n *             // + NULL         -->  /\n *             NULL + /abc/def/  -->  /abc/def\n *             NULL + abc//      -->  abc\n *             NULL + //         -->  /\n *             NULL + NULL       -->  (empty string)\n *             \"\" + \"\"           -->  (empty string)\n *             \"\" + /            -->  /\n *             \"..\" + /etc/foo   -->  NULL\n *             /tmp + \"..\"       -->  NULL\n */",
      "file" : "utils.c"
   },
   {
      "function" : "pdfdataCreate",
      "comment" : "/*---------------------------------------------------------------------*\n *                     Create/destroy/access pdf data                  *\n *---------------------------------------------------------------------*/",
      "file" : "pdfio.c"
   },
   {
      "function" : "pdfdataDestroy",
      "comment" : "/*---------------------------------------------------------------------*\n *                     Create/destroy/access pdf data                  *\n *---------------------------------------------------------------------*/",
      "file" : "pdfio.c"
   },
   {
      "function" : "pdfdataGetCid",
      "comment" : "/*---------------------------------------------------------------------*\n *                     Create/destroy/access pdf data                  *\n *---------------------------------------------------------------------*/",
      "file" : "pdfio.c"
   },
   {
      "function" : "pixAbsDiffByColumn",
      "comment" : "/*!\n *  pixAbsDiffByColumn()\n *\n *      Input:  pix (8 bpp; no colormap)\n *              box (<optional> clipping box for region; can be null)\n *      Return: na of abs val pixel difference averages by column,\n *              or null on error\n *\n *  Notes:\n *      (1) This is an average over differences of adjacent pixels along\n *          each column.\n *      (2) To resample for a bin size different from 1, use\n *          numaUniformSampling() on the result of this function.\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixAbsDiffByRow",
      "comment" : "/*!\n *  pixAbsDiffByRow()\n *\n *      Input:  pix (8 bpp; no colormap)\n *              box (<optional> clipping box for region; can be null)\n *      Return: na of abs val pixel difference averages by row, or null on error\n *\n *  Notes:\n *      (1) This is an average over differences of adjacent pixels along\n *          each row.\n *      (2) To resample for a bin size different from 1, use\n *          numaUniformSampling() on the result of this function.\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixAbsDiffInRect",
      "comment" : "/*!\n *  pixAbsDiffInRect()\n *\n *      Input:  pix (8 bpp; not cmapped)\n *              box (<optional> if null, use entire image)\n *              dir (differences along L_HORIZONTAL_LINE or L_VERTICAL_LINE)\n *              &absdiff (<return> average of abs diff pixel values in region)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This gives the average over the abs val of differences of\n *          adjacent pixels values, along either each\n *             row:     dir == L_HORIZONTAL_LINE\n *             column:  dir == L_VERTICAL_LINE\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixAbsDiffOnLine",
      "comment" : "/*!\n *  pixAbsDiffOnLine()\n *\n *      Input:  pix (8 bpp; not cmapped)\n *              x1, y1 (first point; x1 <= x2, y1 <= y2)\n *              x2, y2 (first point)\n *              &absdiff (<return> average of abs diff pixel values on line)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This gives the average over the abs val of differences of\n *          adjacent pixels values, along a line that is either horizontal\n *          or vertical.\n *      (2) If horizontal, require x1 < x2; if vertical, require y1 < y2.\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixAbsDifference",
      "comment" : "/*!\n *  pixAbsDifference()\n *\n *      Input:  pixs1, pixs2  (both either 8 or 16 bpp gray, or 32 bpp RGB)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) The depth of pixs1 and pixs2 must be equal.\n *      (2) Clips computation to the min size, aligning the UL corners\n *      (3) For 8 and 16 bpp, assumes one gray component.\n *      (4) For 32 bpp, assumes 3 color components, and ignores the\n *          LSB of each word (the alpha channel)\n *      (5) Computes the absolute value of the difference between\n *          each component value.\n */",
      "file" : "pixarith.c"
   },
   {
      "function" : "pixAccumulate",
      "comment" : "/*!\n *  pixAccumulate()\n *\n *      Input:  pixd (32 bpp)\n *              pixs (1, 8, 16 or 32 bpp)\n *              op  (L_ARITH_ADD or L_ARITH_SUBTRACT)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This adds or subtracts each pixs value from pixd.\n *      (2) This clips to the minimum of pixs and pixd, so they\n *          do not need to be the same size.\n *      (3) The alignment is to the origin (UL corner) of pixs & pixd.\n */",
      "file" : "pixarith.c"
   },
   {
      "function" : "pixAddAlphaToBlend",
      "comment" : "/*!\n *  pixAddAlphaToBlend()\n *\n *      Input:  pixs (any depth)\n *              fract (fade fraction in the alpha component)\n *              invert (1 to photometrically invert pixs)\n *      Return: pixd (32 bpp with alpha), or null on error\n *\n *  Notes:\n *      (1) This is a simple alpha layer generator, where typically white has\n *          maximum transparency and black has minimum.\n *      (2) If @invert == 1, generate the same alpha layer but invert\n *          the input image photometrically.  This is useful for blending\n *          over dark images, where you want dark regions in pixs, such\n *          as text, to be lighter in the blended image.\n *      (3) The fade @fract gives the minimum transparency (i.e.,\n *          maximum opacity).  A small fraction is useful for adding\n *          a watermark to an image.\n *      (4) If pixs has a colormap, it is removed to rgb.\n *      (5) If pixs already has an alpha layer, it is overwritten.\n */",
      "file" : "blend.c"
   },
   {
      "function" : "pixAddBlackOrWhiteBorder",
      "comment" : "/*!\n *  pixAddBlackOrWhiteBorder()\n *\n *      Input:  pixs (all depths; colormap ok)\n *              left, right, top, bot  (number of pixels added)\n *              op (L_GET_BLACK_VAL, L_GET_WHITE_VAL)\n *      Return: pixd (with the added exterior pixels), or null on error\n *\n *  Notes:\n *      (1) See pixGetBlackOrWhiteVal() for possible side effect (adding\n *          a color to a colormap).\n *      (2) The only complication is that pixs may have a colormap.\n *          There are two ways to add the black or white border:\n *          (a) As done here (simplest, most efficient)\n *          (b) l_int32 ws, hs, d;\n *              pixGetDimensions(pixs, &ws, &hs, &d);\n *              Pix *pixd = pixCreate(ws + left + right, hs + top + bot, d);\n *              PixColormap *cmap = pixGetColormap(pixs);\n *              if (cmap != NULL)\n *                  pixSetColormap(pixd, pixcmapCopy(cmap));\n *              pixSetBlackOrWhite(pixd, L_SET_WHITE);  // uses cmap\n *              pixRasterop(pixd, left, top, ws, hs, PIX_SET, pixs, 0, 0);\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixAddBorder",
      "comment" : "/*!\n *  pixAddBorder()\n *\n *      Input:  pixs (all depths; colormap ok)\n *              npix (number of pixels to be added to each side)\n *              val  (value of added border pixels)\n *      Return: pixd (with the added exterior pixels), or null on error\n *\n *  Notes:\n *      (1) See pixGetBlackOrWhiteVal() for values of black and white pixels.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixAddBorderGeneral",
      "comment" : "/*!\n *  pixAddBorderGeneral()\n *\n *      Input:  pixs (all depths; colormap ok)\n *              left, right, top, bot  (number of pixels added)\n *              val   (value of added border pixels)\n *      Return: pixd (with the added exterior pixels), or null on error\n *\n *  Notes:\n *      (1) For binary images:\n *             white:  val = 0\n *             black:  val = 1\n *          For grayscale images:\n *             white:  val = 2 ** d - 1\n *             black:  val = 0\n *          For rgb color images:\n *             white:  val = 0xffffff00\n *             black:  val = 0\n *          For colormapped images, set val to the appropriate colormap index.\n *      (2) If the added border is either black or white, you can use\n *             pixAddBlackOrWhiteBorder()\n *          The black and white values for all images can be found with\n *             pixGetBlackOrWhiteVal()\n *          which, if pixs is cmapped, may add an entry to the colormap.\n *          Alternatively, if pixs has a colormap, you can find the index\n *          of the pixel whose intensity is closest to white or black:\n *             white: pixcmapGetRankIntensity(cmap, 1.0, &index);\n *             black: pixcmapGetRankIntensity(cmap, 0.0, &index);\n *          and use that for val.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixAddConstantGray",
      "comment" : "/*!\n *  pixAddConstantGray()\n *\n *      Input:  pixs (8, 16 or 32 bpp)\n *              val  (amount to add to each pixel)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) In-place operation.\n *      (2) No clipping for 32 bpp.\n *      (3) For 8 and 16 bpp, if val > 0 the result is clipped\n *          to 0xff and 0xffff, rsp.\n *      (4) For 8 and 16 bpp, if val < 0 the result is clipped to 0.\n */",
      "file" : "pixarith.c"
   },
   {
      "function" : "pixAddContinuedBorder",
      "comment" : "/*!\n *  pixAddContinuedBorder()\n *\n *      Input:  pixs\n *              left, right, top, bot (pixels on each side to be added)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This adds pixels on each side whose values are equal to\n *          the value on the closest boundary pixel.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixAddGaussianNoise",
      "comment" : "/*!\n *  pixAddGaussianNoise()\n *\n *      Input:  pixs (8 bpp gray or 32 bpp rgb; no colormap)\n *              stdev (of noise)\n *      Return: pixd (8 or 32 bpp), or null on error\n *\n *  Notes:\n *      (1) This adds noise to each pixel, taken from a normal\n *          distribution with zero mean and specified standard deviation.\n */",
      "file" : "convolve.c"
   },
   {
      "function" : "pixAddGray",
      "comment" : "/*!\n *  pixAddGray()\n *\n *      Input:  pixd (<optional>; this can be null, equal to pixs1, or\n *                    different from pixs1)\n *              pixs1 (can be == to pixd)\n *              pixs2\n *      Return: pixd always\n *\n *  Notes:\n *      (1) Arithmetic addition of two 8, 16 or 32 bpp images.\n *      (2) For 8 and 16 bpp, we do explicit clipping to 0xff and 0xffff,\n *          respectively.\n *      (3) Alignment is to UL corner.\n *      (4) There are 3 cases.  The result can go to a new dest,\n *          in-place to pixs1, or to an existing input dest:\n *          * pixd == null:   (src1 + src2) --> new pixd\n *          * pixd == pixs1:  (src1 + src2) --> src1  (in-place)\n *          * pixd != pixs1:  (src1 + src2) --> input pixd\n *      (5) pixs2 must be different from both pixd and pixs1.\n */",
      "file" : "pixarith.c"
   },
   {
      "function" : "pixAddGrayColormap8",
      "comment" : "/*!\n *  pixAddGrayColormap8()\n *\n *      Input:  pixs (8 bpp)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If pixs has a colormap, this is a no-op.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixAddMinimalGrayColormap8",
      "comment" : "/*!\n *  pixAddMinimalGrayColormap8()\n *\n *      Input:  pixs (8 bpp)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This generates a colormapped version of the input image\n *          that has the same number of colormap entries as the\n *          input image has unique gray levels.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixAddMirroredBorder",
      "comment" : "/*!\n *  pixAddMirroredBorder()\n *\n *      Input:  pixs (all depths; colormap ok)\n *              left, right, top, bot (number of pixels added)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This applies what is effectively mirror boundary conditions.\n *          For the added border pixels in pixd, the pixels in pixs\n *          near the border are mirror-copied into the border region.\n *      (2) This is useful for avoiding special operations near\n *          boundaries when doing image processing operations\n *          such as rank filters and convolution.  In use, one first\n *          adds mirrored pixels to each side of the image.  The number\n *          of pixels added on each side is half the filter dimension.\n *          Then the image processing operations proceed over a\n *          region equal to the size of the original image, and\n *          write directly into a dest pix of the same size as pixs.\n *      (3) The general pixRasterop() is used for an in-place operation here\n *          because there is no overlap between the src and dest rectangles.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixAddMixedBorder",
      "comment" : "/*!\n *  pixAddMixedBorder()\n *\n *      Input:  pixs (all depths; colormap ok)\n *              left, right, top, bot (number of pixels added)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This applies mirrored boundary conditions horizontally\n *          and repeated b.c. vertically.\n *      (2) It is specifically used for avoiding special operations\n *          near boundaries when convolving a hue-saturation histogram\n *          with a given window size.  The repeated b.c. are used\n *          vertically for hue, and the mirrored b.c. are used\n *          horizontally for saturation.  The number of pixels added\n *          on each side is approximately (but not quite) half the\n *          filter dimension.  The image processing operations can\n *          then proceed over a region equal to the size of the original\n *          image, and write directly into a dest pix of the same\n *          size as pixs.\n *      (3) The general pixRasterop() can be used for an in-place\n *          operation here because there is no overlap between the\n *          src and dest rectangles.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixAddRGB",
      "comment" : "/*!\n *  pixAddRGB()\n *\n *      Input:  pixs1, pixs2  (32 bpp RGB, or colormapped)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Clips computation to the minimum size, aligning the UL corners.\n *      (2) Removes any colormap to RGB, and ignores the LSB of each\n *          pixel word (the alpha channel).\n *      (3) Adds each component value, pixelwise, clipping to 255.\n *      (4) This is useful to combine two images where most of the\n *          pixels are essentially black, such as in pixPerceptualDiff().\n */",
      "file" : "pixarith.c"
   },
   {
      "function" : "pixAddRepeatedBorder",
      "comment" : "/*!\n *  pixAddRepeatedBorder()\n *\n *      Input:  pixs (all depths; colormap ok)\n *              left, right, top, bot (number of pixels added)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This applies a repeated border, as if the central part of\n *          the image is tiled over the plane.  So, for example, the\n *          pixels in the left border come from the right side of the image.\n *      (2) The general pixRasterop() is used for an in-place operation here\n *          because there is no overlap between the src and dest rectangles.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixAddSingleTextblock",
      "comment" : "/*!\n *  pixAddSingleTextblock()\n *\n *      Input:  pixs (input pix; colormap ok)\n *              bmf (bitmap font data)\n *              textstr (<optional> text string to be added)\n *              val (color to set the text)\n *              location (L_ADD_ABOVE, L_ADD_AT_TOP, L_ADD_AT_BOT, L_ADD_BELOW)\n *              &overflow (<optional return> 1 if text overflows\n *                         allocated region and is clipped; 0 otherwise)\n *      Return: pixd (new pix with rendered text), or null on error\n *\n *  Notes:\n *      (1) This function paints a set of lines of text over an image.\n *          If @location is L_ADD_ABOVE or L_ADD_BELOW, the pix size\n *          is expanded with a border and rendered over the border.\n *      (2) @val is the pixel value to be painted through the font mask.\n *          It should be chosen to agree with the depth of pixs.\n *          If it is out of bounds, an intermediate value is chosen.\n *          For RGB, use hex notation: 0xRRGGBB00, where RR is the\n *          hex representation of the red intensity, etc.\n *      (3) If textstr == NULL, use the text field in the pix.\n *      (4) If there is a colormap, this does the best it can to use\n *          the requested color, or something similar to it.\n *      (5) Typical usage is for labelling a pix with some text data.\n */",
      "file" : "textops.c"
   },
   {
      "function" : "pixAddSingleTextline",
      "comment" : "/*!\n *  pixAddSingleTextline()\n *\n *      Input:  pixs (input pix; colormap ok)\n *              bmf (bitmap font data)\n *              textstr (<optional> text string to be added)\n *              val (color to set the text)\n *              location (L_ADD_ABOVE, L_ADD_BELOW, L_ADD_LEFT, L_ADD_RIGHT)\n *      Return: pixd (new pix with rendered text), or null on error\n *\n *  Notes:\n *      (1) This function expands an image as required to paint a single\n *          line of text adjacent to the image.\n *      (2) @val is the pixel value to be painted through the font mask.\n *          It should be chosen to agree with the depth of pixs.\n *          If it is out of bounds, an intermediate value is chosen.\n *          For RGB, use hex notation: 0xRRGGBB00, where RR is the\n *          hex representation of the red intensity, etc.\n *      (3) If textstr == NULL, use the text field in the pix.\n *      (4) If there is a colormap, this does the best it can to use\n *          the requested color, or something similar to it.\n *      (5) Typical usage is for labelling a pix with some text data.\n */",
      "file" : "textops.c"
   },
   {
      "function" : "pixAddText",
      "comment" : "/*!\n *  pixAddText()\n *\n *      Input:  pix\n *              textstring\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This adds the new textstring to any existing text.\n *      (2) Either or both the existing text and the new text\n *          string can be null.\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixAddWithIndicator",
      "comment" : "/*!\n *  pixAddWithIndicator()\n *\n *      Input:  pixs (1 bpp pix from which components are added; in-place)\n *              pixa (of connected components, some of which will be put\n *                    into pixs)\n *              na (numa indicator: add components corresponding to 1s)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This complements pixRemoveWithIndicator().   Here, the selected\n *          components are added to pixs.\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixAffine",
      "comment" : "/*!\n *  pixAffine()\n *\n *      Input:  pixs (all depths; colormap ok)\n *              vc  (vector of 6 coefficients for affine transformation)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Brings in either black or white pixels from the boundary\n *      (2) Removes any existing colormap, if necessary, before transforming\n */",
      "file" : "affine.c"
   },
   {
      "function" : "pixAffineColor",
      "comment" : "/*!\n *  pixAffineColor()\n *\n *      Input:  pixs (32 bpp)\n *              vc  (vector of 6 coefficients for affine transformation)\n *              colorval (e.g., 0 to bring in BLACK, 0xffffff00 for WHITE)\n *      Return: pixd, or null on error\n */",
      "file" : "affine.c"
   },
   {
      "function" : "pixAffineGray",
      "comment" : "/*!\n *  pixAffineGray()\n *\n *      Input:  pixs (8 bpp)\n *              vc  (vector of 6 coefficients for affine transformation)\n *              grayval (0 to bring in BLACK, 255 for WHITE)\n *      Return: pixd, or null on error\n */",
      "file" : "affine.c"
   },
   {
      "function" : "pixAffinePta",
      "comment" : "/*!\n *  pixAffinePta()\n *\n *      Input:  pixs (all depths; colormap ok)\n *              ptad  (3 pts of final coordinate space)\n *              ptas  (3 pts of initial coordinate space)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Brings in either black or white pixels from the boundary\n *      (2) Removes any existing colormap, if necessary, before transforming\n */",
      "file" : "affine.c"
   },
   {
      "function" : "pixAffinePtaColor",
      "comment" : "/*!\n *  pixAffinePtaColor()\n *\n *      Input:  pixs (32 bpp)\n *              ptad  (3 pts of final coordinate space)\n *              ptas  (3 pts of initial coordinate space)\n *              colorval (e.g., 0 to bring in BLACK, 0xffffff00 for WHITE)\n *      Return: pixd, or null on error\n */",
      "file" : "affine.c"
   },
   {
      "function" : "pixAffinePtaGray",
      "comment" : "/*!\n *  pixAffinePtaGray()\n *\n *      Input:  pixs (8 bpp)\n *              ptad  (3 pts of final coordinate space)\n *              ptas  (3 pts of initial coordinate space)\n *              grayval (0 to bring in BLACK, 255 for WHITE)\n *      Return: pixd, or null on error\n */",
      "file" : "affine.c"
   },
   {
      "function" : "pixAffinePtaWithAlpha",
      "comment" : "/*!\n *  pixAffinePtaWithAlpha()\n *\n *      Input:  pixs (32 bpp rgb)\n *              ptad  (3 pts of final coordinate space)\n *              ptas  (3 pts of initial coordinate space)\n *              pixg (<optional> 8 bpp, can be null)\n *              fract (between 0.0 and 1.0, with 0.0 fully transparent\n *                     and 1.0 fully opaque)\n *              border (of pixels added to capture transformed source pixels)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) The alpha channel is transformed separately from pixs,\n *          and aligns with it, being fully transparent outside the\n *          boundary of the transformed pixs.  For pixels that are fully\n *          transparent, a blending function like pixBlendWithGrayMask()\n *          will give zero weight to corresponding pixels in pixs.\n *      (2) If pixg is NULL, it is generated as an alpha layer that is\n *          partially opaque, using @fract.  Otherwise, it is cropped\n *          to pixs if required and @fract is ignored.  The alpha channel\n *          in pixs is never used.\n *      (3) Colormaps are removed.\n *      (4) When pixs is transformed, it doesn't matter what color is brought\n *          in because the alpha channel will be transparent (0) there.\n *      (5) To avoid losing source pixels in the destination, it may be\n *          necessary to add a border to the source pix before doing\n *          the affine transformation.  This can be any non-negative number.\n *      (6) The input @ptad and @ptas are in a coordinate space before\n *          the border is added.  Internally, we compensate for this\n *          before doing the affine transform on the image after the border\n *          is added.\n *      (7) The default setting for the border values in the alpha channel\n *          is 0 (transparent) for the outermost ring of pixels and\n *          (0.5 * fract * 255) for the second ring.  When blended over\n *          a second image, this\n *          (a) shrinks the visible image to make a clean overlap edge\n *              with an image below, and\n *          (b) softens the edges by weakening the aliasing there.\n *          Use l_setAlphaMaskBorder() to change these values.\n *      (8) A subtle use of gamma correction is to remove gamma correction\n *          before scaling and restore it afterwards.  This is done\n *          by sandwiching this function between a gamma/inverse-gamma\n *          photometric transform:\n *              pixt = pixGammaTRCWithAlpha(NULL, pixs, 1.0 / gamma, 0, 255);\n *              pixd = pixAffinePtaWithAlpha(pixg, ptad, ptas, NULL,\n *                                           fract, border);\n *              pixGammaTRCWithAlpha(pixd, pixd, gamma, 0, 255);\n *              pixDestroy(&pixt);\n *          This has the side-effect of producing artifacts in the very\n *          dark regions.\n */",
      "file" : "affine.c"
   },
   {
      "function" : "pixAffineSampled",
      "comment" : "/*!\n *  pixAffineSampled()\n *\n *      Input:  pixs (all depths)\n *              vc  (vector of 6 coefficients for affine transformation)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Brings in either black or white pixels from the boundary.\n *      (2) Retains colormap, which you can do for a sampled transform..\n *      (3) For 8 or 32 bpp, much better quality is obtained by the\n *          somewhat slower pixAffine().  See that function\n *          for relative timings between sampled and interpolated.\n */",
      "file" : "affine.c"
   },
   {
      "function" : "pixAffineSampledPta",
      "comment" : "/*!\n *  pixAffineSampledPta()\n *\n *      Input:  pixs (all depths)\n *              ptad  (3 pts of final coordinate space)\n *              ptas  (3 pts of initial coordinate space)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Brings in either black or white pixels from the boundary.\n *      (2) Retains colormap, which you can do for a sampled transform..\n *      (3) The 3 points must not be collinear.\n *      (4) The order of the 3 points is arbitrary; however, to compare\n *          with the sequential transform they must be in these locations\n *          and in this order: origin, x-axis, y-axis.\n *      (5) For 1 bpp images, this has much better quality results\n *          than pixAffineSequential(), particularly for text.\n *          It is about 3x slower, but does not require additional\n *          border pixels.  The poor quality of pixAffineSequential()\n *          is due to repeated quantized transforms.  It is strongly\n *          recommended that pixAffineSampled() be used for 1 bpp images.\n *      (6) For 8 or 32 bpp, much better quality is obtained by the\n *          somewhat slower pixAffinePta().  See that function\n *          for relative timings between sampled and interpolated.\n *      (7) To repeat, use of the sequential transform,\n *          pixAffineSequential(), for any images, is discouraged.\n */",
      "file" : "affine.c"
   },
   {
      "function" : "pixAffineSequential",
      "comment" : "/*!\n *  pixAffineSequential()\n *\n *      Input:  pixs\n *              ptad  (3 pts of final coordinate space)\n *              ptas  (3 pts of initial coordinate space)\n *              bw    (pixels of additional border width during computation)\n *              bh    (pixels of additional border height during computation)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) The 3 pts must not be collinear.\n *      (2) The 3 pts must be given in this order:\n *           - origin\n *           - a location along the x-axis\n *           - a location along the y-axis.\n *      (3) You must guess how much border must be added so that no\n *          pixels are lost in the transformations from src to\n *          dest coordinate space.  (This can be calculated but it\n *          is a lot of work!)  For coordinate spaces that are nearly\n *          at right angles, on a 300 ppi scanned page, the addition\n *          of 1000 pixels on each side is usually sufficient.\n *      (4) This is here for pedagogical reasons.  It is about 3x faster\n *          on 1 bpp images than pixAffineSampled(), but the results\n *          on text are much inferior.\n */",
      "file" : "affine.c"
   },
   {
      "function" : "pixAlphaBlendUniform",
      "comment" : "/*!\n *  pixAlphaBlendUniform()\n *\n *      Input:  pixs (32 bpp rgba, with alpha)\n *              color (32 bit color in 0xrrggbb00 format)\n *      Return: pixd (32 bpp rgb: pixs blended over uniform color @color),\n *                    a clone of pixs if no alpha, and null on error\n *\n *  Notes:\n *      (1) This is a convenience function that renders 32 bpp RGBA images\n *          (with an alpha channel) over a uniform background of\n *          value @color.  To render over a white background,\n *          use @color = 0xffffff00.  The result is an RGB image.\n *      (2) If pixs does not have an alpha channel, it returns a clone\n *          of pixs.\n */",
      "file" : "blend.c"
   },
   {
      "function" : "pixAlphaIsOpaque",
      "comment" : "/*!\n *  pixAlphaIsOpaque()\n *\n *      Input:  pix (32 bpp, spp == 4)\n *              &opaque (<return> 1 if spp == 4 and all alpha component\n *                       values are 255 (opaque); 0 otherwise)\n *      Return: 0 if OK, 1 on error\n *      Notes:\n *          (1) On error, opaque is returned as 0 (FALSE).\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixAnd",
      "comment" : "/*!\n *  pixAnd()\n *\n *      Input:  pixd  (<optional>; this can be null, equal to pixs1,\n *                     different from pixs1)\n *              pixs1 (can be == pixd)\n *              pixs2 (must be != pixd)\n *      Return: pixd always\n *\n *  Notes:\n *      (1) This gives the intersection of two images with equal depth,\n *          aligning them to the the UL corner.  pixs1 and pixs2\n *          need not have the same width and height.\n *      (2) There are 3 cases:\n *            (a) pixd == null,   (src1 & src2) --> new pixd\n *            (b) pixd == pixs1,  (src1 & src2) --> src1  (in-place)\n *            (c) pixd != pixs1,  (src1 & src2) --> input pixd\n *      (3) For clarity, if the case is known, use these patterns:\n *            (a) pixd = pixAnd(NULL, pixs1, pixs2);\n *            (b) pixAnd(pixs1, pixs1, pixs2);\n *            (c) pixAnd(pixd, pixs1, pixs2);\n *      (4) The size of the result is determined by pixs1.\n *      (5) The depths of pixs1 and pixs2 must be equal.\n *      (6) Note carefully that the order of pixs1 and pixs2 only matters\n *          for the in-place case.  For in-place, you must have\n *          pixd == pixs1.  Setting pixd == pixs2 gives an incorrect\n *          result: the copy puts pixs1 image data in pixs2, and\n *          the rasterop is then between pixs2 and pixs2 (a no-op).\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixApplyHorizDisparity",
      "comment" : "/*!\n *  pixApplyHorizDisparity()\n *\n *      Input:  dew\n *              pixs (1, 8 or 32 bpp)\n *              grayin (gray value, from 0 to 255, for pixels brought in;\n *                      use -1 to use pixels on the boundary of pixs)\n *      Return: pixd (modified to remove horizontal disparity if possible),\n *              or null on error.\n *\n *  Notes:\n *      (1) This applies the horizontal disparity array to the specified\n *          image.\n *      (2) Specify gray color for pixels brought in from the outside:\n *          0 is black, 255 is white.  Use -1 to select pixels from the\n *          boundary of the source image.\n *      (3) The input pixs has already been corrected for vertical disparity.\n *          If the horizontal disparity array doesn't exist, this returns\n *          a clone of @pixs.\n */",
      "file" : "dewarp3.c"
   },
   {
      "function" : "pixApplyInvBackgroundGrayMap",
      "comment" : "/*!\n *  pixApplyInvBackgroundGrayMap()\n *\n *      Input:  pixs (8 bpp grayscale; no colormap)\n *              pixm (16 bpp, inverse background map)\n *              sx (tile width in pixels)\n *              sy (tile height in pixels)\n *      Return: pixd (8 bpp), or null on error\n */",
      "file" : "adaptmap.c"
   },
   {
      "function" : "pixApplyInvBackgroundRGBMap",
      "comment" : "/*!\n *  pixApplyInvBackgroundRGBMap()\n *\n *      Input:  pixs (32 bpp rbg)\n *              pixmr (16 bpp, red inverse background map)\n *              pixmg (16 bpp, green inverse background map)\n *              pixmb (16 bpp, blue inverse background map)\n *              sx (tile width in pixels)\n *              sy (tile height in pixels)\n *      Return: pixd (32 bpp rbg), or null on error\n */",
      "file" : "adaptmap.c"
   },
   {
      "function" : "pixApplyLocalThreshold",
      "comment" : "/*!\n *  pixApplyLocalThreshold()\n *\n *      Input:  pixs (8 bpp grayscale; not colormapped)\n *              pixth (8 bpp array of local thresholds)\n *              redfactor ( ... )\n *      Return: pixd (1 bpp, thresholded image), or null on error\n */",
      "file" : "binarize.c"
   },
   {
      "function" : "pixApplyVariableGrayMap",
      "comment" : "/*!\n *  pixApplyVariableGrayMap()\n *\n *      Input:  pixs (8 bpp)\n *              pixg (8 bpp, variable map)\n *              target (typ. 128 for threshold)\n *      Return: pixd (8 bpp), or null on error\n *\n *  Notes:\n *      (1) Suppose you have an image that you want to transform based\n *          on some photometric measurement at each point, such as the\n *          threshold value for binarization.  Representing the photometric\n *          measurement as an image pixg, you can threshold in input image\n *          using pixVarThresholdToBinary().  Alternatively, you can map\n *          the input image pointwise so that the threshold over the\n *          entire image becomes a constant, such as 128.  For example,\n *          if a pixel in pixg is 150 and the target is 128, the\n *          corresponding pixel in pixs is mapped linearly to a value\n *          (128/150) of the input value.  If the resulting mapped image\n *          pixd were then thresholded at 128, you would obtain the\n *          same result as a direct binarization using pixg with\n *          pixVarThresholdToBinary().\n *      (2) The sizes of pixs and pixg must be equal.\n */",
      "file" : "adaptmap.c"
   },
   {
      "function" : "pixApplyVertDisparity",
      "comment" : "/*!\n *  pixApplyVertDisparity()\n *\n *      Input:  dew\n *              pixs (1, 8 or 32 bpp)\n *              grayin (gray value, from 0 to 255, for pixels brought in;\n *                      use -1 to use pixels on the boundary of pixs)\n *      Return: pixd (modified to remove vertical disparity), or null on error\n *\n *  Notes:\n *      (1) This applies the vertical disparity array to the specified\n *          image.  For src pixels above the image, we use the pixels\n *          in the first raster line.\n *      (2) Specify gray color for pixels brought in from the outside:\n *          0 is black, 255 is white.  Use -1 to select pixels from the\n *          boundary of the source image.\n */",
      "file" : "dewarp3.c"
   },
   {
      "function" : "pixAssignToNearestColor",
      "comment" : "/*!\n *  pixAssignToNearestColor()\n *\n *      Input:  pixd  (8 bpp, colormapped)\n *              pixs  (32 bpp; 24-bit color)\n *              pixm  (<optional> 1 bpp)\n *              level (of octcube used for finding nearest color in cmap)\n *              countarray (<optional> ptr to array, in which we can store\n *                          the number of pixels found in each color in\n *                          the colormap in pixd)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is used in phase 2 of color segmentation, where pixs\n *          is the original input image to pixColorSegment(), and\n *          pixd is the colormapped image returned from\n *          pixColorSegmentCluster().  It is also used, with a mask,\n *          in phase 4.\n *      (2) This is an in-place operation.\n *      (3) The colormap in pixd is unchanged.\n *      (4) pixs and pixd must be the same size (w, h).\n *      (5) The selection mask pixm can be null.  If it exists, it must\n *          be the same size as pixs and pixd, and only pixels\n *          corresponding to fg in pixm are assigned.  Set to\n *          NULL if all pixels in pixd are to be assigned.\n *      (6) The countarray can be null.  If it exists, it is pre-allocated\n *          and of a size at least equal to the size of the colormap in pixd.\n *      (7) This does a best-fit (non-greedy) assignment of pixels to\n *          existing clusters.  Specifically, it assigns each pixel\n *          in pixd to the color index in the pixd colormap that has a\n *          color closest to the corresponding rgb pixel in pixs.\n *      (8) 'level' is the octcube level used to quickly find the nearest\n *          color in the colormap for each pixel.  For color segmentation,\n *          this parameter is set to LEVEL_IN_OCTCUBE.\n *      (9) We build a mapping table from octcube to colormap index so\n *          that this function can run in a time (otherwise) independent\n *          of the number of colors in the colormap.  This avoids a\n *          brute-force search for the closest colormap color to each\n *          pixel in the image.\n */",
      "file" : "colorseg.c"
   },
   {
      "function" : "pixAverageByColumn",
      "comment" : "/*!\n *  pixAverageByColumn()\n *\n *      Input:  pix (8 or 16 bpp; no colormap)\n *              box (<optional> clipping box for sum; can be null)\n *              type (L_WHITE_IS_MAX, L_BLACK_IS_MAX)\n *      Return: na of pixel averages by column, or null on error\n *\n *  Notes:\n *      (1) To resample for a bin size different from 1, use\n *          numaUniformSampling() on the result of this function.\n *      (2) If type == L_BLACK_IS_MAX, black pixels get the maximum\n *          value (0xff for 8 bpp, 0xffff for 16 bpp) and white get 0.\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixAverageByRow",
      "comment" : "/*!\n *  pixAverageByRow()\n *\n *      Input:  pix (8 or 16 bpp; no colormap)\n *              box (<optional> clipping box for sum; can be null)\n *              type (L_WHITE_IS_MAX, L_BLACK_IS_MAX)\n *      Return: na of pixel averages by row, or null on error\n *\n *  Notes:\n *      (1) To resample for a bin size different from 1, use\n *          numaUniformSampling() on the result of this function.\n *      (2) If type == L_BLACK_IS_MAX, black pixels get the maximum\n *          value (0xff for 8 bpp, 0xffff for 16 bpp) and white get 0.\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixAverageInRect",
      "comment" : "/*!\n *  pixAverageInRect()\n *\n *      Input:  pix (1, 2, 4, 8 bpp; not cmapped)\n *              box (<optional> if null, use entire image)\n *              &ave (<return> average of pixel values in region)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixAverageIntensityProfile",
      "comment" : "/*!\n *  pixAverageIntensityProfile()\n *\n *      Input:  pixs (any depth; colormap OK)\n *              fract (fraction of image width or height to be used)\n *              dir (averaging direction: L_HORIZONTAL_LINE or L_VERTICAL_LINE)\n *              first, last (span of rows or columns to measure)\n *              factor1 (sampling along fast scan direction; >= 1)\n *              factor2 (sampling along slow scan direction; >= 1)\n *      Return: na (of reversal profile), or null on error.\n *\n *  Notes:\n *      (1) If d != 1 bpp, colormaps are removed and the result\n *          is converted to 8 bpp.\n *      (2) If @dir == L_HORIZONTAL_LINE, the intensity is averaged\n *          along each horizontal raster line (sampled by @factor1),\n *          and the profile is the array of these averages in the\n *          vertical direction between @first and @last raster lines,\n *          and sampled by @factor2.\n *      (3) If @dir == L_VERTICAL_LINE, the intensity is averaged\n *          along each vertical line (sampled by @factor1),\n *          and the profile is the array of these averages in the\n *          horizontal direction between @first and @last columns,\n *          and sampled by @factor2.\n *      (4) The averages are measured over the central @fract of the image.\n *          Use @fract == 1.0 to average across the entire width or height.\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixAverageOnLine",
      "comment" : "/*!\n *  pixAverageOnLine()\n *\n *      Input:  pixs (1 bpp or 8 bpp; no colormap)\n *              x1, y1 (starting pt for line)\n *              x2, y2 (end pt for line)\n *              factor (sampling; >= 1)\n *      Return: average of pixel values along line, or null on error.\n *\n *  Notes:\n *      (1) The line must be either horizontal or vertical, so either\n *          y1 == y2 (horizontal) or x1 == x2 (vertical).\n *      (2) If horizontal, x1 must be <= x2.\n *          If vertical, y1 must be <= y2.\n *          characterize the intensity smoothness along a line.\n *      (3) Input end points are clipped to the pix.\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixAverageRasterScans",
      "comment" : "/*!\n *  pixAverageRasterScans()\n *\n *      Input:  pixs (input image; 8 bpp)\n *              nscans (number of adjacent scans, about the center vertically)\n *      Return: numa (of average pixel values across image), or null on error\n */",
      "file" : "readbarcode.c"
   },
   {
      "function" : "pixBackgroundNorm",
      "comment" : "/*!\n *  pixBackgroundNorm()\n *\n *      Input:  pixs (8 bpp grayscale or 32 bpp rgb)\n *              pixim (<optional> 1 bpp 'image' mask; can be null)\n *              pixg (<optional> 8 bpp grayscale version; can be null)\n *              sx, sy (tile size in pixels)\n *              thresh (threshold for determining foreground)\n *              mincount (min threshold on counts in a tile)\n *              bgval (target bg val; typ. > 128)\n *              smoothx (half-width of block convolution kernel width)\n *              smoothy (half-width of block convolution kernel height)\n *      Return: pixd (8 bpp or 32 bpp rgb), or null on error\n *\n *  Notes:\n *    (1) This is a top-level interface for normalizing the image intensity\n *        by mapping the image so that the background is near the input\n *        value 'bgval'.\n *    (2) The input image is either grayscale or rgb.\n *    (3) For each component in the input image, the background value\n *        in each tile is estimated using the values in the tile that\n *        are not part of the foreground, where the foreground is\n *        determined by the input 'thresh' argument.\n *    (4) An optional binary mask can be specified, with the foreground\n *        pixels typically over image regions.  The resulting background\n *        map values will be determined by surrounding pixels that are\n *        not under the mask foreground.  The origin (0,0) of this mask\n *        is assumed to be aligned with the origin of the input image.\n *        This binary mask must not fully cover pixs, because then there\n *        will be no pixels in the input image available to compute\n *        the background.\n *    (5) An optional grayscale version of the input pixs can be supplied.\n *        The only reason to do this is if the input is RGB and this\n *        grayscale version can be used elsewhere.  If the input is RGB\n *        and this is not supplied, it is made internally using only\n *        the green component, and destroyed after use.\n *    (6) The dimensions of the pixel tile (sx, sy) give the amount by\n *        by which the map is reduced in size from the input image.\n *    (7) The threshold is used to binarize the input image, in order to\n *        locate the foreground components.  If this is set too low,\n *        some actual foreground may be used to determine the maps;\n *        if set too high, there may not be enough background\n *        to determine the map values accurately.  Typically, it's\n *        better to err by setting the threshold too high.\n *    (8) A 'mincount' threshold is a minimum count of pixels in a\n *        tile for which a background reading is made, in order for that\n *        pixel in the map to be valid.  This number should perhaps be\n *        at least 1/3 the size of the tile.\n *    (9) A 'bgval' target background value for the normalized image.  This\n *        should be at least 128.  If set too close to 255, some\n *        clipping will occur in the result.\n *    (10) Two factors, 'smoothx' and 'smoothy', are input for smoothing\n *        the map.  Each low-pass filter kernel dimension is\n *        is 2 * (smoothing factor) + 1, so a\n *        value of 0 means no smoothing. A value of 1 or 2 is recommended.\n */",
      "file" : "adaptmap.c"
   },
   {
      "function" : "pixBackgroundNormFlex",
      "comment" : "/*!\n *  pixBackgroundNormFlex()\n *\n *      Input:  pixs (8 bpp grayscale; not colormapped)\n *              sx, sy (desired tile dimensions; actual size may vary; use\n *                      values between 3 and 10)\n *              smoothx, smoothy (half-width of convolution kernel applied to\n *                                threshold array: use values between 1 and 3)\n *              delta (difference parameter in basin filling; use 0\n *                     to skip)\n *      Return: pixd (8 bpp, background-normalized), or null on error)\n *\n *  Notes:\n *      (1) This does adaptation flexibly to a quickly varying background.\n *          For that reason, all input parameters should be small.\n *      (2) sx and sy give the tile size; they should be in [5 - 7].\n *      (3) The full width and height of the convolution kernel\n *          are (2 * smoothx + 1) and (2 * smoothy + 1).  They\n *          should be in [1 - 2].\n *      (4) Basin filling is used to fill the large fg regions.  The\n *          parameter @delta measures the height that the black\n *          background is raised from the local minima.  By raising\n *          the background, it is possible to threshold the large\n *          fg regions to foreground.  If @delta is too large,\n *          bg regions will be lifted, causing thickening of\n *          the fg regions.  Use 0 to skip.\n */",
      "file" : "adaptmap.c"
   },
   {
      "function" : "pixBackgroundNormGrayArray",
      "comment" : "/*!\n *  pixBackgroundNormGrayArray()\n *\n *      Input:  pixs (8 bpp grayscale)\n *              pixim (<optional> 1 bpp 'image' mask; can be null)\n *              sx, sy (tile size in pixels)\n *              thresh (threshold for determining foreground)\n *              mincount (min threshold on counts in a tile)\n *              bgval (target bg val; typ. > 128)\n *              smoothx (half-width of block convolution kernel width)\n *              smoothy (half-width of block convolution kernel height)\n *              &pixd (<return> 16 bpp array of inverted background value)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *    (1) See notes in pixBackgroundNorm().\n *    (2) This returns a 16 bpp pix that can be used by\n *        pixApplyInvBackgroundGrayMap() to generate a normalized version\n *        of the input pixs.\n */",
      "file" : "adaptmap.c"
   },
   {
      "function" : "pixBackgroundNormGrayArrayMorph",
      "comment" : "/*!\n *  pixBackgroundNormGrayArrayMorph()\n *\n *      Input:  pixs (8 bpp grayscale)\n *              pixim (<optional> 1 bpp 'image' mask; can be null)\n *              reduction (at which morph closings are done; between 2 and 16)\n *              size (of square Sel for the closing; use an odd number)\n *              bgval (target bg val; typ. > 128)\n *              &pixd (<return> 16 bpp array of inverted background value)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *    (1) See notes in pixBackgroundNormMorph().\n *    (2) This returns a 16 bpp pix that can be used by\n *        pixApplyInvBackgroundGrayMap() to generate a normalized version\n *        of the input pixs.\n */",
      "file" : "adaptmap.c"
   },
   {
      "function" : "pixBackgroundNormMorph",
      "comment" : "/*!\n *  pixBackgroundNormMorph()\n *\n *      Input:  pixs (8 bpp grayscale or 32 bpp rgb)\n *              pixim (<optional> 1 bpp 'image' mask; can be null)\n *              reduction (at which morph closings are done; between 2 and 16)\n *              size (of square Sel for the closing; use an odd number)\n *              bgval (target bg val; typ. > 128)\n *      Return: pixd (8 bpp), or null on error\n *\n *  Notes:\n *    (1) This is a top-level interface for normalizing the image intensity\n *        by mapping the image so that the background is near the input\n *        value 'bgval'.\n *    (2) The input image is either grayscale or rgb.\n *    (3) For each component in the input image, the background value\n *        is estimated using a grayscale closing; hence the 'Morph'\n *        in the function name.\n *    (4) An optional binary mask can be specified, with the foreground\n *        pixels typically over image regions.  The resulting background\n *        map values will be determined by surrounding pixels that are\n *        not under the mask foreground.  The origin (0,0) of this mask\n *        is assumed to be aligned with the origin of the input image.\n *        This binary mask must not fully cover pixs, because then there\n *        will be no pixels in the input image available to compute\n *        the background.\n *    (5) The map is computed at reduced size (given by 'reduction')\n *        from the input pixs and optional pixim.  At this scale,\n *        pixs is closed to remove the background, using a square Sel\n *        of odd dimension.  The product of reduction * size should be\n *        large enough to remove most of the text foreground.\n *    (6) No convolutional smoothing needs to be done on the map before\n *        inverting it.\n *    (7) A 'bgval' target background value for the normalized image.  This\n *        should be at least 128.  If set too close to 255, some\n *        clipping will occur in the result.\n */",
      "file" : "adaptmap.c"
   },
   {
      "function" : "pixBackgroundNormRGBArrays",
      "comment" : "/*!\n *  pixBackgroundNormRGBArrays()\n *\n *      Input:  pixs (32 bpp rgb)\n *              pixim (<optional> 1 bpp 'image' mask; can be null)\n *              pixg (<optional> 8 bpp grayscale version; can be null)\n *              sx, sy (tile size in pixels)\n *              thresh (threshold for determining foreground)\n *              mincount (min threshold on counts in a tile)\n *              bgval (target bg val; typ. > 128)\n *              smoothx (half-width of block convolution kernel width)\n *              smoothy (half-width of block convolution kernel height)\n *              &pixr (<return> 16 bpp array of inverted R background value)\n *              &pixg (<return> 16 bpp array of inverted G background value)\n *              &pixb (<return> 16 bpp array of inverted B background value)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *    (1) See notes in pixBackgroundNorm().\n *    (2) This returns a set of three 16 bpp pix that can be used by\n *        pixApplyInvBackgroundGrayMap() to generate a normalized version\n *        of each component of the input pixs.\n */",
      "file" : "adaptmap.c"
   },
   {
      "function" : "pixBackgroundNormRGBArraysMorph",
      "comment" : "/*!\n *  pixBackgroundNormRGBArraysMorph()\n *\n *      Input:  pixs (32 bpp rgb)\n *              pixim (<optional> 1 bpp 'image' mask; can be null)\n *              reduction (at which morph closings are done; between 2 and 16)\n *              size (of square Sel for the closing; use an odd number)\n *              bgval (target bg val; typ. > 128)\n *              &pixr (<return> 16 bpp array of inverted R background value)\n *              &pixg (<return> 16 bpp array of inverted G background value)\n *              &pixb (<return> 16 bpp array of inverted B background value)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *    (1) See notes in pixBackgroundNormMorph().\n *    (2) This returns a set of three 16 bpp pix that can be used by\n *        pixApplyInvBackgroundGrayMap() to generate a normalized version\n *        of each component of the input pixs.\n */",
      "file" : "adaptmap.c"
   },
   {
      "function" : "pixBackgroundNormSimple",
      "comment" : "/*!\n *  pixBackgroundNormSimple()\n *\n *      Input:  pixs (8 bpp grayscale or 32 bpp rgb)\n *              pixim (<optional> 1 bpp 'image' mask; can be null)\n *              pixg (<optional> 8 bpp grayscale version; can be null)\n *      Return: pixd (8 bpp or 32 bpp rgb), or null on error\n *\n *  Notes:\n *    (1) This is a simplified interface to pixBackgroundNorm(),\n *        where seven parameters are defaulted.\n *    (2) The input image is either grayscale or rgb.\n *    (3) See pixBackgroundNorm() for usage and function.\n */",
      "file" : "adaptmap.c"
   },
   {
      "function" : "pixBestCorrelation",
      "comment" : "/*!\n *  pixBestCorrelation()\n *\n *      Input:  pix1   (1 bpp)\n *              pix2   (1 bpp)\n *              area1  (number of on pixels in pix1)\n *              area2  (number of on pixels in pix2)\n *              etransx (estimated x translation of pix2 to align with pix1)\n *              etransy (estimated y translation of pix2 to align with pix1)\n *              maxshift  (max x and y shift of pix2, around the estimated\n *                          alignment location, relative to pix1)\n *              tab8 (<optional> sum tab for ON pixels in byte; can be NULL)\n *              &delx (<optional return> best x shift of pix2 relative to pix1\n *              &dely (<optional return> best y shift of pix2 relative to pix1\n *              &score (<optional return> maximum score found; can be NULL)\n *              debugflag (<= 0 to skip; positive to generate output.\n *                         The integer is used to label the debug image.)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This maximizes the correlation score between two 1 bpp images,\n *          by starting with an estimate of the alignment\n *          (@etransx, @etransy) and computing the correlation around this.\n *          It optionally returns the shift (@delx, @dely) that maximizes\n *          the correlation score when pix2 is shifted by this amount\n *          relative to pix1.\n *      (2) Get the centroids of pix1 and pix2, using pixCentroid(),\n *          to compute (@etransx, @etransy).  Get the areas using\n *          pixCountPixels().\n *      (3) The centroid of pix2 is shifted with respect to the centroid\n *          of pix1 by all values between -maxshiftx and maxshiftx,\n *          and likewise for the y shifts.  Therefore, the number of\n *          correlations computed is:\n *               (2 * maxshiftx + 1) * (2 * maxshifty + 1)\n *          Consequently, if pix1 and pix2 are large, you should do this\n *          in a coarse-to-fine sequence.  See the use of this function\n *          in pixCompareWithTranslation().\n */",
      "file" : "compare.c"
   },
   {
      "function" : "pixBilateral",
      "comment" : "/*!\n *  pixBilateral()\n *\n *      Input:  pixs (8 bpp gray or 32 bpp rgb, no colormap)\n *              spatial_stdev  (of gaussian kernel; in pixels, > 0.5)\n *              range_stdev  (of gaussian range kernel; > 5.0; typ. 50.0)\n *              ncomps (number of intermediate sums J(k,x); in [4 ... 30])\n *              reduction  (1, 2 or 4)\n *      Return: pixd (bilateral filtered image), or null on error\n *\n *  Notes:\n *      (1) This performs a relatively fast, separable bilateral\n *          filtering operation.  The time is proportional to ncomps\n *          and varies inversely approximately as the cube of the\n *          reduction factor.  See bilateral.h for algorithm details.\n *      (2) We impose minimum values for range_stdev and ncomps to\n *          avoid nasty artifacts when either are too small.  We also\n *          impose a constraint on their product:\n *               ncomps * range_stdev >= 100.\n *          So for values of range_stdev >= 25, ncomps can be as small as 4.\n *          Here is a qualitative, intuitive explanation for this constraint.\n *          Call the difference in k values between the J(k) == 'delta', where\n *              'delta' ~ 200 / ncomps\n *          Then this constraint is roughly equivalent to the condition:\n *              'delta' < 2 * range_stdev\n *          Note that at an intensity difference of (2 * range_stdev), the\n *          range part of the kernel reduces the effect by the factor 0.14.\n *          This constraint requires that we have a sufficient number of\n *          PCBs (i.e, a small enough 'delta'), so that for any value of\n *          image intensity I, there exists a k (and a PCB, J(k), such that\n *              |I - k| < range_stdev\n *          Any fewer PCBs and we don't have enough to support this condition.\n *      (3) The upper limit of 30 on ncomps is imposed because the\n *          gain in accuracy is not worth the extra computation.\n *      (4) The size of the gaussian kernel is twice the spatial_stdev\n *          on each side of the origin.  The minimum value of\n *          spatial_stdev, 0.5, is required to have a finite sized\n *          spatial kernel.  In practice, a much larger value is used.\n *      (5) Computation of the intermediate images goes inversely\n *          as the cube of the reduction factor.  If you can use a\n *          reduction of 2 or 4, it is well-advised.\n *      (6) The range kernel is defined over the absolute value of pixel\n *          grayscale differences, and hence must have size 256 x 1.\n *          Values in the array represent the multiplying weight\n *          depending on the absolute gray value difference between\n *          the source pixel and the neighboring pixel, and should\n *          be monotonically decreasing.\n *      (7) Interesting observation.  Run this on prog/fish24.jpg, with\n *          range_stdev = 60, ncomps = 6, and spatial_dev = {10, 30, 50}.\n *          As spatial_dev gets larger, we get the counter-intuitive\n *          result that the body of the red fish becomes less blurry.\n */",
      "file" : "bilateral.c"
   },
   {
      "function" : "pixBilateralExact",
      "comment" : "/*!\n *  pixBilateralExact()\n *\n *      Input:  pixs (8 bpp gray or 32 bpp rgb)\n *              spatial_kel  (gaussian kernel)\n *              range_kel (<optional> 256 x 1, monotonically decreasing)\n *      Return: pixd (8 bpp bilateral filtered image)\n *\n *  Notes:\n *      (1) The spatial_kel is a conventional smoothing kernel, typically a\n *          2-d Gaussian kernel or other block kernel.  It can be either\n *          normalized or not, but must be everywhere positive.\n *      (2) The range_kel is defined over the absolute value of pixel\n *          grayscale differences, and hence must have size 256 x 1.\n *          Values in the array represent the multiplying weight for each\n *          gray value difference between the target pixel and center of the\n *          kernel, and should be monotonically decreasing.\n *      (3) If range_kel == NULL, a constant weight is applied regardless\n *          of the range value difference.  This degenerates to a regular\n *          pixConvolve() with a normalized kernel.\n */",
      "file" : "bilateral.c"
   },
   {
      "function" : "pixBilateralGray",
      "comment" : "/*!\n *  pixBilateralGray()\n *\n *      Input:  pixs (8 bpp gray)\n *              spatial_stdev  (of gaussian kernel; in pixels, > 0.5)\n *              range_stdev  (of gaussian range kernel; > 5.0; typ. 50.0)\n *              ncomps (number of intermediate sums J(k,x); in [4 ... 30])\n *              reduction  (1, 2 or 4)\n *      Return: pixd (8 bpp bilateral filtered image), or null on error\n *\n *  Notes:\n *      (1) See pixBilateral() for constraints on the input parameters.\n *      (2) See pixBilateral() for algorithm details.\n */",
      "file" : "bilateral.c"
   },
   {
      "function" : "pixBilateralGrayExact",
      "comment" : "/*!\n *  pixBilateralGrayExact()\n *\n *      Input:  pixs (8 bpp gray)\n *              spatial_kel  (gaussian kernel)\n *              range_kel (<optional> 256 x 1, monotonically decreasing)\n *      Return: pixd (8 bpp bilateral filtered image)\n *\n *  Notes:\n *      (1) See pixBilateralExact().\n */",
      "file" : "bilateral.c"
   },
   {
      "function" : "pixBilinear",
      "comment" : "/*!\n *  pixBilinear()\n *\n *      Input:  pixs (all depths; colormap ok)\n *              vc  (vector of 8 coefficients for bilinear transformation)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Brings in either black or white pixels from the boundary\n *      (2) Removes any existing colormap, if necessary, before transforming\n */",
      "file" : "bilinear.c"
   },
   {
      "function" : "pixBilinearColor",
      "comment" : "/*!\n *  pixBilinearColor()\n *\n *      Input:  pixs (32 bpp)\n *              vc  (vector of 8 coefficients for bilinear transformation)\n *              colorval (e.g., 0 to bring in BLACK, 0xffffff00 for WHITE)\n *      Return: pixd, or null on error\n */",
      "file" : "bilinear.c"
   },
   {
      "function" : "pixBilinearGray",
      "comment" : "/*!\n *  pixBilinearGray()\n *\n *      Input:  pixs (8 bpp)\n *              vc  (vector of 8 coefficients for bilinear transformation)\n *              grayval (0 to bring in BLACK, 255 for WHITE)\n *      Return: pixd, or null on error\n */",
      "file" : "bilinear.c"
   },
   {
      "function" : "pixBilinearPta",
      "comment" : "/*!\n *  pixBilinearPta()\n *\n *      Input:  pixs (all depths; colormap ok)\n *              ptad  (4 pts of final coordinate space)\n *              ptas  (4 pts of initial coordinate space)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Brings in either black or white pixels from the boundary\n *      (2) Removes any existing colormap, if necessary, before transforming\n */",
      "file" : "bilinear.c"
   },
   {
      "function" : "pixBilinearPtaColor",
      "comment" : "/*!\n *  pixBilinearPtaColor()\n *\n *      Input:  pixs (32 bpp)\n *              ptad  (4 pts of final coordinate space)\n *              ptas  (4 pts of initial coordinate space)\n *              colorval (e.g., 0 to bring in BLACK, 0xffffff00 for WHITE)\n *      Return: pixd, or null on error\n */",
      "file" : "bilinear.c"
   },
   {
      "function" : "pixBilinearPtaGray",
      "comment" : "/*!\n *  pixBilinearPtaGray()\n *\n *      Input:  pixs (8 bpp)\n *              ptad  (4 pts of final coordinate space)\n *              ptas  (4 pts of initial coordinate space)\n *              grayval (0 to bring in BLACK, 255 for WHITE)\n *      Return: pixd, or null on error\n */",
      "file" : "bilinear.c"
   },
   {
      "function" : "pixBilinearPtaWithAlpha",
      "comment" : "/*!\n *  pixBilinearPtaWithAlpha()\n *\n *      Input:  pixs (32 bpp rgb)\n *              ptad  (4 pts of final coordinate space)\n *              ptas  (4 pts of initial coordinate space)\n *              pixg (<optional> 8 bpp, can be null)\n *              fract (between 0.0 and 1.0, with 0.0 fully transparent\n *                     and 1.0 fully opaque)\n *              border (of pixels added to capture transformed source pixels)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) The alpha channel is transformed separately from pixs,\n *          and aligns with it, being fully transparent outside the\n *          boundary of the transformed pixs.  For pixels that are fully\n *          transparent, a blending function like pixBlendWithGrayMask()\n *          will give zero weight to corresponding pixels in pixs.\n *      (2) If pixg is NULL, it is generated as an alpha layer that is\n *          partially opaque, using @fract.  Otherwise, it is cropped\n *          to pixs if required and @fract is ignored.  The alpha channel\n *          in pixs is never used.\n *      (3) Colormaps are removed.\n *      (4) When pixs is transformed, it doesn't matter what color is brought\n *          in because the alpha channel will be transparent (0) there.\n *      (5) To avoid losing source pixels in the destination, it may be\n *          necessary to add a border to the source pix before doing\n *          the bilinear transformation.  This can be any non-negative number.\n *      (6) The input @ptad and @ptas are in a coordinate space before\n *          the border is added.  Internally, we compensate for this\n *          before doing the bilinear transform on the image after\n *          the border is added.\n *      (7) The default setting for the border values in the alpha channel\n *          is 0 (transparent) for the outermost ring of pixels and\n *          (0.5 * fract * 255) for the second ring.  When blended over\n *          a second image, this\n *          (a) shrinks the visible image to make a clean overlap edge\n *              with an image below, and\n *          (b) softens the edges by weakening the aliasing there.\n *          Use l_setAlphaMaskBorder() to change these values.\n *      (8) A subtle use of gamma correction is to remove gamma correction\n *          before scaling and restore it afterwards.  This is done\n *          by sandwiching this function between a gamma/inverse-gamma\n *          photometric transform:\n *              pixt = pixGammaTRCWithAlpha(NULL, pixs, 1.0 / gamma, 0, 255);\n *              pixd = pixBilinearPtaWithAlpha(pixt, ptad, ptas, NULL,\n *                                             fract, border);\n *              pixGammaTRCWithAlpha(pixd, pixd, gamma, 0, 255);\n *              pixDestroy(&pixt);\n *          This has the side-effect of producing artifacts in the very\n *          dark regions.\n */",
      "file" : "bilinear.c"
   },
   {
      "function" : "pixBilinearSampled",
      "comment" : "/*!\n *  pixBilinearSampled()\n *\n *      Input:  pixs (all depths)\n *              vc  (vector of 8 coefficients for bilinear transformation)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Brings in either black or white pixels from the boundary.\n *      (2) Retains colormap, which you can do for a sampled transform..\n *      (3) For 8 or 32 bpp, much better quality is obtained by the\n *          somewhat slower pixBilinear().  See that function\n *          for relative timings between sampled and interpolated.\n */",
      "file" : "bilinear.c"
   },
   {
      "function" : "pixBilinearSampledPta",
      "comment" : "/*!\n *  pixBilinearSampledPta()\n *\n *      Input:  pixs (all depths)\n *              ptad  (4 pts of final coordinate space)\n *              ptas  (4 pts of initial coordinate space)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Brings in either black or white pixels from the boundary.\n *      (2) Retains colormap, which you can do for a sampled transform..\n *      (3) No 3 of the 4 points may be collinear.\n *      (4) For 8 and 32 bpp pix, better quality is obtained by the\n *          somewhat slower pixBilinearPta().  See that\n *          function for relative timings between sampled and interpolated.\n */",
      "file" : "bilinear.c"
   },
   {
      "function" : "pixBlend",
      "comment" : "/*!\n *  pixBlend()\n *\n *      Input:  pixs1 (blendee)\n *              pixs2 (blender; typ. smaller)\n *              x,y  (origin (UL corner) of pixs2 relative to\n *                    the origin of pixs1; can be < 0)\n *              fract (blending fraction)\n *      Return: pixd (blended image), or null on error\n *\n *  Notes:\n *      (1) This is a simple top-level interface.  For more flexibility,\n *          call directly into pixBlendMask(), etc.\n */",
      "file" : "blend.c"
   },
   {
      "function" : "pixBlendBackgroundToColor",
      "comment" : "/*!\n *  pixBlendBackgroundToColor()\n *\n *      Input:  pixd (can be NULL or pixs)\n *              pixs (32 bpp rgb)\n *              box (region for blending; can be NULL))\n *              color (32 bit color in 0xrrggbb00 format)\n *              gamma, minval, maxval (args for grayscale TRC mapping)\n *      Return: pixd always\n *\n *  Notes:\n *      (1) This in effect replaces light background pixels in pixs\n *          by the input color.  It does it by alpha blending so that\n *          there are no visible artifacts from hard cutoffs.\n *      (2) If pixd == pixs, this is done in-place.\n *      (3) If box == NULL, this is performed on all of pixs.\n *      (4) The alpha component for blending is derived from pixs,\n *          by converting to grayscale and enhancing with a TRC.\n *      (5) The last three arguments specify the TRC operation.\n *          Suggested values are: @gamma = 0.3, @minval = 50, @maxval = 200.\n *          To skip the TRC, use @gamma == 1, @minval = 0, @maxval = 255.\n *          See pixGammaTRC() for details.\n */",
      "file" : "blend.c"
   },
   {
      "function" : "pixBlendBoxaRandom",
      "comment" : "/*!\n *  pixBlendBoxaRandom()\n *\n *      Input:  pixs (any depth; can be cmapped)\n *              boxa (of boxes, to blend/paint)\n *              fract (of box color to use)\n *      Return: pixd (32 bpp, with blend/painted boxes), or null on error\n *\n *  Notes:\n *      (1) pixs is converted to 32 bpp.\n *      (2) This differs from pixPaintBoxaRandom(), in that the\n *          colors here are blended with the color of pixs.\n *      (3) We use up to 254 different colors for painting the regions.\n *      (4) If boxes overlap, the final color depends only on the last\n *          rect that is used.\n */",
      "file" : "boxfunc3.c"
   },
   {
      "function" : "pixBlendCmap",
      "comment" : "/*!\n *  pixBlendCmap()\n *\n *      Input:  pixs (2, 4 or 8 bpp, with colormap)\n *              pixb (colormapped blender)\n *              x, y (UL corner of blender relative to pixs)\n *              sindex (colormap index of pixels in pixs to be changed)\n *      Return: 0 if OK, 1 on error\n *\n *  Note:\n *      (1) This function combines two colormaps, and replaces the pixels\n *          in pixs that have a specified color value with those in pixb.\n *      (2) sindex must be in the existing colormap; otherwise an\n *          error is returned.  In use, sindex will typically be the index\n *          for white (255, 255, 255).\n *      (3) Blender colors that already exist in the colormap are used;\n *          others are added.  If any blender colors cannot be\n *          stored in the colormap, an error is returned.\n *      (4) In the implementation, a mapping is generated from each\n *          original blender colormap index to the corresponding index\n *          in the expanded colormap for pixs.  Then for each pixel in\n *          pixs with value sindex, and which is covered by a blender pixel,\n *          the new index corresponding to the blender pixel is substituted\n *          for sindex.\n */",
      "file" : "blend.c"
   },
   {
      "function" : "pixBlendColor",
      "comment" : "/*!\n *  pixBlendColor()\n *\n *      Input:  pixd (<optional>; either NULL or equal to pixs1 for in-place)\n *              pixs1 (blendee; depth > 1)\n *              pixs2 (blender, any depth;; typ. smaller in size than pixs1)\n *              x,y  (origin (UL corner) of pixs2 relative to\n *                    the origin of pixs1)\n *              fract (blending fraction)\n *              transparent (1 to use transparency; 0 otherwise)\n *              transpix (pixel color in pixs2 that is to be transparent)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) For inplace operation (pixs1 must be 32 bpp), call it this way:\n *            pixBlendColor(pixs1, pixs1, pixs2, ...)\n *      (2) For generating a new pixd:\n *            pixd = pixBlendColor(NULL, pixs1, pixs2, ...)\n *      (3) If pixs2 is not 32 bpp rgb, it is converted.\n *      (4) Clipping of pixs2 to pixs1 is done in the inner pixel loop.\n *      (5) If pixs1 has a colormap, it is removed to generate a 32 bpp pix.\n *      (6) If pixs1 has depth < 32, it is unpacked to generate a 32 bpp pix.\n *      (7) If transparent = 0, the blending fraction (fract) is\n *          applied equally to all pixels.\n *      (8) If transparent = 1, all pixels of value transpix (typically\n *          either 0 or 0xffffff00) in pixs2 are transparent in the blend.\n */",
      "file" : "blend.c"
   },
   {
      "function" : "pixBlendColorByChannel",
      "comment" : "/*\n *  pixBlendColorByChannel()\n *\n *      Input:  pixd (<optional>; either NULL or equal to pixs1 for in-place)\n *              pixs1 (blendee; depth > 1)\n *              pixs2 (blender, any depth; typ. smaller in size than pixs1)\n *              x,y  (origin (UL corner) of pixs2 relative to\n *                    the origin of pixs1)\n *              rfract, gfract, bfract (blending fractions by channel)\n *              transparent (1 to use transparency; 0 otherwise)\n *              transpix (pixel color in pixs2 that is to be transparent)\n *      Return: pixd if OK; pixs1 on error\n *\n * Notes:\n *     (1) This generalizes pixBlendColor() in two ways:\n *         (a) The mixing fraction is specified per channel.\n *         (b) The mixing fraction may be < 0 or > 1, in which case,\n *             the min or max of two images are taken, respectively.\n *     (2) Specifically,\n *         for p = pixs1[i], c = pixs2[i], f = fract[i], i = 1, 2, 3:\n *             f < 0.0:          p --> min(p, c)\n *             0.0 <= f <= 1.0:  p --> (1 - f) * p + f * c\n *             f > 1.0:          p --> max(a, c)\n *         Special cases:\n *             f = 0:   p --> p\n *             f = 1:   p --> c\n *     (3) See usage notes in pixBlendColor()\n *     (4) pixBlendColor() would be equivalent to\n *           pixBlendColorChannel(..., fract, fract, fract, ...);\n *         at a small cost of efficiency.\n */",
      "file" : "blend.c"
   },
   {
      "function" : "pixBlendGray",
      "comment" : "/*!\n *  pixBlendGray()\n *\n *      Input:  pixd (<optional>; either NULL or equal to pixs1 for in-place)\n *              pixs1 (blendee, depth > 1)\n *              pixs2 (blender, any depth; typ. smaller in size than pixs1)\n *              x,y  (origin (UL corner) of pixs2 relative to\n *                    the origin of pixs1; can be < 0)\n *              fract (blending fraction)\n *              type (L_BLEND_GRAY, L_BLEND_GRAY_WITH_INVERSE)\n *              transparent (1 to use transparency; 0 otherwise)\n *              transpix (pixel grayval in pixs2 that is to be transparent)\n *      Return: pixd if OK; pixs1 on error\n *\n *  Notes:\n *      (1) For inplace operation (pixs1 not cmapped), call it this way:\n *            pixBlendGray(pixs1, pixs1, pixs2, ...)\n *      (2) For generating a new pixd:\n *            pixd = pixBlendGray(NULL, pixs1, pixs2, ...)\n *      (3) Clipping of pixs2 to pixs1 is done in the inner pixel loop.\n *      (4) If pixs1 has a colormap, it is removed; otherwise, if pixs1\n *          has depth < 8, it is unpacked to generate a 8 bpp pix.\n *      (5) If transparent = 0, the blending fraction (fract) is\n *          applied equally to all pixels.\n *      (6) If transparent = 1, all pixels of value transpix (typically\n *          either 0 or 0xff) in pixs2 are transparent in the blend.\n *      (7) After processing pixs1, it is either 8 bpp or 32 bpp:\n *          - if 8 bpp, the fraction of pixs2 is mixed with pixs1.\n *          - if 32 bpp, each component of pixs1 is mixed with\n *            the same fraction of pixs2.\n *      (8) For L_BLEND_GRAY_WITH_INVERSE, the white values of the blendee\n *          (cval == 255 in the code below) result in a delta of 0.\n *          Thus, these pixels are intrinsically transparent!\n *          The \"pivot\" value of the src, at which no blending occurs, is\n *          128.  Compare with the adaptive pivot in pixBlendGrayAdapt().\n *      (9) Invalid @fract defaults to 0.5 with a warning.\n *          Invalid @type defaults to L_BLEND_GRAY with a warning.\n */",
      "file" : "blend.c"
   },
   {
      "function" : "pixBlendGrayAdapt",
      "comment" : "/*!\n *  pixBlendGrayAdapt()\n *\n *      Input:  pixd (<optional>; either NULL or equal to pixs1 for in-place)\n *              pixs1 (blendee, depth > 1)\n *              pixs2 (blender, any depth; typ. smaller in size than pixs1)\n *              x,y  (origin (UL corner) of pixs2 relative to\n *                    the origin of pixs1; can be < 0)\n *              fract (blending fraction)\n *              shift (>= 0 but <= 128: shift of zero blend value from\n *                     median source; use -1 for default value; )\n *      Return: pixd if OK; pixs1 on error\n *\n *  Notes:\n *      (1) For inplace operation (pixs1 not cmapped), call it this way:\n *            pixBlendGrayAdapt(pixs1, pixs1, pixs2, ...)\n *          For generating a new pixd:\n *            pixd = pixBlendGrayAdapt(NULL, pixs1, pixs2, ...)\n *      (2) Clipping of pixs2 to pixs1 is done in the inner pixel loop.\n *      (3) If pixs1 has a colormap, it is removed.\n *      (4) If pixs1 has depth < 8, it is unpacked to generate a 8 bpp pix.\n *      (5) This does a blend with inverse.  Whereas in pixGlendGray(), the\n *          zero blend point is where the blendee pixel is 128, here\n *          the zero blend point is found adaptively, with respect to the\n *          median of the blendee region.  If the median is < 128,\n *          the zero blend point is found from\n *              median + shift.\n *          Otherwise, if the median >= 128, the zero blend point is\n *              median - shift.\n *          The purpose of shifting the zero blend point away from the\n *          median is to prevent a situation in pixBlendGray() where\n *          the median is 128 and the blender is not visible.\n *          The default value of shift is 64.\n *      (6) After processing pixs1, it is either 8 bpp or 32 bpp:\n *          - if 8 bpp, the fraction of pixs2 is mixed with pixs1.\n *          - if 32 bpp, each component of pixs1 is mixed with\n *            the same fraction of pixs2.\n *      (7) The darker the blender, the more it mixes with the blendee.\n *          A blender value of 0 has maximum mixing; a value of 255\n *          has no mixing and hence is transparent.\n */",
      "file" : "blend.c"
   },
   {
      "function" : "pixBlendGrayInverse",
      "comment" : "/*!\n *  pixBlendGrayInverse()\n *\n *      Input:  pixd (<optional>; either NULL or equal to pixs1 for in-place)\n *              pixs1 (blendee, depth > 1)\n *              pixs2 (blender, any depth; typ. smaller in size than pixs1)\n *              x,y  (origin (UL corner) of pixs2 relative to\n *                    the origin of pixs1; can be < 0)\n *              fract (blending fraction)\n *      Return: pixd if OK; pixs1 on error\n *\n *  Notes:\n *      (1) For inplace operation (pixs1 not cmapped), call it this way:\n *            pixBlendGrayInverse(pixs1, pixs1, pixs2, ...)\n *      (2) For generating a new pixd:\n *            pixd = pixBlendGrayInverse(NULL, pixs1, pixs2, ...)\n *      (3) Clipping of pixs2 to pixs1 is done in the inner pixel loop.\n *      (4) If pixs1 has a colormap, it is removed; otherwise if pixs1\n *          has depth < 8, it is unpacked to generate a 8 bpp pix.\n *      (5) This is a no-nonsense blender.  It changes the src1 pixel except\n *          when the src1 pixel is midlevel gray.  Use fract == 1 for the most\n *          aggressive blending, where, if the gray pixel in pixs2 is 0,\n *          we get a complete inversion of the color of the src pixel in pixs1.\n *      (6) The basic logic is that each component transforms by:\n                 d  -->  c * d + (1 - c ) * (f * (1 - d) + d * (1 - f))\n *          where c is the blender pixel from pixs2,\n *                f is @fract,\n *                c and d are normalized to [0...1]\n *          This has the property that for f == 0 (no blend) or c == 1 (white):\n *               d  -->  d\n *          For c == 0 (black) we get maximum inversion:\n *               d  -->  f * (1 - d) + d * (1 - f)   [inversion by fraction f]\n */",
      "file" : "blend.c"
   },
   {
      "function" : "pixBlendHardLight",
      "comment" : "/*\n *  pixBlendHardLight()\n *\n *      Input:  pixd (<optional>; either NULL or equal to pixs1 for in-place)\n *              pixs1 (blendee; depth > 1, may be cmapped)\n *              pixs2 (blender, 8 or 32 bpp; may be colormapped;\n *                     typ. smaller in size than pixs1)\n *              x,y  (origin (UL corner) of pixs2 relative to\n *                    the origin of pixs1)\n *              fract (blending fraction, or 'opacity factor')\n *      Return: pixd if OK; pixs1 on error\n *\n *  Notes:\n *      (1) pixs2 must be 8 or 32 bpp; either may have a colormap.\n *      (2) Clipping of pixs2 to pixs1 is done in the inner pixel loop.\n *      (3) Only call in-place if pixs1 is not colormapped.\n *      (4) If pixs1 has a colormap, it is removed to generate either an\n *          8 or 32 bpp pix, depending on the colormap.\n *      (5) For inplace operation, call it this way:\n *            pixBlendHardLight(pixs1, pixs1, pixs2, ...)\n *      (6) For generating a new pixd:\n *            pixd = pixBlendHardLight(NULL, pixs1, pixs2, ...)\n *      (7) This is a generalization of the usual hard light blending,\n *          where fract == 1.0.\n *      (8) \"Overlay\" blending is the same as hard light blending, with\n *          fract == 1.0, except that the components are switched\n *          in the test.  (Note that the result is symmetric in the\n *          two components.)\n *      (9) See, e.g.:\n *           http://www.pegtop.net/delphi/articles/blendmodes/hardlight.htm\n *           http://www.digitalartform.com/imageArithmetic.htm\n *      (10) This function was built by Paco Galanes.\n */",
      "file" : "blend.c"
   },
   {
      "function" : "pixBlendInRect",
      "comment" : "/*!\n *  pixBlendInRect()\n *\n *      Input:  pixs (32 bpp rgb)\n *              box (<optional> in which all pixels will be blended)\n *              val  (blend value; 0xrrggbb00)\n *              fract (fraction of color to be blended with each pixel in pixs)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This is an in-place function.  It blends the input color @val\n *          with the pixels in pixs in the specified rectangle.\n *          If no rectangle is specified, it blends over the entire image.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixBlendMask",
      "comment" : "/*!\n *  pixBlendMask()\n *\n *      Input:  pixd (<optional>; either NULL or equal to pixs1 for in-place)\n *              pixs1 (blendee, depth > 1)\n *              pixs2 (blender, 1 bpp; typ. smaller in size than pixs1)\n *              x,y  (origin (UL corner) of pixs2 relative to\n *                    the origin of pixs1; can be < 0)\n *              fract (blending fraction)\n *              type (L_BLEND_WITH_INVERSE, L_BLEND_TO_WHITE, L_BLEND_TO_BLACK)\n *      Return: pixd if OK; null on error\n *\n *  Notes:\n *      (1) Clipping of pixs2 to pixs1 is done in the inner pixel loop.\n *      (2) If pixs1 has a colormap, it is removed.\n *      (3) For inplace operation (pixs1 not cmapped), call it this way:\n *            pixBlendMask(pixs1, pixs1, pixs2, ...)\n *      (4) For generating a new pixd:\n *            pixd = pixBlendMask(NULL, pixs1, pixs2, ...)\n *      (5) Only call in-place if pixs1 does not have a colormap.\n *      (6) Invalid @fract defaults to 0.5 with a warning.\n *          Invalid @type defaults to L_BLEND_WITH_INVERSE with a warning.\n */",
      "file" : "blend.c"
   },
   {
      "function" : "pixBlendWithGrayMask",
      "comment" : "/*!\n *  pixBlendWithGrayMask()\n *\n *      Input:  pixs1 (8 bpp gray, rgb, rgba or colormapped)\n *              pixs2 (8 bpp gray, rgb, rgba or colormapped)\n *              pixg (<optional> 8 bpp gray, for transparency of pixs2;\n *                    can be null)\n *              x, y (UL corner of pixs2 and pixg with respect to pixs1)\n *      Return: pixd (blended image), or null on error\n *\n *  Notes:\n *      (1) The result is 8 bpp grayscale if both pixs1 and pixs2 are\n *          8 bpp gray.  Otherwise, the result is 32 bpp rgb.\n *      (2) pixg is an 8 bpp transparency image, where 0 is transparent\n *          and 255 is opaque.  It determines the transparency of pixs2\n *          when applied over pixs1.  It can be null if pixs2 is rgba,\n *          in which case we use the alpha component of pixs2.\n *      (3) If pixg exists, it need not be the same size as pixs2.\n *          However, we assume their UL corners are aligned with each other,\n *          and placed at the location (x, y) in pixs1.\n *      (4) The pixels in pixd are a combination of those in pixs1\n *          and pixs2, where the amount from pixs2 is proportional to\n *          the value of the pixel (p) in pixg, and the amount from pixs1\n *          is proportional to (255 - p).  Thus pixg is a transparency\n *          image (usually called an alpha blender) where each pixel\n *          can be associated with a pixel in pixs2, and determines\n *          the amount of the pixs2 pixel in the final result.\n *          For example, if pixg is all 0, pixs2 is transparent and\n *          the result in pixd is simply pixs1.\n *      (5) A typical use is for the pixs2/pixg combination to be\n *          a small watermark that is applied to pixs1.\n */",
      "file" : "blend.c"
   },
   {
      "function" : "pixBlockBilateralExact",
      "comment" : "/*!\n *  pixBlockBilateralExact()\n *\n *      Input:  pixs (8 bpp gray or 32 bpp rgb)\n *              spatial_stdev (> 0.0)\n *              range_stdev (> 0.0)\n *      Return: pixd (8 bpp or 32 bpp bilateral filtered image)\n *\n *  Notes:\n *      (1) See pixBilateralExact().  This provides an interface using\n *          the standard deviations of the spatial and range filters.\n *      (2) The convolution window halfwidth is 2 * spatial_stdev,\n *          and the square filter size is 4 * spatial_stdev + 1.\n *          The kernel captures 95% of total energy.  This is compensated\n *          by normalization.\n *      (3) The range_stdev is analogous to spatial_halfwidth in the\n *          grayscale domain [0...255], and determines how much damping of the\n *          smoothing operation is applied across edges.  The larger this\n *          value is, the smaller the damping.  The smaller the value, the\n *          more edge details are preserved.  These approximations are useful\n *          for deciding the appropriate cutoff.\n *              kernel[1 * stdev] ~= 0.6  * kernel[0]\n *              kernel[2 * stdev] ~= 0.14 * kernel[0]\n *              kernel[3 * stdev] ~= 0.01 * kernel[0]\n *          If range_stdev is infinite there is no damping, and this\n *          becomes a conventional gaussian smoothing.\n *          This value does not affect the run time.\n *      (4) If range_stdev is negative or zero, the range kernel is\n *          ignored and this degenerates to a straight gaussian convolution.\n *      (5) This is very slow for large spatial filters.  The time\n *          on a 3GHz pentium is roughly\n *             T = 1.2 * 10^-8 * (A * sh^2)  sec\n *          where A = # of pixels, sh = spatial halfwidth of filter.\n */",
      "file" : "bilateral.c"
   },
   {
      "function" : "pixBlockconv",
      "comment" : "/*!\n *  pixBlockconv()\n *\n *      Input:  pix (8 or 32 bpp; or 2, 4 or 8 bpp with colormap)\n *              wc, hc   (half width/height of convolution kernel)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) The full width and height of the convolution kernel\n *          are (2 * wc + 1) and (2 * hc + 1)\n *      (2) Returns a copy if both wc and hc are 0\n *      (3) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,\n *          where (w,h) are the dimensions of pixs.\n */",
      "file" : "convolve.c"
   },
   {
      "function" : "pixBlockconvAccum",
      "comment" : "/*!\n *  pixBlockconvAccum()\n *\n *      Input:  pixs (1, 8 or 32 bpp)\n *      Return: accum pix (32 bpp), or null on error.\n *\n *  Notes:\n *      (1) The general recursion relation is\n *            a(i,j) = v(i,j) + a(i-1, j) + a(i, j-1) - a(i-1, j-1)\n *          For the first line, this reduces to the special case\n *            a(i,j) = v(i,j) + a(i, j-1)\n *          For the first column, the special case is\n *            a(i,j) = v(i,j) + a(i-1, j)\n */",
      "file" : "convolve.c"
   },
   {
      "function" : "pixBlockconvGray",
      "comment" : "/*!\n *  pixBlockconvGray()\n *\n *      Input:  pix (8 bpp)\n *              accum pix (32 bpp; can be null)\n *              wc, hc   (half width/height of convolution kernel)\n *      Return: pix (8 bpp), or null on error\n *\n *  Notes:\n *      (1) If accum pix is null, make one and destroy it before\n *          returning; otherwise, just use the input accum pix.\n *      (2) The full width and height of the convolution kernel\n *          are (2 * wc + 1) and (2 * hc + 1).\n *      (3) Returns a copy if both wc and hc are 0.\n *      (4) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,\n *          where (w,h) are the dimensions of pixs.\n */",
      "file" : "convolve.c"
   },
   {
      "function" : "pixBlockconvGrayTile",
      "comment" : "/*!\n *  pixBlockconvGrayTile()\n *\n *      Input:  pixs (8 bpp gray)\n *              pixacc (32 bpp accum pix)\n *              wc, hc   (half width/height of convolution kernel)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) The full width and height of the convolution kernel\n *          are (2 * wc + 1) and (2 * hc + 1)\n *      (2) Assumes that the input pixs is padded with (wc + 1) pixels on\n *          left and right, and with (hc + 1) pixels on top and bottom.\n *          The returned pix has these stripped off; they are only used\n *          for computation.\n *      (3) Returns a copy if both wc and hc are 0\n *      (4) Require that w > 2 * wc + 1 and h > 2 * hc + 1,\n *          where (w,h) are the dimensions of pixs.\n */",
      "file" : "convolve.c"
   },
   {
      "function" : "pixBlockconvGrayUnnormalized",
      "comment" : "/*!\n *  pixBlockconvGrayUnnormalized()\n *\n *      Input:  pixs (8 bpp)\n *              wc, hc   (half width/height of convolution kernel)\n *      Return: pix (32 bpp; containing the convolution without normalizing\n *                   for the window size), or null on error\n *\n *  Notes:\n *      (1) The full width and height of the convolution kernel\n *          are (2 * wc + 1) and (2 * hc + 1).\n *      (2) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,\n *          where (w,h) are the dimensions of pixs.\n *      (3) Returns a copy if both wc and hc are 0.\n *      (3) Adds mirrored border to avoid treating the boundary pixels\n *          specially.  Note that we add wc + 1 pixels to the left\n *          and wc to the right.  The added width is 2 * wc + 1 pixels,\n *          and the particular choice simplifies the indexing in the loop.\n *          Likewise, add hc + 1 pixels to the top and hc to the bottom.\n *      (4) To get the normalized result, divide by the area of the\n *          convolution kernel: (2 * wc + 1) * (2 * hc + 1)\n *          Specifically, do this:\n *               pixc = pixBlockconvGrayUnnormalized(pixs, wc, hc);\n *               fract = 1. / ((2 * wc + 1) * (2 * hc + 1));\n *               pixMultConstantGray(pixc, fract);\n *               pixd = pixGetRGBComponent(pixc, L_ALPHA_CHANNEL);\n *      (5) Unlike pixBlockconvGray(), this always computes the accumulation\n *          pix because its size is tied to wc and hc.\n *      (6) Compare this implementation with pixBlockconvGray(), where\n *          most of the code in blockconvLow() is special casing for\n *          efficiently handling the boundary.  Here, the use of\n *          mirrored borders and destination indexing makes the\n *          implementation very simple.\n */",
      "file" : "convolve.c"
   },
   {
      "function" : "pixBlockconvTiled",
      "comment" : "/*!\n *  pixBlockconvTiled()\n *\n *      Input:  pix (8 or 32 bpp; or 2, 4 or 8 bpp with colormap)\n *              wc, hc   (half width/height of convolution kernel)\n *              nx, ny  (subdivision into tiles)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) The full width and height of the convolution kernel\n *          are (2 * wc + 1) and (2 * hc + 1)\n *      (2) Returns a copy if both wc and hc are 0\n *      (3) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,\n *          where (w,h) are the dimensions of pixs.\n *      (4) For nx == ny == 1, this defaults to pixBlockconv(), which\n *          is typically about twice as fast, and gives nearly\n *          identical results as pixBlockconvGrayTile().\n *      (5) If the tiles are too small, nx and/or ny are reduced\n *          a minimum amount so that the tiles are expanded to the\n *          smallest workable size in the problematic direction(s).\n *      (6) Why a tiled version?  Three reasons:\n *          (a) Because the accumulator is a uint32, overflow can occur\n *              for an image with more than 16M pixels.\n *          (b) The accumulator array for 16M pixels is 64 MB; using\n *              tiles reduces the size of this array.\n *          (c) Each tile can be processed independently, in parallel,\n *              on a multicore processor.\n */",
      "file" : "convolve.c"
   },
   {
      "function" : "pixBlockrank",
      "comment" : "/*!\n *  pixBlockrank()\n *\n *      Input:  pixs (1 bpp)\n *              accum pix (<optional> 32 bpp)\n *              wc, hc   (half width/height of block sum/rank kernel)\n *              rank   (between 0.0 and 1.0; 0.5 is median filter)\n *      Return: pixd (1 bpp)\n *\n *  Notes:\n *      (1) The full width and height of the convolution kernel\n *          are (2 * wc + 1) and (2 * hc + 1)\n *      (2) This returns a pixd where each pixel is a 1 if the\n *          neighborhood (2 * wc + 1) x (2 * hc + 1)) pixels\n *          contains the rank fraction of 1 pixels.  Otherwise,\n *          the returned pixel is 0.  Note that the special case\n *          of rank = 0.0 is always satisfied, so the returned\n *          pixd has all pixels with value 1.\n *      (3) If accum pix is null, make one, use it, and destroy it\n *          before returning; otherwise, just use the input accum pix\n *      (4) If both wc and hc are 0, returns a copy unless rank == 0.0,\n *          in which case this returns an all-ones image.\n *      (5) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,\n *          where (w,h) are the dimensions of pixs.\n */",
      "file" : "convolve.c"
   },
   {
      "function" : "pixBlocksum",
      "comment" : "/*!\n *  pixBlocksum()\n *\n *      Input:  pixs (1 bpp)\n *              accum pix (<optional> 32 bpp)\n *              wc, hc   (half width/height of block sum/rank kernel)\n *      Return: pixd (8 bpp)\n *\n *  Notes:\n *      (1) If accum pix is null, make one and destroy it before\n *          returning; otherwise, just use the input accum pix\n *      (2) The full width and height of the convolution kernel\n *          are (2 * wc + 1) and (2 * hc + 1)\n *      (3) Use of wc = hc = 1, followed by pixInvert() on the\n *          8 bpp result, gives a nice anti-aliased, and somewhat\n *          darkened, result on text.\n *      (4) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,\n *          where (w,h) are the dimensions of pixs.\n *      (5) Returns in each dest pixel the sum of all src pixels\n *          that are within a block of size of the kernel, centered\n *          on the dest pixel.  This sum is the number of src ON\n *          pixels in the block at each location, normalized to 255\n *          for a block containing all ON pixels.  For pixels near\n *          the boundary, where the block is not entirely contained\n *          within the image, we then multiply by a second normalization\n *          factor that is greater than one, so that all results\n *          are normalized by the number of participating pixels\n *          within the block.\n */",
      "file" : "convolve.c"
   },
   {
      "function" : "pixCensusTransform",
      "comment" : "/*!\n *  pixCensusTransform()\n *\n *      Input:  pixs (8 bpp)\n *              halfsize (of square over which neighbors are averaged)\n *              accum pix (<optional> 32 bpp)\n *      Return: pixd (1 bpp)\n *\n *  Notes:\n *      (1) The Census transform was invented by Ramin Zabih and John Woodfill\n *          (\"Non-parametric local transforms for computing visual\n *          correspondence\", Third European Conference on Computer Vision,\n *          Stockholm, Sweden, May 1994); see publications at\n *             http://www.cs.cornell.edu/~rdz/index.htm\n *          This compares each pixel against the average of its neighbors,\n *          in a square of odd dimension centered on the pixel.\n *          If the pixel is greater than the average of its neighbors,\n *          the output pixel value is 1; otherwise it is 0.\n *      (2) This can be used as an encoding for an image that is\n *          fairly robust against slow illumination changes, with\n *          applications in image comparison and mosaicing.\n *      (3) The size of the convolution kernel is (2 * halfsize + 1)\n *          on a side.  The halfsize parameter must be >= 1.\n *      (4) If accum pix is null, make one, use it, and destroy it\n *          before returning; otherwise, just use the input accum pix\n */",
      "file" : "convolve.c"
   },
   {
      "function" : "pixCentroid",
      "comment" : "/*!\n *  pixCentroid()\n *\n *      Input:  pix (1 or 8 bpp)\n *              centtab (<optional> table for finding centroids; can be null)\n *              sumtab (<optional> table for finding pixel sums; can be null)\n *              &xave, &yave (<return> coordinates of centroid, relative to\n *                            the UL corner of the pix)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Any table not passed in will be made internally and destroyed\n *          after use.\n */",
      "file" : "morphapp.c"
   },
   {
      "function" : "pixChangeRefcount",
      "comment" : "/* no-op */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixChooseOutputFormat",
      "comment" : "/*!\n *  pixChooseOutputFormat()\n *\n *      Input:  pix\n *      Return: output format, or 0 on error\n *\n *  Notes:\n *      (1) This should only be called if the requested format is IFF_DEFAULT.\n *      (2) If the pix wasn't read from a file, its input format value\n *          will be IFF_UNKNOWN, and in that case it is written out\n *          in a compressed but lossless format.\n */",
      "file" : "writefile.c"
   },
   {
      "function" : "pixCleanupByteProcessing",
      "comment" : "/*!\n *  pixCleanupByteProcessing()\n *\n *      Input:  pix (8 bpp, no colormap)\n *              lineptrs (ptrs to the beginning of each raster line of data)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This must be called after processing that was initiated\n *          by pixSetupByteProcessing() has finished.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixClearAll",
      "comment" : "/*!\n *  pixClearAll()\n *\n *      Input:  pix (all depths; use cmapped with caution)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Clears all data to 0.  For 1 bpp, this is white; for grayscale\n *          or color, this is black.\n *      (2) Caution: for colormapped pix, this sets the color to the first\n *          one in the colormap.  Be sure that this is the intended color!\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixClearInRect",
      "comment" : "/*!\n *  pixClearInRect()\n *\n *      Input:  pix (all depths; can be cmapped)\n *              box (in which all pixels will be cleared)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Clears all data in rect to 0.  For 1 bpp, this is white;\n *          for grayscale or color, this is black.\n *      (2) Caution: for colormapped pix, this sets the color to the first\n *          one in the colormap.  Be sure that this is the intended color!\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixClearPixel",
      "comment" : "/*!\n *  pixClearPixel()\n *\n *      Input:  pix\n *              (x,y) pixel coords\n *      Return: 0 if OK; 1 on error.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixClipBoxToEdges",
      "comment" : "/*!\n *  pixClipBoxToEdges()\n *\n *      Input:  pixs (1 bpp)\n *              boxs  (<optional> ; use full image if null)\n *              lowthresh (threshold to choose clipping location)\n *              highthresh (threshold required to find an edge)\n *              maxwidth (max allowed width between low and high thresh locs)\n *              factor (sampling factor along pixel counting direction)\n *              &pixd  (<optional return> clipped pix returned)\n *              &boxd  (<optional return> bounding box)\n *      Return: 0 if OK; 1 on error or if a fg edge is not found from\n *              all four sides.\n *\n *  Notes:\n *      (1) At least one of {&pixd, &boxd} must be specified.\n *      (2) If there are no fg pixels, the returned ptrs are null.\n *      (3) This function attempts to locate rectangular \"image\" regions\n *          of high-density fg pixels, that have well-defined edges\n *          on the four sides.\n *      (4) Edges are searched for on each side, iterating in order\n *          from left, right, top and bottom.  As each new edge is\n *          found, the search box is resized to use that location.\n *          Once an edge is found, it is held.  If no more edges\n *          are found in one iteration, the search fails.\n *      (5) See pixScanForEdge() for usage of the thresholds and @maxwidth.\n *      (6) The thresholds must be at least 1, and the low threshold\n *          cannot be larger than the high threshold.\n *      (7) If the low and high thresholds are both 1, this is equivalent\n *          to pixClipBoxToForeground().\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixClipBoxToForeground",
      "comment" : "/*!\n *  pixClipBoxToForeground()\n *\n *      Input:  pixs (1 bpp)\n *              boxs  (<optional> ; use full image if null)\n *              &pixd  (<optional return> clipped pix returned)\n *              &boxd  (<optional return> bounding box)\n *      Return: 0 if OK; 1 on error or if there are no fg pixels\n *\n *  Notes:\n *      (1) At least one of {&pixd, &boxd} must be specified.\n *      (2) If there are no fg pixels, the returned ptrs are null.\n *      (3) Do not use &pixs for the 3rd arg or &boxs for the 4th arg;\n *          this will leak memory.\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixClipMasked",
      "comment" : "/*!\n *  pixClipMasked()\n *\n *      Input:  pixs (1, 2, 4, 8, 16, 32 bpp; colormap ok)\n *              pixm  (clipping mask, 1 bpp)\n *              x, y (origin of clipping mask relative to pixs)\n *              outval (val to use for pixels that are outside the mask)\n *      Return: pixd, (clipped pix) or null on error or if pixm doesn't\n *              intersect pixs\n *\n *  Notes:\n *      (1) If pixs has a colormap, it is preserved in pixd.\n *      (2) The depth of pixd is the same as that of pixs.\n *      (3) If the depth of pixs is 1, use @outval = 0 for white background\n *          and 1 for black; otherwise, use the max value for white\n *          and 0 for black.  If pixs has a colormap, the max value for\n *          @outval is 0xffffffff; otherwise, it is 2^d - 1.\n *      (4) When using 1 bpp pixs, this is a simple clip and\n *          blend operation.  For example, if both pix1 and pix2 are\n *          black text on white background, and you want to OR the\n *          fg on the two images, let pixm be the inverse of pix2.\n *          Then the operation takes all of pix1 that's in the bg of\n *          pix2, and for the remainder (which are the pixels\n *          corresponding to the fg of the pix2), paint them black\n *          (1) in pix1.  The function call looks like\n *             pixClipMasked(pix2, pixInvert(pix1, pix1), x, y, 1);\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixClipRectangle",
      "comment" : "/*!\n *  pixClipRectangle()\n *\n *      Input:  pixs\n *              box  (requested clipping region; const)\n *              &boxc (<optional return> actual box of clipped region)\n *      Return: clipped pix, or null on error or if rectangle\n *              doesn't intersect pixs\n *\n *  Notes:\n *\n *  This should be simple, but there are choices to be made.\n *  The box is defined relative to the pix coordinates.  However,\n *  if the box is not contained within the pix, we have two choices:\n *\n *      (1) clip the box to the pix\n *      (2) make a new pix equal to the full box dimensions,\n *          but let rasterop do the clipping and positioning\n *          of the src with respect to the dest\n *\n *  Choice (2) immediately brings up the problem of what pixel values\n *  to use that were not taken from the src.  For example, on a grayscale\n *  image, do you want the pixels not taken from the src to be black\n *  or white or something else?  To implement choice 2, one needs to\n *  specify the color of these extra pixels.\n *\n *  So we adopt (1), and clip the box first, if necessary,\n *  before making the dest pix and doing the rasterop.  But there\n *  is another issue to consider.  If you want to paste the\n *  clipped pix back into pixs, it must be properly aligned, and\n *  it is necessary to use the clipped box for alignment.\n *  Accordingly, this function has a third (optional) argument, which is\n *  the input box clipped to the src pix.\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixClipRectangles",
      "comment" : "/*!\n *  pixClipRectangles()\n *\n *      Input:  pixs\n *              boxa (requested clipping regions)\n *      Return: pixa (consisting of requested regions), or null on error\n *\n *  Notes:\n *     (1) The returned pixa includes the actual regions clipped out from\n *         the input pixs.\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixClipToForeground",
      "comment" : "/*!\n *  pixClipToForeground()\n *\n *      Input:  pixs (1 bpp)\n *              &pixd  (<optional return> clipped pix returned)\n *              &box   (<optional return> bounding box)\n *      Return: 0 if OK; 1 on error or if there are no fg pixels\n *\n *  Notes:\n *      (1) At least one of {&pixd, &box} must be specified.\n *      (2) If there are no fg pixels, the returned ptrs are null.\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixClone",
      "comment" : "/*!\n *  pixClone()\n *\n *      Input:  pix\n *      Return: same pix (ptr), or null on error\n *\n *  Notes:\n *      (1) A \"clone\" is simply a handle (ptr) to an existing pix.\n *          It is implemented because (a) images can be large and\n *          hence expensive to copy, and (b) extra handles to a data\n *          structure need to be made with a simple policy to avoid\n *          both double frees and memory leaks.  Pix are reference\n *          counted.  The side effect of pixClone() is an increase\n *          by 1 in the ref count.\n *      (2) The protocol to be used is:\n *          (a) Whenever you want a new handle to an existing image,\n *              call pixClone(), which just bumps a ref count.\n *          (b) Always call pixDestroy() on all handles.  This\n *              decrements the ref count, nulls the handle, and\n *              only destroys the pix when pixDestroy() has been\n *              called on all handles.\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixClose",
      "comment" : "/*!\n *  pixClose()\n *\n *      Input:  pixd (<optional>; this can be null, equal to pixs,\n *                    or different from pixs)\n *              pixs (1 bpp)\n *              sel\n *      Return: pixd\n *\n *  Notes:\n *      (1) Generic morphological closing, using hits in the Sel.\n *      (2) This implementation is a strict dual of the opening if\n *          symmetric boundary conditions are used (see notes at top\n *          of this file).\n *      (3) There are three cases:\n *          (a) pixd == null   (result into new pixd)\n *          (b) pixd == pixs   (in-place; writes result back to pixs)\n *          (c) pixd != pixs   (puts result into existing pixd)\n *      (4) For clarity, if the case is known, use these patterns:\n *          (a) pixd = pixClose(NULL, pixs, ...);\n *          (b) pixClose(pixs, pixs, ...);\n *          (c) pixClose(pixd, pixs, ...);\n *      (5) The size of the result is determined by pixs.\n */",
      "file" : "morph.c"
   },
   {
      "function" : "pixCloseBrick",
      "comment" : "/*!\n *  pixCloseBrick()\n *\n *      Input:  pixd  (<optional>; this can be null, equal to pixs,\n *                     or different from pixs)\n *              pixs (1 bpp)\n *              hsize (width of brick Sel)\n *              vsize (height of brick Sel)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Sel is a brick with all elements being hits\n *      (2) The origin is at (x, y) = (hsize/2, vsize/2)\n *      (3) Do separably if both hsize and vsize are > 1.\n *      (4) There are three cases:\n *          (a) pixd == null   (result into new pixd)\n *          (b) pixd == pixs   (in-place; writes result back to pixs)\n *          (c) pixd != pixs   (puts result into existing pixd)\n *      (5) For clarity, if the case is known, use these patterns:\n *          (a) pixd = pixCloseBrick(NULL, pixs, ...);\n *          (b) pixCloseBrick(pixs, pixs, ...);\n *          (c) pixCloseBrick(pixd, pixs, ...);\n *      (6) The size of the result is determined by pixs.\n */",
      "file" : "morph.c"
   },
   {
      "function" : "pixCloseBrickDwa",
      "comment" : "/*!\n *  pixCloseBrickDwa()\n *\n *      Input:  pixd  (<optional>; this can be null, equal to pixs,\n *                     or different from pixs)\n *              pixs (1 bpp)\n *              hsize (width of brick Sel)\n *              vsize (height of brick Sel)\n *      Return: pixd\n *\n *  Notes:\n *      (1) This is a 'safe' closing; we add an extra border of 32 OFF\n *          pixels for the standard asymmetric b.c.\n *      (2) These implement 2D brick Sels, using linear Sels generated\n *          with selaAddBasic().\n *      (3) A brick Sel has hits for all elements.\n *      (4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)\n *      (5) Do separably if both hsize and vsize are > 1.\n *      (6) It is necessary that both horizontal and vertical Sels\n *          of the input size are defined in the basic sela.\n *      (7) Note that we must always set or clear the border pixels\n *          before each operation, depending on the the b.c.\n *          (symmetric or asymmetric).\n *      (8) There are three cases:\n *          (a) pixd == null   (result into new pixd)\n *          (b) pixd == pixs   (in-place; writes result back to pixs)\n *          (c) pixd != pixs   (puts result into existing pixd)\n *      (9) For clarity, if the case is known, use these patterns:\n *          (a) pixd = pixCloseBrickDwa(NULL, pixs, ...);\n *          (b) pixCloseBrickDwa(pixs, pixs, ...);\n *          (c) pixCloseBrickDwa(pixd, pixs, ...);\n *      (10) The size of the result is determined by pixs.\n *      (11) If either linear Sel is not found, this calls\n *           the appropriate decomposible function.\n */",
      "file" : "morphdwa.c"
   },
   {
      "function" : "pixCloseCompBrick",
      "comment" : "/*!\n *  pixCloseCompBrick()\n *\n *      Input:  pixd  (<optional>; this can be null, equal to pixs,\n *                     or different from pixs)\n *              pixs (1 bpp)\n *              hsize (width of brick Sel)\n *              vsize (height of brick Sel)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Sel is a brick with all elements being hits\n *      (2) The origin is at (x, y) = (hsize/2, vsize/2)\n *      (3) Do compositely for each dimension > 1.\n *      (4) Do separably if both hsize and vsize are > 1.\n *      (5) There are three cases:\n *          (a) pixd == null   (result into new pixd)\n *          (b) pixd == pixs   (in-place; writes result back to pixs)\n *          (c) pixd != pixs   (puts result into existing pixd)\n *      (6) For clarity, if the case is known, use these patterns:\n *          (a) pixd = pixCloseCompBrick(NULL, pixs, ...);\n *          (b) pixCloseCompBrick(pixs, pixs, ...);\n *          (c) pixCloseCompBrick(pixd, pixs, ...);\n *      (7) The dimensions of the resulting image are determined by pixs.\n *      (8) CAUTION: both hsize and vsize are being decomposed.\n *          The decomposer chooses a product of sizes (call them\n *          'terms') for each that is close to the input size,\n *          but not necessarily equal to it.  It attempts to optimize:\n *             (a) for consistency with the input values: the product\n *                 of terms is close to the input size\n *             (b) for efficiency of the operation: the sum of the\n *                 terms is small; ideally about twice the square\n *                 root of the input size.\n *          So, for example, if the input hsize = 37, which is\n *          a prime number, the decomposer will break this into two\n *          terms, 6 and 6, so that the net result is a dilation\n *          with hsize = 36.\n */",
      "file" : "morph.c"
   },
   {
      "function" : "pixCloseCompBrickDwa",
      "comment" : "/*!\n *  pixCloseCompBrickDwa()\n *\n *      Input:  pixd  (<optional>; this can be null, equal to pixs,\n *                     or different from pixs)\n *              pixs (1 bpp)\n *              hsize (width of brick Sel)\n *              vsize (height of brick Sel)\n *      Return: pixd\n *\n *  Notes:\n *      (1) This implements a separable composite safe closing with 2D\n *          brick Sels.\n *      (2) For efficiency, it may decompose each linear morphological\n *          operation into two (brick + comb).\n *      (3) A brick Sel has hits for all elements.\n *      (4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)\n *      (5) Do separably if both hsize and vsize are > 1.\n *      (6) It is necessary that both horizontal and vertical Sels\n *          of the input size are defined in the basic sela.\n *      (7) There are three cases:\n *          (a) pixd == null   (result into new pixd)\n *          (b) pixd == pixs   (in-place; writes result back to pixs)\n *          (c) pixd != pixs   (puts result into existing pixd)\n *      (8) For clarity, if the case is known, use these patterns:\n *          (a) pixd = pixCloseCompBrickDwa(NULL, pixs, ...);\n *          (b) pixCloseCompBrickDwa(pixs, pixs, ...);\n *          (c) pixCloseCompBrickDwa(pixd, pixs, ...);\n *      (9) The size of pixd is determined by pixs.\n *      (10) CAUTION: both hsize and vsize are being decomposed.\n *          The decomposer chooses a product of sizes (call them\n *          'terms') for each that is close to the input size,\n *           but not necessarily equal to it.  It attempts to optimize:\n *              (a) for consistency with the input values: the product\n *                  of terms is close to the input size\n *              (b) for efficiency of the operation: the sum of the\n *                  terms is small; ideally about twice the square\n *                   root of the input size.\n *           So, for example, if the input hsize = 37, which is\n *           a prime number, the decomposer will break this into two\n *           terms, 6 and 6, so that the net result is a dilation\n *           with hsize = 36.\n */",
      "file" : "morphdwa.c"
   },
   {
      "function" : "pixCloseCompBrickExtendDwa",
      "comment" : "/*!\n *  pixCloseCompBrickExtendDwa()\n *\n *      Input:  pixd  (<optional>; this can be null, equal to pixs,\n *                     or different from pixs)\n *              pixs (1 bpp)\n *              hsize (width of brick Sel)\n *              vsize (height of brick Sel)\n *      Return: pixd\n *\n *      (1) There are three cases:\n *          (a) pixd == null   (result into new pixd)\n *          (b) pixd == pixs   (in-place; writes result back to pixs)\n *          (c) pixd != pixs   (puts result into existing pixd)\n *      (2) There is no need to call this directly:  pixCloseCompBrickDwa()\n *          calls this function if either brick dimension exceeds 63.\n */",
      "file" : "morphdwa.c"
   },
   {
      "function" : "pixCloseGeneralized",
      "comment" : "/*!\n *  pixCloseGeneralized()\n *\n *      Input:  pixd (<optional>; this can be null, equal to pixs,\n *                    or different from pixs)\n *              pixs (1 bpp)\n *              sel\n *      Return: pixd\n *\n *  Notes:\n *      (1) Generalized morphological closing, using both hits and\n *          misses in the Sel.\n *      (2) This does a dilation using the hits, followed by a\n *          hit-miss transform.\n *      (3) This operation is a dual of the generalized opening.\n *      (4) There are three cases:\n *          (a) pixd == null   (result into new pixd)\n *          (b) pixd == pixs   (in-place; writes result back to pixs)\n *          (c) pixd != pixs   (puts result into existing pixd)\n *      (5) For clarity, if the case is known, use these patterns:\n *          (a) pixd = pixCloseGeneralized(NULL, pixs, ...);\n *          (b) pixCloseGeneralized(pixs, pixs, ...);\n *          (c) pixCloseGeneralized(pixd, pixs, ...);\n *      (6) The size of the result is determined by pixs.\n */",
      "file" : "morph.c"
   },
   {
      "function" : "pixCloseGray",
      "comment" : "/*!\n *  pixCloseGray()\n *\n *      Input:  pixs\n *              hsize  (of Sel; must be odd; origin implicitly in center)\n *              vsize  (ditto)\n *      Return: pixd\n *\n *  Notes:\n *      (1) Sel is a brick with all elements being hits\n *      (2) If hsize = vsize = 1, just returns a copy.\n */",
      "file" : "graymorph.c"
   },
   {
      "function" : "pixCloseGray3",
      "comment" : "/*!\n *  pixCloseGray3()\n *\n *      Input:  pixs (8 bpp, not cmapped)\n *              hsize  (1 or 3)\n *              vsize  (1 or 3)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Special case for 1x3, 3x1 or 3x3 brick sel (all hits)\n *      (2) If hsize = vsize = 1, just returns a copy.\n */",
      "file" : "graymorph.c"
   },
   {
      "function" : "pixCloseSafe",
      "comment" : "/*!\n *  pixCloseSafe()\n *\n *      Input:  pixd (<optional>; this can be null, equal to pixs,\n *                    or different from pixs)\n *              pixs (1 bpp)\n *              sel\n *      Return: pixd\n *\n *  Notes:\n *      (1) Generic morphological closing, using hits in the Sel.\n *      (2) If non-symmetric boundary conditions are used, this\n *          function adds a border of OFF pixels that is of\n *          sufficient size to avoid losing pixels from the dilation,\n *          and it removes the border after the operation is finished.\n *          It thus enforces a correct extensive result for closing.\n *      (3) If symmetric b.c. are used, it is not necessary to add\n *          and remove this border.\n *      (4) There are three cases:\n *          (a) pixd == null   (result into new pixd)\n *          (b) pixd == pixs   (in-place; writes result back to pixs)\n *          (c) pixd != pixs   (puts result into existing pixd)\n *      (5) For clarity, if the case is known, use these patterns:\n *          (a) pixd = pixCloseSafe(NULL, pixs, ...);\n *          (b) pixCloseSafe(pixs, pixs, ...);\n *          (c) pixCloseSafe(pixd, pixs, ...);\n *      (6) The size of the result is determined by pixs.\n */",
      "file" : "morph.c"
   },
   {
      "function" : "pixCloseSafeBrick",
      "comment" : "/*!\n *  pixCloseSafeBrick()\n *\n *      Input:  pixd  (<optional>; this can be null, equal to pixs,\n *                     or different from pixs)\n *              pixs (1 bpp)\n *              hsize (width of brick Sel)\n *              vsize (height of brick Sel)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Sel is a brick with all elements being hits\n *      (2) The origin is at (x, y) = (hsize/2, vsize/2)\n *      (3) Do separably if both hsize and vsize are > 1.\n *      (4) Safe closing adds a border of 0 pixels, of sufficient size so\n *          that all pixels in input image are processed within\n *          32-bit words in the expanded image.  As a result, there is\n *          no special processing for pixels near the boundary, and there\n *          are no boundary effects.  The border is removed at the end.\n *      (5) There are three cases:\n *          (a) pixd == null   (result into new pixd)\n *          (b) pixd == pixs   (in-place; writes result back to pixs)\n *          (c) pixd != pixs   (puts result into existing pixd)\n *      (6) For clarity, if the case is known, use these patterns:\n *          (a) pixd = pixCloseBrick(NULL, pixs, ...);\n *          (b) pixCloseBrick(pixs, pixs, ...);\n *          (c) pixCloseBrick(pixd, pixs, ...);\n *      (7) The size of the result is determined by pixs.\n */",
      "file" : "morph.c"
   },
   {
      "function" : "pixCloseSafeCompBrick",
      "comment" : "/*!\n *  pixCloseSafeCompBrick()\n *\n *      Input:  pixd  (<optional>; this can be null, equal to pixs,\n *                     or different from pixs)\n *              pixs (1 bpp)\n *              hsize (width of brick Sel)\n *              vsize (height of brick Sel)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Sel is a brick with all elements being hits\n *      (2) The origin is at (x, y) = (hsize/2, vsize/2)\n *      (3) Do compositely for each dimension > 1.\n *      (4) Do separably if both hsize and vsize are > 1.\n *      (5) Safe closing adds a border of 0 pixels, of sufficient size so\n *          that all pixels in input image are processed within\n *          32-bit words in the expanded image.  As a result, there is\n *          no special processing for pixels near the boundary, and there\n *          are no boundary effects.  The border is removed at the end.\n *      (6) There are three cases:\n *          (a) pixd == null   (result into new pixd)\n *          (b) pixd == pixs   (in-place; writes result back to pixs)\n *          (c) pixd != pixs   (puts result into existing pixd)\n *      (7) For clarity, if the case is known, use these patterns:\n *          (a) pixd = pixCloseSafeCompBrick(NULL, pixs, ...);\n *          (b) pixCloseSafeCompBrick(pixs, pixs, ...);\n *          (c) pixCloseSafeCompBrick(pixd, pixs, ...);\n *      (8) The dimensions of the resulting image are determined by pixs.\n *      (9) CAUTION: both hsize and vsize are being decomposed.\n *          The decomposer chooses a product of sizes (call them\n *          'terms') for each that is close to the input size,\n *          but not necessarily equal to it.  It attempts to optimize:\n *             (a) for consistency with the input values: the product\n *                 of terms is close to the input size\n *             (b) for efficiency of the operation: the sum of the\n *                 terms is small; ideally about twice the square\n *                 root of the input size.\n *          So, for example, if the input hsize = 37, which is\n *          a prime number, the decomposer will break this into two\n *          terms, 6 and 6, so that the net result is a dilation\n *          with hsize = 36.\n */",
      "file" : "morph.c"
   },
   {
      "function" : "pixColorContent",
      "comment" : "/*!\n *  pixColorContent()\n *\n *      Input:  pixs  (32 bpp rgb or 8 bpp colormapped)\n *              rwhite, gwhite, bwhite (color value associated with white point)\n *              mingray (min gray value for which color is measured)\n *              &pixr (<optional return> 8 bpp red 'content')\n *              &pixg (<optional return> 8 bpp green 'content')\n *              &pixb (<optional return> 8 bpp blue 'content')\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This returns the color content in each component, which is\n *          a measure of the deviation from gray, and is defined\n *          as the difference between the component and the average of\n *          the other two components.  See the discussion at the\n *          top of this file.\n *      (2) The three numbers (rwhite, gwhite and bwhite) can be thought\n *          of as the values in the image corresponding to white.\n *          They are used to compensate for an unbalanced color white point.\n *          They must either be all 0 or all non-zero.  To turn this\n *          off, set them all to 0.\n *      (3) If the maximum component after white point correction,\n *          max(r,g,b), is less than mingray, all color components\n *          for that pixel are set to zero.\n *          Use mingray = 0 to turn off this filtering of dark pixels.\n *      (4) Therefore, use 0 for all four input parameters if the color\n *          magnitude is to be calculated without either white balance\n *          correction or dark filtering.\n */",
      "file" : "colorcontent.c"
   },
   {
      "function" : "pixColorFraction",
      "comment" : "/*!\n *  pixColorFraction()\n *\n *      Input:  pixs  (32 bpp rgb)\n *              darkthresh (threshold near black; if the lightest component\n *                          is below this, the pixel is not considered in\n *                          the statistics; typ. 20)\n *              lightthresh (threshold near white; if the darkest component\n *                           is above this, the pixel is not considered in\n *                           the statistics; typ. 244)\n *              diffthresh (thresh for the maximum difference between\n *                          component value; below this the pixel is not\n *                          considered to have sufficient color)\n *              factor (subsampling factor)\n *              &pixfract (<return> fraction of pixels in intermediate\n *                         brightness range that were considered\n *                         for color content)\n *              &colorfract (<return> fraction of pixels that meet the\n *                           criterion for sufficient color; 0.0 on error)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This function is asking the question: to what extent does the\n *          image appear to have color?   The amount of color a pixel\n *          appears to have depends on both the deviation of the\n *          individual components from their average and on the average\n *          intensity itself.  For example, the color will be much more\n *          obvious with a small deviation from white than the same\n *          deviation from black.\n *      (2) Any pixel that meets these three tests is considered a\n *          colorful pixel:\n *            (a) the lightest component must equal or exceed @darkthresh\n *            (b) the darkest component must not exceed @lightthresh\n *            (c) the max difference between components must equal or\n *                exceed @diffthresh.\n *      (3) The dark pixels are removed from consideration because\n *          they don't appear to have color.\n *      (4) The very lightest pixels are removed because if an image\n *          has a lot of \"white\", the color fraction will be artificially\n *          low, even if all the other pixels are colorful.\n *      (5) If pixfract is very small, there are few pixels that are neither\n *          black nor white.  If colorfract is very small, the pixels\n *          that are neither black nor white have very little color\n *          content.  The product 'pixfract * colorfract' gives the\n *          fraction of pixels with significant color content.\n *      (6) One use of this function is as a preprocessing step for median\n *          cut quantization (colorquant2.c), which does a very poor job\n *          splitting the color space into rectangular volume elements when\n *          all the pixels are near the diagonal of the color cube.  For\n *          octree quantization of an image with only gray values, the\n *          2^(level) octcubes on the diagonal are the only ones\n *          that can be occupied.\n */",
      "file" : "colorcontent.c"
   },
   {
      "function" : "pixColorGray",
      "comment" : "/*!\n *  pixColorGray()\n *\n *      Input:  pixs (8 bpp gray, rgb or colormapped image)\n *              box (<optional> region in which to apply color; can be NULL)\n *              type (L_PAINT_LIGHT, L_PAINT_DARK)\n *              thresh (average value below/above which pixel is unchanged)\n *              rval, gval, bval (new color to paint)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This is an in-place operation; pixs is modified.\n *          If pixs is colormapped, the operation will add colors to the\n *          colormap.  Otherwise, pixs will be converted to 32 bpp rgb if\n *          it is initially 8 bpp gray.\n *      (2) If type == L_PAINT_LIGHT, it colorizes non-black pixels,\n *          preserving antialiasing.\n *          If type == L_PAINT_DARK, it colorizes non-white pixels,\n *          preserving antialiasing.\n *      (3) If box is NULL, applies function to the entire image; otherwise,\n *          clips the operation to the intersection of the box and pix.\n *      (4) If colormapped, calls pixColorGrayCmap(), which applies the\n *          coloring algorithm only to pixels that are strictly gray.\n *      (5) For RGB, determines a \"gray\" value by averaging; then uses this\n *          value, plus the input rgb target, to generate the output\n *          pixel values.\n *      (6) thresh is only used for rgb; it is ignored for colormapped pix.\n *          If type == L_PAINT_LIGHT, use thresh = 0 if all pixels are to\n *          be colored (black pixels will be unaltered).\n *          In situations where there are a lot of black pixels,\n *          setting thresh > 0 will make the function considerably\n *          more efficient without affecting the final result.\n *          If type == L_PAINT_DARK, use thresh = 255 if all pixels\n *          are to be colored (white pixels will be unaltered).\n *          In situations where there are a lot of white pixels,\n *          setting thresh < 255 will make the function considerably\n *          more efficient without affecting the final result.\n */",
      "file" : "coloring.c"
   },
   {
      "function" : "pixColorGrayCmap",
      "comment" : "/*!\n *  pixColorGrayCmap()\n *\n *      Input:  pixs (2, 4 or 8 bpp, with colormap)\n *              box (<optional> region to set color; can be NULL)\n *              type (L_PAINT_LIGHT, L_PAINT_DARK)\n *              rval, gval, bval (target color)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is an in-place operation.\n *      (2) If type == L_PAINT_LIGHT, it colorizes non-black pixels,\n *          preserving antialiasing.\n *          If type == L_PAINT_DARK, it colorizes non-white pixels,\n *          preserving antialiasing.\n *      (3) If box is NULL, applies function to the entire image; otherwise,\n *          clips the operation to the intersection of the box and pix.\n *      (4) This can also be called through pixColorGray().\n *      (5) This increases the colormap size by the number of\n *          different gray (non-black or non-white) colors in the\n *          input colormap.  If there is not enough room in the colormap\n *          for this expansion, it returns 1 (error), and the caller\n *          should check the return value.  If an error is returned\n *          and the cmap is only 2 or 4 bpp, the pix can be converted\n *          to 8 bpp and this function will succeed if run again on\n *          a larger colormap.\n *      (6) Using the darkness of each original pixel in the rect,\n *          it generates a new color (based on the input rgb values).\n *          If type == L_PAINT_LIGHT, the new color is a (generally)\n *          darken-to-black version of the  input rgb color, where the\n *          amount of darkening increases with the darkness of the\n *          original pixel color.\n *          If type == L_PAINT_DARK, the new color is a (generally)\n *          faded-to-white version of the  input rgb color, where the\n *          amount of fading increases with the brightness of the\n *          original pixel color.\n */",
      "file" : "paintcmap.c"
   },
   {
      "function" : "pixColorGrayRegions",
      "comment" : "/*!\n *  pixColorGrayRegions()\n *\n *      Input:  pixs (2, 4 or 8 bpp gray, rgb, or colormapped)\n *              boxa (of regions in which to apply color)\n *              type (L_PAINT_LIGHT, L_PAINT_DARK)\n *              thresh (average value below/above which pixel is unchanged)\n *              rval, gval, bval (new color to paint)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This generates a new image, where some of the pixels in each\n *          box in the boxa are colorized.  See pixColorGray() for usage\n *          with @type and @thresh.  Note that @thresh is only used for\n *          rgb; it is ignored for colormapped images.\n *      (2) If the input image is colormapped, the new image will be 8 bpp\n *          colormapped if possible; otherwise, it will be converted\n *          to 32 bpp rgb.  Only pixels that are strictly gray will be\n *          colorized.\n *      (3) If the input image is not colormapped, it is converted to rgb.\n *          A \"gray\" value for a pixel is determined by averaging the\n *          components, and the output rgb value is determined from this.\n *      (4) This can be used in conjunction with pixFindColorRegions() to\n *          add highlight color to a grayscale image.\n */",
      "file" : "coloring.c"
   },
   {
      "function" : "pixColorGrayRegionsCmap",
      "comment" : "/*!\n *  pixColorGrayRegionsCmap()\n *\n *      Input:  pixs (8 bpp, with colormap)\n *              boxa (of regions in which to apply color)\n *              type (L_PAINT_LIGHT, L_PAINT_DARK)\n *              rval, gval, bval (target color)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is an in-place operation.\n *      (2) If type == L_PAINT_LIGHT, it colorizes non-black pixels,\n *          preserving antialiasing.\n *          If type == L_PAINT_DARK, it colorizes non-white pixels,\n *          preserving antialiasing.  See pixColorGrayCmap() for details.\n *      (3) This can also be called through pixColorGrayRegions().\n *      (4) This increases the colormap size by the number of\n *          different gray (non-black or non-white) colors in the\n *          selected regions of pixs.  If there is not enough room in\n *          the colormap for this expansion, it returns 1 (error),\n *          and the caller should check the return value.\n *      (5) Because two boxes in the boxa can overlap, pixels that\n *          are colorized in the first box must be excluded in the\n *          second because their value exceeds the size of the map.\n */",
      "file" : "paintcmap.c"
   },
   {
      "function" : "pixColorMagnitude",
      "comment" : "/*!\n *  pixColorMagnitude()\n *\n *      Input:  pixs  (32 bpp rgb or 8 bpp colormapped)\n *              rwhite, gwhite, bwhite (color value associated with white point)\n *              type (chooses the method for calculating the color magnitude:\n *                    L_MAX_DIFF_FROM_AVERAGE_2, L_MAX_MIN_DIFF_FROM_2,\n *                    L_MAX_DIFF)\n *      Return: pixd (8 bpp, amount of color in each source pixel),\n *                    or NULL on error\n *\n *  Notes:\n *      (1) For an RGB image, a gray pixel is one where all three components\n *          are equal.  We define the amount of color in an RGB pixel by\n *          considering the absolute value of the differences between the\n *          three color components.  Consider the two largest\n *          of these differences.  The pixel component in common to these\n *          two differences is the color farthest from the other two.\n *          The color magnitude in an RGB pixel can be taken as:\n *              * the average of these two differences; i.e., the\n *                average distance from the two components that are\n *                nearest to each other to the third component, or\n *              * the minimum value of these two differences; i.e., the\n *                maximum over all components of the minimum distance\n *                from that component to the other two components.\n *          Even more simply, the color magnitude can be taken as\n *              * the maximum difference between component values\n *      (2) As an example, suppose that R and G are the closest in\n *          magnitude.  Then the color is determined as:\n *              * the average distance of B from these two; namely,\n *                (|B - R| + |B - G|) / 2, which can also be found\n *                from |B - (R + G) / 2|, or\n *              * the minimum distance of B from these two; namely,\n *                min(|B - R|, |B - G|).\n *              * the max(|B - R|, |B - G|)\n *      (3) The three numbers (rwhite, gwhite and bwhite) can be thought\n *          of as the values in the image corresponding to white.\n *          They are used to compensate for an unbalanced color white point.\n *          They must either be all 0 or all non-zero.  To turn this\n *          off, set them all to 0.\n *      (4) We allow the following methods for choosing the color\n *          magnitude from the three components:\n *              * L_MAX_DIFF_FROM_AVERAGE_2\n *              * L_MAX_MIN_DIFF_FROM_2\n *              * L_MAX_DIFF\n *          These are described above in (1) and (2), as well as at\n *          the top of this file.\n */",
      "file" : "colorcontent.c"
   },
   {
      "function" : "pixColorMorph",
      "comment" : "/*!\n *  pixColorMorph()\n *\n *      Input:  pixs\n *              type  (L_MORPH_DILATE, L_MORPH_ERODE, L_MORPH_OPEN,\n *                     or L_MORPH_CLOSE)\n *              hsize  (of Sel; must be odd; origin implicitly in center)\n *              vsize  (ditto)\n *      Return: pixd\n *\n *  Notes:\n *      (1) This does the morph operation on each component separately,\n *          and recombines the result.\n *      (2) Sel is a brick with all elements being hits.\n *      (3) If hsize = vsize = 1, just returns a copy.\n */",
      "file" : "colormorph.c"
   },
   {
      "function" : "pixColorMorphSequence",
      "comment" : "/*!\n *  pixColorMorphSequence()\n *\n *      Input:  pixs\n *              sequence (string specifying sequence)\n *              dispsep (controls debug display of each result in the sequence:\n *                       0: no output\n *                       > 0: gives horizontal separation in pixels between\n *                            successive displays\n *                       < 0: pdf output; abs(dispsep) is used for naming)\n *              dispy (if dispsep > 0, this gives the y-value of the\n *                     UL corner for display; otherwise it is ignored)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This works on 32 bpp rgb images.\n *      (2) Each component is processed separately.\n *      (3) This runs a pipeline of operations; no branching is allowed.\n *      (4) This only uses brick SELs.\n *      (5) A new image is always produced; the input image is not changed.\n *      (6) This contains an interpreter, allowing sequences to be\n *          generated and run.\n *      (7) Sel sizes (width, height) must each be odd numbers.\n *      (8) The format of the sequence string is defined below.\n *      (9) Intermediate results can optionally be displayed.\n *      (10) The sequence string is formatted as follows:\n *            - An arbitrary number of operations,  each separated\n *              by a '+' character.  White space is ignored.\n *            - Each operation begins with a case-independent character\n *              specifying the operation:\n *                 d or D  (dilation)\n *                 e or E  (erosion)\n *                 o or O  (opening)\n *                 c or C  (closing)\n *            - The args to the morphological operations are bricks of hits,\n *              and are formatted as a.b, where a and b are horizontal and\n *              vertical dimensions, rsp. (each must be an odd number)\n *           Example valid sequences are:\n *             \"c5.3 + o7.5\"\n *             \"D9.1\"\n */",
      "file" : "morphseq.c"
   },
   {
      "function" : "pixColorSegment",
      "comment" : "/*!\n *  pixColorSegment()\n *\n *      Input:  pixs  (32 bpp; 24-bit color)\n *              maxdist (max euclidean dist to existing cluster)\n *              maxcolors (max number of colors allowed in first pass)\n *              selsize (linear size of sel for closing to remove noise)\n *              finalcolors (max number of final colors allowed after 4th pass)\n *      Return: pixd (8 bit with colormap), or null on error\n *\n *  Color segmentation proceeds in four phases:\n *\n *  Phase 1:  pixColorSegmentCluster()\n *  The image is traversed in raster order.  Each pixel either\n *  becomes the representative for a new cluster or is assigned to an\n *  existing cluster.  Assignment is greedy.  The data is stored in\n *  a colormapped image.  Three auxiliary arrays are used to hold\n *  the colors of the representative pixels, for fast lookup.\n *  The average color in each cluster is computed.\n *\n *  Phase 2.  pixAssignToNearestColor()\n *  A second (non-greedy) clustering pass is performed, where each pixel\n *  is assigned to the nearest cluster (average).  We also keep track\n *  of how many pixels are assigned to each cluster.\n *\n *  Phase 3.  pixColorSegmentClean()\n *  For each cluster, starting with the largest, do a morphological\n *  closing to eliminate small components within larger ones.\n *\n *  Phase 4.  pixColorSegmentRemoveColors()\n *  Eliminate all colors except the most populated 'finalcolors'.\n *  Then remove unused colors from the colormap, and reassign those\n *  pixels to the nearest remaining cluster, using the original pixel values.\n *\n *  Notes:\n *      (1) The goal is to generate a small number of colors.\n *          Typically this would be specified by 'finalcolors',\n *          a number that would be somewhere between 3 and 6.\n *          The parameter 'maxcolors' specifies the maximum number of\n *          colors generated in the first phase.  This should be\n *          larger than finalcolors, perhaps twice as large.\n *          If more than 'maxcolors' are generated in the first phase\n *          using the input 'maxdist', the distance is repeatedly\n *          increased by a multiplicative factor until the condition\n *          is satisfied.  The implicit relation between 'maxdist'\n *          and 'maxcolors' is thus adjusted programmatically.\n *      (2) As a very rough guideline, given a target value of 'finalcolors',\n *          here are approximate values of 'maxdist' and 'maxcolors'\n *          to start with:\n *\n *               finalcolors    maxcolors    maxdist\n *               -----------    ---------    -------\n *                   3             6          100\n *                   4             8           90\n *                   5            10           75\n *                   6            12           60\n *\n *          For a given number of finalcolors, if you use too many\n *          maxcolors, the result will be noisy.  If you use too few,\n *          the result will be a relatively poor assignment of colors.\n */",
      "file" : "colorseg.c"
   },
   {
      "function" : "pixColorSegmentClean",
      "comment" : "/*!\n *  pixColorSegmentClean()\n *\n *      Input:  pixs  (8 bpp, colormapped)\n *              selsize (for closing)\n *              countarray (ptr to array containing the number of pixels\n *                          found in each color in the colormap)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This operation is in-place.\n *      (2) This is phase 3 of color segmentation.  It is the first\n *          part of a two-step noise removal process.  Colors with a\n *          large population are closed first; this operation absorbs\n *          small sets of intercolated pixels of a different color.\n */",
      "file" : "colorseg.c"
   },
   {
      "function" : "pixColorSegmentCluster",
      "comment" : "/*!\n *  pixColorSegmentCluster()\n *\n *      Input:  pixs  (32 bpp; 24-bit color)\n *              maxdist (max euclidean dist to existing cluster)\n *              maxcolors (max number of colors allowed in first pass)\n *      Return: pixd (8 bit with colormap), or null on error\n *\n *  Notes:\n *      (1) This is phase 1.  See description in pixColorSegment().\n *      (2) Greedy unsupervised classification.  If the limit 'maxcolors'\n *          is exceeded, the computation is repeated with a larger\n *          allowed cluster size.\n *      (3) On each successive iteration, 'maxdist' is increased by a\n *          constant factor.  See comments in pixColorSegment() for\n *          a guideline on parameter selection.\n *          Note that the diagonal of the 8-bit rgb color cube is about\n *          440, so for 'maxdist' = 440, you are guaranteed to get 1 color!\n */",
      "file" : "colorseg.c"
   },
   {
      "function" : "pixColorSegmentRemoveColors",
      "comment" : "/*!\n *  pixColorSegmentRemoveColors()\n *\n *      Input:  pixd  (8 bpp, colormapped)\n *              pixs  (32 bpp rgb, with initial pixel values)\n *              finalcolors (max number of colors to retain)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This operation is in-place.\n *      (2) This is phase 4 of color segmentation, and the second part\n *          of the 2-step noise removal.  Only 'finalcolors' different\n *          colors are retained, with colors with smaller populations\n *          being replaced by the nearest color of the remaining colors.\n *          For highest accuracy, for pixels that are being replaced,\n *          we find the nearest colormap color  to the original rgb color.\n */",
      "file" : "colorseg.c"
   },
   {
      "function" : "pixColorSegmentTryCluster",
      "comment" : "/*!\n *  pixColorSegmentTryCluster()\n *\n *      Input:  pixd\n *              pixs\n *              maxdist\n *              maxcolors\n *      Return: 0 if OK, 1 on error\n *\n *  Note: This function should only be called from pixColorSegCluster()\n */",
      "file" : "colorseg.c"
   },
   {
      "function" : "pixColorShiftRGB",
      "comment" : "/*!\n *  pixColorShiftRGB()\n *\n *      Input:  pixs (32 bpp rgb)\n *              rfract (fractional shift in red component)\n *              gfract (fractional shift in green component)\n *              bfract (fractional shift in blue component)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This allows independent fractional shifts of the r,g and b\n *          components.  A positive shift pushes to saturation (255);\n *          a negative shift pushes toward 0 (black).\n *      (2) The effect can be imagined using a color wheel that consists\n *          (for our purposes) of these 6 colors, separated by 60 degrees:\n *             red, magenta, blue, cyan, green, yellow\n *      (3) So, for example, a negative shift of the blue component\n *          (bfract < 0) could be accompanied by positive shifts\n *          of red and green to make an image more yellow.\n *      (4) Examples of limiting cases:\n *            rfract = 1 ==> r = 255\n *            rfract = -1 ==> r = 0\n */",
      "file" : "enhance.c"
   },
   {
      "function" : "pixColorizeGray",
      "comment" : "/*!\n *  pixColorizeGray()\n *\n *      Input:  pixs (8 bpp gray; 2, 4 or 8 bpp colormapped)\n *              color (32 bit rgba pixel)\n *              cmapflag (1 for result to have colormap; 0 for RGB)\n *      Return: pixd (8 bpp colormapped or 32 bpp rgb), or null on error\n *\n *  Notes:\n *      (1) This applies the specific color to the grayscale image.\n *      (2) If pixs already has a colormap, it is removed to gray\n *          before colorizing.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixColorsForQuantization",
      "comment" : "/*!\n *  pixColorsForQuantization()\n *      Input:  pixs (8 bpp gray or 32 bpp rgb; with or without colormap)\n *              thresh (binary threshold on edge gradient; 0 for default)\n *              &ncolors (<return> the number of colors found)\n *              &iscolor (<optional return> 1 if significant color is found;\n *                        0 otherwise.  If pixs is 8 bpp, and does not have\n *                        a colormap with color entries, this is 0)\n *              debug (1 to output masked image that is tested for colors;\n *                     0 otherwise)\n *      Return: 0 if OK, 1 on error.\n *\n *  Notes:\n *      (1) This function finds a measure of the number of colors that are\n *          found in low-gradient regions of an image.  By its\n *          magnitude relative to some threshold (not specified in\n *          this function), it gives a good indication of whether\n *          quantization will generate posterization.   This number\n *          is larger for images with regions of slowly varying\n *          intensity (if 8 bpp) or color (if rgb). Such images, if\n *          quantized, may require dithering to avoid posterization,\n *          and lossless compression is then expected to be poor.\n *      (2) If pixs has a colormap, the number of colors returned is\n *          the number in the colormap.\n *      (3) It is recommended that document images be reduced to a width\n *          of 800 pixels before applying this function.  Then it can\n *          be expected that color detection will be fairly accurate\n *          and the number of colors will reflect both the content and\n *          the type of compression to be used.  For less than 15 colors,\n *          there is unlikely to be a halftone image, and lossless\n *          quantization should give both a good visual result and\n *          better compression.\n *      (4) When using the default threshold on the gradient (15),\n *          images (both gray and rgb) where ncolors is greater than\n *          about 15 will compress poorly with either lossless\n *          compression or dithered quantization, and they may be\n *          posterized with non-dithered quantization.\n *      (5) For grayscale images, or images without significant color,\n *          this returns the number of significant gray levels in\n *          the low-gradient regions.  The actual number of gray levels\n *          can be large due to jpeg compression noise in the background.\n *      (6) Similarly, for color images, the actual number of different\n *          (r,g,b) colors in the low-gradient regions (rather than the\n *          number of occupied level 4 octcubes) can be quite large, e.g.,\n *          due to jpeg compression noise, even for regions that appear\n *          to be of a single color.  By quantizing to level 4 octcubes,\n *          most of these superfluous colors are removed from the counting.\n *      (7) The image is tested for color.  If there is very little color,\n *          it is thresholded to gray and the number of gray levels in\n *          the low gradient regions is found.  If the image has color,\n *          the number of occupied level 4 octcubes is found.\n *      (8) The number of colors in the low-gradient regions increases\n *          monotonically with the threshold @thresh on the edge gradient.\n *      (9) Background: grayscale and color quantization is often useful\n *          to achieve highly compressed images with little visible\n *          distortion.  However, gray or color washes (regions of\n *          low gradient) can defeat this approach to high compression.\n *          How can one determine if an image is expected to compress\n *          well using gray or color quantization?  We use the fact that\n *            * gray washes, when quantized with less than 50 intensities,\n *              have posterization (visible boundaries between regions\n *              of uniform 'color') and poor lossless compression\n *            * color washes, when quantized with level 4 octcubes,\n *              typically result in both posterization and the occupancy\n *              of many level 4 octcubes.\n *          Images can have colors either intrinsically or as jpeg\n *          compression artifacts.  This function reduces but does not\n *          completely eliminate measurement of jpeg quantization noise\n *          in the white background of grayscale or color images.\n */",
      "file" : "colorcontent.c"
   },
   {
      "function" : "pixColumnStats",
      "comment" : "/*!\n *  pixColumnStats()\n *\n *      Input:  pixs (8 bpp; not cmapped)\n *              box (<optional> clipping box; can be null)\n *              &namean (<optional return> numa of mean values)\n *              &namedian (<optional return> numa of median values)\n *              &namode (<optional return> numa of mode intensity values)\n *              &namodecount (<optional return> numa of mode counts)\n *              &navar (<optional return> numa of variance)\n *              &narootvar (<optional return> numa of square root of variance)\n *      Return: na (numa of requested statistic for each column),\n *                  or null on error\n *\n *  Notes:\n *      (1) This computes numas that represent row vectors of statistics,\n *          with each of its values derived from the corresponding col of a Pix.\n *      (2) Use NULL on input to prevent computation of any of the 5 numas.\n *      (3) Other functions that compute pixel column statistics are:\n *             pixCountPixelsByColumn()\n *             pixAverageByColumn()\n *             pixVarianceByColumn()\n *             pixGetColumnStats()\n */",
      "file" : "pix4.c"
   },
   {
      "function" : "pixCombineMasked",
      "comment" : "/*!\n *  pixCombineMasked()\n *\n *      Input:  pixd (1 bpp, 8 bpp gray or 32 bpp rgb; no cmap)\n *              pixs (1 bpp, 8 bpp gray or 32 bpp rgb; no cmap)\n *              pixm (<optional> 1 bpp mask; no operation if NULL)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) In-place operation; pixd is changed.\n *      (2) This sets each pixel in pixd that co-locates with an ON\n *          pixel in pixm to the corresponding value of pixs.\n *      (3) pixs and pixd must be the same depth and not colormapped.\n *      (4) All three input pix are aligned at the UL corner, and the\n *          operation is clipped to the intersection of all three images.\n *      (5) If pixm == NULL, it's a no-op.\n *      (6) Implementation: see notes in pixCombineMaskedGeneral().\n *          For 8 bpp selective masking, you might guess that it\n *          would be faster to generate an 8 bpp version of pixm,\n *          using pixConvert1To8(pixm, 0, 255), and then use a\n *          general combine operation\n *               d = (d & ~m) | (s & m)\n *          on a word-by-word basis.  Not always.  The word-by-word\n *          combine takes a time that is independent of the mask data.\n *          If the mask is relatively sparse, the byte-check method\n *          is actually faster!\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixCombineMaskedGeneral",
      "comment" : "/*!\n *  pixCombineMaskedGeneral()\n *\n *      Input:  pixd (1 bpp, 8 bpp gray or 32 bpp rgb)\n *              pixs (1 bpp, 8 bpp gray or 32 bpp rgb)\n *              pixm (<optional> 1 bpp mask)\n *              x, y (origin of pixs and pixm relative to pixd; can be negative)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) In-place operation; pixd is changed.\n *      (2) This is a generalized version of pixCombinedMasked(), where\n *          the source and mask can be placed at the same (arbitrary)\n *          location relative to pixd.\n *      (3) pixs and pixd must be the same depth and not colormapped.\n *      (4) The UL corners of both pixs and pixm are aligned with\n *          the point (x, y) of pixd, and the operation is clipped to\n *          the intersection of all three images.\n *      (5) If pixm == NULL, it's a no-op.\n *      (6) Implementation.  There are two ways to do these.  In the first,\n *          we use rasterop, ORing the part of pixs under the mask\n *          with pixd (which has been appropriately cleared there first).\n *          In the second, the mask is used one pixel at a time to\n *          selectively replace pixels of pixd with those of pixs.\n *          Here, we use rasterop for 1 bpp and pixel-wise replacement\n *          for 8 and 32 bpp.  To use rasterop for 8 bpp, for example,\n *          we must first generate an 8 bpp version of the mask.\n *          The code is simple:\n *\n *             Pix *pixm8 = pixConvert1To8(NULL, pixm, 0, 255);\n *             Pix *pixt = pixAnd(NULL, pixs, pixm8);\n *             pixRasterop(pixd, x, y, wmin, hmin, PIX_DST & PIX_NOT(PIX_SRC),\n *                         pixm8, 0, 0);\n *             pixRasterop(pixd, x, y, wmin, hmin, PIX_SRC | PIX_DST,\n *                         pixt, 0, 0);\n *             pixDestroy(&pixt);\n *             pixDestroy(&pixm8);\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixCompareBinary",
      "comment" : "/*!\n *  pixCompareBinary()\n *\n *      Input:  pix1 (1 bpp)\n *              pix2 (1 bpp)\n *              comptype (L_COMPARE_XOR, L_COMPARE_SUBTRACT)\n *              &fract (<return> fraction of pixels that are different)\n *              &pixdiff (<optional return> pix of difference)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) The two images are aligned at the UL corner, and do not\n *          need to be the same size.\n *      (2) If using L_COMPARE_SUBTRACT, pix2 is subtracted from pix1.\n *      (3) The total number of pixels is determined by pix1.\n */",
      "file" : "compare.c"
   },
   {
      "function" : "pixCompareGray",
      "comment" : "/*!\n *  pixCompareGray()\n *\n *      Input:  pix1 (8 or 16 bpp, not cmapped)\n *              pix2 (8 or 16 bpp, not cmapped)\n *              comptype (L_COMPARE_SUBTRACT, L_COMPARE_ABS_DIFF)\n *              plottype (gplot plot output type, or 0 for no plot)\n *              &same (<optional return> 1 if pixel values are identical)\n *              &diff (<optional return> average difference)\n *              &rmsdiff (<optional return> rms of difference)\n *              &pixdiff (<optional return> pix of difference)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) See pixCompareGrayOrRGB() for details.\n *      (2) Use pixCompareGrayOrRGB() if the input pix are colormapped.\n */",
      "file" : "compare.c"
   },
   {
      "function" : "pixCompareGrayOrRGB",
      "comment" : "/*!\n *  pixCompareGrayOrRGB()\n *\n *      Input:  pix1 (8 or 16 bpp gray, 32 bpp rgb, or colormapped)\n *              pix2 (8 or 16 bpp gray, 32 bpp rgb, or colormapped)\n *              comptype (L_COMPARE_SUBTRACT, L_COMPARE_ABS_DIFF)\n *              plottype (gplot plot output type, or 0 for no plot)\n *              &same (<optional return> 1 if pixel values are identical)\n *              &diff (<optional return> average difference)\n *              &rmsdiff (<optional return> rms of difference)\n *              &pixdiff (<optional return> pix of difference)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) The two images are aligned at the UL corner, and do not\n *          need to be the same size.  If they are not the same size,\n *          the comparison will be made over overlapping pixels.\n *      (2) If there is a colormap, it is removed and the result\n *          is either gray or RGB depending on the colormap.\n *      (3) If RGB, each component is compared separately.\n *      (4) If type is L_COMPARE_ABS_DIFF, pix2 is subtracted from pix1\n *          and the absolute value is taken.\n *      (5) If type is L_COMPARE_SUBTRACT, pix2 is subtracted from pix1\n *          and the result is clipped to 0.\n *      (6) The plot output types are specified in gplot.h.\n *          Use 0 if no difference plot is to be made.\n *      (7) If the images are pixelwise identical, no difference\n *          plot is made, even if requested.  The result (TRUE or FALSE)\n *          is optionally returned in the parameter 'same'.\n *      (8) The average difference (either subtracting or absolute value)\n *          is optionally returned in the parameter 'diff'.\n *      (9) The RMS difference is optionally returned in the\n *          parameter 'rmsdiff'.  For RGB, we return the average of\n *          the RMS differences for each of the components.\n */",
      "file" : "compare.c"
   },
   {
      "function" : "pixCompareRGB",
      "comment" : "/*!\n *  pixCompareRGB()\n *\n *      Input:  pix1 (32 bpp rgb)\n *              pix2 (32 bpp rgb)\n *              comptype (L_COMPARE_SUBTRACT, L_COMPARE_ABS_DIFF)\n *              plottype (gplot plot output type, or 0 for no plot)\n *              &same (<optional return> 1 if pixel values are identical)\n *              &diff (<optional return> average difference)\n *              &rmsdiff (<optional return> rms of difference)\n *              &pixdiff (<optional return> pix of difference)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) See pixCompareGrayOrRGB() for details.\n */",
      "file" : "compare.c"
   },
   {
      "function" : "pixCompareRankDifference",
      "comment" : "/*!\n *  pixCompareRankDifference()\n *\n *      Input:  pix1 (8 bpp gray or 32 bpp rgb, or colormapped)\n *              pix2 (8 bpp gray or 32 bpp rgb, or colormapped)\n *              factor (subsampling factor; use 0 or 1 for no subsampling)\n *      Return: narank (numa of rank difference), or null on error\n *\n *  Notes:\n *      (1) This answers the question: if the pixel values in each\n *          component are compared by absolute difference, for\n *          any value of difference, what is the fraction of\n *          pixel pairs that have a difference of this magnitude\n *          or greater.  For a difference of 0, the fraction is 1.0.\n *          In this sense, it is a mapping from pixel difference to\n *          rank order of difference.\n *      (2) The two images are aligned at the UL corner, and do not\n *          need to be the same size.  If they are not the same size,\n *          the comparison will be made over overlapping pixels.\n *      (3) If there is a colormap, it is removed and the result\n *          is either gray or RGB depending on the colormap.\n *      (4) If RGB, pixel differences for each component are aggregated\n *          into a single histogram.\n */",
      "file" : "compare.c"
   },
   {
      "function" : "pixCompareTiled",
      "comment" : "/*!\n *  pixCompareTiled()\n *\n *      Input:  pix1 (8 bpp or 32 bpp rgb)\n *              pix2 (8 bpp 32 bpp rgb)\n *              sx, sy (tile size; must be > 1)\n *              type (L_MEAN_ABSVAL or L_ROOT_MEAN_SQUARE)\n *              &pixdiff (<return> pix of difference)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) With L_MEAN_ABSVAL, we compute for each tile the\n *          average abs value of the pixel component difference between\n *          the two (aligned) images.  With L_ROOT_MEAN_SQUARE, we\n *          compute instead the rms difference over all components.\n *      (2) The two input pix must be the same depth.  Comparison is made\n *          using UL corner alignment.\n *      (3) For 32 bpp, the distance between corresponding tiles\n *          is found by averaging the measured difference over all three\n *          components of each pixel in the tile.\n *      (4) The result, pixdiff, contains one pixel for each source tile.\n */",
      "file" : "compare.c"
   },
   {
      "function" : "pixCompareWithTranslation",
      "comment" : "/*!\n *  pixCompareWithTranslation()\n *\n *      Input:  pix1, pix2 (any depth; colormap OK)\n *              thresh (threshold for converting to 1 bpp)\n *              &delx (<return> x translation on pix2 to align with pix1)\n *              &dely (<return> y translation on pix2 to align with pix1)\n *              &score (<return> correlation score at best alignment)\n *              debugflag (1 for debug output; 0 for no debugging)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This does a coarse-to-fine search for best translational\n *          alignment of two images, measured by a scoring function\n *          that is the correlation between the fg pixels.\n *      (2) The threshold is used if the images aren't 1 bpp.\n *      (3) With debug on, you get a pdf that shows, as a grayscale\n *          image, the score as a function of shift from the initial\n *          estimate, for each of the four levels.  The shift is 0 at\n *          the center of the image.\n *      (4) With debug on, you also get a pdf that shows the\n *          difference at the best alignment between the two images,\n *          at each of the four levels.  The red and green pixels\n *          show locations where one image has a fg pixel and the\n *          other doesn't.  The black pixels are where both images\n *          have fg pixels, and white pixels are where neither image\n *          has fg pixels.\n */",
      "file" : "compare.c"
   },
   {
      "function" : "pixComponentFunction",
      "comment" : "/*!\n *  pixComponentFunction()\n *\n *      Input:  pix (32 bpp rgb)\n *              rnum, gnum, bnum (coefficients for numerator)\n *              rdenom, gdenom, bdenom (coefficients for denominator)\n *      Return: fpixd, or null on error\n *\n *  Notes:\n *      (1) This stores a function of the component values of each\n *          input pixel in @fpixd.\n *      (2) The function is a ratio of linear combinations of component values.\n *          There are two special cases for denominator coefficients:\n *          (a) The denominator is 1.0: input 0 for all denominator coefficients\n *          (b) Only one component is used in the denominator: input 1.0\n *              for that denominator component and 0.0 for the other two.\n *      (3) If the denominator is 0, multiply by an arbitrary number that\n *          is much larger than 1.  Choose 256 \"arbitrarily\".\n *\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "pixConformsToRectangle",
      "comment" : "/*!\n *  pixConformsToRectangle()\n *\n *      Input:  pixs (1 bpp)\n *              box (<optional> if null, use the entire pixs)\n *              dist (max distance allowed between bounding box and nearest\n *                    foreground pixel within it)\n *              &conforms (<return> 0 (false) if not conforming;\n *                        1 (true) if conforming)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) There are several ways to test if a connected component has\n *          an essentially rectangular boundary, such as:\n *           a. Fraction of fill into the bounding box\n *           b. Max-min distance of fg pixel from periphery of bounding box\n *           c. Max depth of bg intrusions into component within bounding box\n *          The weakness of (a) is that it is highly sensitive to holes\n *          within the c.c.  The weakness of (b) is that it can have\n *          arbitrarily large intrusions into the c.c.  Method (c) tests\n *          the integrity of the outer boundary of the c.c., with respect\n *          to the enclosing bounding box, so we use it.\n *      (2) This tests if the connected component within the box conforms\n *          to the box at all points on the periphery within @dist.\n *          Inside, at a distance from the box boundary that is greater\n *          than @dist, we don't care about the pixels in the c.c.\n *      (3) We can think of the conforming condition as follows:\n *          No pixel inside a distance @dist from the boundary\n *          can connect to the boundary through a path through the bg.\n *          To implement this, we need to do a flood fill.  We can go\n *          either from inside toward the boundary, or the other direction.\n *          It's easiest to fill from the boundary, and then verify that\n *          there are no filled pixels farther than @dist from the boundary.\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixConnComp",
      "comment" : "/*!\n *  pixConnComp()\n *\n *      Input:  pixs (1 bpp)\n *              &pixa   (<optional return> pixa of each c.c.)\n *              connectivity (4 or 8)\n *      Return: boxa, or null on error\n *\n *  Notes:\n *      (1) This is the top-level call for getting bounding boxes or\n *          a pixa of the components, and it can be used instead\n *          of either pixConnCompBB() or pixConnCompPixa(), rsp.\n */",
      "file" : "conncomp.c"
   },
   {
      "function" : "pixConnCompAreaTransform",
      "comment" : "/*!\n *  pixConnCompAreaTransform()\n *\n *      Input:   pixs (1 bpp)\n *               connect (connectivity: 4 or 8)\n *      Return:  pixd (16 bpp), or null on error\n *\n *  Notes:\n *      (1) The pixel values in pixd label the area of the fg component\n *          to which the pixel belongs.  Pixels in the bg are labelled 0.\n *      (2) The pixel values cannot exceed 2^16 - 1, even if the area\n *          of the c.c. is larger.\n *      (3) For purposes of visualization, the output can be converted\n *          to 8 bpp, using pixConvert16To8() or pixMaxDynamicRange().\n */",
      "file" : "pixlabel.c"
   },
   {
      "function" : "pixConnCompBB",
      "comment" : "/*!\n *  pixConnCompBB()\n *\n *      Input:  pixs (1 bpp)\n *              connectivity (4 or 8)\n *      Return: boxa, or null on error\n *\n * Notes:\n *     (1) Finds bounding boxes of 4- or 8-connected components\n *         in a binary image.\n *     (2) This works on a copy of the input pix.  The c.c. are located\n *         in raster order and erased one at a time.  In the process,\n *         the b.b. is computed and saved.\n */",
      "file" : "conncomp.c"
   },
   {
      "function" : "pixConnCompPixa",
      "comment" : "/*!\n *  pixConnCompPixa()\n *\n *      Input:  pixs (1 bpp)\n *              &pixa (<return> pixa of each c.c.)\n *              connectivity (4 or 8)\n *      Return: boxa, or null on error\n *\n *  Notes:\n *      (1) This finds bounding boxes of 4- or 8-connected components\n *          in a binary image, and saves images of each c.c\n *          in a pixa array.\n *      (2) It sets up 2 temporary pix, and for each c.c. that is\n *          located in raster order, it erases the c.c. from one pix,\n *          then uses the b.b. to extract the c.c. from the two pix using\n *          an XOR, and finally erases the c.c. from the second pix.\n *      (3) A clone of the returned boxa (where all boxes in the array\n *          are clones) is inserted into the pixa.\n *      (4) If the input is valid, this always returns a boxa and a pixa.\n *          If pixs is empty, the boxa and pixa will be empty.\n */",
      "file" : "conncomp.c"
   },
   {
      "function" : "pixConnCompTransform",
      "comment" : "/*!\n *  pixConnCompTransform()\n *\n *      Input:   pixs (1 bpp)\n *               connect (connectivity: 4 or 8)\n *               depth (of pixd: 8 or 16 bpp; use 0 for auto determination)\n *      Return:  pixd (8 or 16 bpp), or null on error\n *\n *  Notes:\n *      (1) pixd is 8 or 16 bpp, and the pixel values label the fg component,\n *          starting with 1.  Pixels in the bg are labelled 0.\n *      (2) If @depth = 0, the depth of pixd is 8 if the number of c.c.\n *          is less than 254, and 16 otherwise.\n *      (3) If @depth = 8, the assigned label for the n-th component is\n *          1 + n % 254.  We use mod 254 because 0 is uniquely assigned\n *          to black: e.g., see pixcmapCreateRandom().  Likewise,\n *          if @depth = 16, the assigned label uses mod(2^16 - 2).\n */",
      "file" : "pixlabel.c"
   },
   {
      "function" : "pixContrastNorm",
      "comment" : "/*!\n *  pixContrastNorm()\n *\n *      Input:  pixd (<optional> 8 bpp; null or equal to pixs)\n *              pixs (8 bpp grayscale; not colormapped)\n *              sx, sy (tile dimensions)\n *              mindiff (minimum difference to accept as valid)\n *              smoothx, smoothy (half-width of convolution kernel applied to\n *                                min and max arrays: use 0 for no smoothing)\n *      Return: pixd always\n *\n *  Notes:\n *      (1) This function adaptively attempts to expand the contrast\n *          to the full dynamic range in each tile.  If the contrast in\n *          a tile is smaller than @mindiff, it uses the min and max\n *          pixel values from neighboring tiles.  It also can use\n *          convolution to smooth the min and max values from\n *          neighboring tiles.  After all that processing, it is\n *          possible that the actual pixel values in the tile are outside\n *          the computed [min ... max] range for local contrast\n *          normalization.  Such pixels are taken to be at either 0\n *          (if below the min) or 255 (if above the max).\n *      (2) pixd can be equal to pixs (in-place operation) or\n *          null (makes a new pixd).\n *      (3) sx and sy give the tile size; they are typically at least 20.\n *      (4) mindiff is used to eliminate results for tiles where it is\n *          likely that either fg or bg is missing.  A value around 50\n *          or more is reasonable.\n *      (5) The full width and height of the convolution kernel\n *          are (2 * smoothx + 1) and (2 * smoothy + 1).  Some smoothing\n *          is typically useful, and we limit the smoothing half-widths\n *          to the range from 0 to 8.\n *      (6) A linear TRC (gamma = 1.0) is applied to increase the contrast\n *          in each tile.  The result can subsequently be globally corrected,\n *          by applying pixGammaTRC() with arbitrary values of gamma\n *          and the 0 and 255 points of the mapping.\n */",
      "file" : "adaptmap.c"
   },
   {
      "function" : "pixContrastTRC",
      "comment" : "/*!\n *  pixContrastTRC()\n *\n *      Input:  pixd (<optional> null or equal to pixs)\n *              pixs (8 or 32 bpp; or 2, 4 or 8 bpp with colormap)\n *              factor  (0.0 is no enhancement)\n *      Return: pixd always\n *\n *  Notes:\n *      (1) pixd must either be null or equal to pixs.\n *          For in-place operation, set pixd == pixs:\n *             pixContrastTRC(pixs, pixs, ...);\n *          To get a new image, set pixd == null:\n *             pixd = pixContrastTRC(NULL, pixs, ...);\n *      (2) If pixs is colormapped, the colormap is transformed,\n *          either in-place or in a copy of pixs.\n *      (3) Contrast is enhanced by mapping each color component\n *          using an atan function with maximum slope at 127.\n *          Pixels below 127 are lowered in intensity and pixels\n *          above 127 are increased.\n *      (4) The useful range for the contrast factor is scaled to\n *          be in (0.0 to 1.0), but larger values can also be used.\n *      (5) If factor == 0.0, no enhancement is performed; return a copy\n *          unless in-place, in which case this is a no-op.\n *      (6) For color images that are not colormapped, the mapping\n *          is applied to each component.\n */",
      "file" : "enhance.c"
   },
   {
      "function" : "pixContrastTRCMasked",
      "comment" : "/*!\n *  pixContrastTRCMasked()\n *\n *      Input:  pixd (<optional> null or equal to pixs)\n *              pixs (8 or 32 bpp; or 2, 4 or 8 bpp with colormap)\n *              pixm (<optional> null or 1 bpp)\n *              factor  (0.0 is no enhancement)\n *      Return: pixd always\n *\n *  Notes:\n *      (1) Same as pixContrastTRC() except mapping is optionally over\n *          a subset of pixels described by pixm.\n *      (2) Masking does not work for colormapped images.\n *      (3) See pixContrastTRC() for details on how to use the parameters.\n */",
      "file" : "enhance.c"
   },
   {
      "function" : "pixConvert16To8",
      "comment" : "/*!\n *  pixConvert16To8()\n *\n *      Input:  pixs (16 bpp)\n *              type (L_LS_BYTE, L_MS_BYTE, L_CLIP_TO_255)\n *      Return: pixd (8 bpp), or null on error\n *\n *  Notes:\n *      (1) For each dest pixel, use either the LSB, the MSB, or the\n *          min(val, 255) for each 16-bit src pixel.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvert1To16",
      "comment" : "/*!\n *  pixConvert1To16()\n *\n *      Input:  pixd (<optional> 16 bpp, can be null)\n *              pixs (1 bpp)\n *              val0 (16 bit value to be used for 0s in pixs)\n *              val1 (16 bit value to be used for 1s in pixs)\n *      Return: pixd (16 bpp)\n *\n *  Notes:\n *      (1) If pixd is null, a new pix is made.\n *      (2) If pixd is not null, it must be of equal width and height\n *          as pixs.  It is always returned.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvert1To2",
      "comment" : "/*!\n *  pixConvert1To2()\n *\n *      Input:  pixd (<optional> 2 bpp, can be null)\n *              pixs (1 bpp)\n *              val0 (2 bit value to be used for 0s in pixs)\n *              val1 (2 bit value to be used for 1s in pixs)\n *      Return: pixd (2 bpp)\n *\n *  Notes:\n *      (1) If pixd is null, a new pix is made.\n *      (2) If pixd is not null, it must be of equal width and height\n *          as pixs.  It is always returned.\n *      (3) A simple unpacking might use val0 = 0 and val1 = 3.\n *      (4) If you want a colormapped pixd, use pixConvert1To2Cmap().\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvert1To2Cmap",
      "comment" : "/*!\n *  pixConvert1To2Cmap()\n *\n *      Input:  pixs (1 bpp)\n *      Return: pixd (2 bpp, cmapped)\n *\n *  Notes:\n *      (1) Input 0 is mapped to (255, 255, 255); 1 is mapped to (0, 0, 0)\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvert1To32",
      "comment" : "/*!\n *  pixConvert1To32()\n *\n *      Input:  pixd (<optional> 32 bpp, can be null)\n *              pixs (1 bpp)\n *              val0 (32 bit value to be used for 0s in pixs)\n *              val1 (32 bit value to be used for 1s in pixs)\n *      Return: pixd (32 bpp)\n *\n *  Notes:\n *      (1) If pixd is null, a new pix is made.\n *      (2) If pixd is not null, it must be of equal width and height\n *          as pixs.  It is always returned.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvert1To4",
      "comment" : "/*!\n *  pixConvert1To4()\n *\n *      Input:  pixd (<optional> 4 bpp, can be null)\n *              pixs (1 bpp)\n *              val0 (4 bit value to be used for 0s in pixs)\n *              val1 (4 bit value to be used for 1s in pixs)\n *      Return: pixd (4 bpp)\n *\n *  Notes:\n *      (1) If pixd is null, a new pix is made.\n *      (2) If pixd is not null, it must be of equal width and height\n *          as pixs.  It is always returned.\n *      (3) A simple unpacking might use val0 = 0 and val1 = 15, or v.v.\n *      (4) If you want a colormapped pixd, use pixConvert1To4Cmap().\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvert1To4Cmap",
      "comment" : "/*!\n *  pixConvert1To4Cmap()\n *\n *      Input:  pixs (1 bpp)\n *      Return: pixd (4 bpp, cmapped)\n *\n *  Notes:\n *      (1) Input 0 is mapped to (255, 255, 255); 1 is mapped to (0, 0, 0)\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvert1To8",
      "comment" : "/*!\n *  pixConvert1To8()\n *\n *      Input:  pixd (<optional> 8 bpp, can be null)\n *              pixs (1 bpp)\n *              val0 (8 bit value to be used for 0s in pixs)\n *              val1 (8 bit value to be used for 1s in pixs)\n *      Return: pixd (8 bpp)\n *\n *  Notes:\n *      (1) If pixd is null, a new pix is made.\n *      (2) If pixd is not null, it must be of equal width and height\n *          as pixs.  It is always returned.\n *      (3) A simple unpacking might use val0 = 0 and val1 = 255, or v.v.\n *      (4) In a typical application where one wants to use a colormap\n *          with the dest, you can use val0 = 0, val1 = 1 to make a\n *          non-cmapped 8 bpp pix, and then make a colormap and set 0\n *          and 1 to the desired colors.  Here is an example:\n *             pixd = pixConvert1To8(NULL, pixs, 0, 1);\n *             cmap = pixCreate(8);\n *             pixcmapAddColor(cmap, 255, 255, 255);\n *             pixcmapAddColor(cmap, 0, 0, 0);\n *             pixSetColormap(pixd, cmap);\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvert24To32",
      "comment" : "/*!\n *  pixConvert24To32()\n *\n *      Input:  pixs (24 bpp rgb)\n *      Return: pixd (32 bpp rgb), or null on error\n *\n *  Notes:\n *      (1) 24 bpp rgb pix are not supported in leptonica, except for a small\n *          number of formatted write operations.  The data is a byte array,\n *          with pixels in order r,g,b, and padded to 32 bit boundaries\n *          in each line.\n *      (2) Because 24 bpp rgb pix are conveniently generated by programs\n *          such as xpdf (which has SplashBitmaps that store the raster\n *          data in consecutive 24-bit rgb pixels), it is useful to provide\n *          24 bpp pix that simply incorporate that data.  The only things\n *          we can do with these are:\n *            (a) write them to file in png, jpeg, tiff and pnm\n *            (b) interconvert between 24 and 32 bpp in memory (for testing).\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvert2To8",
      "comment" : "/*!\n *  pixConvert2To8()\n *\n *      Input:  pixs (2 bpp)\n *              val0 (8 bit value to be used for 00 in pixs)\n *              val1 (8 bit value to be used for 01 in pixs)\n *              val2 (8 bit value to be used for 10 in pixs)\n *              val3 (8 bit value to be used for 11 in pixs)\n *              cmapflag (TRUE if pixd is to have a colormap; FALSE otherwise)\n *      Return: pixd (8 bpp), or null on error\n *\n *  Notes:\n *      - A simple unpacking might use val0 = 0,\n *        val1 = 85 (0x55), val2 = 170 (0xaa), val3 = 255.\n *      - If cmapflag is TRUE:\n *          - The 8 bpp image is made with a colormap.\n *          - If pixs has a colormap, the input values are ignored and\n *            the 8 bpp image is made using the colormap\n *          - If pixs does not have a colormap, the input values are\n *            used to build the colormap.\n *      - If cmapflag is FALSE:\n *          - The 8 bpp image is made without a colormap.\n *          - If pixs has a colormap, the input values are ignored,\n *            the colormap is removed, and the values stored in the 8 bpp\n *            image are from the colormap.\n *          - If pixs does not have a colormap, the input values are\n *            used to populate the 8 bpp image.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvert32To24",
      "comment" : "/*!\n *  pixConvert32To24()\n *\n *      Input:  pixs (32 bpp rgb)\n *      Return: pixd (24 bpp rgb), or null on error\n *\n *  Notes:\n *      (1) See pixconvert24To32().\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvert4To8",
      "comment" : "/*!\n *  pixConvert4To8()\n *\n *      Input:  pixs (4 bpp)\n *              cmapflag (TRUE if pixd is to have a colormap; FALSE otherwise)\n *      Return: pixd (8 bpp), or null on error\n *\n *  Notes:\n *      - If cmapflag is TRUE:\n *          - pixd is made with a colormap.\n *          - If pixs has a colormap, it is copied and the colormap\n *            index values are placed in pixd.\n *          - If pixs does not have a colormap, a colormap with linear\n *            trc is built and the pixel values in pixs are placed in\n *            pixd as colormap index values.\n *      - If cmapflag is FALSE:\n *          - pixd is made without a colormap.\n *          - If pixs has a colormap, it is removed and the values stored\n *            in pixd are from the colormap (converted to gray).\n *          - If pixs does not have a colormap, the pixel values in pixs\n *            are used, with shift replication, to populate pixd.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvert8To16",
      "comment" : "/*!\n *  pixConvert8To16()\n *\n *      Input:  pixs (8 bpp; colormap removed to gray)\n *              leftshift (number of bits: 0 is no shift;\n *                         8 replicates in MSB and LSB of dest)\n *      Return: pixd (16 bpp), or null on error\n *\n *  Notes:\n *      (1) For left shift of 8, the 8 bit value is replicated in both\n *          the MSB and the LSB of the pixels in pixd.  That way, we get\n *          proportional mapping, with a correct map from 8 bpp white\n *          (0xff) to 16 bpp white (0xffff).\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvert8To32",
      "comment" : "/*!\n *  pixConvert8To32()\n *\n *      Input:  pix (8 bpp)\n *      Return: 32 bpp rgb pix, or null on error\n *\n *  Notes:\n *      (1) If there is no colormap, replicates the gray value\n *          into the 3 MSB of the dest pixel.\n *      (2) Implicit assumption about RGB component ordering.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvertColorToSubpixelRGB",
      "comment" : "/*!\n *  pixConvertColorToSubpixelRGB()\n *\n *      Input:  pixs (32 bpp or colormapped)\n *              scalex, scaley\n *              order (of subpixel rgb color components in composition of pixd:\n *                     L_SUBPIXEL_ORDER_RGB, L_SUBPIXEL_ORDER_BGR,\n *                     L_SUBPIXEL_ORDER_VRGB, L_SUBPIXEL_ORDER_VBGR)\n *\n *      Return: pixd (32 bpp), or null on error\n *\n *  Notes:\n *      (1) If pixs has a colormap, it is removed to 32 bpp rgb.\n *          If the colormap has no color, pixConvertGrayToSubpixelRGB()\n *          should be called instead, because it will give the same result\n *          more efficiently.  The function pixConvertToSubpixelRGB()\n *          will do the best thing for all cases.\n *      (2) For horizontal subpixel splitting, the input rgb image\n *          is rescaled by @scaley vertically and by 3.0 times\n *          @scalex horizontally.  Then for each horizontal triplet\n *          of pixels, the r component of the final pixel is selected\n *          from the r component of the appropriate pixel in the triplet,\n *          and likewise for g and b.  Vertical subpixel splitting is\n *          handled similarly.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvertForPSWrap",
      "comment" : "/*!\n *  pixConvertForPSWrap()\n *\n *      Input:  pixs (1, 2, 4, 8, 16, 32 bpp)\n *      Return: pixd (1, 8, or 32 bpp), or null on error\n *\n *  Notes:\n *      (1) For wrapping in PostScript, we convert pixs to\n *          1 bpp, 8 bpp (gray) and 32 bpp (RGB color).\n *      (2) Colormaps are removed.  For pixs with colormaps, the\n *          images are converted to either 8 bpp gray or 32 bpp\n *          RGB, depending on whether the colormap has color content.\n *      (3) Images without colormaps, that are not 1 bpp or 32 bpp,\n *          are converted to 8 bpp gray.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvertGrayToColormap",
      "comment" : "/*!\n *  pixConvertGrayToColormap()\n *\n *      Input:  pixs (2, 4 or 8 bpp grayscale)\n *      Return: pixd (2, 4 or 8 bpp with colormap), or null on error\n *\n *  Notes:\n *      (1) This is a simple interface for adding a colormap to a\n *          2, 4 or 8 bpp grayscale image without causing any\n *          quantization.  There is some similarity to operations\n *          in grayquant.c, such as pixThresholdOn8bpp(), where\n *          the emphasis is on quantization with an arbitrary number\n *          of levels, and a colormap is an option.\n *      (2) Returns a copy if pixs already has a colormap.\n *      (3) For 8 bpp src, this is a lossless transformation.\n *      (4) For 2 and 4 bpp src, this generates a colormap that\n *          assumes full coverage of the gray space, with equally spaced\n *          levels: 4 levels for d = 2 and 16 levels for d = 4.\n *      (5) In all cases, the depth of the dest is the same as the src.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvertGrayToColormap8",
      "comment" : "/*!\n *  pixConvertGrayToColormap8()\n *\n *      Input:  pixs (8 bpp grayscale)\n *              mindepth (of pixd; valid values are 2, 4 and 8)\n *      Return: pixd (2, 4 or 8 bpp with colormap), or null on error\n *\n *  Notes:\n *      (1) Returns a copy if pixs already has a colormap.\n *      (2) This is a lossless transformation; there is no quantization.\n *          We compute the number of different gray values in pixs,\n *          and construct a colormap that has exactly these values.\n *      (3) 'mindepth' is the minimum depth of pixd.  If mindepth == 8,\n *          pixd will always be 8 bpp.  Let the number of different\n *          gray values in pixs be ngray.  If mindepth == 4, we attempt\n *          to save pixd as a 4 bpp image, but if ngray > 16,\n *          pixd must be 8 bpp.  Likewise, if mindepth == 2,\n *          the depth of pixd will be 2 if ngray <= 4 and 4 if ngray > 4\n *          but <= 16.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvertGrayToFalseColor",
      "comment" : "/*!\n *  pixConvertGrayToFalseColor()\n *\n *      Input:  pixs (8 or 16 bpp grayscale)\n *              gamma factor (0.0 or 1.0 for default; > 1.0 for brighter;\n *                            2.0 is quite nice)\n *      Return: pixd (8 bpp with colormap), or null on error\n *\n *  Notes:\n *      (1) For 8 bpp input, this simply adds a colormap to the input image.\n *      (2) For 16 bpp input, it first converts to 8 bpp, using the MSB,\n *          and then adds the colormap.\n *      (3) The colormap is modeled after the Matlab \"jet\" configuration.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvertGrayToSubpixelRGB",
      "comment" : "/*!\n *  pixConvertGrayToSubpixelRGB()\n *\n *      Input:  pixs (8 bpp or colormapped)\n *              scalex, scaley\n *              order (of subpixel rgb color components in composition of pixd:\n *                     L_SUBPIXEL_ORDER_RGB, L_SUBPIXEL_ORDER_BGR,\n *                     L_SUBPIXEL_ORDER_VRGB, L_SUBPIXEL_ORDER_VBGR)\n *\n *      Return: pixd (32 bpp), or null on error\n *\n *  Notes:\n *      (1) If pixs has a colormap, it is removed to 8 bpp.\n *      (2) For horizontal subpixel splitting, the input gray image\n *          is rescaled by @scaley vertically and by 3.0 times\n *          @scalex horizontally.  Then each horizontal triplet\n *          of pixels is mapped back to a single rgb pixel, with the\n *          r, g and b values being assigned from the triplet of gray values.\n *          Similar operations are used for vertical subpixel splitting.\n *      (3) This is a form of subpixel rendering that tends to give the\n *          resulting text a sharper and somewhat chromatic display.\n *          For horizontal subpixel splitting, the observable difference\n *          between @order=L_SUBPIXEL_ORDER_RGB and\n *          @order=L_SUBPIXEL_ORDER_BGR is reduced by optical diffusers\n *          in the display that make the pixel color appear to emerge\n *          from the entire pixel.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvertHSVToRGB",
      "comment" : "/*!\n *  pixConvertHSVToRGB()\n *\n *      Input:  pixd (can be NULL; if not NULL, must == pixs)\n *              pixs\n *      Return: pixd always\n *\n *  Notes:\n *      (1) For pixs = pixd, this is in-place; otherwise pixd must be NULL.\n *      (2) The user takes responsibility for making sure that pixs is\n *          in our HSV space.  The definition of our HSV space is given\n *          in convertRGBToHSV().\n *      (3) The h, s and v values are stored in the same places as\n *          the r, g and b values, respectively.  Here, they are explicitly\n *          placed in the 3 MS bytes in the pixel.\n */",
      "file" : "colorspace.c"
   },
   {
      "function" : "pixConvertLossless",
      "comment" : "/*!\n *  pixConvertLossless()\n *\n *      Input:  pixs (1, 2, 4, 8 bpp, not cmapped)\n *              d (destination depth: 2, 4 or 8)\n *      Return: pixd (2, 4 or 8 bpp), or null on error\n *\n *  Notes:\n *      (1) This is a lossless unpacking (depth-increasing)\n *          conversion.  If ds is the depth of pixs, then\n *           - if d < ds, returns NULL\n *           - if d == ds, returns a copy\n *           - if d > ds, does the unpacking conversion\n *      (2) If pixs has a colormap, this is an error.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvertRGBToColormap",
      "comment" : "/*!\n *  pixConvertRGBToColormap()\n *\n *      Input:  pixs (32 bpp rgb)\n *              ditherflag (1 to dither, 0 otherwise)\n *      Return: pixd (2, 4 or 8 bpp with colormap), or null on error\n *\n *  Notes:\n *      (1) This function has two relatively simple modes of color\n *          quantization:\n *            (a) If the image is made orthographically and has not more\n *                than 256 'colors' at the level 4 octcube leaves,\n *                it is quantized nearly exactly.  The ditherflag\n *                is ignored.\n *            (b) Most natural images have more than 256 different colors;\n *                in that case we use adaptive octree quantization,\n *                with dithering if requested.\n *      (2) If there are not more than 256 occupied level 4 octcubes,\n *          the color in the colormap that represents all pixels in\n *          one of those octcubes is given by the first pixel that\n *          falls into that octcube.\n *      (3) If there are more than 256 colors, we use adaptive octree\n *          color quantization.\n *      (4) Dithering gives better visual results on images where\n *          there is a color wash (a slow variation of color), but it\n *          is about twice as slow and results in significantly larger\n *          files when losslessly compressed (e.g., into png).\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvertRGBToGray",
      "comment" : "/*!\n *  pixConvertRGBToGray()\n *\n *      Input:  pix (32 bpp RGB)\n *              rwt, gwt, bwt  (non-negative; these should add to 1.0,\n *                              or use 0.0 for default)\n *      Return: 8 bpp pix, or null on error\n *\n *  Notes:\n *      (1) Use a weighted average of the RGB values.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvertRGBToGrayFast",
      "comment" : "/*!\n *  pixConvertRGBToGrayFast()\n *\n *      Input:  pix (32 bpp RGB)\n *      Return: 8 bpp pix, or null on error\n *\n *  Notes:\n *      (1) This function should be used if speed of conversion\n *          is paramount, and the green channel can be used as\n *          a fair representative of the RGB intensity.  It is\n *          several times faster than pixConvertRGBToGray().\n *      (2) To combine RGB to gray conversion with subsampling,\n *          use pixScaleRGBToGrayFast() instead.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvertRGBToGrayMinMax",
      "comment" : "/*!\n *  pixConvertRGBToGrayMinMax()\n *\n *      Input:  pix (32 bpp RGB)\n *              type (L_CHOOSE_MIN or L_CHOOSE_MAX)\n *      Return: 8 bpp pix, or null on error\n *\n *  Notes:\n *      (1) This chooses either the min or the max of the three\n *          RGB sample values.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvertRGBToGraySatBoost",
      "comment" : "/*!\n *  pixConvertRGBToGraySatBoost()\n *\n *      Input:  pixs (32 bpp rgb)\n *              refval (between 1 and 255; typ. less than 128)\n *      Return: pixd (8 bpp), or null on error\n *\n *  Notes:\n *      (1) This returns the max component value, boosted by\n *          the saturation. The maximum boost occurs where\n *          the maximum component value is equal to some reference value.\n *          This particular weighting is due to Dany Qumsiyeh.\n *      (2) For gray pixels (zero saturation), this returns\n *          the intensity of any component.\n *      (3) For fully saturated pixels ('fullsat'), this rises linearly\n *          with the max value and has a slope equal to 255 divided\n *          by the reference value; for a max value greater than\n *          the reference value, it is clipped to 255.\n *      (4) For saturation values in between, the output is a linear\n *          combination of (2) and (3), weighted by saturation.\n *          It falls between these two curves, and does not exceed 255.\n *      (5) This can be useful for distinguishing an object that has nonzero\n *          saturation from a gray background.  For this, the refval\n *          should be chosen near the expected value of the background,\n *          to achieve maximum saturation boost there.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvertRGBToHSV",
      "comment" : "/*!\n *  pixConvertRGBToHSV()\n *\n *      Input:  pixd (can be NULL; if not NULL, must == pixs)\n *              pixs\n *      Return: pixd always\n *\n *  Notes:\n *      (1) For pixs = pixd, this is in-place; otherwise pixd must be NULL.\n *      (2) The definition of our HSV space is given in convertRGBToHSV().\n *      (3) The h, s and v values are stored in the same places as\n *          the r, g and b values, respectively.  Here, they are explicitly\n *          placed in the 3 MS bytes in the pixel.\n *      (4) Normalizing to 1 and considering the r,g,b components,\n *          a simple way to understand the HSV space is:\n *           - v = max(r,g,b)\n *           - s = (max - min) / max\n *           - h ~ (mid - min) / (max - min)  [apart from signs and constants]\n *      (5) Normalizing to 1, some properties of the HSV space are:\n *           - For gray values (r = g = b) along the continuum between\n *             black and white:\n *                s = 0  (becoming undefined as you approach black)\n *                h is undefined everywhere\n *           - Where one component is saturated and the others are zero:\n *                v = 1\n *                s = 1\n *                h = 0 (r = max), 1/3 (g = max), 2/3 (b = max)\n *           - Where two components are saturated and the other is zero:\n *                v = 1\n *                s = 1\n *                h = 1/2 (if r = 0), 5/6 (if g = 0), 1/6 (if b = 0)\n */",
      "file" : "colorspace.c"
   },
   {
      "function" : "pixConvertRGBToHue",
      "comment" : "/*!\n *  pixConvertRGBToHue()\n *\n *      Input:  pixs (32 bpp RGB or 8 bpp with colormap)\n *      Return: pixd (8 bpp hue of HSV), or null on error\n *\n *  Notes:\n *      (1) The conversion to HSV hue is in-lined here.\n *      (2) If there is a colormap, it is removed.\n *      (3) If you just want the hue component, this does it\n *          at about 10 Mpixels/sec/GHz, which is about\n *          2x faster than using pixConvertRGBToHSV()\n */",
      "file" : "colorspace.c"
   },
   {
      "function" : "pixConvertRGBToLuminance",
      "comment" : "/*!\n *  pixConvertRGBToLuminance()\n *\n *      Input:  pix (32 bpp RGB)\n *      Return: 8 bpp pix, or null on error\n *\n *  Notes:\n *      (1) Use a standard luminance conversion.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvertRGBToSaturation",
      "comment" : "/*!\n *  pixConvertRGBToSaturation()\n *\n *      Input:  pixs (32 bpp RGB or 8 bpp with colormap)\n *      Return: pixd (8 bpp sat of HSV), or null on error\n *\n *  Notes:\n *      (1) The conversion to HSV sat is in-lined here.\n *      (2) If there is a colormap, it is removed.\n *      (3) If you just want the saturation component, this does it\n *          at about 12 Mpixels/sec/GHz.\n */",
      "file" : "colorspace.c"
   },
   {
      "function" : "pixConvertRGBToValue",
      "comment" : "/*!\n *  pixConvertRGBToValue()\n *\n *      Input:  pixs (32 bpp RGB or 8 bpp with colormap)\n *      Return: pixd (8 bpp max component intensity of HSV), or null on error\n *\n *  Notes:\n *      (1) The conversion to HSV sat is in-lined here.\n *      (2) If there is a colormap, it is removed.\n *      (3) If you just want the value component, this does it\n *          at about 35 Mpixels/sec/GHz.\n */",
      "file" : "colorspace.c"
   },
   {
      "function" : "pixConvertRGBToYUV",
      "comment" : "/*!\n *  pixConvertRGBToYUV()\n *\n *      Input:  pixd (can be NULL; if not NULL, must == pixs)\n *              pixs\n *      Return: pixd always\n *\n *  Notes:\n *      (1) For pixs = pixd, this is in-place; otherwise pixd must be NULL.\n *      (2) The Y, U and V values are stored in the same places as\n *          the r, g and b values, respectively.  Here, they are explicitly\n *          placed in the 3 MS bytes in the pixel.\n *      (3) Normalizing to 1 and considering the r,g,b components,\n *          a simple way to understand the YUV space is:\n *           - Y = weighted sum of (r,g,b)\n *           - U = weighted difference between Y and B\n *           - V = weighted difference between Y and R\n *      (4) Following video conventions, Y, U and V are in the range:\n *             Y: [16, 235]\n *             U: [16, 240]\n *             V: [16, 240]\n *      (5) For the coefficients in the transform matrices, see eq. 4 in\n *          \"Frequently Asked Questions about Color\" by Charles Poynton,\n *          http://www.poynton.com/notes/colour_and_gamma/ColorFAQ.html\n */",
      "file" : "colorspace.c"
   },
   {
      "function" : "pixConvertTo1",
      "comment" : "/*!\n *  pixConvertTo1()\n *\n *      Input:  pixs (1, 2, 4, 8, 16 or 32 bpp)\n *              threshold (for final binarization, relative to 8 bpp)\n *      Return: pixd (1 bpp), or null on error\n *\n *  Notes:\n *      (1) This is a top-level function, with simple default values\n *          used in pixConvertTo8() if unpacking is necessary.\n *      (2) Any existing colormap is removed.\n *      (3) If the input image has 1 bpp and no colormap, the operation is\n *          lossless and a copy is returned.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvertTo16",
      "comment" : "/*!\n *  pixConvertTo16()\n *\n *      Input:  pixs (1, 8 bpp)\n *      Return: pixd (16 bpp), or null on error\n *\n *  Usage: Top-level function, with simple default values for unpacking.\n *      1 bpp:  val0 = 0xffff, val1 = 0\n *      8 bpp:  replicates the 8 bit value in both the MSB and LSB\n *              of the 16 bit pixel.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvertTo1BySampling",
      "comment" : "/*!\n *  pixConvertTo1BySampling()\n *\n *      Input:  pixs (1, 2, 4, 8, 16 or 32 bpp)\n *              factor (submsampling factor; integer >= 1)\n *              threshold (for final binarization, relative to 8 bpp)\n *      Return: pixd (1 bpp), or null on error\n *\n *  Notes:\n *      (1) This is a fast, quick/dirty, top-level converter.\n *      (2) See pixConvertTo1() for default values.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvertTo32",
      "comment" : "/*!\n *  pixConvertTo32()\n *\n *      Input:  pixs (1, 2, 4, 8, 16 or 32 bpp)\n *      Return: pixd (32 bpp), or null on error\n *\n *  Usage: Top-level function, with simple default values for unpacking.\n *      1 bpp:  val0 = 255, val1 = 0\n *              and then replication into R, G and B components\n *      2 bpp:  if colormapped, use the colormap values; otherwise,\n *              use val0 = 0, val1 = 0x55, val2 = 0xaa, val3 = 255\n *              and replicate gray into R, G and B components\n *      4 bpp:  if colormapped, use the colormap values; otherwise,\n *              replicate 2 nybs into a byte, and then into R,G,B components\n *      8 bpp:  if colormapped, use the colormap values; otherwise,\n *              replicate gray values into R, G and B components\n *      16 bpp: replicate MSB into R, G and B components\n *      24 bpp: unpack the pixels, maintaining word alignment on each scanline\n *      32 bpp: makes a copy\n *\n *  Notes:\n *      (1) Never returns a clone of pixs.\n *      (2) Implicit assumption about RGB component ordering.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvertTo32BySampling",
      "comment" : "/*!\n *  pixConvertTo32BySampling()\n *\n *      Input:  pixs (1, 2, 4, 8, 16 or 32 bpp)\n *              factor (submsampling factor; integer >= 1)\n *      Return: pixd (32 bpp), or null on error\n *\n *  Notes:\n *      (1) This is a fast, quick/dirty, top-level converter.\n *      (2) See pixConvertTo32() for default values.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvertTo8",
      "comment" : "/*!\n *  pixConvertTo8()\n *\n *      Input:  pixs (1, 2, 4, 8, 16 or 32 bpp)\n *              cmapflag (TRUE if pixd is to have a colormap; FALSE otherwise)\n *      Return: pixd (8 bpp), or null on error\n *\n *  Notes:\n *      (1) This is a top-level function, with simple default values\n *          for unpacking.\n *      (2) The result, pixd, is made with a colormap if specified.\n *          It is always a new image -- never a clone.  For example,\n *          if d == 8, and cmapflag matches the existence of a cmap\n *          in pixs, the operation is lossless and it returns a copy.\n *      (3) The default values used are:\n *          - 1 bpp: val0 = 255, val1 = 0\n *          - 2 bpp: 4 bpp:  even increments over dynamic range\n *          - 8 bpp: lossless if cmap matches cmapflag\n *          - 16 bpp: use most significant byte\n *      (4) If 32 bpp RGB, this is converted to gray.  If you want\n *          to do color quantization, you must specify the type\n *          explicitly, using the color quantization code.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvertTo8BySampling",
      "comment" : "/*!\n *  pixConvertTo8BySampling()\n *\n *      Input:  pixs (1, 2, 4, 8, 16 or 32 bpp)\n *              factor (submsampling factor; integer >= 1)\n *              cmapflag (TRUE if pixd is to have a colormap; FALSE otherwise)\n *      Return: pixd (8 bpp), or null on error\n *\n *  Notes:\n *      (1) This is a fast, quick/dirty, top-level converter.\n *      (2) See pixConvertTo8() for default values.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvertTo8Color",
      "comment" : "/*!\n *  pixConvertTo8Color()\n *\n *      Input:  pixs (1, 2, 4, 8, 16 or 32 bpp)\n *              dither (1 to dither if necessary; 0 otherwise)\n *      Return: pixd (8 bpp, cmapped), or null on error\n *\n *  Notes:\n *      (1) This is a top-level function, with simple default values\n *          for unpacking.\n *      (2) The result, pixd, is always made with a colormap.\n *      (3) If d == 8, the operation is lossless and it returns a copy.\n *      (4) The default values used for increasing depth are:\n *          - 1 bpp: val0 = 255, val1 = 0\n *          - 2 bpp: 4 bpp:  even increments over dynamic range\n *      (5) For 16 bpp, use the most significant byte.\n *      (6) For 32 bpp RGB, use octcube quantization with optional dithering.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvertTo8Or32",
      "comment" : "/*!\n *  pixConvertTo8Or32()\n *\n *      Input:  pixs (1, 2, 4, 8, 16, with or without colormap; or 32 bpp rgb)\n *              copyflag (use 0 to return clone if pixs does not need to\n *                         be changed; 1 to return a copy in those situations)\n *              warnflag (1 to issue warning if colormap is removed; else 0)\n *      Return: pixd (8 bpp grayscale or 32 bpp rgb), or null on error\n *\n *  Notes:\n *      (1) If there is a colormap, the colormap is removed to 8 or 32 bpp,\n *          depending on whether the colors in the colormap are all gray.\n *      (2) If the input is either rgb or 8 bpp without a colormap,\n *          this returns either a clone or a copy, depending on @copyflag.\n *      (3) Otherwise, the pix is converted to 8 bpp grayscale.\n *          In all cases, pixd does not have a colormap.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvertToDPix",
      "comment" : "/*!\n *  pixConvertToDPix()\n *\n *      Input:  pix (1, 2, 4, 8, 16 or 32 bpp)\n *              ncomps (number of components: 3 for RGB, 1 otherwise)\n *      Return: dpix, or null on error\n *\n *  Notes:\n *      (1) If colormapped, remove to grayscale.\n *      (2) If 32 bpp and @ncomps == 3, this is RGB; convert to luminance.\n *          In all other cases the src image is treated as having a single\n *          component of pixel values.\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "pixConvertToFPix",
      "comment" : "/*!\n *  pixConvertToFPix()\n *\n *      Input:  pix (1, 2, 4, 8, 16 or 32 bpp)\n *              ncomps (number of components: 3 for RGB, 1 otherwise)\n *      Return: fpix, or null on error\n *\n *  Notes:\n *      (1) If colormapped, remove to grayscale.\n *      (2) If 32 bpp and @ncomps == 3, this is RGB; convert to luminance.\n *          In all other cases the src image is treated as having a single\n *          component of pixel values.\n */",
      "file" : "fpix2.c"
   },
   {
      "function" : "pixConvertToPdf",
      "comment" : "/*!\n *  pixConvertToPdf()\n *\n *      Input:  pix\n *              type (L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE)\n *              quality (used for JPEG only; 0 for default (75))\n *              fileout (output pdf file; only required on last image on page)\n *              x, y (location of lower-left corner of image, in pixels,\n *                    relative to the PostScript origin (0,0) at\n *                    the lower-left corner of the page)\n *              res (override the resolution of the input image, in ppi;\n *                   use 0 to respect the resolution embedded in the input)\n *              title (<optional> pdf title)\n *              &lpd (ptr to lpd, which is created on the first invocation\n *                    and returned until last image is processed)\n *              position (in image sequence: L_FIRST_IMAGE, L_NEXT_IMAGE,\n *                       L_LAST_IMAGE)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If @res == 0 and the input resolution field is 0,\n *          this will use DEFAULT_INPUT_RES.\n *      (2) This only writes data to fileout if it is the last\n *          image to be written on the page.\n *      (3) See comments in convertToPdf().\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "pixConvertToPdfData",
      "comment" : "/*!\n *  pixConvertToPdfData()\n *\n *      Input:  pix (all depths; cmap OK)\n *              type (L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE)\n *              quality (used for JPEG only; 0 for default (75))\n *              &data (<return> pdf array)\n *              &nbytes (<return> number of bytes in pdf array)\n *              x, y (location of lower-left corner of image, in pixels,\n *                    relative to the PostScript origin (0,0) at\n *                    the lower-left corner of the page)\n *              res (override the resolution of the input image, in ppi;\n *                   use 0 to respect the resolution embedded in the input)\n *              title (<optional> pdf title)\n *              &lpd (ptr to lpd, which is created on the first invocation\n *                    and returned until last image is processed)\n *              position (in image sequence: L_FIRST_IMAGE, L_NEXT_IMAGE,\n *                       L_LAST_IMAGE)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If @res == 0 and the input resolution field is 0,\n *          this will use DEFAULT_INPUT_RES.\n *      (2) This only writes @data if it is the last image to be\n *          written on the page.\n *      (3) See comments in convertToPdf().\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "pixConvertToPdfDataSegmented",
      "comment" : "/*!\n *  pixConvertToPdfDataSegmented()\n *\n *      Input:  pixs (any depth, cmap OK)\n *              res (input image resolution; typ. 300 ppi; use 0 for default)\n *              type (compression type for non-image regions; the\n *                    image regions are always compressed with L_JPEG_ENCODE)\n *              thresh (used for converting gray --> 1 bpp with L_G4_ENCODE)\n *              boxa (<optional> of image regions; can be null)\n *              quality (used for jpeg image regions; 0 for default)\n *              scalefactor (used for jpeg regions; must be <= 1.0)\n *              title (<optional> pdf title; typically taken from the\n *                     input file for the pix)\n *              &data (<return> pdf data in memory)\n *              &nbytes (<return> number of bytes in pdf data)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) See convertToPdfSegmented() for details.\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "pixConvertToPdfSegmented",
      "comment" : "/*!\n *  pixConvertToPdfSegmented()\n *\n *      Input:  pixs (any depth, cmap OK)\n *              res (input image resolution; typ. 300 ppi; use 0 for default)\n *              type (compression type for non-image regions; the\n *                    image regions are always compressed with L_JPEG_ENCODE)\n *              thresh (used for converting gray --> 1 bpp with L_G4_ENCODE)\n *              boxa (<optional> of image regions; can be null)\n *              quality (used for jpeg image regions; 0 for default)\n *              scalefactor (used for jpeg regions; must be <= 1.0)\n *              title (<optional> pdf title; typically taken from the\n *                     input file for the pix)\n *              fileout (output pdf file)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) See convertToPdfSegmented() for details.\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "pixConvertToSubpixelRGB",
      "comment" : "/*!\n *  pixConvertToSubpixelRGB()\n *\n *      Input:  pixs (8 bpp grayscale, 32 bpp rgb, or colormapped)\n *              scalex, scaley (anisotropic scaling permitted between\n *                              source and destination)\n *              order (of subpixel rgb color components in composition of pixd:\n *                     L_SUBPIXEL_ORDER_RGB, L_SUBPIXEL_ORDER_BGR,\n *                     L_SUBPIXEL_ORDER_VRGB, L_SUBPIXEL_ORDER_VBGR)\n *\n *      Return: pixd (32 bpp), or null on error\n *\n *  Notes:\n *      (1) If pixs has a colormap, it is removed based on its contents\n *          to either 8 bpp gray or rgb.\n *      (2) For horizontal subpixel splitting, the input image\n *          is rescaled by @scaley vertically and by 3.0 times\n *          @scalex horizontally.  Then each horizontal triplet\n *          of pixels is mapped back to a single rgb pixel, with the\n *          r, g and b values being assigned based on the pixel triplet.\n *          For gray triplets, the r, g, and b values are set equal to\n *          the three gray values.  For color triplets, the r, g and b\n *          values are set equal to the components from the appropriate\n *          subpixel.  Vertical subpixel splitting is handled similarly.\n *      (3) See pixConvertGrayToSubpixelRGB() and\n *          pixConvertColorToSubpixelRGB() for further details.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixConvertYUVToRGB",
      "comment" : "/*!\n *  pixConvertYUVToRGB()\n *\n *      Input:  pixd (can be NULL; if not NULL, must == pixs)\n *              pixs\n *      Return: pixd always\n *\n *  Notes:\n *      (1) For pixs = pixd, this is in-place; otherwise pixd must be NULL.\n *      (2) The user takes responsibility for making sure that pixs is\n *          in YUV space.\n *      (3) The Y, U and V values are stored in the same places as\n *          the r, g and b values, respectively.  Here, they are explicitly\n *          placed in the 3 MS bytes in the pixel.\n */",
      "file" : "colorspace.c"
   },
   {
      "function" : "pixConvolve",
      "comment" : "/*!\n *  pixConvolve()\n *\n *      Input:  pixs (8, 16, 32 bpp; no colormap)\n *              kernel\n *              outdepth (of pixd: 8, 16 or 32)\n *              normflag (1 to normalize kernel to unit sum; 0 otherwise)\n *      Return: pixd (8, 16 or 32 bpp)\n *\n *  Notes:\n *      (1) This gives a convolution with an arbitrary kernel.\n *      (2) The input pixs must have only one sample/pixel.\n *          To do a convolution on an RGB image, use pixConvolveRGB().\n *      (3) The parameter @outdepth determines the depth of the result.\n *          If the kernel is normalized to unit sum, the output values\n *          can never exceed 255, so an output depth of 8 bpp is sufficient.\n *          If the kernel is not normalized, it may be necessary to use\n *          16 or 32 bpp output to avoid overflow.\n *      (4) If normflag == 1, the result is normalized by scaling all\n *          kernel values for a unit sum.  If the sum of kernel values\n *          is very close to zero, the kernel can not be normalized and\n *          the convolution will not be performed.  A warning is issued.\n *      (5) The kernel values can be positive or negative, but the\n *          result for the convolution can only be stored as a positive\n *          number.  Consequently, if it goes negative, the choices are\n *          to clip to 0 or take the absolute value.  We're choosing\n *          to take the absolute value.  (Another possibility would be\n *          to output a second unsigned image for the negative values.)\n *          If you want to get a clipped result, or to keep the negative\n *          values in the result, use fpixConvolve(), with the\n *          converters in fpix2.c between pix and fpix.\n *      (6) This uses a mirrored border to avoid special casing on\n *          the boundaries.\n *      (7) To get a subsampled output, call l_setConvolveSampling().\n *          The time to make a subsampled output is reduced by the\n *          product of the sampling factors.\n *      (8) The function is slow, running at about 12 machine cycles for\n *          each pixel-op in the convolution.  For example, with a 3 GHz\n *          cpu, a 1 Mpixel grayscale image, and a kernel with\n *          (sx * sy) = 25 elements, the convolution takes about 100 msec.\n */",
      "file" : "convolve.c"
   },
   {
      "function" : "pixConvolveRGB",
      "comment" : "/*!\n *  pixConvolveRGB()\n *\n *      Input:  pixs (32 bpp rgb)\n *              kernel\n *      Return: pixd (32 bpp rgb)\n *\n *  Notes:\n *      (1) This gives a convolution on an RGB image using an\n *          arbitrary kernel (which we normalize to keep each\n *          component within the range [0 ... 255].\n *      (2) The input pixs must be RGB.\n *      (3) The kernel values can be positive or negative, but the\n *          result for the convolution can only be stored as a positive\n *          number.  Consequently, if it goes negative, we clip the\n *          result to 0.\n *      (4) To get a subsampled output, call l_setConvolveSampling().\n *          The time to make a subsampled output is reduced by the\n *          product of the sampling factors.\n *      (5) This uses a mirrored border to avoid special casing on\n *          the boundaries.\n */",
      "file" : "convolve.c"
   },
   {
      "function" : "pixConvolveRGBSep",
      "comment" : "/*!\n *  pixConvolveRGBSep()\n *\n *      Input:  pixs (32 bpp rgb)\n *              kelx (x-dependent kernel)\n *              kely (y-dependent kernel)\n *      Return: pixd (32 bpp rgb)\n *\n *  Notes:\n *      (1) This does a convolution on an RGB image using a separable\n *          kernel that is a sequence of convolutions in x and y.  The two\n *          one-dimensional kernel components must be input separately;\n *          the full kernel is the product of these components.\n *          The support for the full kernel is thus a rectangular region.\n *      (2) The kernel values can be positive or negative, but the\n *          result for the convolution can only be stored as a positive\n *          number.  Consequently, if it goes negative, we clip the\n *          result to 0.\n *      (3) To get a subsampled output, call l_setConvolveSampling().\n *          The time to make a subsampled output is reduced by the\n *          product of the sampling factors.\n *      (4) This uses a mirrored border to avoid special casing on\n *          the boundaries.\n */",
      "file" : "convolve.c"
   },
   {
      "function" : "pixConvolveSep",
      "comment" : "/*!\n *  pixConvolveSep()\n *\n *      Input:  pixs (8, 16, 32 bpp; no colormap)\n *              kelx (x-dependent kernel)\n *              kely (y-dependent kernel)\n *              outdepth (of pixd: 8, 16 or 32)\n *              normflag (1 to normalize kernel to unit sum; 0 otherwise)\n *      Return: pixd (8, 16 or 32 bpp)\n *\n *  Notes:\n *      (1) This does a convolution with a separable kernel that is\n *          is a sequence of convolutions in x and y.  The two\n *          one-dimensional kernel components must be input separately;\n *          the full kernel is the product of these components.\n *          The support for the full kernel is thus a rectangular region.\n *      (2) The input pixs must have only one sample/pixel.\n *          To do a convolution on an RGB image, use pixConvolveSepRGB().\n *      (3) The parameter @outdepth determines the depth of the result.\n *          If the kernel is normalized to unit sum, the output values\n *          can never exceed 255, so an output depth of 8 bpp is sufficient.\n *          If the kernel is not normalized, it may be necessary to use\n *          16 or 32 bpp output to avoid overflow.\n *      (2) The @normflag parameter is used as in pixConvolve().\n *      (4) The kernel values can be positive or negative, but the\n *          result for the convolution can only be stored as a positive\n *          number.  Consequently, if it goes negative, the choices are\n *          to clip to 0 or take the absolute value.  We're choosing\n *          the former for now.  Another possibility would be to output\n *          a second unsigned image for the negative values.\n *      (5) Warning: if you use l_setConvolveSampling() to get a\n *          subsampled output, and the sampling factor is larger than\n *          the kernel half-width, it is faster to use the non-separable\n *          version pixConvolve().  This is because the first convolution\n *          here must be done on every raster line, regardless of the\n *          vertical sampling factor.  If the sampling factor is smaller\n *          than kernel half-width, it's faster to use the separable\n *          convolution.\n *      (6) This uses mirrored borders to avoid special casing on\n *          the boundaries.\n */",
      "file" : "convolve.c"
   },
   {
      "function" : "pixConvolveWithBias",
      "comment" : "/*!\n *  pixConvolveWithBias()\n *\n *      Input:  pixs (8 bpp; no colormap)\n *              kel1\n *              kel2  (can be null; use if separable)\n *              force8 (if 1, force output to 8 bpp; otherwise, determine\n *                      output depth by the dynamic range of pixel values)\n *              &bias (<return> applied bias)\n *      Return: pixd (8 or 16 bpp)\n *\n *  Notes:\n *      (1) This does a convolution with either a single kernel or\n *          a pair of separable kernels, and automatically applies whatever\n *          bias (shift) is required so that the resulting pixel values\n *          are non-negative.\n *      (2) The kernel is always normalized.  If there are no negative\n *          values in the kernel, a standard normalized convolution is\n *          performed, with 8 bpp output.  If the sum of kernel values is\n *          very close to zero, the kernel can not be normalized and\n *          the convolution will not be performed.  An error message results.\n *      (3) If there are negative values in the kernel, the pix is\n *          converted to an fpix, the convolution is done on the fpix, and\n *          a bias (shift) may need to be applied.\n *      (4) If force8 == TRUE and the range of values after the convolution\n *          is > 255, the output values will be scaled to fit in [0 ... 255].\n *          If force8 == FALSE, the output will be either 8 or 16 bpp,\n *          to accommodate the dynamic range of output values without scaling.\n */",
      "file" : "convolve.c"
   },
   {
      "function" : "pixCopy",
      "comment" : "/*!\n *  pixCopy()\n *\n *      Input:  pixd (<optional>; can be null, or equal to pixs,\n *                    or different from pixs)\n *              pixs\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) There are three cases:\n *            (a) pixd == null  (makes a new pix; refcount = 1)\n *            (b) pixd == pixs  (no-op)\n *            (c) pixd != pixs  (data copy; no change in refcount)\n *          If the refcount of pixd > 1, case (c) will side-effect\n *          these handles.\n *      (2) The general pattern of use is:\n *             pixd = pixCopy(pixd, pixs);\n *          This will work for all three cases.\n *          For clarity when the case is known, you can use:\n *            (a) pixd = pixCopy(NULL, pixs);\n *            (c) pixCopy(pixd, pixs);\n *      (3) For case (c), we check if pixs and pixd are the same\n *          size (w,h,d).  If so, the data is copied directly.\n *          Otherwise, the data is reallocated to the correct size\n *          and the copy proceeds.  The refcount of pixd is unchanged.\n *      (4) This operation, like all others that may involve a pre-existing\n *          pixd, will side-effect any existing clones of pixd.\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixCopyBorder",
      "comment" : "/*!\n *  pixCopyBorder()\n *\n *      Input:  pixd (all depths; colormap ok; can be NULL)\n *              pixs (same depth and size as pixd)\n *              left, right, top, bot (number of pixels to copy)\n *      Return: pixd, or null on error if pixd is not defined\n *\n *  Notes:\n *      (1) pixd can be null, but otherwise it must be the same size\n *          and depth as pixs.  Always returns pixd.\n *      (1) This is useful in situations where by setting a few border\n *          pixels we can avoid having to copy all pixels in pixs into\n *          pixd as an initialization step for some operation.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixCopyColormap",
      "comment" : "/*!\n *  pixCopyColormap()\n *\n *      Input:  src and dest Pix\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This always destroys any colormap in pixd (except if\n *          the operation is a no-op.\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixCopyDimensions",
      "comment" : "/*!\n *  pixCopyDimensions()\n *\n *      Input:  pixd\n *              pixd\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixCopyInputFormat",
      "comment" : "/* no-op */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixCopyRGBComponent",
      "comment" : "/*!\n *  pixCopyRGBComponent()\n *\n *      Input:  pixd (32 bpp)\n *              pixs (32 bpp)\n *              comp (one of the set: {COLOR_RED, COLOR_GREEN,\n *                                     COLOR_BLUE, L_ALPHA_CHANNEL})\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) The two images are registered to the UL corner.  The sizes\n *          are usually the same, and a warning is issued if they differ.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixCopyResolution",
      "comment" : "/*!\n *  pixSetResolution()\n *\n *      Input:  pix\n *              xres, yres (use 0 to skip the setting for either of these)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixCopySpp",
      "comment" : "/*!\n *  pixCopySpp()\n *\n *      Input:  pixd\n *              pixs\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixCopyText",
      "comment" : "/*!\n *  pixAddText()\n *\n *      Input:  pix\n *              textstring\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This adds the new textstring to any existing text.\n *      (2) Either or both the existing text and the new text\n *          string can be null.\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixCorrelationBestShift",
      "comment" : "/*!\n *  pixCorrelationBestShift()\n *\n *      Input:  pix1   (1 bpp, the unknown image; typically larger)\n *              pix2   (1 bpp, the matching template image))\n *              nasum1 (vertical column pixel sums for pix1)\n *              namoment1  (vertical column first moment of pixels for pix1)\n *              area2  (number of on pixels in pix2)\n *              ycent2  (y component of centroid of pix2)\n *              maxyshift  (max y shift of pix2 around the location where\n *                          the centroids of pix2 and a windowed part of pix1\n *                          are vertically aligned)\n *              tab8 (<optional> sum tab for ON pixels in byte; can be NULL)\n *              &delx (<optional return> best x shift of pix2 relative to pix1\n *              &dely (<optional return> best y shift of pix2 relative to pix1\n *              &score (<optional return> maximum score found; can be NULL)\n *              debugflag (<= 0 to skip; positive to generate output.\n *                         The integer is used to label the debug image.)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This maximizes the correlation score between two 1 bpp images,\n *          one of which is typically wider.  In a typical example,\n *          pix1 is a bitmap of 2 or more touching characters and pix2 is\n *          a single character template.  This finds the location of pix2\n *          that gives the largest correlation.\n *      (2) The windowed area of fg pixels and windowed first moment\n *          in the y direction are computed from the input sum and moment\n *          column arrays, @nasum1 and @namoment1\n *      (3) This is a brute force operation.  We compute the correlation\n *          at every x shift for which pix2 fits entirely within pix1,\n *          and where the centroid of pix2 is aligned, within +-maxyshift,\n *          with the centroid of a window of pix1 of the same width.\n *          The correlation is taken over the full height of pix1.\n *          This can be made more efficient.\n */",
      "file" : "recogident.c"
   },
   {
      "function" : "pixCorrelationBinary",
      "comment" : "/*!\n *  pixCorrelationBinary()\n *\n *      Input:  pix1 (1 bpp)\n *              pix2 (1 bpp)\n *              &val (<return> correlation)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) The correlation is a number between 0.0 and 1.0,\n *          based on foreground similarity:\n *                           (|1 AND 2|)**2\n *            correlation =  --------------\n *                             |1| * |2|\n *          where |x| is the count of foreground pixels in image x.\n *          If the images are identical, this is 1.0.\n *          If they have no fg pixels in common, this is 0.0.\n *          If one or both images have no fg pixels, the correlation is 0.0.\n *      (2) Typically the two images are of equal size, but this\n *          is not enforced.  Instead, the UL corners are aligned.\n */",
      "file" : "compare.c"
   },
   {
      "function" : "pixCorrelationScore",
      "comment" : "/*!\n *  pixCorrelationScore()\n *\n *      Input:  pix1   (test pix, 1 bpp)\n *              pix2   (exemplar pix, 1 bpp)\n *              area1  (number of on pixels in pix1)\n *              area2  (number of on pixels in pix2)\n *              delx   (x comp of centroid difference)\n *              dely   (y comp of centroid difference)\n *              maxdiffw (max width difference of pix1 and pix2)\n *              maxdiffh (max height difference of pix1 and pix2)\n *              tab    (sum tab for byte)\n *              &score (<return> correlation score)\n *      Return: 0 if OK, 1 on error\n *\n *  Note: we check first that the two pix are roughly the same size.\n *  For jbclass (jbig2) applications at roughly 300 ppi, maxdiffw and\n *  maxdiffh should be at least 2.\n *\n *  Only if they meet that criterion do we compare the bitmaps.\n *  The centroid difference is used to align the two images to the\n *  nearest integer for the correlation.\n *\n *  The correlation score is the ratio of the square of the number of\n *  pixels in the AND of the two bitmaps to the product of the number\n *  of ON pixels in each.  Denote the number of ON pixels in pix1\n *  by |1|, the number in pix2 by |2|, and the number in the AND\n *  of pix1 and pix2 by |1 & 2|.  The correlation score is then\n *  (|1 & 2|)**2 / (|1|*|2|).\n *\n *  This score is compared with an input threshold, which can\n *  be modified depending on the weight of the template.\n *  The modified threshold is\n *     thresh + (1.0 - thresh) * weight * R\n *  where\n *     weight is a fixed input factor between 0.0 and 1.0\n *     R = |2| / area(2)\n *  and area(2) is the total number of pixels in 2 (i.e., width x height).\n *\n *  To understand why a weight factor is useful, consider what happens\n *  with thick, sans-serif characters that look similar and have a value\n *  of R near 1.  Different characters can have a high correlation value,\n *  and the classifier will make incorrect substitutions.  The weight\n *  factor raises the threshold for these characters.\n *\n *  Yet another approach to reduce such substitutions is to run the classifier\n *  in a non-greedy way, matching to the template with the highest\n *  score, not the first template with a score satisfying the matching\n *  constraint.  However, this is not particularly effective.\n *\n *  The implementation here gives the same result as in\n *  pixCorrelationScoreSimple(), where a temporary Pix is made to hold\n *  the AND and implementation uses rasterop:\n *      pixt = pixCreateTemplate(pix1);\n *      pixRasterop(pixt, idelx, idely, wt, ht, PIX_SRC, pix2, 0, 0);\n *      pixRasterop(pixt, 0, 0, wi, hi, PIX_SRC & PIX_DST, pix1, 0, 0);\n *      pixCountPixels(pixt, &count, tab);\n *      pixDestroy(&pixt);\n *  However, here it is done in a streaming fashion, counting as it goes,\n *  and touching memory exactly once, giving a 3-4x speedup over the\n *  simple implementation.  This very fast correlation matcher was\n *  contributed by William Rucklidge.\n */",
      "file" : "correlscore.c"
   },
   {
      "function" : "pixCorrelationScoreShifted",
      "comment" : "/*!\n *  pixCorrelationScoreShifted()\n *\n *      Input:  pix1   (1 bpp)\n *              pix2   (1 bpp)\n *              area1  (number of on pixels in pix1)\n *              area2  (number of on pixels in pix2)\n *              delx (x translation of pix2 relative to pix1)\n *              dely (y translation of pix2 relative to pix1)\n *              tab    (sum tab for byte)\n *              &score (<return> correlation score)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This finds the correlation between two 1 bpp images,\n *          when pix2 is shifted by (delx, dely) with respect\n *          to each other.\n *      (2) This is implemented by starting with a copy of pix1 and\n *          ANDing its pixels with those of a shifted pix2.\n *      (3) Get the pixel counts for area1 and area2 using piCountPixels().\n *      (4) A good estimate for a shift that would maximize the correlation\n *          is to align the centroids (cx1, cy1; cx2, cy2), giving the\n *          relative translations etransx and etransy:\n *             etransx = cx1 - cx2\n *             etransy = cy1 - cy2\n *          Typically delx is chosen to be near etransx; ditto for dely.\n *          This function is used in pixBestCorrelation(), where the\n *          translations delx and dely are varied to find the best alignment.\n *      (5) We do not check the sizes of pix1 and pix2, because they should\n *          be comparable.\n */",
      "file" : "correlscore.c"
   },
   {
      "function" : "pixCorrelationScoreSimple",
      "comment" : "/*!\n *  pixCorrelationScoreSimple()\n *\n *      Input:  pix1   (test pix, 1 bpp)\n *              pix2   (exemplar pix, 1 bpp)\n *              area1  (number of on pixels in pix1)\n *              area2  (number of on pixels in pix2)\n *              delx   (x comp of centroid difference)\n *              dely   (y comp of centroid difference)\n *              maxdiffw (max width difference of pix1 and pix2)\n *              maxdiffh (max height difference of pix1 and pix2)\n *              tab    (sum tab for byte)\n *              &score (<return> correlation score, in range [0.0 ... 1.0])\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This calculates exactly the same value as pixCorrelationScore().\n *          It is 2-3x slower, but much simpler to understand.\n *      (2) The returned correlation score is 0.0 if the width or height\n *          exceed @maxdiffw or @maxdiffh.\n */",
      "file" : "correlscore.c"
   },
   {
      "function" : "pixCorrelationScoreThresholded",
      "comment" : "/*!\n *  pixCorrelationScoreThresholded()\n *\n *      Input:  pix1   (test pix, 1 bpp)\n *              pix2   (exemplar pix, 1 bpp)\n *              area1  (number of on pixels in pix1)\n *              area2  (number of on pixels in pix2)\n *              delx   (x comp of centroid difference)\n *              dely   (y comp of centroid difference)\n *              maxdiffw (max width difference of pix1 and pix2)\n *              maxdiffh (max height difference of pix1 and pix2)\n *              tab    (sum tab for byte)\n *              downcount (count of 1 pixels below each row of pix1)\n *              score_threshold\n *      Return: whether the correlation score is >= score_threshold\n *\n *\n *  Note: we check first that the two pix are roughly the same size.\n *  Only if they meet that criterion do we compare the bitmaps.\n *  The centroid difference is used to align the two images to the\n *  nearest integer for the correlation.\n *\n *  The correlation score is the ratio of the square of the number of\n *  pixels in the AND of the two bitmaps to the product of the number\n *  of ON pixels in each.  Denote the number of ON pixels in pix1\n *  by |1|, the number in pix2 by |2|, and the number in the AND\n *  of pix1 and pix2 by |1 & 2|.  The correlation score is then\n *  (|1 & 2|)**2 / (|1|*|2|).\n *\n *  This score is compared with an input threshold, which can\n *  be modified depending on the weight of the template.\n *  The modified threshold is\n *     thresh + (1.0 - thresh) * weight * R\n *  where\n *     weight is a fixed input factor between 0.0 and 1.0\n *     R = |2| / area(2)\n *  and area(2) is the total number of pixels in 2 (i.e., width x height).\n *\n *  To understand why a weight factor is useful, consider what happens\n *  with thick, sans-serif characters that look similar and have a value\n *  of R near 1.  Different characters can have a high correlation value,\n *  and the classifier will make incorrect substitutions.  The weight\n *  factor raises the threshold for these characters.\n *\n *  Yet another approach to reduce such substitutions is to run the classifier\n *  in a non-greedy way, matching to the template with the highest\n *  score, not the first template with a score satisfying the matching\n *  constraint.  However, this is not particularly effective.\n *\n *  This very fast correlation matcher was contributed by William Rucklidge.\n */",
      "file" : "correlscore.c"
   },
   {
      "function" : "pixCountArbInRect",
      "comment" : "/*!\n *  pixCountArbInRect()\n *\n *      Input:  pixs (8 bpp, or colormapped)\n *              box (<optional>) over which count is made;\n *                   use entire image null)\n *              val (pixel value to count)\n *              factor (subsampling factor; integer >= 1)\n *              &count (<return> count; estimate it if factor > 1)\n *      Return: na (histogram), or null on error\n *\n *  Notes:\n *      (1) If pixs is cmapped, @val is compared to the colormap index;\n *          otherwise, @val is compared to the grayscale value.\n *      (2) Set the subsampling @factor > 1 to reduce the amount of computation.\n *          If @factor > 1, multiply the count by @factor * @factor.\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixCountByColumn",
      "comment" : "/*!\n *  pixCountByColumn()\n *\n *      Input:  pix (1 bpp)\n *              box (<optional> clipping box for count; can be null)\n *      Return: na of number of ON pixels by column, or null on error\n *\n *  Notes:\n *      (1) To resample for a bin size different from 1, use\n *          numaUniformSampling() on the result of this function.\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixCountByRow",
      "comment" : "/*!\n *  pixCountByRow()\n *\n *      Input:  pix (1 bpp)\n *              box (<optional> clipping box for count; can be null)\n *      Return: na of number of ON pixels by row, or null on error\n *\n *  Notes:\n *      (1) To resample for a bin size different from 1, use\n *          numaUniformSampling() on the result of this function.\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixCountConnComp",
      "comment" : "/*!\n *  pixCountConnComp()\n *\n *      Input:  pixs (1 bpp)\n *              connectivity (4 or 8)\n *              &count (<return>\n *      Return: 0 if OK, 1 on error\n *\n * Notes:\n *     (1) This is the top-level call for getting the number of\n *         4- or 8-connected components in a 1 bpp image.\n *     (2) It works on a copy of the input pix.  The c.c. are located\n *         in raster order and erased one at a time.\n */",
      "file" : "conncomp.c"
   },
   {
      "function" : "pixCountPixels",
      "comment" : "/*!\n *  pixCountPixels()\n *\n *      Input:  pix (1 bpp)\n *              &count (<return> count of ON pixels)\n *              tab8  (<optional> 8-bit pixel lookup table)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixCountPixelsByColumn",
      "comment" : "/*!\n *  pixCountPixelsByColumn()\n *\n *      Input:  pix (1 bpp)\n *      Return: na of counts in each column, or null on error\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixCountPixelsByRow",
      "comment" : "/*!\n *  pixCountPixelsByRow()\n *\n *      Input:  pix (1 bpp)\n *              tab8  (<optional> 8-bit pixel lookup table)\n *      Return: na of counts, or null on error\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixCountPixelsInRow",
      "comment" : "/*!\n *  pixCountPixelsInRow()\n *\n *      Input:  pix (1 bpp)\n *              row number\n *              &count (<return> sum of ON pixels in raster line)\n *              tab8  (<optional> 8-bit pixel lookup table)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixCreate",
      "comment" : "/*!\n *  pixCreate()\n *\n *      Input:  width, height, depth\n *      Return: pixd (with data allocated and initialized to 0),\n *                    or null on error\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixCreateFromPixcomp",
      "comment" : "/*!\n *  pixCreateFromPixcomp()\n *\n *      Input:  pixc\n *      Return: pix, or null on error\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixCreateHeader",
      "comment" : "/*!\n *  pixCreateHeader()\n *\n *      Input:  width, height, depth\n *      Return: pixd (with no data allocated), or null on error\n *\n *  Notes:\n *      (1) It is assumed that all 32 bit pix have 3 spp.  If there is\n *          a valid alpha channel, this will be set to 4 spp later.\n *      (2) If the number of bytes to be allocated is larger than the\n *          maximum value in an int32, we can get overflow, resulting\n *          in a smaller amount of memory actually being allocated.\n *          Later, an attempt to access memory that wasn't allocated will\n *          cause a crash.  So to avoid crashing a program (or worse)\n *          with bad (or malicious) input, this is where we limit the\n *          requested allocation of image data in a typesafe way.\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixCreateNoInit",
      "comment" : "/*!\n *  pixCreateNoInit()\n *\n *      Input:  width, height, depth\n *      Return: pixd (with data allocated but not initialized),\n *                    or null on error\n *\n *  Notes:\n *      (1) Must set pad bits to avoid reading unitialized data, because\n *          some optimized routines (e.g., pixConnComp()) read from pad bits.\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixCreateRGBImage",
      "comment" : "/*!\n *  pixCreateRGBImage()\n *\n *      Input:  8 bpp red pix\n *              8 bpp green pix\n *              8 bpp blue pix\n *      Return: 32 bpp pix, interleaved with 4 samples/pixel,\n *              or null on error\n *\n *  Notes:\n *      (1) the 4th byte, sometimes called the \"alpha channel\",\n *          and which is often used for blending between different\n *          images, is left with 0 value.\n *      (2) see Note (4) in pix.h for details on storage of\n *          8-bit samples within each 32-bit word.\n *      (3) This implementation, setting the r, g and b components\n *          sequentially, is much faster than setting them in parallel\n *          by constructing an RGB dest pixel and writing it to dest.\n *          The reason is there are many more cache misses when reading\n *          from 3 input images simultaneously.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixCreateTemplate",
      "comment" : "/*!\n *  pixCreateTemplate()\n *\n *      Input:  pixs\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Makes a Pix of the same size as the input Pix, with the\n *          data array allocated and initialized to 0.\n *      (2) Copies the other fields, including colormap if it exists.\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixCreateTemplateNoInit",
      "comment" : "/*!\n *  pixCreateTemplateNoInit()\n *\n *      Input:  pixs\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Makes a Pix of the same size as the input Pix, with\n *          the data array allocated but not initialized to 0.\n *      (2) Copies the other fields, including colormap if it exists.\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixCropToMatch",
      "comment" : "/*!\n *  pixCropToMatch()\n *\n *      Input:  pixs1 (any depth, colormap OK)\n *              pixs2 (any depth, colormap OK)\n *              &pixd1 (<return> may be a clone)\n *              &pixd2 (<return> may be a clone)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This resizes pixs1 and/or pixs2 by cropping at the right\n *          and bottom, so that they're the same size.\n *      (2) If a pix doesn't need to be cropped, a clone is returned.\n *      (3) Note: the images are implicitly aligned to the UL corner.\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixCropToSize",
      "comment" : "/*!\n *  pixCropToSize()\n *\n *      Input:  pixs (any depth, colormap OK)\n *              w, h (max dimensions of cropped image)\n *      Return: pixd (cropped if necessary) or null on error.\n *\n *  Notes:\n *      (1) If either w or h is smaller than the corresponding dimension\n *          of pixs, this returns a cropped image; otherwise it returns\n *          a clone of pixs.\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixDebugFlipDetect",
      "comment" : "/*\n *  pixDebugFlipDetect()\n *\n *      Input:  filename (for output debug file)\n *              pixs (input to pix*Detect)\n *              pixhm (hit-miss result from ascenders or descenders)\n *              enable (1 to enable this function; 0 to disable)\n *      Return: void\n */",
      "file" : "flipdetect.c"
   },
   {
      "function" : "pixDeserializeFromMemory",
      "comment" : "/*!\n *  pixDeserializeFromMemory()\n *\n *      Input:  data (serialized data in memory)\n *              nbytes (number of bytes in data string)\n *      Return: pix, or NULL on error\n *\n *  Notes:\n *      (1) See pixSerializeToMemory() for the binary format.\n */",
      "file" : "spixio.c"
   },
   {
      "function" : "pixDeskew",
      "comment" : "/*!\n *  pixDeskew()\n *\n *      Input:  pixs (any depth)\n *              redsearch (for binary search: reduction factor = 1, 2 or 4;\n *                         use 0 for default)\n *      Return: pixd (deskewed pix), or null on error\n *\n *  Notes:\n *      (1) This binarizes if necessary and finds the skew angle.  If the\n *          angle is large enough and there is sufficient confidence,\n *          it returns a deskewed image; otherwise, it returns a clone.\n */",
      "file" : "skew.c"
   },
   {
      "function" : "pixDeskewBarcode",
      "comment" : "/*!\n *  pixDeskewBarcode()\n *\n *      Input:  pixs (input image; 8 bpp)\n *              pixb (binarized edge-filtered input image)\n *              box (identified region containing barcode)\n *              margin (of extra pixels around box to extract)\n *              threshold (for binarization; ~20)\n *              &angle (<optional return> in degrees, clockwise is positive)\n *              &conf (<optional return> confidence)\n *      Return: pixd (deskewed barcode), or null on error\n *\n *  Note:\n *     (1) The (optional) angle returned is the angle in degrees (cw positive)\n *         necessary to rotate the image so that it is deskewed.\n */",
      "file" : "readbarcode.c"
   },
   {
      "function" : "pixDeskewGeneral",
      "comment" : "/*!\n *  pixDeskewGeneral()\n *\n *      Input:  pixs  (any depth)\n *              redsweep  (for linear search: reduction factor = 1, 2 or 4;\n *                         use 0 for default)\n *              sweeprange (in degrees in each direction from 0;\n *                          use 0.0 for default)\n *              sweepdelta (in degrees; use 0.0 for default)\n *              redsearch  (for binary search: reduction factor = 1, 2 or 4;\n *                          use 0 for default;)\n *              thresh (for binarizing the image; use 0 for default)\n *              &angle   (<optional return> angle required to deskew,\n *                        in degrees; use NULL to skip)\n *              &conf    (<optional return> conf value is ratio\n *                        of max/min scores; use NULL to skip)\n *      Return: pixd (deskewed pix), or null on error\n *\n *  Notes:\n *      (1) This binarizes if necessary and finds the skew angle.  If the\n *          angle is large enough and there is sufficient confidence,\n *          it returns a deskewed image; otherwise, it returns a clone.\n */",
      "file" : "skew.c"
   },
   {
      "function" : "pixDeskewLocal",
      "comment" : "/*!\n *  pixDeskewLocal()\n *\n *      Input:  pixs\n *              nslices  (the number of horizontal overlapping slices; must\n *                  be larger than 1 and not exceed 20; use 0 for default)\n *              redsweep (sweep reduction factor: 1, 2, 4 or 8;\n *                        use 0 for default value)\n *              redsearch (search reduction factor: 1, 2, 4 or 8, and\n *                         not larger than redsweep; use 0 for default value)\n *              sweeprange (half the full range, assumed about 0; in degrees;\n *                          use 0.0 for default value)\n *              sweepdelta (angle increment of sweep; in degrees;\n *                          use 0.0 for default value)\n *              minbsdelta (min binary search increment angle; in degrees;\n *                          use 0.0 for default value)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This function allows deskew of a page whose skew changes\n *          approximately linearly with vertical position.  It uses\n *          a projective tranform that in effect does a differential\n *          shear about the LHS of the page, and makes all text lines\n *          horizontal.\n *      (2) The origin of the keystoning can be either a cheap document\n *          feeder that rotates the page as it is passed through, or a\n *          camera image taken from either the left or right side\n *          of the vertical.\n *      (3) The image transformation is a projective warping,\n *          not a rotation.  Apart from this function, the text lines\n *          must be properly aligned vertically with respect to each\n *          other.  This can be done by pre-processing the page; e.g.,\n *          by rotating or horizontally shearing it.\n *          Typically, this can be achieved by vertically aligning\n *          the page edge.\n */",
      "file" : "baseline.c"
   },
   {
      "function" : "pixDestroy",
      "comment" : "/*!\n *  pixDestroy()\n *\n *      Input:  &pix <will be nulled>\n *      Return: void\n *\n *  Notes:\n *      (1) Decrements the ref count and, if 0, destroys the pix.\n *      (2) Always nulls the input ptr.\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixDestroyColormap",
      "comment" : "/*!\n *  pixDestroyColormap()\n *\n *      Input:  pix\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixDilate",
      "comment" : "/*!\n *  pixDilate()\n *\n *      Input:  pixd  (<optional>; this can be null, equal to pixs,\n *                     or different from pixs)\n *              pixs (1 bpp)\n *              sel\n *      Return: pixd\n *\n *  Notes:\n *      (1) This dilates src using hits in Sel.\n *      (2) There are three cases:\n *          (a) pixd == null   (result into new pixd)\n *          (b) pixd == pixs   (in-place; writes result back to pixs)\n *          (c) pixd != pixs   (puts result into existing pixd)\n *      (3) For clarity, if the case is known, use these patterns:\n *          (a) pixd = pixDilate(NULL, pixs, ...);\n *          (b) pixDilate(pixs, pixs, ...);\n *          (c) pixDilate(pixd, pixs, ...);\n *      (4) The size of the result is determined by pixs.\n */",
      "file" : "morph.c"
   },
   {
      "function" : "pixDilateBrick",
      "comment" : "/*!\n *  pixDilateBrick()\n *\n *      Input:  pixd  (<optional>; this can be null, equal to pixs,\n *                     or different from pixs)\n *              pixs (1 bpp)\n *              hsize (width of brick Sel)\n *              vsize (height of brick Sel)\n *      Return: pixd\n *\n *  Notes:\n *      (1) Sel is a brick with all elements being hits\n *      (2) The origin is at (x, y) = (hsize/2, vsize/2)\n *      (3) Do separably if both hsize and vsize are > 1.\n *      (4) There are three cases:\n *          (a) pixd == null   (result into new pixd)\n *          (b) pixd == pixs   (in-place; writes result back to pixs)\n *          (c) pixd != pixs   (puts result into existing pixd)\n *      (5) For clarity, if the case is known, use these patterns:\n *          (a) pixd = pixDilateBrick(NULL, pixs, ...);\n *          (b) pixDilateBrick(pixs, pixs, ...);\n *          (c) pixDilateBrick(pixd, pixs, ...);\n *      (6) The size of the result is determined by pixs.\n */",
      "file" : "morph.c"
   },
   {
      "function" : "pixDilateBrickDwa",
      "comment" : "/*!\n *  pixDilateBrickDwa()\n *\n *      Input:  pixd  (<optional>; this can be null, equal to pixs,\n *                     or different from pixs)\n *              pixs (1 bpp)\n *              hsize (width of brick Sel)\n *              vsize (height of brick Sel)\n *      Return: pixd\n *\n *  Notes:\n *      (1) These implement 2D brick Sels, using linear Sels generated\n *          with selaAddBasic().\n *      (2) A brick Sel has hits for all elements.\n *      (3) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)\n *      (4) Do separably if both hsize and vsize are > 1.\n *      (5) It is necessary that both horizontal and vertical Sels\n *          of the input size are defined in the basic sela.\n *      (6) There are three cases:\n *          (a) pixd == null   (result into new pixd)\n *          (b) pixd == pixs   (in-place; writes result back to pixs)\n *          (c) pixd != pixs   (puts result into existing pixd)\n *      (7) For clarity, if the case is known, use these patterns:\n *          (a) pixd = pixDilateBrickDwa(NULL, pixs, ...);\n *          (b) pixDilateBrickDwa(pixs, pixs, ...);\n *          (c) pixDilateBrickDwa(pixd, pixs, ...);\n *      (8) The size of pixd is determined by pixs.\n *      (9) If either linear Sel is not found, this calls\n *          the appropriate decomposible function.\n */",
      "file" : "morphdwa.c"
   },
   {
      "function" : "pixDilateCompBrick",
      "comment" : "/*!\n *  pixDilateCompBrick()\n *\n *      Input:  pixd  (<optional>; this can be null, equal to pixs,\n *                     or different from pixs)\n *              pixs (1 bpp)\n *              hsize (width of brick Sel)\n *              vsize (height of brick Sel)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Sel is a brick with all elements being hits\n *      (2) The origin is at (x, y) = (hsize/2, vsize/2)\n *      (3) Do compositely for each dimension > 1.\n *      (4) Do separably if both hsize and vsize are > 1.\n *      (5) There are three cases:\n *          (a) pixd == null   (result into new pixd)\n *          (b) pixd == pixs   (in-place; writes result back to pixs)\n *          (c) pixd != pixs   (puts result into existing pixd)\n *      (6) For clarity, if the case is known, use these patterns:\n *          (a) pixd = pixDilateCompBrick(NULL, pixs, ...);\n *          (b) pixDilateCompBrick(pixs, pixs, ...);\n *          (c) pixDilateCompBrick(pixd, pixs, ...);\n *      (7) The dimensions of the resulting image are determined by pixs.\n *      (8) CAUTION: both hsize and vsize are being decomposed.\n *          The decomposer chooses a product of sizes (call them\n *          'terms') for each that is close to the input size,\n *          but not necessarily equal to it.  It attempts to optimize:\n *             (a) for consistency with the input values: the product\n *                 of terms is close to the input size\n *             (b) for efficiency of the operation: the sum of the\n *                 terms is small; ideally about twice the square\n *                 root of the input size.\n *          So, for example, if the input hsize = 37, which is\n *          a prime number, the decomposer will break this into two\n *          terms, 6 and 6, so that the net result is a dilation\n *          with hsize = 36.\n */",
      "file" : "morph.c"
   },
   {
      "function" : "pixDilateCompBrickDwa",
      "comment" : "/*!\n *  pixDilateCompBrickDwa()\n *\n *      Input:  pixd  (<optional>; this can be null, equal to pixs,\n *                     or different from pixs)\n *              pixs (1 bpp)\n *              hsize (width of brick Sel)\n *              vsize (height of brick Sel)\n *      Return: pixd\n *\n *  Notes:\n *      (1) These implement a separable composite dilation with 2D brick Sels.\n *      (2) For efficiency, it may decompose each linear morphological\n *          operation into two (brick + comb).\n *      (3) A brick Sel has hits for all elements.\n *      (4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)\n *      (5) Do separably if both hsize and vsize are > 1.\n *      (6) It is necessary that both horizontal and vertical Sels\n *          of the input size are defined in the basic sela.\n *      (7) There are three cases:\n *          (a) pixd == null   (result into new pixd)\n *          (b) pixd == pixs   (in-place; writes result back to pixs)\n *          (c) pixd != pixs   (puts result into existing pixd)\n *      (8) For clarity, if the case is known, use these patterns:\n *          (a) pixd = pixDilateCompBrickDwa(NULL, pixs, ...);\n *          (b) pixDilateCompBrickDwa(pixs, pixs, ...);\n *          (c) pixDilateCompBrickDwa(pixd, pixs, ...);\n *      (9) The size of pixd is determined by pixs.\n *      (10) CAUTION: both hsize and vsize are being decomposed.\n *          The decomposer chooses a product of sizes (call them\n *          'terms') for each that is close to the input size,\n *           but not necessarily equal to it.  It attempts to optimize:\n *              (a) for consistency with the input values: the product\n *                  of terms is close to the input size\n *              (b) for efficiency of the operation: the sum of the\n *                  terms is small; ideally about twice the square\n *                   root of the input size.\n *           So, for example, if the input hsize = 37, which is\n *           a prime number, the decomposer will break this into two\n *           terms, 6 and 6, so that the net result is a dilation\n *           with hsize = 36.\n */",
      "file" : "morphdwa.c"
   },
   {
      "function" : "pixDilateCompBrickExtendDwa",
      "comment" : "/*!\n *  pixDilateCompBrickExtendDwa()\n *\n *      Input:  pixd  (<optional>; this can be null, equal to pixs,\n *                     or different from pixs)\n *              pixs (1 bpp)\n *              hsize (width of brick Sel)\n *              vsize (height of brick Sel)\n *      Return: pixd\n *\n *  Notes:\n *      (1) Ankur Jain suggested and implemented extending the composite\n *          DWA operations beyond the 63 pixel limit.  This is a\n *          simplified and approximate implementation of the extension.\n *          This allows arbitrary Dwa morph operations using brick Sels,\n *          by decomposing the horizontal and vertical dilations into\n *          a sequence of 63-element dilations plus a dilation of size\n *          between 3 and 62.\n *      (2) The 63-element dilations are exact, whereas the extra dilation\n *          is approximate, because the underlying decomposition is\n *          in pixDilateCompBrickDwa().  See there for further details.\n *      (3) There are three cases:\n *          (a) pixd == null   (result into new pixd)\n *          (b) pixd == pixs   (in-place; writes result back to pixs)\n *          (c) pixd != pixs   (puts result into existing pixd)\n *      (4) There is no need to call this directly:  pixDilateCompBrickDwa()\n *          calls this function if either brick dimension exceeds 63.\n */",
      "file" : "morphdwa.c"
   },
   {
      "function" : "pixDilateGray",
      "comment" : "/*!\n *  pixDilateGray()\n *\n *      Input:  pixs\n *              hsize  (of Sel; must be odd; origin implicitly in center)\n *              vsize  (ditto)\n *      Return: pixd\n *\n *  Notes:\n *      (1) Sel is a brick with all elements being hits\n *      (2) If hsize = vsize = 1, just returns a copy.\n */",
      "file" : "graymorph.c"
   },
   {
      "function" : "pixDilateGray3",
      "comment" : "/*!\n *  pixDilateGray3()\n *\n *      Input:  pixs (8 bpp, not cmapped)\n *              hsize  (1 or 3)\n *              vsize  (1 or 3)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Special case for 1x3, 3x1 or 3x3 brick sel (all hits)\n *      (2) If hsize = vsize = 1, just returns a copy.\n */",
      "file" : "graymorph.c"
   },
   {
      "function" : "pixDilateGray3h",
      "comment" : "/*!\n *  pixDilateGray3h()\n *\n *      Input:  pixs (8 bpp, not cmapped)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Special case for horizontal 3x1 brick Sel;\n *          also used as the first step for the 3x3 brick Sel.\n */",
      "file" : "graymorph.c"
   },
   {
      "function" : "pixDilateGray3v",
      "comment" : "/*!\n *  pixDilateGray3v()\n *\n *      Input:  pixs (8 bpp, not cmapped)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Special case for vertical 1x3 brick Sel;\n *          also used as the second step for the 3x3 brick Sel.\n */",
      "file" : "graymorph.c"
   },
   {
      "function" : "pixDisplay",
      "comment" : "/*!\n *  pixDisplay()\n *\n *      Input:  pix (1, 2, 4, 8, 16, 32 bpp)\n *              x, y  (location of display frame on the screen)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This displays the image using xzgv, xli or xv on Unix,\n *          or i_view on Windows.  The display program must be on\n *          your $PATH variable.  It is chosen by setting the global\n *          var_DISPLAY_PROG, using l_chooseDisplayProg().\n *          Default on Unix is xzgv.\n *      (2) Images with dimensions larger than MAX_DISPLAY_WIDTH or\n *          MAX_DISPLAY_HEIGHT are downscaled to fit those constraints.\n *          This is particulary important for displaying 1 bpp images\n *          with xv, because xv automatically downscales large images\n *          by subsampling, which looks poor.  For 1 bpp, we use\n *          scale-to-gray to get decent-looking anti-aliased images.\n *          In all cases, we write a temporary file to /tmp, that is\n *          read by the display program.\n *      (3) For spp == 4, we call pixDisplayLayersRGBA() to show 3\n *          versions of the image: the image with a fully opaque\n *          alpha, the alpha, and the image as it would appear with\n *          a white background.\n *      (4) Note: this function uses a static internal variable to number\n *          output files written by a single process.  Behavior with a\n *          shared library may be unpredictable.\n */",
      "file" : "writefile.c"
   },
   {
      "function" : "pixDisplayColorArray",
      "comment" : "/*!\n *  pixDisplayColorArray()\n *\n *      Input:  carray (array of colors: 0xrrggbb00)\n *              ncolors (size of array)\n *              side (size of each color square; suggest 200)\n *              ncols (number of columns in output color matrix)\n *              textflag (1 to label each square with text; 0 otherwise)\n *      Return: pixd (color array), or null on error\n */",
      "file" : "pix4.c"
   },
   {
      "function" : "pixDisplayDiffBinary",
      "comment" : "/*!\n *  pixDisplayDiffBinary()\n *\n *      Input:  pix1 (1 bpp)\n *              pix2 (1 bpp)\n *      Return: pixd (4 bpp cmapped), or null on error\n *\n *  Notes:\n *      (1) This gives a color representation of the difference between\n *          pix1 and pix2.  The color difference depends on the order.\n *          The pixels in pixd have 4 colors:\n *           * unchanged:  black (on), white (off)\n *           * on in pix1, off in pix2: red\n *           * on in pix2, off in pix1: green\n *      (2) This aligns the UL corners of pix1 and pix2, and crops\n *          to the overlapping pixels.\n */",
      "file" : "compare.c"
   },
   {
      "function" : "pixDisplayHitMissSel",
      "comment" : "/*!\n *  pixDisplayHitMissSel()\n *\n *      Input:  pixs (1 bpp)\n *              sel (hit-miss in general)\n *              scalefactor (an integer >= 1; use 0 for default)\n *              hitcolor (RGB0 color for center of hit pixels)\n *              misscolor (RGB0 color for center of miss pixels)\n *      Return: pixd (RGB showing both pixs and sel), or null on error\n *  Notes:\n *    (1) We don't allow scalefactor to be larger than MAX_SEL_SCALEFACTOR\n *    (2) The colors are conveniently given as 4 bytes in hex format,\n *        such as 0xff008800.  The least significant byte is ignored.\n */",
      "file" : "selgen.c"
   },
   {
      "function" : "pixDisplayLayersRGBA",
      "comment" : "/*!\n *  pixDisplayLayersRGBA()\n *\n *      Input:  pixs (cmap or 32 bpp rgba)\n *              val (32 bit unsigned color to use as background)\n *              maxw (max output image width; 0 for no scaling)\n *      Return: pixd (showing various image views), or null on error\n *\n *  Notes:\n *      (1) Use @val == 0xffffff00 for white background.\n *      (2) Three views are given:\n *           - the image with a fully opaque alpha\n *           - the alpha layer\n *           - the image as it would appear with a white background.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixDisplayMatchedPattern",
      "comment" : "/*!\n *  pixDisplayMatchedPattern()\n *\n *      Input:  pixs (input image, 1 bpp)\n *              pixp (pattern to be removed from image, 1 bpp)\n *              pixe (image after erosion by Sel that approximates pixp, 1 bpp)\n *              x0, y0 (center of Sel)\n *              color (to paint the matched patterns; 0xrrggbb00)\n *              scale (reduction factor for output pixd)\n *              nlevels (if scale < 1.0, threshold to this number of levels)\n *      Return: pixd (8 bpp, colormapped), or null on error\n *\n *  Notes:\n *    (1) A 4 bpp colormapped image is generated.\n *    (2) If scale <= 1.0, do scale to gray for the output, and threshold\n *        to nlevels of gray.\n *    (3) You can use various functions in selgen to create a Sel\n *        that will generate pixe from pixs.\n *    (4) This function is applied after pixe has been computed.\n *        It finds the centroid of each c.c., and colors the output\n *        pixels using pixp (appropriately aligned) as a stencil.\n *        Alignment is done using the origin of the Sel and the\n *        centroid of the eroded image to place the stencil pixp.\n */",
      "file" : "morphapp.c"
   },
   {
      "function" : "pixDisplayMultiple",
      "comment" : "/*!\n *  pixDisplayMultiple()\n *\n *      Input:  filepattern\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This allows display of multiple images using gthumb on unix\n *          and i_view32 on windows.  The @filepattern is a regular\n *          expression that is expanded by the shell.\n *      (2) _fullpath automatically changes '/' to '\\' if necessary.\n */",
      "file" : "writefile.c"
   },
   {
      "function" : "pixDisplayPta",
      "comment" : "/*!\n *  pixDisplayPta()\n *\n *      Input:  pixd (can be same as pixs or null; 32 bpp if in-place)\n *              pixs (1, 2, 4, 8, 16 or 32 bpp)\n *              pta (of path to be plotted)\n *      Return: pixd (32 bpp RGB version of pixs, with path in green).\n *\n *  Notes:\n *      (1) To write on an existing pixs, pixs must be 32 bpp and\n *          call with pixd == pixs:\n *             pixDisplayPta(pixs, pixs, pta);\n *          To write to a new pix, use pixd == NULL and call:\n *             pixd = pixDisplayPta(NULL, pixs, pta);\n *      (2) On error, returns pixd to avoid losing pixs if called as\n *             pixs = pixDisplayPta(pixs, pixs, pta);\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "pixDisplayPtaPattern",
      "comment" : "/*!\n *  pixDisplayPtaPattern()\n *\n *      Input:  pixd (can be same as pixs or null; 32 bpp if in-place)\n *              pixs (1, 2, 4, 8, 16 or 32 bpp)\n *              pta (giving locations at which the pattern is displayed)\n *              pixp (1 bpp pattern to be placed such that its reference\n *                    point co-locates with each point in pta)\n *              cx, cy (reference point in pattern)\n *              color (in 0xrrggbb00 format)\n *      Return: pixd (32 bpp RGB version of pixs).\n *\n *  Notes:\n *      (1) To write on an existing pixs, pixs must be 32 bpp and\n *          call with pixd == pixs:\n *             pixDisplayPtaPattern(pixs, pixs, pta, ...);\n *          To write to a new pix, use pixd == NULL and call:\n *             pixd = pixDisplayPtaPattern(NULL, pixs, pta, ...);\n *      (2) On error, returns pixd to avoid losing pixs if called as\n *             pixs = pixDisplayPtaPattern(pixs, pixs, pta, ...);\n *      (3) A typical pattern to be used is a circle, generated with\n *             generatePtaFilledCircle()\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "pixDisplayPtaa",
      "comment" : "/*!\n *  pixDisplayPtaa()\n *\n *      Input:  pixs (1, 2, 4, 8, 16 or 32 bpp)\n *              ptaa (array of paths to be plotted)\n *      Return: pixd (32 bpp RGB version of pixs, with paths plotted\n *                    in different colors), or null on error\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "pixDisplayPtaaPattern",
      "comment" : "/*!\n *  pixDisplayPtaaPattern()\n *\n *      Input:  pixd (32 bpp)\n *              pixs (1, 2, 4, 8, 16 or 32 bpp; 32 bpp if in place)\n *              ptaa (giving locations at which the pattern is displayed)\n *              pixp (1 bpp pattern to be placed such that its reference\n *                    point co-locates with each point in pta)\n *              cx, cy (reference point in pattern)\n *      Return: pixd (32 bpp RGB version of pixs).\n *\n *  Notes:\n *      (1) To write on an existing pixs, pixs must be 32 bpp and\n *          call with pixd == pixs:\n *             pixDisplayPtaPattern(pixs, pixs, pta, ...);\n *          To write to a new pix, use pixd == NULL and call:\n *             pixd = pixDisplayPtaPattern(NULL, pixs, pta, ...);\n *      (2) Puts a random color on each pattern associated with a pta.\n *      (3) On error, returns pixd to avoid losing pixs if called as\n *             pixs = pixDisplayPtaPattern(pixs, pixs, pta, ...);\n *      (4) A typical pattern to be used is a circle, generated with\n *             generatePtaFilledCircle()\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "pixDisplayWithTitle",
      "comment" : "/*!\n *  pixDisplayWithTitle()\n *\n *      Input:  pix (1, 2, 4, 8, 16, 32 bpp)\n *              x, y  (location of display frame)\n *              title (<optional> on frame; can be NULL);\n *              dispflag (1 to write, else disabled)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) See notes for pixDisplay().\n *      (2) This displays the image if dispflag == 1.\n */",
      "file" : "writefile.c"
   },
   {
      "function" : "pixDisplayWrite",
      "comment" : "/*!\n *  pixDisplayWrite()\n *\n *      Input:  pix (1, 2, 4, 8, 16, 32 bpp)\n *              reduction (-1 to reset/erase; 0 to disable;\n *                         otherwise this is a reduction factor)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This defaults to jpeg output for pix that are 32 bpp or\n *          8 bpp without a colormap.  If you want to write all images\n *          losslessly, use format == IFF_PNG in pixDisplayWriteFormat().\n *      (2) See pixDisplayWriteFormat() for usage details.\n */",
      "file" : "writefile.c"
   },
   {
      "function" : "pixDisplayWriteFormat",
      "comment" : "/*!\n *  pixDisplayWriteFormat()\n *\n *      Input:  pix (1, 2, 4, 8, 16, 32 bpp)\n *              reduction (-1 to reset/erase; 0 to disable;\n *                         otherwise this is a reduction factor)\n *              format (IFF_PNG or IFF_JFIF_JPEG)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This writes files if reduction > 0.  These can be displayed using\n *            pixDisplayMultiple(\"/tmp/display/file*\");\n *      (2) All previously written files can be erased by calling with\n *          reduction < 0; the value of pixs is ignored.\n *      (3) If reduction > 1 and depth == 1, this does a scale-to-gray\n *          reduction.\n *      (4) This function uses a static internal variable to number\n *          output files written by a single process.  Behavior\n *          with a shared library may be unpredictable.\n *      (5) Output file format is as follows:\n *            format == IFF_JFIF_JPEG:\n *                png if d < 8 or d == 16 or if the output pix\n *                has a colormap.   Otherwise, output is jpg.\n *            format == IFF_PNG:\n *                png (lossless) on all images.\n *      (6) For 16 bpp, the choice of full dynamic range with log scale\n *          is the best for displaying these images.  Alternative outputs are\n *             pix8 = pixMaxDynamicRange(pixt, L_LINEAR_SCALE);\n *             pix8 = pixConvert16To8(pixt, 0);  // low order byte\n *             pix8 = pixConvert16To8(pixt, 1);  // high order byte\n */",
      "file" : "writefile.c"
   },
   {
      "function" : "pixDistanceFunction",
      "comment" : "/*!\n *  pixDistanceFunction()\n *\n *      Input:  pixs  (1 bpp source)\n *              connectivity  (4 or 8)\n *              outdepth (8 or 16 bits for pixd)\n *              boundcond (L_BOUNDARY_BG, L_BOUNDARY_FG)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This computes the distance of each pixel from the nearest\n *          background pixel.  All bg pixels therefore have a distance of 0,\n *          and the fg pixel distances increase linearly from 1 at the\n *          boundary.  It can also be used to compute the distance of\n *          each pixel from the nearest fg pixel, by inverting the input\n *          image before calling this function.  Then all fg pixels have\n *          a distance 0 and the bg pixel distances increase linearly\n *          from 1 at the boundary.\n *      (2) The algorithm, described in Leptonica on the page on seed\n *          filling and connected components, is due to Luc Vincent.\n *          In brief, we generate an 8 or 16 bpp image, initialized\n *          with the fg pixels of the input pix set to 1 and the\n *          1-boundary pixels (i.e., the boundary pixels of width 1 on\n *          the four sides set as either:\n *            * L_BOUNDARY_BG: 0\n *            * L_BOUNDARY_FG:  max\n *          where max = 0xff for 8 bpp and 0xffff for 16 bpp.\n *          Then do raster/anti-raster sweeps over all pixels interior\n *          to the 1-boundary, where the value of each new pixel is\n *          taken to be 1 more than the minimum of the previously-seen\n *          connected pixels (using either 4 or 8 connectivity).\n *          Finally, set the 1-boundary pixels using the mirrored method;\n *          this removes the max values there.\n *      (3) Using L_BOUNDARY_BG clamps the distance to 0 at the\n *          boundary.  Using L_BOUNDARY_FG allows the distance\n *          at the image boundary to \"float\".\n *      (4) For 4-connected, one could initialize only the left and top\n *          1-boundary pixels, and go all the way to the right\n *          and bottom; then coming back reset left and top.  But we\n *          instead use a method that works for both 4- and 8-connected.\n */",
      "file" : "seedfill.c"
   },
   {
      "function" : "pixDitherOctindexWithCmap",
      "comment" : "/*!\n *  pixDitherOctindexWithCmap()\n *\n *      Input:  pixs (32 bpp rgb)\n *              pixd (8 bpp cmapped)\n *              rtab, gtab, btab (tables from rval to octindex)\n *              indexmap (array mapping octindex to cmap index)\n *              difcap (max allowed dither transfer; use 0 for infinite cap)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This performs dithering to generate the colormap indices\n *          in pixd.  The colormap has been calculated, along with\n *          four input LUTs that together give the inverse colormapping\n *          from RGB to colormap index.\n *      (2) For pixOctreeQuantByPopulation(), @indexmap maps from the\n *          standard octindex to colormap index (after subtracting 1).\n *          The basic pixel-level function, without dithering, is:\n *             extractRGBValues(lines[j], &rval, &gval, &bval);\n *             octindex = rtab[rval] | gtab[gval] | btab[bval];\n *             SET_DATA_BYTE(lined, j, indexmap[octindex] - 1);\n *      (3) This can be used in any situation where the general\n *          prescription for finding the colormap index from the rgb\n *          value is precisely this:\n *             cmapindex = indexmap[rtab[rval] | gtab[gval] | btab[bval]] - 1\n *          For example, in pixFixedOctcubeQuant256(), we don't use\n *          standard octcube indexing, the rtab (etc) LUTs map directly\n *          to the colormap index, and @indexmap just compensates for\n *          the 1-off indexing assumed to be in that table.\n */",
      "file" : "colorquant1.c"
   },
   {
      "function" : "pixDitherTo2bpp",
      "comment" : "/*!\n *  pixDitherTo2bpp()\n *\n *      Input:  pixs (8 bpp)\n *              cmapflag (1 to generate a colormap)\n *      Return: pixd (dithered 2 bpp), or null on error\n *\n *  An analog of the Floyd-Steinberg error diffusion dithering\n *  algorithm is used to \"dibitize\" an 8 bpp grayscale image\n *  to 2 bpp, using equally spaced gray values of 0, 85, 170, and 255,\n *  which are served by thresholds of 43, 128 and 213.\n *  If cmapflag == 1, the colormap values are set to 0, 85, 170 and 255.\n *  If a pixel has a value between 0 and 42, it is dibitized\n *  to 0, and the excess (above 0) is added to the\n *  three neighboring pixels, in the fractions 3/8 to (i, j+1),\n *  3/8 to (i+1, j) and 1/4 to (i+1, j+1), truncating to 255 if\n *  necessary.  If a pixel has a value between 43 and 127, it is\n *  dibitized to 1, and the excess (above 85) is added to the three\n *  neighboring pixels as before.  If the value is below 85, the\n *  excess is subtracted.  With a value between 128\n *  and 212, it is dibitized to 2, with the excess on either side\n *  of 170 distributed as before.  Finally, with a value between\n *  213 and 255, it is dibitized to 3, with the excess (below 255)\n *  subtracted from the neighbors.  We always truncate to 0 or 255.\n *  The details can be seen in the lookup table generation.\n *\n *  This function differs from straight dithering in that it allows\n *  clipping of grayscale to 0 or 255 if the values are\n *  sufficiently close, without distribution of the excess.\n *  This uses default values (from pix.h) to specify the range of lower\n *  and upper values (near 0 and 255, rsp) that are clipped to black\n *  and white without propagating the excess.\n *  Not propagating the excess has the effect of reducing the snake\n *  patterns in parts of the image that are nearly black or white;\n *  however, it also prevents any attempt to reproduce gray for those values.\n *\n *  The implementation uses 3 lookup tables for simplicity, and\n *  a pair of line buffers to avoid modifying pixs.\n */",
      "file" : "grayquant.c"
   },
   {
      "function" : "pixDitherTo2bppSpec",
      "comment" : "/*!\n *  pixDitherTo2bppSpec()\n *\n *      Input:  pixs (8 bpp)\n *              lowerclip (lower clip distance to black; use 0 for default)\n *              upperclip (upper clip distance to white; use 0 for default)\n *              cmapflag (1 to generate a colormap)\n *      Return: pixd (dithered 2 bpp), or null on error\n *\n *  Notes:\n *      (1) See comments above in pixDitherTo2bpp() for details.\n *      (2) The input parameters lowerclip and upperclip specify the range\n *          of lower and upper values (near 0 and 255, rsp) that are\n *          clipped to black and white without propagating the excess.\n *          For that reason, lowerclip and upperclip should be small numbers.\n */",
      "file" : "grayquant.c"
   },
   {
      "function" : "pixDitherToBinary",
      "comment" : "/*!\n *  pixDitherToBinary()\n *\n *      Input:  pixs\n *      Return: pixd (dithered binary), or null on error\n *\n *  The Floyd-Steinberg error diffusion dithering algorithm\n *  binarizes an 8 bpp grayscale image to a threshold of 128.\n *  If a pixel has a value above 127, it is binarized to white\n *  and the excess (below 255) is subtracted from three\n *  neighboring pixels in the fractions 3/8 to (i, j+1),\n *  3/8 to (i+1, j) and 1/4 to (i+1,j+1), truncating to 0\n *  if necessary.  Likewise, if it the pixel has a value\n *  below 128, it is binarized to black and the excess above 0\n *  is added to the neighboring pixels, truncating to 255 if necessary.\n *\n *  This function differs from straight dithering in that it allows\n *  clipping of grayscale to 0 or 255 if the values are\n *  sufficiently close, without distribution of the excess.\n *  This uses default values to specify the range of lower\n *  and upper values (near 0 and 255, rsp) that are clipped\n *  to black and white without propagating the excess.\n *  Not propagating the excess has the effect of reducing the\n *  snake patterns in parts of the image that are nearly black or white;\n *  however, it also prevents the attempt to reproduce gray for those values.\n *\n *  The implementation is straightforward.  It uses a pair of\n *  line buffers to avoid changing pixs.  It is about 2x faster\n *  than the implementation using LUTs.\n */",
      "file" : "grayquant.c"
   },
   {
      "function" : "pixDitherToBinaryLUT",
      "comment" : "/*!\n *  pixDitherToBinaryLUT()\n *\n *      Input:  pixs\n *              lowerclip (lower clip distance to black; use -1 for default)\n *              upperclip (upper clip distance to white; use -1 for default)\n *      Return: pixd (dithered binary), or null on error\n *\n *  This implementation is deprecated.  You should use pixDitherToBinary().\n *\n *  See comments in pixDitherToBinary()\n *\n *  This implementation additionally uses three lookup tables to\n *  generate the output pixel value and the excess or deficit\n *  carried over to the neighboring pixels.\n */",
      "file" : "grayquant.c"
   },
   {
      "function" : "pixDitherToBinarySpec",
      "comment" : "/*!\n *  pixDitherToBinarySpec()\n *\n *      Input:  pixs\n *              lowerclip (lower clip distance to black; use 0 for default)\n *              upperclip (upper clip distance to white; use 0 for default)\n *      Return: pixd (dithered binary), or null on error\n *\n *  Notes:\n *      (1) See comments above in pixDitherToBinary() for details.\n *      (2) The input parameters lowerclip and upperclip specify the range\n *          of lower and upper values (near 0 and 255, rsp) that are\n *          clipped to black and white without propagating the excess.\n *          For that reason, lowerclip and upperclip should be small numbers.\n */",
      "file" : "grayquant.c"
   },
   {
      "function" : "pixDrawBoxa",
      "comment" : "/*!\n *  pixDrawBoxa()\n *\n *      Input:  pixs (any depth; can be cmapped)\n *              boxa (of boxes, to draw)\n *              width (of lines)\n *              val (rgba color to draw)\n *      Return: pixd (with outlines of boxes added), or null on error\n *\n *  Notes:\n *      (1) If pixs is 1 bpp or is colormapped, it is converted to 8 bpp\n *          and the boxa is drawn using a colormap; otherwise,\n *          it is converted to 32 bpp rgb.\n */",
      "file" : "boxfunc3.c"
   },
   {
      "function" : "pixDrawBoxaRandom",
      "comment" : "/*!\n *  pixDrawBoxaRandom()\n *\n *      Input:  pixs (any depth, can be cmapped)\n *              boxa (of boxes, to draw)\n *              width (thickness of line)\n *      Return: pixd (with box outlines drawn), or null on error\n *\n *  Notes:\n *      (1) If pixs is 1 bpp, we draw the boxa using a colormap;\n *          otherwise, we convert to 32 bpp.\n *      (2) We use up to 254 different colors for drawing the boxes.\n *      (3) If boxes overlap, the later ones draw over earlier ones.\n */",
      "file" : "boxfunc3.c"
   },
   {
      "function" : "pixEmbedForRotation",
      "comment" : "/*!\n *  pixEmbedForRotation()\n *\n *      Input:  pixs (1, 2, 4, 8, 32 bpp rgb)\n *              angle (radians; clockwise is positive)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)\n *              width (original width; use 0 to avoid embedding)\n *              height (original height; use 0 to avoid embedding)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) For very small rotations, just return a clone.\n *      (2) Generate larger image to embed pixs if necessary, and\n *          place the center of the input image in the center.\n *      (3) Rotation brings either white or black pixels in\n *          from outside the image.  For colormapped images where\n *          there is no white or black, a new color is added if\n *          possible for these pixels; otherwise, either the\n *          lightest or darkest color is used.  In most cases,\n *          the colormap will be removed prior to rotation.\n *      (4) The dest is to be expanded so that no image pixels\n *          are lost after rotation.  Input of the original width\n *          and height allows the expansion to stop at the maximum\n *          required size, which is a square with side equal to\n *          sqrt(w*w + h*h).\n *      (5) For an arbitrary angle, the expansion can be found by\n *          considering the UL and UR corners.  As the image is\n *          rotated, these move in an arc centered at the center of\n *          the image.  Normalize to a unit circle by dividing by half\n *          the image diagonal.  After a rotation of T radians, the UL\n *          and UR corners are at points T radians along the unit\n *          circle.  Compute the x and y coordinates of both these\n *          points and take the max of absolute values; these represent\n *          the half width and half height of the containing rectangle.\n *          The arithmetic is done using formulas for sin(a+b) and cos(a+b),\n *          where b = T.  For the UR corner, sin(a) = h/d and cos(a) = w/d.\n *          For the UL corner, replace a by (pi - a), and you have\n *          sin(pi - a) = h/d, cos(pi - a) = -w/d.  The equations\n *          given below follow directly.\n */",
      "file" : "rotate.c"
   },
   {
      "function" : "pixEndianByteSwap",
      "comment" : "/*!\n *  pixEndianByteSwap()\n *\n *      Input:  pixs\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is used on little-endian platforms to swap\n *          the bytes within a word; bytes 0 and 3 are swapped,\n *          and bytes 1 and 2 are swapped.\n *      (2) This is required for little-endians in situations\n *          where we convert from a serialized byte order that is\n *          in raster order, as one typically has in file formats,\n *          to one with MSB-to-the-left in each 32-bit word, or v.v.\n *          See pix.h for a description of the canonical format\n *          (MSB-to-the left) that is used for both little-endian\n *          and big-endian platforms.   For big-endians, the\n *          MSB-to-the-left word order has the bytes in raster\n *          order when serialized, so no byte flipping is required.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixEndianByteSwapNew",
      "comment" : "/*!\n *  pixEndianByteSwapNew()\n *\n *      Input:  pixs\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This is used to convert the data in a pix to a\n *          serialized byte buffer in raster order, and, for RGB,\n *          in order RGBA.  This requires flipping bytes within\n *          each 32-bit word for little-endian platforms, because the\n *          words have a MSB-to-the-left rule, whereas byte raster-order\n *          requires the left-most byte in each word to be byte 0.\n *          For big-endians, no swap is necessary, so this returns a clone.\n *      (2) Unlike pixEndianByteSwap(), which swaps the bytes in-place,\n *          this returns a new pix (or a clone).  We provide this\n *          because often when serialization is done, the source\n *          pix needs to be restored to canonical little-endian order,\n *          and this requires a second byte swap.  In such a situation,\n *          it is twice as fast to make a new pix in big-endian order,\n *          use it, and destroy it.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixEndianTwoByteSwap",
      "comment" : "/*!\n *  pixEndianTwoByteSwap()\n *\n *      Input:  pixs\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is used on little-endian platforms to swap the\n *          2-byte entities within a 32-bit word.\n *      (2) This is equivalent to a full byte swap, as performed\n *          by pixEndianByteSwap(), followed by byte swaps in\n *          each of the 16-bit entities separately.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixEndianTwoByteSwapNew",
      "comment" : "/*!\n *  pixEndianTwoByteSwapNew()\n *\n *      Input:  pixs\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is used on little-endian platforms to swap the\n *          2-byte entities within a 32-bit word.\n *      (2) This is equivalent to a full byte swap, as performed\n *          by pixEndianByteSwap(), followed by byte swaps in\n *          each of the 16-bit entities separately.\n *      (3) Unlike pixEndianTwoByteSwap(), which swaps the shorts in-place,\n *          this returns a new pix (or a clone).  We provide this\n *          to avoid having to swap twice in situations where the input\n *          pix must be restored to canonical little-endian order.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixEqual",
      "comment" : "/*!\n *  pixEqual()\n *\n *      Input:  pix1\n *              pix2\n *              &same  (<return> 1 if same; 0 if different)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) Equality is defined as having the same pixel values for\n *          each respective image pixel.\n *      (2) This works on two pix of any depth.  If one or both pix\n *          have a colormap, the depths can be different and the\n *          two pix can still be equal.\n *      (3) This ignores the alpha component for 32 bpp images.\n *      (4) If both pix have colormaps and the depths are equal,\n *          use the pixEqualWithCmap() function, which does a fast\n *          comparison if the colormaps are identical and a relatively\n *          slow comparison otherwise.\n *      (5) In all other cases, any existing colormaps must first be\n *          removed before doing pixel comparison.  After the colormaps\n *          are removed, the resulting two images must have the same depth.\n *          The \"lowest common denominator\" is RGB, but this is only\n *          chosen when necessary, or when both have colormaps but\n *          different depths.\n *      (6) For images without colormaps that are not 32 bpp, all bits\n *          in the image part of the data array must be identical.\n */",
      "file" : "compare.c"
   },
   {
      "function" : "pixEqualWithAlpha",
      "comment" : "/*!\n *  pixEqualWithAlpha()\n *\n *      Input:  pix1\n *              pix2\n *              use_alpha (1 to compare alpha in RGBA; 0 to ignore)\n *              &same  (<return> 1 if same; 0 if different)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) See notes in pixEqual().\n *      (2) This is more general than pixEqual(), in that for 32 bpp\n *          RGBA images, where spp = 4, you can optionally include\n *          the alpha component in the comparison.\n */",
      "file" : "compare.c"
   },
   {
      "function" : "pixEqualWithCmap",
      "comment" : "/*!\n *  pixEqualWithCmap()\n *\n *      Input:  pix1\n *              pix2\n *              &same\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This returns same = TRUE if the images have identical content.\n *      (2) Both pix must have a colormap, and be of equal size and depth.\n *          If these conditions are not satisfied, it is not an error;\n *          the returned result is same = FALSE.\n *      (3) We then check whether the colormaps are the same; if so,\n *          the comparison proceeds 32 bits at a time.\n *      (4) If the colormaps are different, the comparison is done by\n *          slow brute force.\n */",
      "file" : "compare.c"
   },
   {
      "function" : "pixEqualizeTRC",
      "comment" : "/*!\n *  pixEqualizeTRC()\n *\n *      Input:  pixd (<optional> null or equal to pixs)\n *              pixs (8 bpp gray, 32 bpp rgb, or colormapped)\n *              fract (fraction of equalization movement of pixel values)\n *              factor (subsampling factor; integer >= 1)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) pixd must either be null or equal to pixs.\n *          For in-place operation, set pixd == pixs:\n *             pixEqualizeTRC(pixs, pixs, ...);\n *          To get a new image, set pixd == null:\n *             pixd = pixEqualizeTRC(NULL, pixs, ...);\n *      (2) In histogram equalization, a tone reproduction curve\n *          mapping is used to make the number of pixels at each\n *          intensity equal.\n *      (3) If fract == 0.0, no equalization is performed; return a copy\n *          unless in-place, in which case this is a no-op.\n *          If fract == 1.0, equalization is complete.\n *      (4) Set the subsampling factor > 1 to reduce the amount of computation.\n *      (5) If pixs is colormapped, the colormap is removed and\n *          converted to rgb or grayscale.\n *      (6) If pixs has color, equalization is done in each channel\n *          separately.\n *      (7) Note that even if there is a colormap, we can get an\n *          in-place operation because the intermediate image pixt\n *          is copied back to pixs (which for in-place is the same\n *          as pixd).\n */",
      "file" : "enhance.c"
   },
   {
      "function" : "pixErode",
      "comment" : "/*!\n *  pixErode()\n *\n *      Input:  pixd  (<optional>; this can be null, equal to pixs,\n *                     or different from pixs)\n *              pixs (1 bpp)\n *              sel\n *      Return: pixd\n *\n *  Notes:\n *      (1) This erodes src using hits in Sel.\n *      (2) There are three cases:\n *          (a) pixd == null   (result into new pixd)\n *          (b) pixd == pixs   (in-place; writes result back to pixs)\n *          (c) pixd != pixs   (puts result into existing pixd)\n *      (3) For clarity, if the case is known, use these patterns:\n *          (a) pixd = pixErode(NULL, pixs, ...);\n *          (b) pixErode(pixs, pixs, ...);\n *          (c) pixErode(pixd, pixs, ...);\n *      (4) The size of the result is determined by pixs.\n */",
      "file" : "morph.c"
   },
   {
      "function" : "pixErodeBrick",
      "comment" : "/*!\n *  pixErodeBrick()\n *\n *      Input:  pixd  (<optional>; this can be null, equal to pixs,\n *                     or different from pixs)\n *              pixs (1 bpp)\n *              hsize (width of brick Sel)\n *              vsize (height of brick Sel)\n *      Return: pixd\n *\n *  Notes:\n *      (1) Sel is a brick with all elements being hits\n *      (2) The origin is at (x, y) = (hsize/2, vsize/2)\n *      (3) Do separably if both hsize and vsize are > 1.\n *      (4) There are three cases:\n *          (a) pixd == null   (result into new pixd)\n *          (b) pixd == pixs   (in-place; writes result back to pixs)\n *          (c) pixd != pixs   (puts result into existing pixd)\n *      (5) For clarity, if the case is known, use these patterns:\n *          (a) pixd = pixErodeBrick(NULL, pixs, ...);\n *          (b) pixErodeBrick(pixs, pixs, ...);\n *          (c) pixErodeBrick(pixd, pixs, ...);\n *      (6) The size of the result is determined by pixs.\n */",
      "file" : "morph.c"
   },
   {
      "function" : "pixErodeBrickDwa",
      "comment" : "/*!\n *  pixErodeBrickDwa()\n *\n *      Input:  pixd  (<optional>; this can be null, equal to pixs,\n *                     or different from pixs)\n *              pixs (1 bpp)\n *              hsize (width of brick Sel)\n *              vsize (height of brick Sel)\n *      Return: pixd\n *\n *  Notes:\n *      (1) These implement 2D brick Sels, using linear Sels generated\n *          with selaAddBasic().\n *      (2) A brick Sel has hits for all elements.\n *      (3) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)\n *      (4) Do separably if both hsize and vsize are > 1.\n *      (5) It is necessary that both horizontal and vertical Sels\n *          of the input size are defined in the basic sela.\n *      (6) Note that we must always set or clear the border pixels\n *          before each operation, depending on the the b.c.\n *          (symmetric or asymmetric).\n *      (7) There are three cases:\n *          (a) pixd == null   (result into new pixd)\n *          (b) pixd == pixs   (in-place; writes result back to pixs)\n *          (c) pixd != pixs   (puts result into existing pixd)\n *      (8) For clarity, if the case is known, use these patterns:\n *          (a) pixd = pixErodeBrickDwa(NULL, pixs, ...);\n *          (b) pixErodeBrickDwa(pixs, pixs, ...);\n *          (c) pixErodeBrickDwa(pixd, pixs, ...);\n *      (9) The size of the result is determined by pixs.\n *      (10) If either linear Sel is not found, this calls\n *           the appropriate decomposible function.\n */",
      "file" : "morphdwa.c"
   },
   {
      "function" : "pixErodeCompBrick",
      "comment" : "/*!\n *  pixErodeCompBrick()\n *\n *      Input:  pixd  (<optional>; this can be null, equal to pixs,\n *                     or different from pixs)\n *              pixs (1 bpp)\n *              hsize (width of brick Sel)\n *              vsize (height of brick Sel)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Sel is a brick with all elements being hits\n *      (2) The origin is at (x, y) = (hsize/2, vsize/2)\n *      (3) Do compositely for each dimension > 1.\n *      (4) Do separably if both hsize and vsize are > 1.\n *      (5) There are three cases:\n *          (a) pixd == null   (result into new pixd)\n *          (b) pixd == pixs   (in-place; writes result back to pixs)\n *          (c) pixd != pixs   (puts result into existing pixd)\n *      (6) For clarity, if the case is known, use these patterns:\n *          (a) pixd = pixErodeCompBrick(NULL, pixs, ...);\n *          (b) pixErodeCompBrick(pixs, pixs, ...);\n *          (c) pixErodeCompBrick(pixd, pixs, ...);\n *      (7) The dimensions of the resulting image are determined by pixs.\n *      (8) CAUTION: both hsize and vsize are being decomposed.\n *          The decomposer chooses a product of sizes (call them\n *          'terms') for each that is close to the input size,\n *          but not necessarily equal to it.  It attempts to optimize:\n *             (a) for consistency with the input values: the product\n *                 of terms is close to the input size\n *             (b) for efficiency of the operation: the sum of the\n *                 terms is small; ideally about twice the square\n *                 root of the input size.\n *          So, for example, if the input hsize = 37, which is\n *          a prime number, the decomposer will break this into two\n *          terms, 6 and 6, so that the net result is a dilation\n *          with hsize = 36.\n */",
      "file" : "morph.c"
   },
   {
      "function" : "pixErodeCompBrickDwa",
      "comment" : "/*!\n *  pixErodeCompBrickDwa()\n *\n *      Input:  pixd  (<optional>; this can be null, equal to pixs,\n *                     or different from pixs)\n *              pixs (1 bpp)\n *              hsize (width of brick Sel)\n *              vsize (height of brick Sel)\n *      Return: pixd\n *\n *  Notes:\n *      (1) These implement a separable composite erosion with 2D brick Sels.\n *      (2) For efficiency, it may decompose each linear morphological\n *          operation into two (brick + comb).\n *      (3) A brick Sel has hits for all elements.\n *      (4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)\n *      (5) Do separably if both hsize and vsize are > 1.\n *      (6) It is necessary that both horizontal and vertical Sels\n *          of the input size are defined in the basic sela.\n *      (7) There are three cases:\n *          (a) pixd == null   (result into new pixd)\n *          (b) pixd == pixs   (in-place; writes result back to pixs)\n *          (c) pixd != pixs   (puts result into existing pixd)\n *      (8) For clarity, if the case is known, use these patterns:\n *          (a) pixd = pixErodeCompBrickDwa(NULL, pixs, ...);\n *          (b) pixErodeCompBrickDwa(pixs, pixs, ...);\n *          (c) pixErodeCompBrickDwa(pixd, pixs, ...);\n *      (9) The size of pixd is determined by pixs.\n *      (10) CAUTION: both hsize and vsize are being decomposed.\n *          The decomposer chooses a product of sizes (call them\n *          'terms') for each that is close to the input size,\n *           but not necessarily equal to it.  It attempts to optimize:\n *              (a) for consistency with the input values: the product\n *                  of terms is close to the input size\n *              (b) for efficiency of the operation: the sum of the\n *                  terms is small; ideally about twice the square\n *                   root of the input size.\n *           So, for example, if the input hsize = 37, which is\n *           a prime number, the decomposer will break this into two\n *           terms, 6 and 6, so that the net result is a dilation\n *           with hsize = 36.\n */",
      "file" : "morphdwa.c"
   },
   {
      "function" : "pixErodeCompBrickExtendDwa",
      "comment" : "/*!\n *  pixErodeCompBrickExtendDwa()\n *\n *      Input:  pixd  (<optional>; this can be null, equal to pixs,\n *                     or different from pixs)\n *              pixs (1 bpp)\n *              hsize (width of brick Sel)\n *              vsize (height of brick Sel)\n *      Return: pixd\n *\n *  Notes:\n *      (1) See pixDilateCompBrickExtendDwa() for usage.\n *      (2) There is no need to call this directly:  pixErodeCompBrickDwa()\n *          calls this function if either brick dimension exceeds 63.\n */",
      "file" : "morphdwa.c"
   },
   {
      "function" : "pixErodeGray",
      "comment" : "/*!\n *  pixErodeGray()\n *\n *      Input:  pixs\n *              hsize  (of Sel; must be odd; origin implicitly in center)\n *              vsize  (ditto)\n *      Return: pixd\n *\n *  Notes:\n *      (1) Sel is a brick with all elements being hits\n *      (2) If hsize = vsize = 1, just returns a copy.\n */",
      "file" : "graymorph.c"
   },
   {
      "function" : "pixErodeGray3",
      "comment" : "/*!\n *  pixErodeGray3()\n *\n *      Input:  pixs (8 bpp, not cmapped)\n *              hsize  (1 or 3)\n *              vsize  (1 or 3)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Special case for 1x3, 3x1 or 3x3 brick sel (all hits)\n *      (2) If hsize = vsize = 1, just returns a copy.\n *      (3) It would be nice not to add a border, but it is required\n *          if we want the same results as from the general case.\n *          We add 4 bytes on the left to speed up the copying, and\n *          8 bytes at the right and bottom to allow unrolling of\n *          the computation of 8 pixels.\n */",
      "file" : "graymorph.c"
   },
   {
      "function" : "pixErodeGray3h",
      "comment" : "/*!\n *  pixErodeGray3h()\n *\n *      Input:  pixs (8 bpp, not cmapped)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Special case for horizontal 3x1 brick Sel;\n *          also used as the first step for the 3x3 brick Sel.\n */",
      "file" : "graymorph.c"
   },
   {
      "function" : "pixErodeGray3v",
      "comment" : "/*!\n *  pixErodeGray3v()\n *\n *      Input:  pixs (8 bpp, not cmapped)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Special case for vertical 1x3 brick Sel;\n *          also used as the second step for the 3x3 brick Sel.\n *      (2) Surprisingly, this is faster than setting up the\n *          lineptrs array and accessing into it; e.g.,\n *              val4 = GET_DATA_BYTE(lines8[i + 3], j);\n */",
      "file" : "graymorph.c"
   },
   {
      "function" : "pixExpandBinaryPower2",
      "comment" : "/*!\n *  pixExpandBinaryPower2()\n *\n *      Input:  pixs (1 bpp)\n *              factor (expansion factor: 1, 2, 4, 8, 16)\n *      Return: pixd (expanded 1 bpp by replication), or null on error\n */",
      "file" : "binexpand.c"
   },
   {
      "function" : "pixExpandBinaryReplicate",
      "comment" : "/*!\n *  pixExpandBinaryReplicate()\n *\n *      Input:  pixs (1 bpp)\n *              factor (integer scale factor for replicative expansion)\n *      Return: pixd (scaled up), or null on error\n */",
      "file" : "binexpand.c"
   },
   {
      "function" : "pixExpandReplicate",
      "comment" : "/*!\n *  pixExpandReplicate()\n *\n *      Input:  pixs (1, 2, 4, 8, 16, 32 bpp)\n *              factor (integer scale factor for replicative expansion)\n *      Return: pixd (scaled up), or null on error.\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixExtendByReplication",
      "comment" : "/*!\n *  pixExtendByReplication()\n *\n *      Input:  pixs (8 bpp)\n *              addw (number of extra pixels horizontally to add)\n *              addh (number of extra pixels vertically to add)\n *      Return: pixd (extended with replicated pixel values), or null on error\n *\n *  Notes:\n *      (1) The pixel values are extended to the left and down, as required.\n */",
      "file" : "adaptmap.c"
   },
   {
      "function" : "pixExtractBarcodeCrossings",
      "comment" : "/*!\n *  pixExtractBarcodeCrossings()\n *\n *      Input:  pixs (input image; 8 bpp)\n *              thresh (estimated pixel threshold for crossing\n *                      white <--> black; typ. ~120)\n *              debugflag (use 1 to generate debug output)\n *      Return: numa (of crossings, in pixel units), or null on error\n */",
      "file" : "readbarcode.c"
   },
   {
      "function" : "pixExtractBarcodeWidths1",
      "comment" : "/*!\n *  pixExtractBarcodeWidths1()\n *\n *      Input:  pixs (input image; 8 bpp)\n *              thresh (estimated pixel threshold for crossing\n *                      white <--> black; typ. ~120)\n *              binfract (histo binsize as a fraction of minsize; e.g., 0.25)\n *              &naehist (<optional return> histogram of black widths; NULL ok)\n *              &naohist (<optional return> histogram of white widths; NULL ok)\n *              debugflag (use 1 to generate debug output)\n *      Return: nad (numa of barcode widths in encoded integer units),\n *                  or null on error\n *\n *  Note:\n *     (1) The widths are alternating black/white, starting with black\n *         and ending with black.\n *     (2) This method uses the widths of the bars directly, in terms\n *         of the (float) number of pixels between transitions.\n *         The histograms of these widths for black and white bars is\n *         generated and interpreted.\n */",
      "file" : "readbarcode.c"
   },
   {
      "function" : "pixExtractBarcodeWidths2",
      "comment" : "/*!\n *  pixExtractBarcodeWidths2()\n *\n *      Input:  pixs (input image; 8 bpp)\n *              thresh (estimated pixel threshold for crossing\n *                      white <--> black; typ. ~120)\n *              &width (<optional return> best decoding window width, in pixels)\n *              &nac (<optional return> number of transitions in each window)\n *              debugflag (use 1 to generate debug output)\n *      Return: nad (numa of barcode widths in encoded integer units),\n *                  or null on error\n *\n *  Notes:\n *      (1) The widths are alternating black/white, starting with black\n *          and ending with black.\n *      (2) The optional best decoding window width is the width of the window\n *          that is used to make a decision about whether a transition occurs.\n *          It is approximately the average width in pixels of the narrowest\n *          white and black bars (i.e., those corresponding to unit width).\n *      (3) The optional return signal @nac is a sequence of 0s, 1s,\n *          and perhaps a few 2s, giving the number of crossings in each window.\n *          On the occasion where there is a '2', it is interpreted as\n *          as ending two runs: the previous one and another one that has length 1.\n */",
      "file" : "readbarcode.c"
   },
   {
      "function" : "pixExtractBarcodes",
      "comment" : "/*!\n *  pixExtractBarcodes()\n *\n *      Input:  pixs (8 bpp, no colormap)\n *              debugflag (use 1 to generate debug output)\n *      Return: pixa (deskewed and cropped barcodes), or null if\n *                    none found or on error\n */",
      "file" : "readbarcode.c"
   },
   {
      "function" : "pixExtractBorderConnComps",
      "comment" : "/*!\n *  pixExtractBorderConnComps()\n *\n *      Input:  pixs (1 bpp)\n *              filling connectivity (4 or 8)\n *      Return: pixd  (all pixels in the src that are in connected\n *                     components touching the border), or null on error\n */",
      "file" : "seedfill.c"
   },
   {
      "function" : "pixExtractBoundary",
      "comment" : "/*!\n *  pixExtractBoundary()\n *\n *      Input:  pixs (1 bpp)\n *              type (0 for background pixels; 1 for foreground pixels)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Extracts the fg or bg boundary pixels for each component.\n *          Components are assumed to end at the boundary of pixs.\n */",
      "file" : "morphapp.c"
   },
   {
      "function" : "pixExtractData",
      "comment" : "/*!\n *  pixExtractData()\n *\n *  Notes:\n *      (1) This extracts the pix image data for use in another context.\n *          The caller still needs to use pixDestroy() on the input pix.\n *      (2) If refcount == 1, the data is extracted and the\n *          pix->data ptr is set to NULL.\n *      (3) If refcount > 1, this simply returns a copy of the data,\n *          using the pix allocator, and leaving the input pix unchanged.\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixExtractOnLine",
      "comment" : "/*!\n *  pixExtractOnLine()\n *\n *      Input:  pixs (1 bpp or 8 bpp; no colormap)\n *              x1, y1 (one end point for line)\n *              x2, y2 (another end pt for line)\n *              factor (sampling; >= 1)\n *      Return: na (of pixel values along line), or null on error.\n *\n *  Notes:\n *      (1) Input end points are clipped to the pix.\n *      (2) If the line is either horizontal, or closer to horizontal\n *          than to vertical, the points will be extracted from left\n *          to right in the pix.  Likewise, if the line is vertical,\n *          or closer to vertical than to horizontal, the points will\n *          be extracted from top to bottom.\n *      (3) Can be used with numaCountReverals(), for example, to\n *          characterize the intensity smoothness along a line.\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixFHMTGen_1",
      "comment" : "/*!\n *  pixFHMTGen_1()\n *\n *      Input:  pixd (usual 3 choices: null, == pixs, != pixs)\n *              pixs (1 bpp)\n *              sel name\n *      Return: pixd\n *\n *  Notes:\n *      (1) This is a dwa implementation of the hit-miss transform\n *          on pixs by the sel.\n *      (2) The sel must be limited in size to not more than 31 pixels\n *          about the origin.  It must have at least one hit, and it\n *          can have any number of misses.\n *      (3) This handles all required setting of the border pixels\n *          before erosion and dilation.\n */",
      "file" : "fhmtgen.1.c"
   },
   {
      "function" : "pixFMorphopGen_1",
      "comment" : "/*!\n *  pixFMorphopGen_1()\n *\n *      Input:  pixd (usual 3 choices: null, == pixs, != pixs)\n *              pixs (1 bpp)\n *              operation  (L_MORPH_DILATE, L_MORPH_ERODE,\n *                          L_MORPH_OPEN, L_MORPH_CLOSE)\n *              sel name\n *      Return: pixd\n *\n *  Notes:\n *      (1) This is a dwa operation, and the Sels must be limited in\n *          size to not more than 31 pixels about the origin.\n *      (2) A border of appropriate size (32 pixels, or 64 pixels\n *          for safe closing with asymmetric b.c.) must be added before\n *          this function is called.\n *      (3) This handles all required setting of the border pixels\n *          before erosion and dilation.\n *      (4) The closing operation is safe; no pixels can be removed\n *          near the boundary.\n */",
      "file" : "fmorphgen.1.c"
   },
   {
      "function" : "pixFMorphopGen_2",
      "comment" : "/*!\n *  pixFMorphopGen_2()\n *\n *      Input:  pixd (usual 3 choices: null, == pixs, != pixs)\n *              pixs (1 bpp)\n *              operation  (L_MORPH_DILATE, L_MORPH_ERODE,\n *                          L_MORPH_OPEN, L_MORPH_CLOSE)\n *              sel name\n *      Return: pixd\n *\n *  Notes:\n *      (1) This is a dwa operation, and the Sels must be limited in\n *          size to not more than 31 pixels about the origin.\n *      (2) A border of appropriate size (32 pixels, or 64 pixels\n *          for safe closing with asymmetric b.c.) must be added before\n *          this function is called.\n *      (3) This handles all required setting of the border pixels\n *          before erosion and dilation.\n *      (4) The closing operation is safe; no pixels can be removed\n *          near the boundary.\n */",
      "file" : "dwacomb.2.c"
   },
   {
      "function" : "pixFadeWithGray",
      "comment" : "/*!\n *  pixFadeWithGray()\n *\n *      Input:  pixs (colormapped or 8 bpp or 32 bpp)\n *              pixb (8 bpp blender)\n *              factor (multiplicative factor to apply to blender value)\n *              type (L_BLEND_TO_WHITE, L_BLEND_TO_BLACK)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This function combines two pix aligned to the UL corner; they\n *          need not be the same size.\n *      (2) Each pixel in pixb is multiplied by 'factor' divided by 255, and\n *          clipped to the range [0 ... 1].  This gives the fade fraction\n *          to be appied to pixs.  Fade either to white (L_BLEND_TO_WHITE)\n *          or to black (L_BLEND_TO_BLACK).\n */",
      "file" : "blend.c"
   },
   {
      "function" : "pixFastTophat",
      "comment" : "/*!\n *  pixFastTophat()\n *\n *      Input:  pixs\n *              xsize (width of max/min op, smoothing; any integer >= 1)\n *              ysize (height of max/min op, smoothing; any integer >= 1)\n *              type   (L_TOPHAT_WHITE: image - min\n *                      L_TOPHAT_BLACK: max - image)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Don't be fooled. This is NOT a tophat.  It is a tophat-like\n *          operation, where the result is similar to what you'd get\n *          if you used an erosion instead of an opening, or a dilation\n *          instead of a closing.\n *      (2) Instead of opening or closing at full resolution, it does\n *          a fast downscale/minmax operation, then a quick small smoothing\n *          at low res, a replicative expansion of the \"background\"\n *          to full res, and finally a removal of the background level\n *          from the input image.  The smoothing step may not be important.\n *      (3) It does not remove noise as well as a tophat, but it is\n *          5 to 10 times faster.\n *          If you need the preciseness of the tophat, don't use this.\n *      (4) The L_TOPHAT_WHITE flag emphasizes small bright regions,\n *          whereas the L_TOPHAT_BLACK flag emphasizes small dark regions.\n */",
      "file" : "morphapp.c"
   },
   {
      "function" : "pixFewColorsMedianCutQuantMixed",
      "comment" : "/*!\n *  pixFewColorsMedianCutQuantMixed()\n *\n *      Input:  pixs (32 bpp rgb)\n *              ncolor (number of colors to be assigned to pixels with\n *                       significant color)\n *              ngray (number of gray colors to be used; must be >= 2)\n *              maxncolors (maximum number of colors to be returned\n *                         from pixColorsForQuantization(); use 0 for default)\n *              darkthresh (threshold near black; if the lightest component\n *                          is below this, the pixel is not considered to\n *                          be gray or color; use 0 for default)\n *              lightthresh (threshold near white; if the darkest component\n *                           is above this, the pixel is not considered to\n *                           be gray or color; use 0 for default)\n *              diffthresh (thresh for the max difference between component\n *                          values; for differences below this, the pixel\n *                          is considered to be gray; use 0 for default)\n *                          considered gray; use 0 for default)\n *      Return: pixd (8 bpp, median cut quantized for pixels that are\n *                    not gray; gray pixels are quantized separately\n *                    over the full gray range); null if too many colors\n *                    or on error\n *\n *  Notes:\n *      (1) This is the \"few colors\" version of pixMedianCutQuantMixed().\n *          It fails (returns NULL) if it finds more than maxncolors, but\n *          otherwise it gives the same result.\n *      (2) Recommended input parameters are:\n *              @maxncolors:  20\n *              @darkthresh:  20\n *              @lightthresh: 244\n *              @diffthresh:  15  (any higher can miss colors differing\n *                                 slightly from gray)\n *      (3) Both ncolor and ngray should be at least equal to maxncolors.\n *          If they're not, they are automatically increased, and a\n *          warning is given.\n *      (4) If very little color content is found, the input is\n *          converted to gray and quantized in equal intervals.\n *      (5) This can be useful for quantizing orthographically generated\n *          images such as color maps, where there may be more than 256 colors\n *          because of aliasing or jpeg artifacts on text or lines, but\n *          there are a relatively small number of solid colors.\n *      (6) Example of usage:\n *             // Try to quantize, using default values for mixed med cut\n *             Pix *pixq = pixFewColorsMedianCutQuantMixed(pixs, 100, 20,\n *                             0, 0, 0, 0);\n *             if (!pixq)  // too many colors; don't quantize\n *                 pixq = pixClone(pixs);\n */",
      "file" : "colorquant2.c"
   },
   {
      "function" : "pixFewColorsOctcubeQuant1",
      "comment" : "/*!\n *  pixFewColorsOctcubeQuant1()\n *\n *      Input:  pixs (32 bpp rgb)\n *              level (significant bits for each of RGB; valid in [1...6])\n *      Return: pixd (quantized to octcube) or null on error\n *\n *  Notes:\n *      (1) Generates a colormapped image, where the colormap table values\n *          are the averages of all pixels that are found in the octcube.\n *      (2) This fails if there are more than 256 colors (i.e., more\n *          than 256 occupied octcubes).\n *      (3) Often level 3 (512 octcubes) will succeed because not more\n *          than half of them are occupied with 1 or more pixels.\n *      (4) The depth of the result, which is either 2, 4 or 8 bpp,\n *          is the minimum required to hold the number of colors that\n *          are found.\n *      (5) This can be useful for quantizing orthographically generated\n *          images such as color maps, where there may be more than 256 colors\n *          because of aliasing or jpeg artifacts on text or lines, but\n *          there are a relatively small number of solid colors.  Then,\n *          use with level = 3 can often generate a compact and accurate\n *          representation of the original RGB image.  For this purpose,\n *          it is better than pixFewColorsOctcubeQuant2(), because it\n *          uses the average value of pixels in the octcube rather\n *          than the first found pixel.  It is also simpler to use,\n *          because it generates the histogram internally.\n */",
      "file" : "colorquant1.c"
   },
   {
      "function" : "pixFewColorsOctcubeQuant2",
      "comment" : "/*!\n *  pixFewColorsOctcubeQuant2()\n *\n *      Input:  pixs (32 bpp rgb)\n *              level (of octcube indexing, for histogram: 3, 4, 5, 6)\n *              na (histogram of pixel occupation in octree leaves at\n *                  given level)\n *              ncolors (number of occupied octree leaves at given level)\n *              &nerrors (<optional return> num of pixels not exactly\n *                        represented in the colormap)\n *      Return: pixd (2, 4 or 8 bpp with colormap), or null on error\n *\n *  Notes:\n *      (1) Generates a colormapped image, where the colormap table values\n *          are the averages of all pixels that are found in the octcube.\n *      (2) This fails if there are more than 256 colors (i.e., more\n *          than 256 occupied octcubes).\n *      (3) Often level 3 (512 octcubes) will succeed because not more\n *          than half of them are occupied with 1 or more pixels.\n *      (4) For an image with not more than 256 colors, it is unlikely\n *          that two pixels of different color will fall in the same\n *          octcube at level = 4.   However it is possible, and this\n *          function optionally returns @nerrors, the number of pixels\n *          where, because more than one color is in the same octcube,\n *          the pixel color is not exactly reproduced in the colormap.\n *          The colormap for an occupied leaf of the octree contains\n *          the color of the first pixel encountered in that octcube.\n *      (5) This differs from pixFewColorsOctcubeQuant1(), which also\n *          requires not more than 256 occupied leaves, but represents\n *          the color of each leaf by an average over the pixels in\n *          that leaf.  This also requires precomputing the histogram\n *          of occupied octree leaves, which is generated using\n *          pixOctcubeHistogram().\n *      (6) This is used in pixConvertRGBToColormap() for images that\n *          are determined, by their histogram, to have relatively few\n *          colors.  This typically happens with orthographically\n *          produced images (as oppopsed to natural images), where\n *          it is expected that most of the pixels within a leaf\n *          octcube have exactly the same color, and quantization to\n *          that color is lossless.\n */",
      "file" : "colorquant1.c"
   },
   {
      "function" : "pixFewColorsOctcubeQuantMixed",
      "comment" : "/*!\n *  pixFewColorsOctcubeQuantMixed()\n *\n *      Input:  pixs (32 bpp rgb)\n *              level (significant octcube bits for each of RGB;\n *                     valid in [1...6]; use 0 for default)\n *              darkthresh (threshold near black; if the lightest component\n *                          is below this, the pixel is not considered to\n *                          be gray or color; uses 0 for default)\n *              lightthresh (threshold near white; if the darkest component\n *                           is above this, the pixel is not considered to\n *                           be gray or color; use 0 for default)\n *              diffthresh (thresh for the max difference between component\n *                          values; for differences below this, the pixel\n *                          is considered to be gray; use 0 for default)\n *                          considered gray; use 0 for default)\n *              minfract (min fraction of pixels for gray histo bin;\n *                        use 0.0 for default)\n *              maxspan (max size of gray histo bin; use 0 for default)\n *      Return: pixd (8 bpp, quantized to octcube for pixels that are\n *                    not gray; gray pixels are quantized separately\n *                    over the full gray range), or null on error\n *\n *  Notes:\n *      (1) First runs pixFewColorsOctcubeQuant1().  If this succeeds,\n *          it separates the color from gray(ish) entries in the cmap,\n *          and re-quantizes the gray pixels.  The result has some pixels\n *          in color and others in gray.\n *      (2) This fails if there are more than 256 colors (i.e., more\n *          than 256 occupied octcubes in the color quantization).\n *      (3) Level 3 (512 octcubes) will usually succeed because not more\n *          than half of them are occupied with 1 or more pixels.\n *      (4) This uses the criterion from pixColorFraction() for deciding\n *          if a colormap entry is color; namely, if the color components\n *          are not too close to either black or white, and the maximum\n *          difference between component values equals or exceeds a threshold.\n *      (5) For quantizing the gray pixels, it uses a histogram-based\n *          method where input parameters determining the buckets are\n *          the minimum population fraction and the maximum allowed size.\n *      (6) Recommended input parameters are:\n *              @level:  3 or 4  (3 is default)\n *              @darkthresh:  20\n *              @lightthresh: 244\n *              @diffthresh: 20\n *              @minfract: 0.05\n *              @maxspan: 15\n *          These numbers are intended to be conservative (somewhat over-\n *          sensitive) in color detection,  It's usually better to pay\n *          extra with octcube quantization of a grayscale image than\n *          to use grayscale quantization on an image that has some\n *          actual color.  Input 0 on any of these to get the default.\n *      (7) This can be useful for quantizing orthographically generated\n *          images such as color maps, where there may be more than 256 colors\n *          because of aliasing or jpeg artifacts on text or lines, but\n *          there are a relatively small number of solid colors.  It usually\n *          gives results that are better than pixOctcubeQuantMixedWithGray(),\n *          both in size and appearance.  But it is a bit slower.\n */",
      "file" : "colorquant1.c"
   },
   {
      "function" : "pixFillBgFromBorder",
      "comment" : "/*!\n *  pixFillBgFromBorder()\n *\n *      Input:  pixs (1 bpp)\n *              filling connectivity (4 or 8)\n *      Return: pixd (with the background c.c. touching the border\n *                    filled to foreground), or null on error\n *\n *  Notes:\n *      (1) This fills all bg components touching the border to fg.\n *          It is the photometric inverse of pixRemoveBorderConnComps().\n *      (2) Invert the result to get the \"holes\" left after this fill.\n *          This can be done multiple times, extracting holes within\n *          holes after each pair of fillings.  Specifically, this code\n *          peels away n successive embeddings of components:\n *              pix1 = <initial image>\n *              for (i = 0; i < 2 * n; i++) {\n *                   pix2 = pixFillBgFromBorder(pix1, 8);\n *                   pixInvert(pix2, pix2);\n *                   pixDestroy(&pix1);\n *                   pix1 = pix2;\n *              }\n\n */",
      "file" : "seedfill.c"
   },
   {
      "function" : "pixFillClosedBorders",
      "comment" : "/*!\n *  pixFillClosedBorders()\n *\n *      Input:  pixs (1 bpp)\n *              filling connectivity (4 or 8)\n *      Return: pixd  (all topologically outer closed borders are filled\n *                     as connected comonents), or null on error\n *\n *  Notes:\n *      (1) Start with 1-pixel black border on otherwise white pixd\n *      (2) Subtract input pixs to remove border pixels that were\n *          also on the closed border\n *      (3) Use the inverted pixs as the filling mask to fill in\n *          all the pixels from the outer border to the closed border\n *          on pixs\n *      (4) Invert the result to get the filled component, including\n *          the input border\n *      (5) If the borders are 4-c.c., use 8-c.c. filling, and v.v.\n *      (6) Closed borders within c.c. that represent holes, etc., are filled.\n */",
      "file" : "seedfill.c"
   },
   {
      "function" : "pixFillHolesToBoundingRect",
      "comment" : "/*!\n *  pixFillHolesToBoundingRect()\n *\n *      Input:  pixs (1 bpp)\n *              minsize (min number of pixels in the hole)\n *              maxhfract (max hole area as fraction of fg pixels in the cc)\n *              minfgfract (min fg area as fraction of bounding rectangle)\n *      Return: pixd (pixs, with some holes possibly filled and some c.c.\n *                    possibly expanded to their bounding rects),\n *                    or null on error\n *\n *  Notes:\n *      (1) This does not fill holes that are smaller in area than 'minsize'.\n *      (2) This does not fill holes with an area larger than\n *          'maxhfract' times the fg area of the c.c.\n *      (3) This does not expand the fg of the c.c. to bounding rect if\n *          the fg area is less than 'minfgfract' times the area of the\n *          bounding rect.\n *      (4) The decisions are made as follows:\n *           - Decide if we are filling the holes; if so, when using\n *             the fg area, include the filled holes.\n *           - Decide based on the fg area if we are filling to a bounding rect.\n *             If so, do it.\n *             If not, fill the holes if the condition is satisfied.\n *      (5) The choice of minsize depends on the resolution.\n *      (6) For solidifying image mask regions on printed materials,\n *          which tend to be rectangular, values for maxhfract\n *          and minfgfract around 0.5 are reasonable.\n */",
      "file" : "seedfill.c"
   },
   {
      "function" : "pixFillMapHoles",
      "comment" : "/*!\n *  pixFillMapHoles()\n *\n *      Input:  pix (8 bpp; a map, with one pixel for each tile in\n *              a larger image)\n *              nx (number of horizontal pixel tiles that are entirely\n *                  covered with pixels in the original source image)\n *              ny (ditto for the number of vertical pixel tiles)\n *              filltype (L_FILL_WHITE or L_FILL_BLACK)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is an in-place operation on pix (the map).  pix is\n *          typically a low-resolution version of some other image\n *          from which it was derived, where each pixel in pix\n *          corresponds to a rectangular tile (say, m x n) of pixels\n *          in the larger image.  All we need to know about the larger\n *          image is whether or not the rightmost column and bottommost\n *          row of pixels in pix correspond to tiles that are\n *          only partially covered by pixels in the larger image.\n *      (2) Typically, some number of pixels in the input map are\n *          not known, and their values must be determined by near\n *          pixels that are known.  These unknown pixels are the 'holes'.\n *          They can take on only two values, 0 and 255, and the\n *          instruction about which to fill is given by the filltype flag.\n *      (3) The \"holes\" can come from two sources.  The first is when there\n *          are not enough foreground or background pixels in a tile;\n *          the second is when a tile is at least partially covered\n *          by an image mask.  If we're filling holes in a fg mask,\n *          the holes are initialized to black (0) and use L_FILL_BLACK.\n *          For filling holes in a bg mask, initialize the holes to\n *          white (255) and use L_FILL_WHITE.\n *      (4) If w is the map width, nx = w or nx = w - 1; ditto for h and ny.\n */",
      "file" : "adaptmap.c"
   },
   {
      "function" : "pixFillPolygon",
      "comment" : "/*!\n *  pixFillPolygon()\n *\n *      Input:  pixs (1 bpp, with 4-connected polygon outline)\n *              pta (vertices of the polygon)\n *              xmin, ymin (min values of vertices of polygon)\n *      Return: pixd (with outline filled), or null on error\n *\n *  Notes:\n *      (1) This fills the interior of the polygon, returning a\n *          new pix.  It works for both convex and non-convex polygons.\n *      (2) To generate a filled polygon from a pta:\n *            PIX *pixt = pixRenderPolygon(pta, 1, &xmin, &ymin);\n *            PIX *pixd = pixFillPolygon(pixt, pta, xmin, ymin);\n *            pixDestroy(&pixt);\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "pixFinalAccumulate",
      "comment" : "/*!\n *  pixFinalAccumulate()\n *\n *      Input:  pixs (32 bpp)\n *              offset (same as used for initialization)\n *              depth  (8, 16 or 32 bpp, of destination)\n *      Return: pixd (8, 16 or 32 bpp), or null on error\n *\n *  Notes:\n *      (1) The offset must be >= 0 and should not exceed 0x40000000.\n *      (2) The offset is subtracted from the src 32 bpp image\n *      (3) For 8 bpp dest, the result is clipped to [0, 0xff]\n *      (4) For 16 bpp dest, the result is clipped to [0, 0xffff]\n */",
      "file" : "pixarith.c"
   },
   {
      "function" : "pixFinalAccumulateThreshold",
      "comment" : "/*!\n *  pixFinalAccumulateThreshold()\n *\n *      Input:  pixs (32 bpp)\n *              offset (same as used for initialization)\n *              threshold (values less than this are set in the destination)\n *      Return: pixd (1 bpp), or null on error\n *\n *  Notes:\n *      (1) The offset must be >= 0 and should not exceed 0x40000000.\n *      (2) The offset is subtracted from the src 32 bpp image\n */",
      "file" : "pixarith.c"
   },
   {
      "function" : "pixFindAreaFraction",
      "comment" : "/*!\n *  pixFindAreaFraction()\n *\n *      Input:  pixs (1 bpp)\n *              tab (<optional> pixel sum table, can be NULL)\n *              &fract (<return> fg area/size ratio)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This finds the ratio of the number of fg pixels to the\n *          size of the pix (w * h).  It is typically used for a\n *          single connected component.\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixFindAreaFractionMasked",
      "comment" : "/*!\n *  pixFindAreaFractionMasked()\n *\n *      Input:  pixs (1 bpp, typically a single component)\n *              box (<optional> for pixs relative to pixm)\n *              pixm (1 bpp mask, typically over the entire image from\n *                    which the component pixs was extracted)\n *              tab (<optional> pixel sum table, can be NULL)\n *              &fract (<return> fg area/size ratio)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This finds the ratio of the number of masked fg pixels\n *          in pixs to the total number of fg pixels in pixs.\n *          It is typically used for a single connected component.\n *          If there are no fg pixels, this returns a ratio of 0.0.\n *      (2) The box gives the location of the pix relative to that\n *          of the UL corner of the mask.  Therefore, the rasterop\n *          is performed with the pix translated to its location\n *          (x, y) in the mask before ANDing.\n *          If box == NULL, the UL corners of pixs and pixm are aligned.\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixFindAreaPerimRatio",
      "comment" : "/*!\n *  pixFindAreaPerimRatio()\n *\n *      Input:  pixs (1 bpp)\n *              tab (<optional> pixel sum table, can be NULL)\n *              &fract (<return> area/perimeter ratio)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The area is the number of fg pixels that are not on the\n *          boundary (i.e., are not 8-connected to a bg pixel), and the\n *          perimeter is the number of fg boundary pixels.  Returns\n *          0.0 if there are no fg pixels.\n *      (2) This function is retained because clients are using it.\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixFindBaselines",
      "comment" : "/*!\n *  pixFindBaselines()\n *\n *      Input:  pixs (1 bpp)\n *              &pta (<optional return> pairs of pts corresponding to\n *                    approx. ends of each text line)\n *              debug (usually 0; set to 1 for debugging output)\n *      Return: na (of baseline y values), or null on error\n *\n *  Notes:\n *      (1) Input binary image must have text lines already aligned\n *          horizontally.  This can be done by either rotating the\n *          image with pixDeskew(), or, if a projective transform\n *          is required, by doing pixDeskewLocal() first.\n *      (2) Input null for &pta if you don't want this returned.\n *          The pta will come in pairs of points (left and right end\n *          of each baseline).\n *      (3) Caution: this will not work properly on text with multiple\n *          columns, where the lines are not aligned between columns.\n *          If there are multiple columns, they should be extracted\n *          separately before finding the baselines.\n *      (4) This function constructs different types of output\n *          for baselines; namely, a set of raster line values and\n *          a set of end points of each baseline.\n *      (5) This function was designed to handle short and long text lines\n *          without using dangerous thresholds on the peak heights.  It does\n *          this by combining the differential signal with a morphological\n *          analysis of the locations of the text lines.  One can also\n *          combine this data to normalize the peak heights, by weighting\n *          the differential signal in the region of each baseline\n *          by the inverse of the width of the text line found there.\n *      (6) There are various debug sections that can be turned on\n *          with the debug flag.\n */",
      "file" : "baseline.c"
   },
   {
      "function" : "pixFindCornerPixels",
      "comment" : "/*!\n *  pixFindCornerPixels()\n *\n *      Input:  pixs (1 bpp)\n *      Return: pta, or null on error\n *\n *  Notes:\n *      (1) Finds the 4 corner-most pixels, as defined by a search\n *          inward from each corner, using a 45 degree line.\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "pixFindDifferentialSquareSum",
      "comment" : "/*!\n *  pixFindDifferentialSquareSum()\n *\n *      Input:  pixs\n *              &sum  (<return> result)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) At the top and bottom, we skip:\n *           - at least one scanline\n *           - not more than 10% of the image height\n *           - not more than 5% of the image width\n */",
      "file" : "skew.c"
   },
   {
      "function" : "pixFindEqualValues",
      "comment" : "/*!\n *  pixFindEqualValues()\n *\n *      Input:  pixs1 (8 bpp)\n *              pixs2 (8 bpp)\n *      Return: pixd (1 bpp mask), or null on error\n *\n *  Notes:\n *      (1) The two images are aligned at the UL corner, and the returned\n *          image has ON pixels where the pixels in pixs1 and pixs2\n *          have equal values.\n */",
      "file" : "seedfill.c"
   },
   {
      "function" : "pixFindHistoPeaksHSV",
      "comment" : "/*!\n *  pixFindHistoPeaksHSV()\n *\n *      Input:  pixs (32 bpp; HS, HV or SV histogram; not changed)\n *              type (L_HS_HISTO, L_HV_HISTO or L_SV_HISTO)\n *              width (half width of sliding window)\n *              height (half height of sliding window)\n *              npeaks (number of peaks to look for)\n *              erasefactor (ratio of erase window size to sliding window size)\n *              &pta (locations of maximum for each integrated peak area)\n *              &natot (integrated peak areas)\n *              &pixa (<optional return> pixa for debugging; NULL to skip)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) pixs is a 32 bpp histogram in a pair of HSV colorspace.  It\n *          should be thought of as a single sample with 32 bps (bits/sample).\n *      (2) After each peak is found, the peak is erased with a window\n *          that is centered on the peak and scaled from the sliding\n *          window by @erasefactor.  Typically, @erasefactor is chosen\n *          to be > 1.0.\n *      (3) Data for a maximum of @npeaks is returned in @pta and @natot.\n *      (4) For debugging, after the pixa is returned, display with:\n *          pixd = pixaDisplayTiledInRows(pixa, 32, 1000, 1.0, 0, 30, 2);\n */",
      "file" : "colorspace.c"
   },
   {
      "function" : "pixFindHorizontalRuns",
      "comment" : "/*!\n *  pixFindHorizontalRuns()\n *\n *      Input:  pix (1 bpp)\n *              y (line to traverse)\n *              xstart (returns array of start positions for fg runs)\n *              xend (returns array of end positions for fg runs)\n *              &n  (<return> the number of runs found)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This finds foreground horizontal runs on a single scanline.\n *      (2) To find background runs, use pixInvert() before applying\n *          this function.\n *      (3) The xstart and xend arrays are input.  They should be\n *          of size w/2 + 1 to insure that they can hold\n *          the maximum number of runs in the raster line.\n */",
      "file" : "runlength.c"
   },
   {
      "function" : "pixFindLargestRectangle",
      "comment" : "/*!\n *  pixFindLargestRectangle()\n *\n *      Input:  pixs  (1 bpp)\n *              polarity (0 within background, 1 within foreground)\n *              &box (<return> largest rectangle, either by area or\n *                    by perimeter)\n *              debugflag (1 to output image with rectangle drawn on it)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Why is this here?  This is a simple and elegant solution to\n *          a problem in computational geometry that at first appears\n *          quite difficult: what is the largest rectangle that can\n *          be placed in the image, covering only pixels of one polarity\n *          (bg or fg)?  The solution is O(n), where n is the number\n *          of pixels in the image, and it requires nothing more than\n *          using a simple recursion relation in a single sweep of the image.\n *      (2) In a sweep from UL to LR with left-to-right being the fast\n *          direction, calculate the largest white rectangle at (x, y),\n *          using previously calculated values at pixels #1 and #2:\n *             #1:    (x, y - 1)\n *             #2:    (x - 1, y)\n *          We also need the most recent \"black\" pixels that were seen\n *          in the current row and column.\n *          Consider the largest area.  There are only two possibilities:\n *             (a)  Min(w(1), horizdist) * (h(1) + 1)\n *             (b)  Min(h(2), vertdist) * (w(2) + 1)\n *          where\n *             horizdist: the distance from the rightmost \"black\" pixel seen\n *                        in the current row across to the current pixel\n *             vertdist: the distance from the lowest \"black\" pixel seen\n *                       in the current column down to the current pixel\n *          and we choose the Max of (a) and (b).\n *      (3) To convince yourself that these recursion relations are correct,\n *          it helps to draw the maximum rectangles at #1 and #2.\n *          Then for #1, you try to extend the rectangle down one line,\n *          so that the height is h(1) + 1.  Do you get the full\n *          width of #1, w(1)?  It depends on where the black pixels are\n *          in the current row.  You know the final width is bounded by w(1)\n *          and w(2) + 1, but the actual value depends on the distribution\n *          of black pixels in the current row that are at a distance\n *          from the current pixel that is between these limits.\n *          We call that value \"horizdist\", and the area is then given\n *          by the expression (a) above.  Using similar reasoning for #2,\n *          where you attempt to extend the rectangle to the right\n *          by 1 pixel, you arrive at (b).  The largest rectangle is\n *          then found by taking the Max.\n */",
      "file" : "maze.c"
   },
   {
      "function" : "pixFindMinRunsOrthogonal",
      "comment" : "/*!\n *  pixFindMinRunsOrthogonal()\n *\n *      Input:   pixs (1 bpp)\n *               angle (in radians)\n *               depth (of pixd: 8 or 16 bpp)\n *      Return:  pixd (8 or 16 bpp), or null on error\n *\n *  Notes:\n *      (1) This computes, for each fg pixel in pixs, the minimum of\n *          the runlengths going through that pixel in two orthogonal\n *          directions: at @angle and at (90 + @angle).\n *      (2) We use rotation by shear because the forward and backward\n *          rotations by the same angle are exact inverse operations.\n *          As a result, the nonzero pixels in pixd correspond exactly\n *          to the fg pixels in pixs.  This is not the case with\n *          sampled rotation, due to spatial quantization.  Nevertheless,\n *          the result suffers from lack of exact correspondence\n *          between original and rotated pixels, also due to spatial\n *          quantization, causing some boundary pixels to be\n *          shifted from bg to fg or v.v.\n */",
      "file" : "runlength.c"
   },
   {
      "function" : "pixFindNormalizedSquareSum",
      "comment" : "/*!\n *  pixFindNormalizedSquareSum()\n *\n *      Input:  pixs\n *              &hratio (<optional return> ratio of normalized horiz square sum\n *                       to result if the pixel distribution were uniform)\n *              &vratio (<optional return> ratio of normalized vert square sum\n *                       to result if the pixel distribution were uniform)\n *              &fract  (<optional return> ratio of fg pixels to total pixels)\n *      Return: 0 if OK, 1 on error or if there are no fg pixels\n *\n *  Notes:\n *      (1) Let the image have h scanlines and N fg pixels.\n *          If the pixels were uniformly distributed on scanlines,\n *          the sum of squares of fg pixels on each scanline would be\n *          h * (N / h)^2.  However, if the pixels are not uniformly\n *          distributed (e.g., for text), the sum of squares of fg\n *          pixels will be larger.  We return in hratio and vratio the\n *          ratio of these two values.\n *      (2) If there are no fg pixels, hratio and vratio are returned as 0.0.\n */",
      "file" : "skew.c"
   },
   {
      "function" : "pixFindOverlapFraction",
      "comment" : "/*!\n *  pixFindOverlapFraction()\n *\n *      Input:  pixs1, pixs2 (1 bpp)\n *              x2, y2 (location in pixs1 of UL corner of pixs2)\n *              tab (<optional> pixel sum table, can be null)\n *              &ratio (<return> ratio fg intersection to fg union)\n *              &noverlap (<optional return> number of overlapping pixels)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The UL corner of pixs2 is placed at (x2, y2) in pixs1.\n *      (2) This measure is similar to the correlation.\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixFindPageForeground",
      "comment" : "/*!\n *  pixFindPageForeground()\n *\n *      Input:  pixs (full resolution (any type or depth)\n *              threshold (for binarization; typically about 128)\n *              mindist (min distance of text from border to allow\n *                       cleaning near border; at 2x reduction, this\n *                       should be larger than 50; typically about 70)\n *              erasedist (when conditions are satisfied, erase anything\n *                         within this distance of the edge;\n *                         typically 30 at 2x reduction)\n *              pagenum (use for debugging when called repeatedly; labels\n *                       debug images that are assembled into pdfdir)\n *              showmorph (set to a negative integer to show steps in\n *                         generating masks; this is typically used\n *                         for debugging region extraction)\n *              display (set to 1  to display mask and selected region\n *                       for debugging a single page)\n *              pdfdir (subdirectory of /tmp where images showing the\n *                      result are placed when called repeatedly; use\n *                      null if no output requested)\n *      Return: box (region including foreground, with some pixel noise\n *                   removed), or null if not found\n *\n *  Notes:\n *      (1) This doesn't simply crop to the fg.  It attempts to remove\n *          pixel noise and junk at the edge of the image before cropping.\n *          The input @threshold is used if pixs is not 1 bpp.\n *      (2) There are several debugging options, determined by the\n *          last 4 arguments.\n *      (3) If you want pdf output of results when called repeatedly,\n *          the pagenum arg labels the images written, which go into\n *          /tmp/<pdfdir>/<pagenum>.png.  In that case,\n *          you would clean out the /tmp directory before calling this\n *          function on each page:\n *              lept_rmdir(pdfdir);\n *              lept_mkdir(pdfdir);\n */",
      "file" : "pageseg.c"
   },
   {
      "function" : "pixFindPerimSizeRatio",
      "comment" : "/*!\n *  pixFindPerimSizeRatio()\n *\n *      Input:  pixs (1 bpp)\n *              tab (<optional> pixel sum table, can be NULL)\n *              &ratio (<return> perimeter/size ratio)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) We take the 'size' as twice the sum of the width and\n *          height of pixs, and the perimeter is the number of fg\n *          boundary pixels.  We use the fg pixels of the boundary\n *          because the pix may be clipped to the boundary, so an\n *          erosion is required to count all boundary pixels.\n *      (2) This has a large value for dendritic, fractal-like components\n *          with highly irregular boundaries.\n *      (3) This is typically used for a single connected component.\n *          It has a value of about 1.0 for rectangular components with\n *          relatively smooth boundaries.\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixFindPerimToAreaRatio",
      "comment" : "/*!\n *  pixFindPerimToAreaRatio()\n *\n *      Input:  pixs (1 bpp)\n *              tab (<optional> pixel sum table, can be NULL)\n *              &fract (<return> perimeter/area ratio)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The perimeter is the number of fg boundary pixels, and the\n *          area is the number of fg pixels.  This returns 0.0 if\n *          there are no fg pixels.\n *      (2) Unlike pixFindAreaPerimRatio(), this uses the full set of\n *          fg pixels for the area, and the ratio is taken in the opposite\n *          order.\n *      (3) This is typically used for a single connected component.\n *          This always has a value <= 1.0, and if the average distance\n *          of a fg pixel from the nearest bg pixel is d, this has\n *          a value ~1/d.\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixFindRectangleComps",
      "comment" : "/*!\n *  pixFindRectangleComps()\n *\n *      Input:  pixs (1 bpp)\n *              dist (max distance allowed between bounding box and nearest\n *                    foreground pixel within it)\n *              minw, minh (minimum size in each direction as a requirement\n *                          for a conforming rectangle)\n *      Return: boxa (of components that conform), or null on error\n *\n *  Notes:\n *      (1) This applies the function pixConformsToRectangle() to\n *          each 8-c.c. in pixs, and returns a boxa containing the\n *          regions of all components that are conforming.\n *      (2) Conforming components must satisfy both the size constraint\n *          given by @minsize and the slop in conforming to a rectangle\n *          determined by @dist.\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixFindSkew",
      "comment" : "/*!\n *  pixFindSkew()\n *\n *      Input:  pixs  (1 bpp)\n *              &angle   (<return> angle required to deskew, in degrees)\n *              &conf    (<return> confidence value is ratio max/min scores)\n *      Return: 0 if OK, 1 on error or if angle measurment not valid\n *\n *  Notes:\n *      (1) This is a simple high-level interface, that uses default\n *          values of the parameters for reasonable speed and accuracy.\n *      (2) The angle returned is the negative of the skew angle of\n *          the image.  It is the angle required for deskew.\n *          Clockwise rotations are positive angles.\n */",
      "file" : "skew.c"
   },
   {
      "function" : "pixFindSkewAndDeskew",
      "comment" : "/*!\n *  pixFindSkewAndDeskew()\n *\n *      Input:  pixs (any depth)\n *              redsearch (for binary search: reduction factor = 1, 2 or 4;\n *                         use 0 for default)\n *              &angle   (<optional return> angle required to deskew,\n *                        in degrees; use NULL to skip)\n *              &conf    (<optional return> conf value is ratio\n *                        of max/min scores; use NULL to skip)\n *      Return: pixd (deskewed pix), or null on error\n *\n *  Notes:\n *      (1) This binarizes if necessary and finds the skew angle.  If the\n *          angle is large enough and there is sufficient confidence,\n *          it returns a deskewed image; otherwise, it returns a clone.\n */",
      "file" : "skew.c"
   },
   {
      "function" : "pixFindSkewOrthogonalRange",
      "comment" : "/*\n *   pixFindSkewOrthogonalRange()\n *\n *      Input:  pixs  (1 bpp)\n *              &angle  (<return> angle required to deskew; in degrees cw)\n *              &conf   (<return> confidence given by ratio of max/min score)\n *              redsweep  (sweep reduction factor = 1, 2, 4 or 8)\n *              redsearch  (binary search reduction factor = 1, 2, 4 or 8;\n *                          and must not exceed redsweep)\n *              sweeprange  (half the full range in each orthogonal\n *                           direction, taken about 0, in degrees)\n *              sweepdelta   (angle increment of sweep; in degrees)\n *              minbsdelta   (min binary search increment angle; in degrees)\n *              confprior  (amount by which confidence of 90 degree rotated\n *                          result is reduced when comparing with unrotated\n *                          confidence value)\n *      Return: 0 if OK, 1 on error or if angle measurment not valid\n *\n *  Notes:\n *      (1) This searches for the skew angle, first in the range\n *          [-sweeprange, sweeprange], and then in\n *          [90 - sweeprange, 90 + sweeprange], with angles measured\n *          clockwise.  For exploring the full range of possibilities,\n *          suggest using sweeprange = 47.0 degrees, giving some overlap\n *          at 45 and 135 degrees.  From these results, and discounting\n *          the the second confidence by @confprior, it selects the\n *          angle for maximal differential variance.  If the angle\n *          is larger than pi/4, the angle found after 90 degree rotation\n *          is selected.\n *      (2) The larger the confidence value, the greater the probability\n *          that the proper alignment is given by the angle that maximizes\n *          variance.  It should be compared to a threshold, which depends\n *          on the application.  Values between 3.0 and 6.0 are common.\n *      (3) Allowing for both portrait and landscape searches is more\n *          difficult, because if the signal from the text lines is weak,\n *          a signal from vertical rules can be larger!\n *          The most difficult documents to deskew have some or all of:\n *            (a) Multiple columns, not aligned\n *            (b) Black lines along the vertical edges\n *            (c) Text from two pages, and at different angles\n *          Rule of thumb for resolution:\n *            (a) If the margins are clean, you can work at 75 ppi,\n *                although 100 ppi is safer.\n *            (b) If there are vertical lines in the margins, do not\n *                work below 150 ppi.  The signal from the text lines must\n *                exceed that from the margin lines.\n *      (4) Choosing the @confprior parameter depends on knowing something\n *          about the source of image.  However, we're not using\n *          real probabilities here, so its use is qualitative.\n *          If landscape and portrait are equally likely, use\n *          @confprior = 0.0.  If the likelihood of portrait (non-rotated)\n *          is 100 times higher than that of landscape, we want to reduce\n *          the chance that we rotate to landscape in a situation where\n *          the landscape signal is accidentally larger than the\n *          portrait signal.  To do this use a positive value of\n *          @confprior; say 1.5.\n */",
      "file" : "skew.c"
   },
   {
      "function" : "pixFindSkewSweep",
      "comment" : "/*!\n *  pixFindSkewSweep()\n *\n *      Input:  pixs  (1 bpp)\n *              &angle   (<return> angle required to deskew, in degrees)\n *              reduction  (factor = 1, 2, 4 or 8)\n *              sweeprange   (half the full range; assumed about 0; in degrees)\n *              sweepdelta   (angle increment of sweep; in degrees)\n *      Return: 0 if OK, 1 on error or if angle measurment not valid\n *\n *  Notes:\n *      (1) This examines the 'score' for skew angles with equal intervals.\n *      (2) Caller must check the return value for validity of the result.\n */",
      "file" : "skew.c"
   },
   {
      "function" : "pixFindSkewSweepAndSearch",
      "comment" : "/*!\n *  pixFindSkewSweepAndSearch()\n *\n *      Input:  pixs  (1 bpp)\n *              &angle   (<return> angle required to deskew; in degrees)\n *              &conf    (<return> confidence given by ratio of max/min score)\n *              redsweep  (sweep reduction factor = 1, 2, 4 or 8)\n *              redsearch  (binary search reduction factor = 1, 2, 4 or 8;\n *                          and must not exceed redsweep)\n *              sweeprange   (half the full range, assumed about 0; in degrees)\n *              sweepdelta   (angle increment of sweep; in degrees)\n *              minbsdelta   (min binary search increment angle; in degrees)\n *      Return: 0 if OK, 1 on error or if angle measurment not valid\n *\n *  Notes:\n *      (1) This finds the skew angle, doing first a sweep through a set\n *          of equal angles, and then doing a binary search until\n *          convergence.\n *      (2) Caller must check the return value for validity of the result.\n *      (3) In computing the differential line sum variance score, we sum\n *          the result over scanlines, but we always skip:\n *           - at least one scanline\n *           - not more than 10% of the image height\n *           - not more than 5% of the image width\n *      (4) See also notes in pixFindSkewSweepAndSearchScore()\n */",
      "file" : "skew.c"
   },
   {
      "function" : "pixFindSkewSweepAndSearchScore",
      "comment" : "/*!\n *  pixFindSkewSweepAndSearchScore()\n *\n *      Input:  pixs  (1 bpp)\n *              &angle   (<return> angle required to deskew; in degrees)\n *              &conf    (<return> confidence given by ratio of max/min score)\n *              &endscore (<optional return> max score; use NULL to ignore)\n *              redsweep  (sweep reduction factor = 1, 2, 4 or 8)\n *              redsearch  (binary search reduction factor = 1, 2, 4 or 8;\n *                          and must not exceed redsweep)\n *              sweepcenter  (angle about which sweep is performed; in degrees)\n *              sweeprange   (half the full range, taken about sweepcenter;\n *                            in degrees)\n *              sweepdelta   (angle increment of sweep; in degrees)\n *              minbsdelta   (min binary search increment angle; in degrees)\n *      Return: 0 if OK, 1 on error or if angle measurment not valid\n *\n *  Notes:\n *      (1) This finds the skew angle, doing first a sweep through a set\n *          of equal angles, and then doing a binary search until convergence.\n *      (2) There are two built-in constants that determine if the\n *          returned confidence is nonzero:\n *            - MIN_VALID_MAXSCORE (minimum allowed maxscore)\n *            - MINSCORE_THRESHOLD_CONSTANT (determines minimum allowed\n *                 minscore, by multiplying by (height * width^2)\n *          If either of these conditions is not satisfied, the returned\n *          confidence value will be zero.  The maxscore is optionally\n *          returned in this function to allow evaluation of the\n *          resulting angle by a method that is independent of the\n *          returned confidence value.\n *      (3) The larger the confidence value, the greater the probability\n *          that the proper alignment is given by the angle that maximizes\n *          variance.  It should be compared to a threshold, which depends\n *          on the application.  Values between 3.0 and 6.0 are common.\n *      (4) By default, the shear is about the UL corner.\n */",
      "file" : "skew.c"
   },
   {
      "function" : "pixFindSkewSweepAndSearchScorePivot",
      "comment" : "/*!\n *  pixFindSkewSweepAndSearchScorePivot()\n *\n *      Input:  pixs  (1 bpp)\n *              &angle   (<return> angle required to deskew; in degrees)\n *              &conf    (<return> confidence given by ratio of max/min score)\n *              &endscore (<optional return> max score; use NULL to ignore)\n *              redsweep  (sweep reduction factor = 1, 2, 4 or 8)\n *              redsearch  (binary search reduction factor = 1, 2, 4 or 8;\n *                          and must not exceed redsweep)\n *              sweepcenter  (angle about which sweep is performed; in degrees)\n *              sweeprange   (half the full range, taken about sweepcenter;\n *                            in degrees)\n *              sweepdelta   (angle increment of sweep; in degrees)\n *              minbsdelta   (min binary search increment angle; in degrees)\n *              pivot  (L_SHEAR_ABOUT_CORNER, L_SHEAR_ABOUT_CENTER)\n *      Return: 0 if OK, 1 on error or if angle measurment not valid\n *\n *  Notes:\n *      (1) See notes in pixFindSkewSweepAndSearchScore().\n *      (2) This allows choice of shear pivoting from either the UL corner\n *          or the center.  For small angles, the ability to discriminate\n *          angles is better with shearing from the UL corner.  However,\n *          for large angles (say, greater than 20 degrees), it is better\n *          to shear about the center because a shear from the UL corner\n *          loses too much of the image.\n */",
      "file" : "skew.c"
   },
   {
      "function" : "pixFindVerticalRuns",
      "comment" : "/*!\n *  pixFindVerticalRuns()\n *\n *      Input:  pix (1 bpp)\n *              x (line to traverse)\n *              ystart (returns array of start positions for fg runs)\n *              yend (returns array of end positions for fg runs)\n *              &n   (<return> the number of runs found)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This finds foreground vertical runs on a single scanline.\n *      (2) To find background runs, use pixInvert() before applying\n *          this function.\n *      (3) The ystart and yend arrays are input.  They should be\n *          of size h/2 + 1 to insure that they can hold\n *          the maximum number of runs in the raster line.\n */",
      "file" : "runlength.c"
   },
   {
      "function" : "pixFixedOctcubeQuant256",
      "comment" : "/*!\n *  pixFixedOctcubeQuant256()\n *\n *      Input:  pixs  (32 bpp; 24-bit color)\n *              ditherflag  (1 for dithering; 0 for no dithering)\n *      Return: pixd (8 bit with colormap), or null on error\n *\n *  This simple 1-pass color quantization works by breaking the\n *  color space into 256 pieces, with 3 bits quantized for each of\n *  red and green, and 2 bits quantized for blue.  We shortchange\n *  blue because the eye is least sensitive to blue.  This\n *  division of the color space is into two levels of octrees,\n *  followed by a further division by 4 (not 8), where both\n *  blue octrees have been combined in the third level.\n *\n *  The color map is generated from the 256 color centers by\n *  taking the representative color to be the center of the\n *  cell volume.  This gives a maximum error in the red and\n *  green values of 16 levels, and a maximum error in the\n *  blue sample of 32 levels.\n *\n *  Each pixel in the 24-bit color image is placed in its containing\n *  cell, given by the relevant MSbits of the red, green and blue\n *  samples.  An error-diffusion dithering is performed on each\n *  color sample to give the appearance of good average local color.\n *  Dithering is required; without it, the contouring and visible\n *  color errors are very bad.\n *\n *  I originally implemented this algorithm in two passes,\n *  where the first pass was used to compute the weighted average\n *  of each sample in each pre-allocated region of color space.\n *  The idea was to use these centroids in the dithering algorithm\n *  of the second pass, to reduce the average error that was\n *  being dithered.  However, with dithering, there is\n *  virtually no difference, so there is no reason to make the\n *  first pass.  Consequently, this 1-pass version just assigns\n *  the pixels to the centers of the pre-allocated cells.\n *  We use dithering to spread the difference between the sample\n *  value and the location of the center of the cell.  For speed\n *  and simplicity, we use integer dithering and propagate only\n *  to the right, down, and diagonally down-right, with ratios\n *  3/8, 3/8 and 1/4, respectively.  The results should be nearly\n *  as good, and a bit faster, with propagation only to the right\n *  and down.\n *\n *  The algorithm is very fast, because there is no search,\n *  only fast generation of the cell index for each pixel.\n *  We use a simple mapping from the three 8 bit rgb samples\n *  to the 8 bit cell index; namely, (r7 r6 r5 g7 g6 g5 b7 b6).\n *  This is not in an octcube format, but it doesn't matter.\n *  There are no storage requirements.  We could keep a\n *  running average of the center of each sample in each\n *  cluster, rather than using the center of the cell, but\n *  this is just extra work, esp. with dithering.\n *\n *  This method gives surprisingly good results with dithering.\n *  However, without dithering, the loss of color accuracy is\n *  evident in regions that are very light or that have subtle\n *  blending of colors.\n */",
      "file" : "colorquant1.c"
   },
   {
      "function" : "pixFixedOctcubeQuantGenRGB",
      "comment" : "/*!\n *  pixFixedOctcubeQuantGenRGB()\n *\n *      Input:  pixs (32 bpp rgb)\n *              level (significant bits for each of r,g,b)\n *      Return: pixd (rgb; quantized to octcube centers), or null on error\n *\n *  Notes:\n *      (1) Unlike the other color quantization functions, this one\n *          generates an rgb image.\n *      (2) The pixel values are quantized to the center of each octcube\n *          (at the specified level) containing the pixel.  They are\n *          not quantized to the average of the pixels in that octcube.\n */",
      "file" : "colorquant1.c"
   },
   {
      "function" : "pixFlipFHMTGen",
      "comment" : "/*\n *  pixFlipFHMTGen()\n *\n *     Input:  pixd (usual 3 choices: null, == pixs, != pixs)\n *             pixs\n *             sel name (one of four defined in SEL_NAMES[])\n *     Return: pixd\n *\n *     Action: hit-miss transform on pixs by the sel\n *     N.B.: the sel must have at least one hit, and it\n *           can have any number of misses.\n */",
      "file" : "fliphmtgen.c"
   },
   {
      "function" : "pixFlipLR",
      "comment" : "/*!\n *  pixFlipLR()\n *\n *      Input:  pixd  (<optional>; can be null, equal to pixs,\n *                     or different from pixs)\n *              pixs (all depths)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This does a left-right flip of the image, which is\n *          equivalent to a rotation out of the plane about a\n *          vertical line through the image center.\n *      (2) There are 3 cases for input:\n *          (a) pixd == null (creates a new pixd)\n *          (b) pixd == pixs (in-place operation)\n *          (c) pixd != pixs (existing pixd)\n *      (3) For clarity, use these three patterns, respectively:\n *          (a) pixd = pixFlipLR(NULL, pixs);\n *          (b) pixFlipLR(pixs, pixs);\n *          (c) pixFlipLR(pixd, pixs);\n *      (4) If an existing pixd is not the same size as pixs, the\n *          image data will be reallocated.\n */",
      "file" : "rotateorth.c"
   },
   {
      "function" : "pixFlipPixel",
      "comment" : "/*!\n *  pixFlipPixel()\n *\n *      Input:  pix\n *              (x,y) pixel coords\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixFlipTB",
      "comment" : "/*!\n *  pixFlipTB()\n *\n *      Input:  pixd  (<optional>; can be null, equal to pixs,\n *                     or different from pixs)\n *              pixs (all depths)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This does a top-bottom flip of the image, which is\n *          equivalent to a rotation out of the plane about a\n *          horizontal line through the image center.\n *      (2) There are 3 cases for input:\n *          (a) pixd == null (creates a new pixd)\n *          (b) pixd == pixs (in-place operation)\n *          (c) pixd != pixs (existing pixd)\n *      (3) For clarity, use these three patterns, respectively:\n *          (a) pixd = pixFlipTB(NULL, pixs);\n *          (b) pixFlipTB(pixs, pixs);\n *          (c) pixFlipTB(pixd, pixs);\n *      (4) If an existing pixd is not the same size as pixs, the\n *          image data will be reallocated.\n */",
      "file" : "rotateorth.c"
   },
   {
      "function" : "pixForegroundFraction",
      "comment" : "/*!\n *  pixForegroundFraction()\n *\n *      Input:  pix (1 bpp)\n *              &fract (<return> fraction of ON pixels)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixFree",
      "comment" : "/*!\n *  pixFree()\n *\n *      Input:  pix\n *      Return: void\n *\n *  Notes:\n *      (1) Decrements the ref count and, if 0, destroys the pix.\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixFreeData",
      "comment" : "/*!\n *  pixFreeData()\n *\n *  Notes:\n *      (1) This frees the data and sets the pix data ptr to null.\n *          It should be used before pixSetData() in the situation where\n *          you want to free any existing data before doing\n *          a subsequent assignment with pixSetData().\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixGammaTRC",
      "comment" : "/*!\n *  pixGammaTRC()\n *\n *      Input:  pixd (<optional> null or equal to pixs)\n *              pixs (8 or 32 bpp; or 2, 4 or 8 bpp with colormap)\n *              gamma (gamma correction; must be > 0.0)\n *              minval  (input value that gives 0 for output; can be < 0)\n *              maxval  (input value that gives 255 for output; can be > 255)\n *      Return: pixd always\n *\n *  Notes:\n *      (1) pixd must either be null or equal to pixs.\n *          For in-place operation, set pixd == pixs:\n *             pixGammaTRC(pixs, pixs, ...);\n *          To get a new image, set pixd == null:\n *             pixd = pixGammaTRC(NULL, pixs, ...);\n *      (2) If pixs is colormapped, the colormap is transformed,\n *          either in-place or in a copy of pixs.\n *      (3) We use a gamma mapping between minval and maxval.\n *      (4) If gamma < 1.0, the image will appear darker;\n *          if gamma > 1.0, the image will appear lighter;\n *      (5) If gamma = 1.0 and minval = 0 and maxval = 255, no\n *          enhancement is performed; return a copy unless in-place,\n *          in which case this is a no-op.\n *      (6) For color images that are not colormapped, the mapping\n *          is applied to each component.\n *      (7) minval and maxval are not restricted to the interval [0, 255].\n *          If minval < 0, an input value of 0 is mapped to a\n *          nonzero output.  This will turn black to gray.\n *          If maxval > 255, an input value of 255 is mapped to\n *          an output value less than 255.  This will turn\n *          white (e.g., in the background) to gray.\n *      (8) Increasing minval darkens the image.\n *      (9) Decreasing maxval bleaches the image.\n *      (10) Simultaneously increasing minval and decreasing maxval\n *           will darken the image and make the colors more intense;\n *           e.g., minval = 50, maxval = 200.\n *      (11) See numaGammaTRC() for further examples of use.\n */",
      "file" : "enhance.c"
   },
   {
      "function" : "pixGammaTRCMasked",
      "comment" : "/*!\n *  pixGammaTRCMasked()\n *\n *      Input:  pixd (<optional> null or equal to pixs)\n *              pixs (8 or 32 bpp; not colormapped)\n *              pixm (<optional> null or 1 bpp)\n *              gamma (gamma correction; must be > 0.0)\n *              minval  (input value that gives 0 for output; can be < 0)\n *              maxval  (input value that gives 255 for output; can be > 255)\n *      Return: pixd always\n *\n *  Notes:\n *      (1) Same as pixGammaTRC() except mapping is optionally over\n *          a subset of pixels described by pixm.\n *      (2) Masking does not work for colormapped images.\n *      (3) See pixGammaTRC() for details on how to use the parameters.\n */",
      "file" : "enhance.c"
   },
   {
      "function" : "pixGammaTRCWithAlpha",
      "comment" : "/*!\n *  pixGammaTRCWithAlpha()\n *\n *      Input:  pixd (<optional> null or equal to pixs)\n *              pixs (32 bpp)\n *              gamma (gamma correction; must be > 0.0)\n *              minval  (input value that gives 0 for output; can be < 0)\n *              maxval  (input value that gives 255 for output; can be > 255)\n *      Return: pixd always\n *\n *  Notes:\n *      (1) See usage notes in pixGammaTRC().\n *      (2) This version saves the alpha channel.  It is only valid\n *          for 32 bpp (no colormap), and is a bit slower.\n */",
      "file" : "enhance.c"
   },
   {
      "function" : "pixGenHalftoneMask",
      "comment" : "/*!\n *  pixGenHalftoneMask()\n *\n *      Input:  pixs (1 bpp, assumed to be 150 to 200 ppi)\n *              &pixtext (<optional return> text part of pixs)\n *              &htfound (<optional return> 1 if the mask is not empty)\n *              debug (flag: 1 for debug output)\n *      Return: pixd (halftone mask), or null on error\n */",
      "file" : "pageseg.c"
   },
   {
      "function" : "pixGenTextblockMask",
      "comment" : "/*!\n *  pixGenTextblockMask()\n *\n *      Input:  pixs (1 bpp, textline mask, assumed to be 150 to 200 ppi)\n *              pixvws (vertical white space mask)\n *              debug (flag: 1 for debug output)\n *      Return: pixd (textblock mask), or null on error\n *\n *  Notes:\n *      (1) Both the input masks (textline and vertical white space) and\n *          the returned textblock mask are at the same resolution.\n *      (2) The result is somewhat noisy, in that small \"blocks\" of\n *          text may be included.  These can be removed by post-processing,\n *          using, e.g.,\n *             pixSelectBySize(pix, 60, 60, 4, L_SELECT_IF_EITHER,\n *                             L_SELECT_IF_GTE, NULL);\n */",
      "file" : "pageseg.c"
   },
   {
      "function" : "pixGenTextlineMask",
      "comment" : "/*!\n *  pixGenTextlineMask()\n *\n *      Input:  pixs (1 bpp, assumed to be 150 to 200 ppi)\n *              &pixvws (<return> vertical whitespace mask)\n *              &tlfound (<optional return> 1 if the mask is not empty)\n *              debug (flag: 1 for debug output)\n *      Return: pixd (textline mask), or null on error\n *\n *  Notes:\n *      (1) The input pixs should be deskewed.\n *      (2) pixs should have no halftone pixels.\n *      (3) Both the input image and the returned textline mask\n *          are at the same resolution.\n */",
      "file" : "pageseg.c"
   },
   {
      "function" : "pixGenerateBarcodeMask",
      "comment" : "/*!\n *  pixGenerateBarcodeMask()\n *\n *      Input:  pixs (1 bpp)\n *              maxspace (largest space in the barcode, in pixels)\n *              nwidth (opening 'width' to remove noise)\n *              nheight (opening 'height' to remove noise)\n *      Return: pixm (mask over barcodes), or null if none found or on error\n *\n *  Notes:\n *      (1) For noise removal, 'width' and 'height' are referred to the\n *          barcode orientation.\n *      (2) If there is skew, the mask will not cover the barcode corners.\n */",
      "file" : "readbarcode.c"
   },
   {
      "function" : "pixGenerateCIData",
      "comment" : "/*!\n *  pixGenerateCIData()\n *\n *      Input:  pixs (8 or 32 bpp, no colormap)\n *              type (L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE)\n *              quality (used for jpeg only; 0 for default (75))\n *              ascii85 (0 for binary; 1 for ascii85-encoded)\n *              &cid (<return> compressed data)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Set ascii85:\n *           - 0 for binary data (not permitted in PostScript)\n *           - 1 for ascii85 (5 for 4) encoded binary data\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "pixGenerateFlateData",
      "comment" : "/*!\n *  pixGenerateFlateData()\n *\n *      Input:  pixs\n *              ascii85flag (0 for gzipped; 1 for ascii85-encoded gzipped)\n *      Return: cid (flate compressed image data), or null on error\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "pixGenerateFromPta",
      "comment" : "/*!\n *  pixGenerateFromPta()\n *\n *      Input:  pta\n *              w, h (of pix)\n *      Return: pix (1 bpp), or null on error\n *\n *  Notes:\n *      (1) Points are rounded to nearest ints.\n *      (2) Any points outside (w,h) are silently discarded.\n *      (3) Output 1 bpp pix has values 1 for each point in the pta.\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "pixGenerateG4Data",
      "comment" : "/*!\n *  pixGenerateG4Data()\n *\n *      Input:  pixs (1 bpp)\n *              ascii85flag (0 for gzipped; 1 for ascii85-encoded gzipped)\n *      Return: cid (g4 compressed image data), or null on error\n *\n *  Notes:\n *      (1) Set ascii85flag:\n *           - 0 for binary data (not permitted in PostScript)\n *           - 1 for ascii85 (5 for 4) encoded binary data\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "pixGenerateJpegData",
      "comment" : "/*!\n *  pixGenerateJpegData()\n *\n *      Input:  pixs (8 or 32 bpp, no colormap)\n *              ascii85flag (0 for jpeg; 1 for ascii85-encoded jpeg)\n *              quality (0 for default, which is 75)\n *      Return: cid (jpeg compressed data), or null on error\n *\n *  Notes:\n *      (1) Set ascii85flag:\n *           - 0 for binary data (not permitted in PostScript)\n *           - 1 for ascii85 (5 for 4) encoded binary data\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "pixGenerateMaskByBand",
      "comment" : "/*!\n *  pixGenerateMaskByBand()\n *\n *      Input:  pixs (2, 4 or 8 bpp, or colormapped)\n *              lower, upper (two pixel values from which a range, either\n *                            between (inband) or outside of (!inband),\n *                            determines which pixels in pixs cause us to\n *                            set a 1 in the dest mask)\n *              inband (1 for finding pixels in [lower, upper];\n *                      0 for finding pixels in [0, lower) union (upper, 255])\n *              usecmap (1 to retain cmap values; 0 to convert to gray)\n *      Return: pixd (1 bpp), or null on error\n *\n *  Notes:\n *      (1) Generates a 1 bpp mask pixd, the same size as pixs, where\n *          the fg pixels in the mask are those either within the specified\n *          band (for inband == 1) or outside the specified band\n *          (for inband == 0).\n *      (2) If pixs is colormapped, @usecmap determines if the colormap\n *          values are used, or if the colormap is removed to gray and\n *          the gray values are used.  For the latter, it generates\n *          an approximate grayscale value for each pixel, and then looks\n *          for gray pixels with the value @val.\n */",
      "file" : "grayquant.c"
   },
   {
      "function" : "pixGenerateMaskByBand32",
      "comment" : "/*!\n *  pixGenerateMaskByBand32()\n *\n *      Input:  pixs (32 bpp)\n *              refval (reference rgb value)\n *              delm (max amount below the ref value for any component)\n *              delp (max amount above the ref value for any component)\n *      Return: pixd (1 bpp), or null on error\n *\n *  Notes:\n *      (1) Generates a 1 bpp mask pixd, the same size as pixs, where\n *          the fg pixels in the mask are those where each component\n *          is within -delm to +delp of the reference value.\n */",
      "file" : "grayquant.c"
   },
   {
      "function" : "pixGenerateMaskByDiscr32",
      "comment" : "/*!\n *  pixGenerateMaskByDiscr32()\n *\n *      Input:  pixs (32 bpp)\n *              refval1 (reference rgb value)\n *              refval2 (reference rgb value)\n *              distflag (L_MANHATTAN_DISTANCE, L_EUCLIDEAN_DISTANCE)\n *      Return: pixd (1 bpp), or null on error\n *\n *  Notes:\n *      (1) Generates a 1 bpp mask pixd, the same size as pixs, where\n *          the fg pixels in the mask are those where the pixel in pixs\n *          is \"closer\" to refval1 than to refval2.\n *      (2) \"Closer\" can be defined in several ways, such as:\n *            - manhattan distance (L1)\n *            - euclidean distance (L2)\n *            - majority vote of the individual components\n *          Here, we have a choice of L1 or L2.\n */",
      "file" : "grayquant.c"
   },
   {
      "function" : "pixGenerateMaskByValue",
      "comment" : "/*!\n *  pixGenerateMaskByValue()\n *\n *      Input:  pixs (2, 4 or 8 bpp, or colormapped)\n *              val (of pixels for which we set 1 in dest)\n *              usecmap (1 to retain cmap values; 0 to convert to gray)\n *      Return: pixd (1 bpp), or null on error\n *\n *  Notes:\n *      (1) @val is the pixel value that we are selecting.  It can be\n *          either a gray value or a colormap index.\n *      (2) If pixs is colormapped, @usecmap determines if the colormap\n *          index values are used, or if the colormap is removed to gray and\n *          the gray values are used.  For the latter, it generates\n *          an approximate grayscale value for each pixel, and then looks\n *          for gray pixels with the value @val.\n */",
      "file" : "grayquant.c"
   },
   {
      "function" : "pixGenerateSelBoundary",
      "comment" : "/*!\n *  pixGenerateSelBoundary()\n *\n *      Input:  pix (1 bpp, typically small, to be used as a pattern)\n *              hitdist (min distance from fg boundary pixel)\n *              missdist (min distance from bg boundary pixel)\n *              hitskip (number of boundary pixels skipped between hits)\n *              missskip (number of boundary pixels skipped between misses)\n *              topflag (flag for extra pixels of bg added above)\n *              botflag (flag for extra pixels of bg added below)\n *              leftflag (flag for extra pixels of bg added to left)\n *              rightflag (flag for extra pixels of bg added to right)\n *              &pixe (<optional return> input pix expanded by extra pixels)\n *      Return: sel (hit-miss for input pattern), or null on error\n *\n *  Notes:\n *    (1) All fg elements selected are exactly hitdist pixels away from\n *        the nearest fg boundary pixel, and ditto for bg elements.\n *        Valid inputs of hitdist and missdist are 0, 1, 2, 3 and 4.\n *        For example, a hitdist of 0 puts the hits at the fg boundary.\n *        Usually, the distances should be > 0 avoid the effect of\n *        noise at the boundary.\n *    (2) Set hitskip < 0 if no hits are to be used.  Ditto for missskip.\n *        If both hitskip and missskip are < 0, the sel would be empty,\n *        and NULL is returned.\n *    (3) The 4 flags determine whether the sel is increased on that side\n *        to allow bg misses to be placed all along that boundary.\n *        The increase in sel size on that side is the minimum necessary\n *        to allow the misses to be placed at mindist.  For text characters,\n *        the topflag and botflag are typically set to 1, and the leftflag\n *        and rightflag to 0.\n *    (4) The input pix, as extended by the extra pixels on selected sides,\n *        can optionally be returned.  For debugging, call\n *        pixDisplayHitMissSel() to visualize the hit-miss sel superimposed\n *        on the generating bitmap.\n *    (5) This is probably the best of the three sel generators, in the\n *        sense that you have the most flexibility with the smallest number\n *        of hits and misses.\n */",
      "file" : "selgen.c"
   },
   {
      "function" : "pixGenerateSelRandom",
      "comment" : "/*!\n *  pixGenerateSelRandom()\n *\n *      Input:  pix (1 bpp, typically small, to be used as a pattern)\n *              hitfract (fraction of allowable fg pixels that are hits)\n *              missfract (fraction of allowable bg pixels that are misses)\n *              distance (min distance from boundary pixel; use 0 for default)\n *              toppix (number of extra pixels of bg added above)\n *              botpix (number of extra pixels of bg added below)\n *              leftpix (number of extra pixels of bg added to left)\n *              rightpix (number of extra pixels of bg added to right)\n *              &pixe (<optional return> input pix expanded by extra pixels)\n *      Return: sel (hit-miss for input pattern), or null on error\n *\n *  Notes:\n *    (1) Either of hitfract and missfract can be zero.  If both are zero,\n *        the sel would be empty, and NULL is returned.\n *    (2) No elements are selected that are less than 'distance' pixels away\n *        from a boundary pixel of the same color.  This makes the\n *        match much more robust to edge noise.  Valid inputs of\n *        'distance' are 0, 1, 2, 3 and 4.  If distance is either 0 or\n *        greater than 4, we reset it to the default value.\n *    (3) The 4 numbers for adding rectangles of pixels outside the fg\n *        can be use if the pattern is expected to be surrounded by bg\n *        (white) pixels.  On the other hand, if the pattern may be near\n *        other fg (black) components on some sides, use 0 for those sides.\n *    (4) The input pix, as extended by the extra pixels on selected sides,\n *        can optionally be returned.  For debugging, call\n *        pixDisplayHitMissSel() to visualize the hit-miss sel superimposed\n *        on the generating bitmap.\n */",
      "file" : "selgen.c"
   },
   {
      "function" : "pixGenerateSelWithRuns",
      "comment" : "/*!\n *  pixGenerateSelWithRuns()\n *\n *      Input:  pix (1 bpp, typically small, to be used as a pattern)\n *              nhlines (number of hor lines along which elements are found)\n *              nvlines (number of vert lines along which elements are found)\n *              distance (min distance from boundary pixel; use 0 for default)\n *              minlength (min runlength to set hit or miss; use 0 for default)\n *              toppix (number of extra pixels of bg added above)\n *              botpix (number of extra pixels of bg added below)\n *              leftpix (number of extra pixels of bg added to left)\n *              rightpix (number of extra pixels of bg added to right)\n *              &pixe (<optional return> input pix expanded by extra pixels)\n *      Return: sel (hit-miss for input pattern), or null on error\n *\n *  Notes:\n *    (1) The horizontal and vertical lines along which elements are\n *        selected are roughly equally spaced.  The actual locations of\n *        the hits and misses are the centers of respective run-lengths.\n *    (2) No elements are selected that are less than 'distance' pixels away\n *        from a boundary pixel of the same color.  This makes the\n *        match much more robust to edge noise.  Valid inputs of\n *        'distance' are 0, 1, 2, 3 and 4.  If distance is either 0 or\n *        greater than 4, we reset it to the default value.\n *    (3) The 4 numbers for adding rectangles of pixels outside the fg\n *        can be use if the pattern is expected to be surrounded by bg\n *        (white) pixels.  On the other hand, if the pattern may be near\n *        other fg (black) components on some sides, use 0 for those sides.\n *    (4) The pixels added to a side allow you to have miss elements there.\n *        There is a constraint between distance, minlength, and\n *        the added pixels for this to work.  We illustrate using the\n *        default values.  If you add 5 pixels to the top, and use a\n *        distance of 1, then you end up with a vertical run of at least\n *        4 bg pixels along the top edge of the image.  If you use a\n *        minimum runlength of 3, each vertical line will always find\n *        a miss near the center of its run.  However, if you use a\n *        minimum runlength of 5, you will not get a miss on every vertical\n *        line.  As another example, if you have 7 added pixels and a\n *        distance of 2, you can use a runlength up to 5 to guarantee\n *        that the miss element is recorded.  We give a warning if the\n *        contraint does not guarantee a miss element outside the\n *        image proper.\n *    (5) The input pix, as extended by the extra pixels on selected sides,\n *        can optionally be returned.  For debugging, call\n *        pixDisplayHitMissSel() to visualize the hit-miss sel superimposed\n *        on the generating bitmap.\n */",
      "file" : "selgen.c"
   },
   {
      "function" : "pixGetAllCCBorders",
      "comment" : "/*!\n *  pixGetAllCCBorders()\n *\n *      Input:  pixs (1 bpp)\n *      Return: ccborda, or null on error\n */",
      "file" : "ccbord.c"
   },
   {
      "function" : "pixGetAverageMasked",
      "comment" : "/*!\n *  pixGetAverageMasked()\n *\n *      Input:  pixs (8 or 16 bpp, or colormapped)\n *              pixm (<optional> 1 bpp mask over which average is to be taken;\n *                    use all pixels if null)\n *              x, y (UL corner of pixm relative to the UL corner of pixs;\n *                    can be < 0)\n *              factor (subsampling factor; >= 1)\n *              type (L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE,\n *                    L_STANDARD_DEVIATION, L_VARIANCE)\n *              &val (<return> measured value of given 'type')\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Use L_MEAN_ABSVAL to get the average value of pixels in pixs\n *          that are under the fg of the optional mask.  If the mask\n *          is null, it finds the average of the pixels in pixs.\n *      (2) Likewise, use L_ROOT_MEAN_SQUARE to get the rms value of\n *          pixels in pixs, either masked or not; L_STANDARD_DEVIATION\n *          to get the standard deviation from the mean of the pixels;\n *          L_VARIANCE to get the average squared difference from the\n *          expected value.  The variance is the square of the stdev.\n *          For the standard deviation, we use\n *              sqrt(<(<x> - x)>^2) = sqrt(<x^2> - <x>^2)\n *      (3) Set the subsampling @factor > 1 to reduce the amount of\n *          computation.\n *      (4) Clipping of pixm (if it exists) to pixs is done in the inner loop.\n *      (5) Input x,y are ignored unless pixm exists.\n */",
      "file" : "pix4.c"
   },
   {
      "function" : "pixGetAverageMaskedRGB",
      "comment" : "/*!\n *  pixGetAverageMaskedRGB()\n *\n *      Input:  pixs (32 bpp, or colormapped)\n *              pixm (<optional> 1 bpp mask over which average is to be taken;\n *                    use all pixels if null)\n *              x, y (UL corner of pixm relative to the UL corner of pixs;\n *                    can be < 0)\n *              factor (subsampling factor; >= 1)\n *              type (L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE,\n *                    L_STANDARD_DEVIATION, L_VARIANCE)\n *              &rval (<return optional> measured red value of given 'type')\n *              &gval (<return optional> measured green value of given 'type')\n *              &bval (<return optional> measured blue value of given 'type')\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) For usage, see pixGetAverageMasked().\n *      (2) If there is a colormap, it is removed before the 8 bpp\n *          component images are extracted.\n */",
      "file" : "pix4.c"
   },
   {
      "function" : "pixGetAverageTiled",
      "comment" : "/*!\n *  pixGetAverageTiled()\n *\n *      Input:  pixs (8 bpp, or colormapped)\n *              sx, sy (tile size; must be at least 2 x 2)\n *              type (L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE, L_STANDARD_DEVIATION)\n *      Return: pixd (average values in each tile), or null on error\n *\n *  Notes:\n *      (1) Only computes for tiles that are entirely contained in pixs.\n *      (2) Use L_MEAN_ABSVAL to get the average abs value within the tile;\n *          L_ROOT_MEAN_SQUARE to get the rms value within each tile;\n *          L_STANDARD_DEVIATION to get the standard dev. from the average\n *          within each tile.\n *      (3) If colormapped, converts to 8 bpp gray.\n */",
      "file" : "pix4.c"
   },
   {
      "function" : "pixGetAverageTiledRGB",
      "comment" : "/*!\n *  pixGetAverageTiledRGB()\n *\n *      Input:  pixs (32 bpp, or colormapped)\n *              sx, sy (tile size; must be at least 2 x 2)\n *              type (L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE, L_STANDARD_DEVIATION)\n *              &pixr (<optional return> tiled 'average' of red component)\n *              &pixg (<optional return> tiled 'average' of green component)\n *              &pixb (<optional return> tiled 'average' of blue component)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) For usage, see pixGetAverageTiled().\n *      (2) If there is a colormap, it is removed before the 8 bpp\n *          component images are extracted.\n */",
      "file" : "pix4.c"
   },
   {
      "function" : "pixGetAverageValue",
      "comment" : "/*!\n *  pixGetAverageValue()\n *\n *      Input:  pixs (8 bpp, 32 bpp or colormapped)\n *              factor (subsampling factor; integer >= 1)\n *              type (L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE,\n *                    L_STANDARD_DEVIATION, L_VARIANCE)\n *              &value (<return> pixel value corresponding to input rank)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Simple function to get average statistical values of an image.\n */",
      "file" : "pix4.c"
   },
   {
      "function" : "pixGetBackgroundGrayMap",
      "comment" : "/*!\n *  pixGetBackgroundGrayMap()\n *\n *      Input:  pixs (8 bpp grayscale; not cmapped)\n *              pixim (<optional> 1 bpp 'image' mask; can be null; it\n *                     should not have all foreground pixels)\n *              sx, sy (tile size in pixels)\n *              thresh (threshold for determining foreground)\n *              mincount (min threshold on counts in a tile)\n *              &pixd (<return> 8 bpp grayscale map)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The background is measured in regions that don't have\n *          images.  It is then propagated into the image regions,\n *          and finally smoothed in each image region.\n */",
      "file" : "adaptmap.c"
   },
   {
      "function" : "pixGetBackgroundGrayMapMorph",
      "comment" : "/*!\n *  pixGetBackgroundGrayMapMorph()\n *\n *      Input:  pixs (8 bpp grayscale; not cmapped)\n *              pixim (<optional> 1 bpp 'image' mask; can be null; it\n *                     should not have all foreground pixels)\n *              reduction (factor at which closing is performed)\n *              size (of square Sel for the closing; use an odd number)\n *              &pixm (<return> grayscale map)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "adaptmap.c"
   },
   {
      "function" : "pixGetBackgroundRGBMap",
      "comment" : "/*!\n *  pixGetBackgroundRGBMap()\n *\n *      Input:  pixs (32 bpp rgb)\n *              pixim (<optional> 1 bpp 'image' mask; can be null; it\n *                     should not have all foreground pixels)\n *              pixg (<optional> 8 bpp grayscale version; can be null)\n *              sx, sy (tile size in pixels)\n *              thresh (threshold for determining foreground)\n *              mincount (min threshold on counts in a tile)\n *              &pixmr, &pixmg, &pixmb (<return> rgb maps)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If pixg, which is a grayscale version of pixs, is provided,\n *          use this internally to generate the foreground mask.\n *          Otherwise, a grayscale version of pixs will be generated\n *          from the green component only, used, and destroyed.\n */",
      "file" : "adaptmap.c"
   },
   {
      "function" : "pixGetBackgroundRGBMapMorph",
      "comment" : "/*!\n *  pixGetBackgroundRGBMapMorph()\n *\n *      Input:  pixs (32 bpp rgb)\n *              pixim (<optional> 1 bpp 'image' mask; can be null; it\n *                     should not have all foreground pixels)\n *              reduction (factor at which closing is performed)\n *              size (of square Sel for the closing; use an odd number)\n *              &pixmr (<return> red component map)\n *              &pixmg (<return> green component map)\n *              &pixmb (<return> blue component map)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "adaptmap.c"
   },
   {
      "function" : "pixGetBinnedColor",
      "comment" : "/*!\n *  pixGetBinnedColor()\n *\n *      Input:  pixs (32 bpp)\n *              pixg (8 bpp grayscale version of pixs)\n *              factor (sampling factor along pixel counting direction)\n *              nbins (number of intensity bins)\n *              nalut (LUT for mapping from intensity to bin number)\n *              &carray (<return> array of average color values in each bin)\n *              debugflag (1 to display output debug plots of color\n *                         components; 2 to write them as png to file)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This takes a color image, a grayscale (intensity) version,\n *          a LUT from intensity to bin number, and the number of bins.\n *          It computes the average color for pixels whose intensity\n *          is in each bin.  This is returned as an array of l_uint32\n *          colors in our standard RGBA ordering.\n *      (2) This function generates equal width intensity bins and\n *          finds the average color in each bin.  Compare this with\n *          pixGetRankColorArray(), which rank orders the pixels\n *          by the value of the selected component in each pixel,\n *          sets up bins with equal population (not intensity width!),\n *          and gets the average color in each bin.\n */",
      "file" : "pix4.c"
   },
   {
      "function" : "pixGetBinnedComponentRange",
      "comment" : "/*!\n *  pixGetBinnedComponentRange()\n *\n *      Input:  pixs (32 bpp rgb)\n *              nbins (number of equal population bins; must be > 1)\n *              factor (subsampling factor; >= 1)\n *              color (L_SELECT_RED, L_SELECT_GREEN or L_SELECT_BLUE)\n *              &minval (<optional return> minimum value of component)\n *              &maxval (<optional return> maximum value of component)\n *              &carray (<optional return> color array of bins)\n *              debugflag (1 for debug output)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This returns the min and max average values of the\n *          selected color component in the set of rank bins,\n *          where the ranking is done using the specified component.\n */",
      "file" : "pix4.c"
   },
   {
      "function" : "pixGetBlackOrWhiteVal",
      "comment" : "/*!\n *  pixGetBlackOrWhiteVal()\n *\n *      Input:  pixs (all depths; cmap ok)\n *              op (L_GET_BLACK_VAL, L_GET_WHITE_VAL)\n *              &val (<return> pixel value)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) Side effect.  For a colormapped image, if the requested\n *          color is not present and there is room to add it in the cmap,\n *          it is added and the new index is returned.  If there is no room,\n *          the index of the closest color in intensity is returned.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixGetCCBorders",
      "comment" : "/*!\n *  pixGetCCBorders()\n *\n *      Input:  pixs (1 bpp, one 8-connected component)\n *              box  (xul, yul, width, height) in global coords\n *      Return: ccbord, or null on error\n *\n *  Notes:\n *      (1) We are finding the exterior and interior borders\n *          of an 8-connected component.   This should be used\n *          on a pix that has exactly one 8-connected component.\n *      (2) Typically, pixs is a c.c. in some larger pix.  The\n *          input box gives its location in global coordinates.\n *          This box is saved, as well as the boxes for the\n *          borders of any holes within the c.c., but the latter\n *          are given in relative coords within the c.c.\n *      (3) The calculations for the exterior border are done\n *          on a pix with a 1-pixel\n *          added border, but the saved pixel coordinates\n *          are the correct (relative) ones for the input pix\n *          (without a 1-pixel border)\n *      (4) For the definition of the three tables -- xpostab[], ypostab[]\n *          and qpostab[] -- see above where they are defined.\n */",
      "file" : "ccbord.c"
   },
   {
      "function" : "pixGetCmapHistogram",
      "comment" : "/*!\n *  pixGetCmapHistogram()\n *\n *      Input:  pixs (colormapped: d = 2, 4 or 8)\n *              factor (subsampling factor; integer >= 1)\n *      Return: na (histogram of cmap indices), or null on error\n *\n *  Notes:\n *      (1) This generates a histogram of colormap pixel indices,\n *          and is of size 2^d.\n *      (2) Set the subsampling @factor > 1 to reduce the amount of computation.\n */",
      "file" : "pix4.c"
   },
   {
      "function" : "pixGetCmapHistogramInRect",
      "comment" : "/*!\n *  pixGetCmapHistogramInRect()\n *\n *      Input:  pixs (colormapped: d = 2, 4 or 8)\n *              box (<optional>) over which histogram is to be computed;\n *                   use full image if null)\n *              factor (subsampling factor; integer >= 1)\n *      Return: na (histogram), or null on error\n *\n *  Notes:\n *      (1) This generates a histogram of colormap pixel indices,\n *          and is of size 2^d.\n *      (2) Set the subsampling @factor > 1 to reduce the amount of computation.\n *      (3) Clipping to the box is done in the inner loop.\n */",
      "file" : "pix4.c"
   },
   {
      "function" : "pixGetCmapHistogramMasked",
      "comment" : "/*!\n *  pixGetCmapHistogramMasked()\n *\n *      Input:  pixs (colormapped: d = 2, 4 or 8)\n *              pixm (<optional> 1 bpp mask over which histogram is\n *                    to be computed; use all pixels if null)\n *              x, y (UL corner of pixm relative to the UL corner of pixs;\n *                    can be < 0; these values are ignored if pixm is null)\n *              factor (subsampling factor; integer >= 1)\n *      Return: na (histogram), or null on error\n *\n *  Notes:\n *      (1) This generates a histogram of colormap pixel indices,\n *          and is of size 2^d.\n *      (2) Set the subsampling @factor > 1 to reduce the amount of computation.\n *      (3) Clipping of pixm to pixs is done in the inner loop.\n */",
      "file" : "pix4.c"
   },
   {
      "function" : "pixGetColorHistogram",
      "comment" : "/*!\n *  pixGetColorHistogram()\n *\n *      Input:  pixs (rgb or colormapped)\n *              factor (subsampling factor; integer >= 1)\n *              &nar (<return> red histogram)\n *              &nag (<return> green histogram)\n *              &nab (<return> blue histogram)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This generates a set of three 256 entry histograms,\n *          one for each color component (r,g,b).\n *      (2) Set the subsampling @factor > 1 to reduce the amount of computation.\n */",
      "file" : "pix4.c"
   },
   {
      "function" : "pixGetColorHistogramMasked",
      "comment" : "/*!\n *  pixGetColorHistogramMasked()\n *\n *      Input:  pixs (32 bpp rgb, or colormapped)\n *              pixm (<optional> 1 bpp mask over which histogram is\n *                    to be computed; use all pixels if null)\n *              x, y (UL corner of pixm relative to the UL corner of pixs;\n *                    can be < 0; these values are ignored if pixm is null)\n *              factor (subsampling factor; integer >= 1)\n *              &nar (<return> red histogram)\n *              &nag (<return> green histogram)\n *              &nab (<return> blue histogram)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This generates a set of three 256 entry histograms,\n *      (2) Set the subsampling @factor > 1 to reduce the amount of computation.\n *      (3) Clipping of pixm (if it exists) to pixs is done in the inner loop.\n *      (4) Input x,y are ignored unless pixm exists.\n */",
      "file" : "pix4.c"
   },
   {
      "function" : "pixGetColorRegion",
      "comment" : "/*!\n *  pixGetColorRegion()\n *\n *      Input:  pixs  (32 bpp; rgb color)\n *              sigbits (valid: 5, 6)\n *              subsample (integer > 0)\n *      Return: vbox (minimum 3D box in color space enclosing all pixels),\n *              or null on error\n *\n *  Notes:\n *      (1) Computes the minimum 3D box in color space enclosing all\n *          pixels in the image.\n */",
      "file" : "colorquant2.c"
   },
   {
      "function" : "pixGetColormap",
      "comment" : "/* no-op */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixGetColumnStats",
      "comment" : "/*!\n *  pixGetColumnStats()\n *\n *      Input:  pixs (8 bpp; not cmapped)\n *              type (L_MEAN_ABSVAL, L_MEDIAN_VAL, L_MODE_VAL, L_MODE_COUNT)\n *              nbins (of histogram for median and mode; ignored for mean)\n *              thresh (on histogram for mode val; ignored for all other types)\n *              rowvect (vector of results gathered down the columns of pixs)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This computes a row vector of statistics using each\n *          column of a Pix.  The result is put in @rowvect.\n *      (2) The @thresh parameter works with L_MODE_VAL only, and\n *          sets a minimum occupancy of the mode bin.\n *          If the occupancy of the mode bin is less than @thresh, the\n *          mode value is returned as 0.  To always return the actual\n *          mode value, set @thresh = 0.\n *      (3) What is the meaning of this @thresh parameter?\n *          For each column, the total count in the histogram is h, the\n *          image height.  So @thresh, relative to h, gives a measure\n *          of the ratio of the bin width to the width of the distribution.\n *          The larger @thresh, the narrower the distribution must be\n *          for the mode value to be returned (instead of returning 0).\n */",
      "file" : "pix4.c"
   },
   {
      "function" : "pixGetComponentRange",
      "comment" : "/*!\n *  pixGetComponentRange()\n *\n *      Input:  pixs (8 bpp grayscale, 32 bpp rgb, or colormapped)\n *              factor (subsampling factor; >= 1; ignored if colormapped)\n *              color (L_SELECT_RED, L_SELECT_GREEN or L_SELECT_BLUE)\n *              &minval (<optional return> minimum value of component)\n *              &maxval (<optional return> maximum value of component)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If pixs is 8 bpp grayscale, the color selection type is ignored.\n */",
      "file" : "pix4.c"
   },
   {
      "function" : "pixGetData",
      "comment" : "/*!\n *  pixGetData()\n *\n *  Notes:\n *      (1) This gives a new handle for the data.  The data is still\n *          owned by the pix, so do not call FREE() on it.\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixGetDepth",
      "comment" : "/*--------------------------------------------------------------------*\n *                                Accessors                           *\n *--------------------------------------------------------------------*/",
      "file" : "pix1.c"
   },
   {
      "function" : "pixGetDifferenceHistogram",
      "comment" : "/*!\n *  pixGetDifferenceHistogram()\n *\n *      Input:  pix1 (8 bpp gray or 32 bpp rgb, or colormapped)\n *              pix2 (8 bpp gray or 32 bpp rgb, or colormapped)\n *              factor (subsampling factor; use 0 or 1 for no subsampling)\n *      Return: na (Numa of histogram of differences), or null on error\n *\n *  Notes:\n *      (1) The two images are aligned at the UL corner, and do not\n *          need to be the same size.  If they are not the same size,\n *          the comparison will be made over overlapping pixels.\n *      (2) If there is a colormap, it is removed and the result\n *          is either gray or RGB depending on the colormap.\n *      (3) If RGB, the maximum difference between pixel components is\n *          saved in the histogram.\n */",
      "file" : "compare.c"
   },
   {
      "function" : "pixGetDifferenceStats",
      "comment" : "/*!\n *  pixGetDifferenceStats()\n *\n *      Input:  pix1 (8 bpp gray or 32 bpp rgb, or colormapped)\n *              pix2 (8 bpp gray or 32 bpp rgb, or colormapped)\n *              factor (subsampling factor; use 0 or 1 for no subsampling)\n *              mindiff (minimum pixel difference to be counted; > 0)\n *              &fractdiff (<return> fraction of pixels with diff greater\n *                          than or equal to mindiff)\n *              &avediff (<return> average difference of pixels with diff\n *                        greater than or equal to mindiff, less mindiff)\n *              printstats (use 1 to print normalized histogram to stderr)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This takes a threshold @mindiff and describes the difference\n *          between two images in terms of two numbers:\n *            (a) the fraction of pixels, @fractdiff, whose difference\n *                equals or exceeds the threshold @mindiff, and\n *            (b) the average value @avediff of the difference in pixel value\n *                for the pixels in the set given by (a), after you subtract\n *                @mindiff.  The reason for subtracting @mindiff is that\n *                you then get a useful measure for the rate of falloff\n *                of the distribution for larger differences.  For example,\n *                if @mindiff = 10 and you find that @avediff = 2.5, it\n *                says that of the pixels with diff > 10, the average of\n *                their diffs is just mindiff + 2.5 = 12.5.  This is a\n *                fast falloff in the histogram with increasing difference.\n *      (2) The two images are aligned at the UL corner, and do not\n *          need to be the same size.  If they are not the same size,\n *          the comparison will be made over overlapping pixels.\n *      (3) If there is a colormap, it is removed and the result\n *          is either gray or RGB depending on the colormap.\n *      (4) If RGB, the maximum difference between pixel components is\n *          saved in the histogram.\n */",
      "file" : "compare.c"
   },
   {
      "function" : "pixGetDimensions",
      "comment" : "/*!\n *  pixGetDimensions()\n *\n *      Input:  pix\n *              &w, &h, &d (<optional return>; each can be null)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixGetEdgeProfile",
      "comment" : "/*!\n *  pixGetEdgeProfile()\n *\n *      Input:  pixs (1 bpp)\n *              side (L_FROM_LEFT, L_FROM_RIGHT, L_FROM_TOP, L_FROM_BOT)\n *              debugfile (<optional> displays constructed edge; use NULL\n *                         for no output)\n *      Return: na (of fg edge pixel locations), or null on error\n */",
      "file" : "edge.c"
   },
   {
      "function" : "pixGetExtremeValue",
      "comment" : "/*!\n *  pixGetExtremeValue()\n *\n *      Input:  pixs (8 bpp grayscale, 32 bpp rgb, or colormapped)\n *              factor (subsampling factor; >= 1; ignored if colormapped)\n *              type (L_SELECT_MIN or L_SELECT_MAX)\n *              &rval (<optional return> red component)\n *              &gval (<optional return> green component)\n *              &bval (<optional return> blue component)\n *              &grayval (<optional return> min or max gray value)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If pixs is grayscale, the result is returned in &grayval.\n *          Otherwise, if there is a colormap or d == 32,\n *          each requested color component is returned.  At least\n *          one color component (address) must be input.\n */",
      "file" : "pix4.c"
   },
   {
      "function" : "pixGetGrayHistogram",
      "comment" : "/*!\n *  pixGetGrayHistogram()\n *\n *      Input:  pixs (1, 2, 4, 8, 16 bpp; can be colormapped)\n *              factor (subsampling factor; integer >= 1)\n *      Return: na (histogram), or null on error\n *\n *  Notes:\n *      (1) If pixs has a colormap, it is converted to 8 bpp gray.\n *          If you want a histogram of the colormap indices, use\n *          pixGetCmapHistogram().\n *      (2) If pixs does not have a colormap, the output histogram is\n *          of size 2^d, where d is the depth of pixs.\n *      (3) This always returns a 256-value histogram of pixel values.\n *      (4) Set the subsampling factor > 1 to reduce the amount of computation.\n */",
      "file" : "pix4.c"
   },
   {
      "function" : "pixGetGrayHistogramInRect",
      "comment" : "/*!\n *  pixGetGrayHistogramInRect()\n *\n *      Input:  pixs (8 bpp, or colormapped)\n *              box (<optional>) over which histogram is to be computed;\n *                   use full image if null)\n *              factor (subsampling factor; integer >= 1)\n *      Return: na (histogram), or null on error\n *\n *  Notes:\n *      (1) If pixs is cmapped, it is converted to 8 bpp gray.\n *          If you want a histogram of the colormap indices, use\n *          pixGetCmapHistogramInRect().\n *      (2) This always returns a 256-value histogram of pixel values.\n *      (3) Set the subsampling @factor > 1 to reduce the amount of computation.\n */",
      "file" : "pix4.c"
   },
   {
      "function" : "pixGetGrayHistogramMasked",
      "comment" : "/*!\n *  pixGetGrayHistogramMasked()\n *\n *      Input:  pixs (8 bpp, or colormapped)\n *              pixm (<optional> 1 bpp mask over which histogram is\n *                    to be computed; use all pixels if null)\n *              x, y (UL corner of pixm relative to the UL corner of pixs;\n *                    can be < 0; these values are ignored if pixm is null)\n *              factor (subsampling factor; integer >= 1)\n *      Return: na (histogram), or null on error\n *\n *  Notes:\n *      (1) If pixs is cmapped, it is converted to 8 bpp gray.\n *          If you want a histogram of the colormap indices, use\n *          pixGetCmapHistogramMasked().\n *      (2) This always returns a 256-value histogram of pixel values.\n *      (3) Set the subsampling factor > 1 to reduce the amount of computation.\n *      (4) Clipping of pixm (if it exists) to pixs is done in the inner loop.\n *      (5) Input x,y are ignored unless pixm exists.\n */",
      "file" : "pix4.c"
   },
   {
      "function" : "pixGetHeight",
      "comment" : "/*--------------------------------------------------------------------*\n *                                Accessors                           *\n *--------------------------------------------------------------------*/",
      "file" : "pix1.c"
   },
   {
      "function" : "pixGetHoleBorder",
      "comment" : "/*!\n *  pixGetHoleBorder()\n *\n *      Input:  ccb  (the exterior border is already made)\n *              pixs (for the connected component at hand)\n *              box  (for the specific hole border, in relative\n *                    coordinates to the c.c.)\n *              xs, ys   (first pixel on hole border, relative to c.c.)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) we trace out hole border on pixs without addition\n *          of single pixel added border to pixs\n *      (2) therefore all coordinates are relative within the c.c. (pixs)\n *      (3) same position tables and stopping condition as for\n *          exterior borders\n */",
      "file" : "ccbord.c"
   },
   {
      "function" : "pixGetInputFormat",
      "comment" : "/* no-op */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixGetInvBackgroundMap",
      "comment" : "/*!\n *  pixGetInvBackgroundMap()\n *\n *      Input:  pixs (8 bpp grayscale; no colormap)\n *              bgval (target bg val; typ. > 128)\n *              smoothx (half-width of block convolution kernel width)\n *              smoothy (half-width of block convolution kernel height)\n *      Return: pixd (16 bpp), or null on error\n *\n *  Note:\n *     - bgval should typically be > 120 and < 240\n *     - pixd is a normalization image; the original image is\n *       multiplied by pixd and the result is divided by 256.\n */",
      "file" : "adaptmap.c"
   },
   {
      "function" : "pixGetLastOffPixelInRun",
      "comment" : "/*\n *  pixGetLastOffPixelInRun()\n *\n *      Input:  pixs (1 bpp)\n *              x, y (starting location)\n *              direction (L_FROM_LEFT, L_FROM_RIGHT, L_FROM_TOP, L_FROM_BOT)\n *              &loc (<return> location in scan direction coordinate\n *                    of last OFF pixel found)\n *      Return: na (of fg edge pixel locations), or null on error\n *\n *  Notes:\n *      (1) Search starts from the pixel at (x, y), which is OFF.\n *      (2) It returns the location in the scan direction of the last\n *          pixel in the current run that is OFF.\n *      (3) The interface for these pixel run functions is cleaner when\n *          you ask for the last pixel in the current run, rather than the\n *          first pixel of opposite polarity that is found, because the\n *          current run may go to the edge of the image, in which case\n *          no pixel of opposite polarity is found.\n */",
      "file" : "edge.c"
   },
   {
      "function" : "pixGetLastOnPixelInRun",
      "comment" : "/*\n *  pixGetLastOnPixelInRun()\n *\n *      Input:  pixs (1 bpp)\n *              x, y (starting location)\n *              direction (L_FROM_LEFT, L_FROM_RIGHT, L_FROM_TOP, L_FROM_BOT)\n *              &loc (<return> location in scan direction coordinate\n *                    of first ON pixel found)\n *      Return: na (of fg edge pixel locations), or null on error\n *\n *  Notes:\n *      (1) Search starts from the pixel at (x, y), which is ON.\n *      (2) It returns the location in the scan direction of the last\n *          pixel in the current run that is ON.\n */",
      "file" : "edge.c"
   },
   {
      "function" : "pixGetLinePtrs",
      "comment" : "/*!\n *  pixGetLinePtrs()\n *\n *      Input:  pix\n *              &size (<optional return> array size, which is the pix height)\n *      Return: array of line ptrs, or null on error\n *\n *  Notes:\n *      (1) This is intended to be used for fast random pixel access.\n *          For example, for an 8 bpp image,\n *              val = GET_DATA_BYTE(lines8[i], j);\n *          is equivalent to, but much faster than,\n *              pixGetPixel(pix, j, i, &val);\n *      (2) How much faster?  For 1 bpp, it's from 6 to 10x faster.\n *          For 8 bpp, it's an amazing 30x faster.  So if you are\n *          doing random access over a substantial part of the image,\n *          use this line ptr array.\n *      (3) When random access is used in conjunction with a stack,\n *          queue or heap, the overall computation time depends on\n *          the operations performed on each struct that is popped\n *          or pushed, and whether we are using a priority queue (O(logn))\n *          or a queue or stack (O(1)).  For example, for maze search,\n *          the overall ratio of time for line ptrs vs. pixGet/Set* is\n *             Maze type     Type                   Time ratio\n *               binary      queue                     0.4\n *               gray        heap (priority queue)     0.6\n *      (4) Because this returns a void** and the accessors take void*,\n *          the compiler cannot check the pointer types.  It is\n *          strongly recommended that you adopt a naming scheme for\n *          the returned ptr arrays that indicates the pixel depth.\n *          (This follows the original intent of Simonyi's \"Hungarian\"\n *          application notation, where naming is used proactively\n *          to make errors visibly obvious.)  By doing this, you can\n *          tell by inspection if the correct accessor is used.\n *          For example, for an 8 bpp pixg:\n *              void **lineg8 = pixGetLinePtrs(pixg, NULL);\n *              val = GET_DATA_BYTE(lineg8[i], j);  // fast access; BYTE, 8\n *              ...\n *              FREE(lineg8);  // don't forget this\n *      (5) These are convenient for accessing bytes sequentially in an\n *          8 bpp grayscale image.  People who write image processing code\n *          on 8 bpp images are accustomed to grabbing pixels directly out\n *          of the raster array.  Note that for little endians, you first\n *          need to reverse the byte order in each 32-bit word.\n *          Here's a typical usage pattern:\n *              pixEndianByteSwap(pix);   // always safe; no-op on big-endians\n *              l_uint8 **lineptrs = (l_uint8 **)pixGetLinePtrs(pix, NULL);\n *              pixGetDimensions(pix, &w, &h, NULL);\n *              for (i = 0; i < h; i++) {\n *                  l_uint8 *line = lineptrs[i];\n *                  for (j = 0; j < w; j++) {\n *                      val = line[j];\n *                      ...\n *                  }\n *              }\n *              pixEndianByteSwap(pix);  // restore big-endian order\n *              FREE(lineptrs);\n *          This can be done even more simply as follows:\n *              l_uint8 **lineptrs = pixSetupByteProcessing(pix, &w, &h);\n *              for (i = 0; i < h; i++) {\n *                  l_uint8 *line = lineptrs[i];\n *                  for (j = 0; j < w; j++) {\n *                      val = line[j];\n *                      ...\n *                  }\n *              }\n *              pixCleanupByteProcessing(pix, lineptrs);\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixGetLocalSkewAngles",
      "comment" : "/*!\n *  pixGetLocalSkewAngles()\n *\n *      Input:  pixs\n *              nslices  (the number of horizontal overlapping slices; must\n *                  be larger than 1 and not exceed 20; use 0 for default)\n *              redsweep (sweep reduction factor: 1, 2, 4 or 8;\n *                        use 0 for default value)\n *              redsearch (search reduction factor: 1, 2, 4 or 8, and\n *                         not larger than redsweep; use 0 for default value)\n *              sweeprange (half the full range, assumed about 0; in degrees;\n *                          use 0.0 for default value)\n *              sweepdelta (angle increment of sweep; in degrees;\n *                          use 0.0 for default value)\n *              minbsdelta (min binary search increment angle; in degrees;\n *                          use 0.0 for default value)\n *              &a (<optional return> slope of skew as fctn of y)\n *              &b (<optional return> intercept at y=0 of skew as fctn of y)\n *      Return: naskew, or null on error\n *\n *  Notes:\n *      (1) The local skew is measured in a set of overlapping strips.\n *          We then do a least square linear fit parameters to get\n *          the slope and intercept parameters a and b in\n *              skew-angle = a * y + b  (degrees)\n *          for the local skew as a function of raster line y.\n *          This is then used to make naskew, which can be interpreted\n *          as the computed skew angle (in degrees) at the left edge\n *          of each raster line.\n *      (2) naskew can then be used to find the baselines of text, because\n *          each text line has a baseline that should intersect\n *          the left edge of the image with the angle given by this\n *          array, evaluated at the raster line of intersection.\n */",
      "file" : "baseline.c"
   },
   {
      "function" : "pixGetLocalSkewTransform",
      "comment" : "/*!\n *  pixGetLocalSkewTransform()\n *\n *      Input:  pixs\n *              nslices  (the number of horizontal overlapping slices; must\n *                  be larger than 1 and not exceed 20; use 0 for default)\n *              redsweep (sweep reduction factor: 1, 2, 4 or 8;\n *                        use 0 for default value)\n *              redsearch (search reduction factor: 1, 2, 4 or 8, and\n *                         not larger than redsweep; use 0 for default value)\n *              sweeprange (half the full range, assumed about 0; in degrees;\n *                          use 0.0 for default value)\n *              sweepdelta (angle increment of sweep; in degrees;\n *                          use 0.0 for default value)\n *              minbsdelta (min binary search increment angle; in degrees;\n *                          use 0.0 for default value)\n *              &ptas  (<return> 4 points in the source)\n *              &ptad  (<return> the corresponding 4 pts in the dest)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This generates two pairs of points in the src, each pair\n *          corresponding to a pair of points that would lie along\n *          the same raster line in a transformed (dewarped) image.\n *      (2) The sets of 4 src and 4 dest points returned by this function\n *          can then be used, in a projective or bilinear transform,\n *          to remove keystoning in the src.\n */",
      "file" : "baseline.c"
   },
   {
      "function" : "pixGetMaxValueInRect",
      "comment" : "/*!\n *  pixGetMaxValueInRect()\n *\n *      Input:  pixs (8 bpp or 32 bpp grayscale; no color space components)\n *              box (<optional> region; set box = NULL to use entire pixs)\n *              &maxval (<optional return> max value in region)\n *              &xmax (<optional return> x location of max value)\n *              &ymax (<optional return> y location of max value)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This can be used to find the maximum and its location\n *          in a 2-dimensional histogram, where the x and y directions\n *          represent two color components (e.g., saturation and hue).\n *      (2) Note that here a 32 bpp pixs has pixel values that are simply\n *          numbers.  They are not 8 bpp components in a colorspace.\n */",
      "file" : "pix4.c"
   },
   {
      "function" : "pixGetMomentByColumn",
      "comment" : "/*!\n *  pixGetMomentByColumn()\n *\n *      Input:  pix (1 bpp)\n *              order (of moment, either 1 or 2)\n *      Return: na of first moment of fg pixels, by column, or null on error\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixGetMostPopulatedColors",
      "comment" : "/*!\n *  pixGetMostPopulatedColors()\n *      Input:  pixs (32 bpp rgb)\n *              sigbits (2-6, significant bits retained in the quantizer\n *                       for each component of the input image)\n *              factor (subsampling factor; use 1 for no subsampling)\n *              ncolors (the number of most populated colors to select)\n *              &array (<optional return> array of colors, each as 0xrrggbb00)\n *              &cmap (<optional return> colormap of the colors)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This finds the @ncolors most populated cubes in rgb colorspace,\n *          where the cube size depends on @sigbits as\n *               cube side = (256 >> sigbits)\n *      (2) The rgb color components are found at the center of the cube.\n *      (3) The output array of colors can be displayed using\n *               pixDisplayColorArray(array, ncolors, ...);\n */",
      "file" : "colorcontent.c"
   },
   {
      "function" : "pixGetOuterBorder",
      "comment" : "/*!\n *  pixGetOuterBorder()\n *\n *      Input:  ccb  (unfilled)\n *              pixs (for the component at hand)\n *              box  (for the component, in global coords)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) the border is saved in relative coordinates within\n *          the c.c. (pixs).  Because the calculation is done\n *          in pixb with added 1 pixel border, we must subtract\n *          1 from each pixel value before storing it.\n *      (2) the stopping condition is that after the first pixel is\n *          returned to, the next pixel is the second pixel.  Having\n *          these 2 pixels recur in sequence proves the path is closed,\n *          and we do not store the second pixel again.\n */",
      "file" : "ccbord.c"
   },
   {
      "function" : "pixGetOuterBorderPta",
      "comment" : "/*!\n *  pixGetOuterBorderPta()\n *\n *      Input:  pixs (1 bpp, one 8-connected component)\n *              box  (<optional> of pixs, in global coordinates)\n *      Return: pta (of outer border, in global coords), or null on error\n *\n *  Notes:\n *      (1) We are finding the exterior border of a single 8-connected\n *          component.\n *      (2) If box is NULL, the outline returned is in the local coords\n *          of the input pix.  Otherwise, box is assumed to give the\n *          location of the pix in global coordinates, and the returned\n *          pta will be in those global coordinates.\n */",
      "file" : "ccbord.c"
   },
   {
      "function" : "pixGetOuterBordersPtaa",
      "comment" : "/*!\n *  pixGetOuterBordersPtaa()\n *\n *      Input:  pixs (1 bpp)\n *      Return: ptaa (of outer borders, in global coords), or null on error\n */",
      "file" : "ccbord.c"
   },
   {
      "function" : "pixGetPSNR",
      "comment" : "/*!\n *  pixGetPSNR()\n *\n *      Input:  pix1, pix2 (8 or 32 bpp; no colormap)\n *              factor (sampling factor; >= 1)\n *              &psnr (<return> power signal/noise ratio difference)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This computes the power S/N ratio, in dB, for the difference\n *          between two images.  By convention, the power S/N\n *          for a grayscale image is ('log' == log base 10,\n *          and 'ln == log base e):\n *            PSNR = 10 * log((255/MSE)^2)\n *                 = 4.3429 * ln((255/MSE)^2)\n *                 = -4.3429 * ln((MSE/255)^2)\n *          where MSE is the mean squared error.\n *          Here are some examples:\n *             MSE             PSNR\n *             ---             ----\n *             10              28.1\n *             3               38.6\n *             1               48.1\n *             0.1             68.1\n *      (2) If pix1 and pix2 have the same pixel values, the MSE = 0.0\n *          and the PSNR is infinity.  For that case, this returns\n *          PSNR = 1000, which corresponds to the very small MSE of\n *          about 10^(-48).\n */",
      "file" : "compare.c"
   },
   {
      "function" : "pixGetPerceptualDiff",
      "comment" : "/*!\n *  pixGetPerceptualDiff()\n *\n *      Input:  pix1 (8 bpp gray or 32 bpp rgb, or colormapped)\n *              pix2 (8 bpp gray or 32 bpp rgb, or colormapped)\n *              sampling (subsampling factor; use 0 or 1 for no subsampling)\n *              dilation (size of grayscale or color Sel; odd)\n *              mindiff (minimum pixel difference to be counted; > 0)\n *              &fract (<return> fraction of pixels with diff greater than\n *                      mindiff)\n *              &pixdiff1 (<optional return> showing difference (gray or color))\n *              &pixdiff2 (<optional return> showing pixels of sufficient diff)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This takes 2 pix and determines, using 2 input parameters:\n *           * @dilation specifies the amount of grayscale or color\n *             dilation to apply to the images, to compensate for\n *             a small amount of misregistration.  A typical number might\n *             be 5, which uses a 5x5 Sel.  Grayscale dilation expands\n *             lighter pixels into darker pixel regions.\n *           * @mindiff determines the threshold on the difference in\n *             pixel values to be counted -- two pixels are not similar\n *             if their difference in value is at least @mindiff.  For\n *             color pixels, we use the maximum component difference.\n *      (2) The pixelwise comparison is always done with the UL corners\n *          aligned.  The sizes of pix1 and pix2 need not be the same,\n *          although in practice it can be useful to scale to the same size.\n *      (3) If there is a colormap, it is removed and the result\n *          is either gray or RGB depending on the colormap.\n *      (4) Two optional diff images can be retrieved (typ. for debugging):\n *           pixdiff1: the gray or color difference\n *           pixdiff2: thresholded to 1 bpp for pixels exceeding @mindiff\n *      (5) The returned value of fract can be compared to some threshold,\n *          which is application dependent.\n *      (6) This method is in analogy to the two-sided hausdorff transform,\n *          except here it is for d > 1.  For d == 1 (see pixRankHaustest()),\n *          we verify that when one pix1 is dilated, it covers at least a\n *          given fraction of the pixels in pix2, and v.v.; in that\n *          case, the two pix are sufficiently similar.  Here, we\n *          do an analogous thing: subtract the dilated pix1 from pix2 to\n *          get a 1-sided hausdorff-like transform.  Then do it the\n *          other way.  Take the component-wise max of the two results,\n *          and threshold to get the fraction of pixels with a difference\n *          below the threshold.\n */",
      "file" : "compare.c"
   },
   {
      "function" : "pixGetPixel",
      "comment" : "/*!\n *  pixGetPixel()\n *\n *      Input:  pix\n *              (x,y) pixel coords\n *              &val (<return> pixel value)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This returns the value in the data array.  If the pix is\n *          colormapped, it returns the colormap index, not the rgb value.\n *      (2) Because of the function overhead and the parameter checking,\n *          this is much slower than using the GET_DATA_*() macros directly.\n *          Speed on a 1 Mpixel RGB image, using a 3 GHz machine:\n *            * pixGet/pixSet: ~25 Mpix/sec\n *            * GET_DATA/SET_DATA: ~350 MPix/sec\n *          If speed is important and you're doing random access into\n *          the pix, use pixGetLinePtrs() and the array access macros.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixGetRGBComponent",
      "comment" : "/*!\n *  pixGetRGBComponent()\n *\n *      Input:  pixs (32 bpp, or colormapped)\n *              comp (one of {COLOR_RED, COLOR_GREEN, COLOR_BLUE,\n *                    L_ALPHA_CHANNEL})\n *      Return: pixd (the selected 8 bpp component image of the\n *                    input 32 bpp image) or null on error\n *\n *  Notes:\n *      (1) Three calls to this function generate the r, g and b 8 bpp\n *          component images.  This is much faster than generating the\n *          three images in parallel, by extracting a src pixel and setting\n *          the pixels of each component image from it.  The reason is\n *          there are many more cache misses when writing to three\n *          output images simultaneously.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixGetRGBComponentCmap",
      "comment" : "/*!\n *  pixGetRGBComponentCmap()\n *\n *      Input:  pixs  (colormapped)\n *              comp  (one of the set: {COLOR_RED, COLOR_GREEN, COLOR_BLUE})\n *      Return: pixd  (the selected 8 bpp component image of the\n *                     input cmapped image), or null on error\n *\n *  Notes:\n *      (1) In leptonica, we do not support alpha in colormaps.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixGetRGBHistogram",
      "comment" : "/*!\n *  pixGetRGBHistogram()\n *      Input:  pixs (32 bpp rgb)\n *              sigbits (2-6, significant bits retained in the quantizer\n *                       for each component of the input image)\n *              factor (subsampling factor; use 1 for no subsampling)\n *      Return: numa (histogram of colors, indexed by RGB\n *                    components), or null on error\n *\n *  Notes:\n *      (1) This uses a simple, fast method of indexing into an rgb image.\n *      (2) The output is a 1D histogram of count vs. rgb-index, which\n *          uses red sigbits as the most significant and blue as the least.\n *      (3) This function produces the same result as pixMedianCutHisto().\n */",
      "file" : "colorcontent.c"
   },
   {
      "function" : "pixGetRGBLine",
      "comment" : "/*!\n *  pixGetRGBLine()\n *\n *      Input:  pixs  (32 bpp)\n *              row\n *              bufr  (array of red samples; size w bytes)\n *              bufg  (array of green samples; size w bytes)\n *              bufb  (array of blue samples; size w bytes)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This puts rgb components from the input line in pixs\n *          into the given buffers.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixGetRGBPixel",
      "comment" : "/*!\n *  pixGetRGBPixel()\n *\n *      Input:  pix (32 bpp rgb, not colormapped)\n *              (x,y) pixel coords\n *              &rval (<optional return> red component)\n *              &gval (<optional return> green component)\n *              &bval (<optional return> blue component)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixGetRandomPixel",
      "comment" : "/*!\n *  pixGetRandomPixel()\n *\n *      Input:  pix (any depth; can be colormapped)\n *              &val (<return> pixel value)\n *              &x (<optional return> x coordinate chosen; can be null)\n *              &y (<optional return> y coordinate chosen; can be null)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) If the pix is colormapped, it returns the rgb value.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixGetRankColorArray",
      "comment" : "/*!\n *  pixGetRankColorArray()\n *\n *      Input:  pixs (32 bpp or cmapped)\n *              nbins (number of equal population bins; must be > 1)\n *              type (color selection flag)\n *              factor (subsampling factor; integer >= 1)\n *              &carray (<return> array of colors, ranked by intensity)\n *              debugflag (1 to display color squares and plots of color\n *                         components; 2 to write them as png to file)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The color selection flag is one of: L_SELECT_RED, L_SELECT_GREEN,\n *          L_SELECT_BLUE, L_SELECT_MIN, L_SELECT_MAX.\n *      (2) Then it finds the histogram of the selected component in each\n *          RGB pixel.  For each of the @nbins sets of pixels,\n *          ordered by this component value, find the average color,\n *          and return this as a \"rank color\" array.  The output array\n *          has @nbins colors.\n *      (3) Set the subsampling factor > 1 to reduce the amount of\n *          computation.  Typically you want at least 10,000 pixels\n *          for reasonable statistics.\n *      (4) The rank color as a function of rank can then be found from\n *             rankint = (l_int32)(rank * (nbins - 1) + 0.5);\n *             extractRGBValues(array[rankint], &rval, &gval, &bval);\n *          where the rank is in [0.0 ... 1.0].\n *          This function is meant to be simple and approximate.\n *      (5) Compare this with pixGetBinnedColor(), which generates equal\n *          width intensity bins and finds the average color in each bin.\n */",
      "file" : "pix4.c"
   },
   {
      "function" : "pixGetRankValue",
      "comment" : "/*!\n *  pixGetRankValue()\n *\n *      Input:  pixs (8 bpp, 32 bpp or colormapped)\n *              factor (subsampling factor; integer >= 1)\n *              rank (between 0.0 and 1.0; 1.0 is brightest, 0.0 is darkest)\n *              &value (<return> pixel value corresponding to input rank)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Simple function to get rank values of an image.\n *          For a color image, the median value (rank = 0.5) can be\n *          used to linearly remap the colors based on the median\n *          of a target image, using pixLinearMapToTargetColor().\n */",
      "file" : "pix4.c"
   },
   {
      "function" : "pixGetRankValueMasked",
      "comment" : "/*!\n *  pixGetRankValueMasked()\n *\n *      Input:  pixs (8 bpp, or colormapped)\n *              pixm (<optional> 1 bpp mask over which rank val is to be taken;\n *                    use all pixels if null)\n *              x, y (UL corner of pixm relative to the UL corner of pixs;\n *                    can be < 0; these values are ignored if pixm is null)\n *              factor (subsampling factor; integer >= 1)\n *              rank (between 0.0 and 1.0; 1.0 is brightest, 0.0 is darkest)\n *              &val (<return> pixel value corresponding to input rank)\n *              &na (<optional return> of histogram)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Computes the rank value of pixels in pixs that are under\n *          the fg of the optional mask.  If the mask is null, it\n *          computes the average of the pixels in pixs.\n *      (2) Set the subsampling @factor > 1 to reduce the amount of\n *          computation.\n *      (3) Clipping of pixm (if it exists) to pixs is done in the inner loop.\n *      (4) Input x,y are ignored unless pixm exists.\n *      (5) The rank must be in [0.0 ... 1.0], where the brightest pixel\n *          has rank 1.0.  For the median pixel value, use 0.5.\n *      (6) The histogram can optionally be returned, so that other rank\n *          values can be extracted without recomputing the histogram.\n *          In that case, just use\n *              numaHistogramGetValFromRank(na, rank, &val);\n *          on the returned Numa for additional rank values.\n */",
      "file" : "pix4.c"
   },
   {
      "function" : "pixGetRankValueMaskedRGB",
      "comment" : "/*!\n *  pixGetRankValueMaskedRGB()\n *\n *      Input:  pixs (32 bpp)\n *              pixm (<optional> 1 bpp mask over which rank val is to be taken;\n *                    use all pixels if null)\n *              x, y (UL corner of pixm relative to the UL corner of pixs;\n *                    can be < 0; these values are ignored if pixm is null)\n *              factor (subsampling factor; integer >= 1)\n *              rank (between 0.0 and 1.0; 1.0 is brightest, 0.0 is darkest)\n *              &rval (<optional return> red component val for to input rank)\n *              &gval (<optional return> green component val for to input rank)\n *              &bval (<optional return> blue component val for to input rank)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Computes the rank component values of pixels in pixs that\n *          are under the fg of the optional mask.  If the mask is null, it\n *          computes the average of the pixels in pixs.\n *      (2) Set the subsampling @factor > 1 to reduce the amount of\n *          computation.\n *      (4) Input x,y are ignored unless pixm exists.\n *      (5) The rank must be in [0.0 ... 1.0], where the brightest pixel\n *          has rank 1.0.  For the median pixel value, use 0.5.\n */",
      "file" : "pix4.c"
   },
   {
      "function" : "pixGetRasterData",
      "comment" : "/*!\n *  pixGetRasterData()\n *\n *      Input:  pixs (1, 8, 32 bpp)\n *              &data (<return> raster data in memory)\n *              &nbytes (<return> number of bytes in data string)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This returns the raster data as a byte string, padded to the\n *          byte.  For 1 bpp, the first pixel is the MSbit in the first byte.\n *          For rgb, the bytes are in (rgb) order.  This is the format\n *          required for flate encoding of pixels in a PostScript file.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixGetRefcount",
      "comment" : "/* no-op */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixGetRegionsBinary",
      "comment" : "/*!\n *  pixGetRegionsBinary()\n *\n *      Input:  pixs (1 bpp, assumed to be 300 to 400 ppi)\n *              &pixhm (<optional return> halftone mask)\n *              &pixtm (<optional return> textline mask)\n *              &pixtb (<optional return> textblock mask)\n *              debug (flag: set to 1 for debug output)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) It is best to deskew the image before segmenting.\n *      (2) The debug flag enables a number of outputs.  These\n *          are included to show how to generate and save/display\n *          these results.\n */",
      "file" : "pageseg.c"
   },
   {
      "function" : "pixGetResolution",
      "comment" : "/*!\n *  pixGetResolution()\n *\n *      Input:  pix\n *              &xres, &yres (<optional return>; each can be null)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixGetRowStats",
      "comment" : "/*!\n *  pixGetRowStats()\n *\n *      Input:  pixs (8 bpp; not cmapped)\n *              type (L_MEAN_ABSVAL, L_MEDIAN_VAL, L_MODE_VAL, L_MODE_COUNT)\n *              nbins (of histogram for median and mode; ignored for mean)\n *              thresh (on histogram for mode; ignored for mean and median)\n *              colvect (vector of results gathered across the rows of pixs)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This computes a column vector of statistics using each\n *          row of a Pix.  The result is put in @colvect.\n *      (2) The @thresh parameter works with L_MODE_VAL only, and\n *          sets a minimum occupancy of the mode bin.\n *          If the occupancy of the mode bin is less than @thresh, the\n *          mode value is returned as 0.  To always return the actual\n *          mode value, set @thresh = 0.\n *      (3) What is the meaning of this @thresh parameter?\n *          For each row, the total count in the histogram is w, the\n *          image width.  So @thresh, relative to w, gives a measure\n *          of the ratio of the bin width to the width of the distribution.\n *          The larger @thresh, the narrower the distribution must be\n *          for the mode value to be returned (instead of returning 0).\n *      (4) If the Pix consists of a set of corresponding columns,\n *          one for each Pix in a Pixa, the width of the Pix is the\n *          number of Pix in the Pixa and the column vector can\n *          be stored as a column in a Pix of the same size as\n *          each Pix in the Pixa.\n */",
      "file" : "pix4.c"
   },
   {
      "function" : "pixGetRunCentersOnLine",
      "comment" : "/*!\n *  pixGetRunCentersOnLine()\n *\n *      Input:  pixs (1 bpp)\n *              x, y (set one of these to -1; see notes)\n *              minlength (minimum length of acceptable run)\n *      Return: numa of fg runs, or null on error\n *\n *  Notes:\n *      (1) Action: this function computes the fg (black) and bg (white)\n *          pixel runlengths along the specified horizontal or vertical line,\n *          and returns a Numa of the \"center\" pixels of each fg run\n *          whose length equals or exceeds the minimum length.\n *      (2) This only works on horizontal and vertical lines.\n *      (3) For horizontal runs, set x = -1 and y to the value\n *          for all points along the raster line.  For vertical runs,\n *          set y = -1 and x to the value for all points along the\n *          pixel column.\n *      (4) For horizontal runs, the points in the Numa are the x\n *          values in the center of fg runs that are of length at\n *          least 'minlength'.  For vertical runs, the points in the\n *          Numa are the y values in the center of fg runs, again\n *          of length 'minlength' or greater.\n *      (5) If there are no fg runs along the line that satisfy the\n *          minlength constraint, the returned Numa is empty.  This\n *          is not an error.\n */",
      "file" : "selgen.c"
   },
   {
      "function" : "pixGetRunsOnLine",
      "comment" : "/*!\n *  pixGetRunsOnLine()\n *\n *      Input:  pixs (1 bpp)\n *              x1, y1, x2, y2\n *      Return: numa, or null on error\n *\n *  Notes:\n *      (1) Action: this function uses the bresenham algorithm to compute\n *          the pixels along the specified line.  It returns a Numa of the\n *          runlengths of the fg (black) and bg (white) runs, always\n *          starting with a white run.\n *      (2) If the first pixel on the line is black, the length of the\n *          first returned run (which is white) is 0.\n */",
      "file" : "selgen.c"
   },
   {
      "function" : "pixGetSpp",
      "comment" : "/* no-op */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixGetText",
      "comment" : "/*!\n *  pixGetText()\n *\n *      Input:  pix\n *      Return: ptr to existing text string\n *\n *  Notes:\n *      (1) The text string belongs to the pix.  The caller must\n *          NOT free it!\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixGetTextBaseline",
      "comment" : "/*!\n *  pixGetTextBaseline()\n *\n *      Input:  pixs (1 bpp, one textline character set)\n *              tab8 (<optional> pixel sum table)\n *              &y   (<return> baseline value)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Method: find the largest difference in pixel sums from one\n *          raster line to the next one below it.  The baseline is the\n *          upper raster line for the pair of raster lines that\n *          maximizes this function.\n */",
      "file" : "bmf.c"
   },
   {
      "function" : "pixGetWidth",
      "comment" : "/*--------------------------------------------------------------------*\n *                                Accessors                           *\n *--------------------------------------------------------------------*/",
      "file" : "pix1.c"
   },
   {
      "function" : "pixGetWindowsHBITMAP",
      "comment" : "/*!\n *  pixGetWindowsHBITMAP()\n *\n *      Input:  pix\n *      Return: Windows hBitmap, or null on error\n *\n *  Notes:\n *      (1) It's the responsibility of the caller to destroy the\n *          returned hBitmap with a call to DeleteObject (or with\n *          something that eventually calls DeleteObject).\n */",
      "file" : "leptwin.c"
   },
   {
      "function" : "pixGetWordBoxesInTextlines",
      "comment" : "/*!\n *  pixGetWordBoxesInTextlines()\n *\n *      Input:  pixs (1 bpp, typ. 300 ppi)\n *              reduction (1 for input res; 2 for 2x reduction of input res)\n *              minwidth, minheight (of saved components; smaller are discarded)\n *              maxwidth, maxheight (of saved components; larger are discarded)\n *              &boxad (<return> word boxes sorted in textline line order)\n *              &naindex (<optional return> index of textline for each word)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The input should be at a resolution of about 300 ppi.\n *          The word masks can be computed at either 150 ppi or 300 ppi.\n *          For the former, set reduction = 2.\n *      (2) This is a special version of pixGetWordsInTextlines(), that\n *          just finds the word boxes in line order, with a numa\n *          giving the textline index for each word.\n *          See pixGetWordsInTextlines() for more details.\n */",
      "file" : "classapp.c"
   },
   {
      "function" : "pixGetWordsInTextlines",
      "comment" : "/*!\n *  pixGetWordsInTextlines()\n *\n *      Input:  pixs (1 bpp, typ. 300 ppi)\n *              reduction (1 for input res; 2 for 2x reduction of input res)\n *              minwidth, minheight (of saved components; smaller are discarded)\n *              maxwidth, maxheight (of saved components; larger are discarded)\n *              &boxad (<return> word boxes sorted in textline line order)\n *              &pixad (<return> word images sorted in textline line order)\n *              &naindex (<return> index of textline for each word)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The input should be at a resolution of about 300 ppi.\n *          The word masks and word images can be computed at either\n *          150 ppi or 300 ppi.  For the former, set reduction = 2.\n *      (2) The four size constraints on saved components are all\n *          scaled by @reduction.\n *      (3) The result are word images (and their b.b.), extracted in\n *          textline order, at either full res or 2x reduction,\n *          and with a numa giving the textline index for each word.\n *      (4) The pixa and boxa interfaces should make this type of\n *          application simple to put together.  The steps are:\n *           - optionally reduce by 2x\n *           - generate first estimate of word masks\n *           - get b.b. of these, and remove the small and big ones\n *           - extract pixa of the word images, using the b.b.\n *           - sort actual word images in textline order (2d)\n *           - flatten them to a pixa (1d), saving the textline index\n *             for each pix\n *      (5) In an actual application, it may be desirable to pre-filter\n *          the input image to remove large components, to extract\n *          single columns of text, and to deskew them.  For example,\n *          to remove both large components and small noisy components\n *          that can interfere with the statistics used to estimate\n *          parameters for segmenting by words, but still retain text lines,\n *          the following image preprocessing can be done:\n *                Pix *pixt = pixMorphSequence(pixs, \"c40.1\", 0);\n *                Pix *pixf = pixSelectBySize(pixt, 0, 60, 8,\n *                                     L_SELECT_HEIGHT, L_SELECT_IF_LT, NULL);\n *                pixAnd(pixf, pixf, pixs);  // the filtered image\n *          The closing turns text lines into long blobs, but does not\n *          significantly increase their height.  But if there are many\n *          small connected components in a dense texture, this is likely\n *          to generate tall components that will be eliminated in pixf.\n */",
      "file" : "classapp.c"
   },
   {
      "function" : "pixGetWpl",
      "comment" : "/* no-op */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixGetXRes",
      "comment" : "/* no-op */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixGetYRes",
      "comment" : "/* no-op */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixGlobalNormNoSatRGB",
      "comment" : "/*!\n *  pixGlobalNormNoSatRGB()\n *\n *      Input:  pixd (<optional> null, existing or equal to pixs)\n *              pixs (32 bpp rgb)\n *              rval, gval, bval (pixel values in pixs that are\n *                                linearly mapped to mapval; but see below)\n *              factor (subsampling factor; integer >= 1)\n *              rank (between 0.0 and 1.0; typ. use a value near 1.0)\n *      Return: pixd (32 bpp rgb), or null on error\n *\n *  Notes:\n *    (1) This is a version of pixGlobalNormRGB(), where the output\n *        intensity is scaled back so that a controlled fraction of\n *        pixel components is allowed to saturate.  See comments in\n *        pixGlobalNormRGB().\n *    (2) The value of pixd determines if the results are written to a\n *        new pix (use NULL), in-place to pixs (use pixs), or to some\n *        other existing pix.\n *    (3) This does a global normalization of an image where the\n *        r,g,b color components are not balanced.  Thus, white in pixs is\n *        represented by a set of r,g,b values that are not all 255.\n *    (4) The input values (rval, gval, bval) can be chosen to be the\n *        color that, after normalization, becomes white background.\n *        For images that are mostly background, the closer these values\n *        are to the median component values, the closer the resulting\n *        background will be to gray, becoming white at the brightest places.\n *    (5) The mapval used in pixGlobalNormRGB() is computed here to\n *        avoid saturation of any component in the image (save for a\n *        fraction of the pixels given by the input rank value).\n */",
      "file" : "adaptmap.c"
   },
   {
      "function" : "pixGlobalNormRGB",
      "comment" : "/*!\n *  pixGlobalNormRGB()\n *\n *      Input:  pixd (<optional> null, existing or equal to pixs)\n *              pixs (32 bpp rgb, or colormapped)\n *              rval, gval, bval (pixel values in pixs that are\n *                                linearly mapped to mapval)\n *              mapval (use 255 for mapping to white)\n *      Return: pixd (32 bpp rgb or colormapped), or null on error\n *\n *  Notes:\n *    (1) The value of pixd determines if the results are written to a\n *        new pix (use NULL), in-place to pixs (use pixs), or to some\n *        other existing pix.\n *    (2) This does a global normalization of an image where the\n *        r,g,b color components are not balanced.  Thus, white in pixs is\n *        represented by a set of r,g,b values that are not all 255.\n *    (3) The input values (rval, gval, bval) should be chosen to\n *        represent the gray color (mapval, mapval, mapval) in src.\n *        Thus, this function will map (rval, gval, bval) to that gray color.\n *    (4) Typically, mapval = 255, so that (rval, gval, bval)\n *        corresponds to the white point of src.  In that case, these\n *        parameters should be chosen so that few pixels have higher values.\n *    (5) In all cases, we do a linear TRC separately on each of the\n *        components, saturating at 255.\n *    (6) If the input pix is 8 bpp without a colormap, you can get\n *        this functionality with mapval = 255 by calling:\n *            pixGammaTRC(pixd, pixs, 1.0, 0, bgval);\n *        where bgval is the value you want to be mapped to 255.\n *        Or more generally, if you want bgval to be mapped to mapval:\n *            pixGammaTRC(pixd, pixs, 1.0, 0, 255 * bgval / mapval);\n */",
      "file" : "adaptmap.c"
   },
   {
      "function" : "pixGrayMorphSequence",
      "comment" : "/*!\n *  pixGrayMorphSequence()\n *\n *      Input:  pixs\n *              sequence (string specifying sequence)\n *              dispsep (controls debug display of each result in the sequence:\n *                       0: no output\n *                       > 0: gives horizontal separation in pixels between\n *                            successive displays\n *                       < 0: pdf output; abs(dispsep) is used for naming)\n *              dispy (if dispsep > 0, this gives the y-value of the\n *                     UL corner for display; otherwise it is ignored)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This works on 8 bpp grayscale images.\n *      (2) This runs a pipeline of operations; no branching is allowed.\n *      (3) This only uses brick SELs.\n *      (4) A new image is always produced; the input image is not changed.\n *      (5) This contains an interpreter, allowing sequences to be\n *          generated and run.\n *      (6) The format of the sequence string is defined below.\n *      (7) In addition to morphological operations, the composite\n *          morph/subtract tophat can be performed.\n *      (8) Sel sizes (width, height) must each be odd numbers.\n *      (9) Intermediate results can optionally be displayed\n *      (10) The sequence string is formatted as follows:\n *            - An arbitrary number of operations,  each separated\n *              by a '+' character.  White space is ignored.\n *            - Each operation begins with a case-independent character\n *              specifying the operation:\n *                 d or D  (dilation)\n *                 e or E  (erosion)\n *                 o or O  (opening)\n *                 c or C  (closing)\n *                 t or T  (tophat)\n *            - The args to the morphological operations are bricks of hits,\n *              and are formatted as a.b, where a and b are horizontal and\n *              vertical dimensions, rsp. (each must be an odd number)\n *            - The args to the tophat are w or W (for white tophat)\n *              or b or B (for black tophat), followed by a.b as for\n *              the dilation, erosion, opening and closing.\n *           Example valid sequences are:\n *             \"c5.3 + o7.5\"\n *             \"c9.9 + tw9.9\"\n */",
      "file" : "morphseq.c"
   },
   {
      "function" : "pixGrayQuantFromCmap",
      "comment" : "/*!\n *  pixGrayQuantFromCmap()\n *\n *      Input:  pixs (8 bpp grayscale without cmap)\n *              cmap (to quantize to; of dest pix)\n *              mindepth (minimum depth of pixd: can be 2, 4 or 8 bpp)\n *      Return: pixd (2, 4 or 8 bpp, colormapped), or null on error\n *\n *  Notes:\n *      (1) In use, pixs is an 8 bpp grayscale image without a colormap.\n *          If there is an existing colormap, a warning is issued and\n *          a copy of the input pixs is returned.\n */",
      "file" : "grayquant.c"
   },
   {
      "function" : "pixGrayQuantFromHisto",
      "comment" : "/*!\n *  pixGrayQuantFromHisto()\n *\n *      Input:  pixd (<optional> quantized pix with cmap; can be null)\n *              pixs (8 bpp gray input pix; not cmapped)\n *              pixm (<optional> mask over pixels in pixs to quantize)\n *              minfract (minimum fraction of pixels in a set of adjacent\n *                        histo bins that causes the set to be automatically\n *                        set aside as a color in the colormap; must be\n *                        at least 0.01)\n *              maxsize (maximum number of adjacent bins allowed to represent\n *                       a color, regardless of the population of pixels\n *                       in the bins; must be at least 2)\n *      Return: pixd (8 bpp, cmapped), or null on error\n *\n *  Notes:\n *      (1) This is useful for quantizing images with relatively few\n *          colors, but which may have both color and gray pixels.\n *          If there are color pixels, it is assumed that an input\n *          rgb image has been color quantized first so that:\n *            - pixd has a colormap describing the color pixels\n *            - pixm is a mask over the non-color pixels in pixd\n *            - the colormap in pixd, and the color pixels in pixd,\n *              have been repacked to go from 0 to n-1 (n colors)\n *          If there are no color pixels, pixd and pixm are both null,\n *          and all pixels in pixs are quantized to gray.\n *      (2) A 256-entry histogram is built of the gray values in pixs.\n *          If pixm exists, the pixels contributing to the histogram are\n *          restricted to the fg of pixm.  A colormap and LUT are generated\n *          from this histogram.  We break up the array into a set\n *          of intervals, each one constituting a color in the colormap:\n *          An interval is identified by summing histogram bins until\n *          either the sum equals or exceeds the @minfract of the total\n *          number of pixels, or the span itself equals or exceeds @maxsize.\n *          The color of each bin is always an average of the pixels\n *          that constitute it.\n *      (3) Note that we do not specify the number of gray colors in\n *          the colormap.  Instead, we specify two parameters that\n *          describe the accuracy of the color assignments; this and\n *          the actual image determine the number of resulting colors.\n *      (4) If a mask exists and it is not the same size as pixs, make\n *          a new mask the same size as pixs, with the original mask\n *          aligned at the UL corners.  Set all additional pixels\n *          in the (larger) new mask set to 1, causing those pixels\n *          in pixd to be set as gray.\n *      (5) We estimate the total number of colors (color plus gray);\n *          if it exceeds 255, return null.\n */",
      "file" : "grayquant.c"
   },
   {
      "function" : "pixHDome",
      "comment" : "/*!\n *  pixHDome()\n *\n *      Input:  pixs (8 bpp, filling mask)\n *              height (of seed below the filling maskhdome; must be >= 0)\n *              connectivity (4 or 8)\n *      Return: pixd (8 bpp), or null on error\n *\n *  Notes:\n *      (1) It is more efficient to use a connectivity of 4 for the fill.\n *      (2) This fills bumps to some level, and extracts the unfilled\n *          part of the bump.  To extract the troughs of basins, first\n *          invert pixs and then apply pixHDome().\n *      (3) It is useful to compare the HDome operation with the TopHat.\n *          The latter extracts peaks or valleys that have a width\n *          not exceeding the size of the structuring element used\n *          in the opening or closing, rsp.  The height of the peak is\n *          irrelevant.  By contrast, for the HDome, the gray seedfill\n *          is used to extract all peaks that have a height not exceeding\n *          a given value, regardless of their width!\n *      (4) Slightly more precisely, suppose you set 'height' = 40.\n *          Then all bumps in pixs with a height greater than or equal\n *          to 40 become, in pixd, bumps with a max value of exactly 40.\n *          All shorter bumps have a max value in pixd equal to the height\n *          of the bump.\n *      (5) The method: the filling mask, pixs, is the image whose peaks\n *          are to be extracted.  The height of a peak is the distance\n *          between the top of the peak and the highest \"leak\" to the\n *          outside -- think of a sombrero, where the leak occurs\n *          at the highest point on the rim.\n *            (a) Generate a seed, pixd, by subtracting some value, p, from\n *                each pixel in the filling mask, pixs.  The value p is\n *                the 'height' input to this function.\n *            (b) Fill in pixd starting with this seed, clipping by pixs,\n *                in the way described in seedfillGrayLow().  The filling\n *                stops before the peaks in pixs are filled.\n *                For peaks that have a height > p, pixd is filled to\n *                the level equal to the (top-of-the-peak - p).\n *                For peaks of height < p, the peak is left unfilled\n *                from its highest saddle point (the leak to the outside).\n *            (c) Subtract the filled seed (pixd) from the filling mask (pixs).\n *          Note that in this procedure, everything is done starting\n *          with the filling mask, pixs.\n *      (6) For segmentation, the resulting image, pixd, can be thresholded\n *          and used as a seed for another filling operation.\n */",
      "file" : "morphapp.c"
   },
   {
      "function" : "pixHMT",
      "comment" : "/*!\n *  pixHMT()\n *\n *      Input:  pixd (<optional>; this can be null, equal to pixs,\n *                    or different from pixs)\n *              pixs (1 bpp)\n *              sel\n *      Return: pixd\n *\n *  Notes:\n *      (1) The hit-miss transform erodes the src, using both hits\n *          and misses in the Sel.  It ANDs the shifted src for hits\n *          and ANDs the inverted shifted src for misses.\n *      (2) There are three cases:\n *          (a) pixd == null   (result into new pixd)\n *          (b) pixd == pixs   (in-place; writes result back to pixs)\n *          (c) pixd != pixs   (puts result into existing pixd)\n *      (3) For clarity, if the case is known, use these patterns:\n *          (a) pixd = pixHMT(NULL, pixs, ...);\n *          (b) pixHMT(pixs, pixs, ...);\n *          (c) pixHMT(pixd, pixs, ...);\n *      (4) The size of the result is determined by pixs.\n */",
      "file" : "morph.c"
   },
   {
      "function" : "pixHMTDwa_1",
      "comment" : "/*!\n *  pixHMTDwa_1()\n *\n *      Input:  pixd (usual 3 choices: null, == pixs, != pixs)\n *              pixs (1 bpp)\n *              sel name\n *      Return: pixd\n *\n *  Notes:\n *      (1) This simply adds a 32 pixel border, calls the appropriate\n *          pixFHMTGen_*(), and removes the border.\n *          See notes below for that function.\n */",
      "file" : "fhmtgen.1.c"
   },
   {
      "function" : "pixHShear",
      "comment" : "/*!\n *  pixHShear()\n *\n *      Input:  pixd (<optional>, this can be null, equal to pixs,\n *                    or different from pixs)\n *              pixs (no restrictions on depth)\n *              yloc (location of horizontal line, measured from origin)\n *              angle (in radians)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK);\n *      Return: pixd, always\n *\n *  Notes:\n *      (1) There are 3 cases:\n *            (a) pixd == null (make a new pixd)\n *            (b) pixd == pixs (in-place)\n *            (c) pixd != pixs\n *      (2) For these three cases, use these patterns, respectively:\n *              pixd = pixHShear(NULL, pixs, ...);\n *              pixHShear(pixs, pixs, ...);\n *              pixHShear(pixd, pixs, ...);\n *      (3) This shear leaves the horizontal line of pixels at y = yloc\n *          invariant.  For a positive shear angle, pixels above this\n *          line are shoved to the right, and pixels below this line\n *          move to the left.\n *      (4) With positive shear angle, this can be used, along with\n *          pixVShear(), to perform a cw rotation, either with 2 shears\n *          (for small angles) or in the general case with 3 shears.\n *      (5) Changing the value of yloc is equivalent to translating\n *          the result horizontally.\n *      (6) This brings in 'incolor' pixels from outside the image.\n *      (7) For in-place operation, pixs cannot be colormapped,\n *          because the in-place operation only blits in 0 or 1 bits,\n *          not an arbitrary colormap index.\n *      (8) The angle is brought into the range [-pi, -pi].  It is\n *          not permitted to be within MIN_DIFF_FROM_HALF_PI radians\n *          from either -pi/2 or pi/2.\n */",
      "file" : "shear.c"
   },
   {
      "function" : "pixHShearCenter",
      "comment" : "/*!\n *  pixHShearCenter()\n *\n *      Input:  pixd (<optional>, if not null, must be equal to pixs)\n *              pixs\n *              angle (in radians)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK);\n *      Return: pixd, or null on error.\n *\n *  Notes:\n *      (1) See pixHShear() for usage.\n *      (2) This does a horizontal shear about the center, with (+) shear\n *          pushing increasingly leftward (-x) with increasing y.\n */",
      "file" : "shear.c"
   },
   {
      "function" : "pixHShearCorner",
      "comment" : "/*!\n *  pixHShearCorner()\n *\n *      Input:  pixd (<optional>, if not null, must be equal to pixs)\n *              pixs\n *              angle (in radians)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK);\n *      Return: pixd, or null on error.\n *\n *  Notes:\n *      (1) See pixHShear() for usage.\n *      (2) This does a horizontal shear about the UL corner, with (+) shear\n *          pushing increasingly leftward (-x) with increasing y.\n */",
      "file" : "shear.c"
   },
   {
      "function" : "pixHShearIP",
      "comment" : "/*!\n *  pixHShearIP()\n *\n *      Input:  pixs\n *              yloc (location of horizontal line, measured from origin)\n *              angle (in radians)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK);\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This is an in-place version of pixHShear(); see comments there.\n *      (2) This brings in 'incolor' pixels from outside the image.\n *      (3) pixs cannot be colormapped, because the in-place operation\n *          only blits in 0 or 1 bits, not an arbitrary colormap index.\n *      (4) Does a horizontal full-band shear about the line with (+) shear\n *          pushing increasingly leftward (-x) with increasing y.\n */",
      "file" : "shear.c"
   },
   {
      "function" : "pixHShearLI",
      "comment" : "/*!\n *  pixHShearLI()\n *\n *      Input:  pixs (8 bpp or 32 bpp, or colormapped)\n *              yloc (location of horizontal line, measured from origin)\n *              angle (in radians, in range (-pi/2 ... pi/2))\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK);\n *      Return: pixd (sheared), or null on error\n *\n *  Notes:\n *      (1) This does horizontal shear with linear interpolation for\n *          accurate results on 8 bpp gray, 32 bpp rgb, or cmapped images.\n *          It is relatively slow compared to the sampled version\n *          implemented by rasterop, but the result is much smoother.\n *      (2) This shear leaves the horizontal line of pixels at y = yloc\n *          invariant.  For a positive shear angle, pixels above this\n *          line are shoved to the right, and pixels below this line\n *          move to the left.\n *      (3) Any colormap is removed.\n *      (4) The angle is brought into the range [-pi/2 + del, pi/2 - del],\n *          where del == MIN_DIFF_FROM_HALF_PI.\n */",
      "file" : "shear.c"
   },
   {
      "function" : "pixHalfEdgeByBandpass",
      "comment" : "/*!\n *  pixHalfEdgeByBandpass()\n *\n *      Input:  pixs (8 bpp gray or 32 bpp rgb)\n *              sm1h, sm1v (\"half-widths\" of smoothing filter sm1)\n *              sm2h, sm2v (\"half-widths\" of smoothing filter sm2)\n *                      (require sm2 != sm1)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) We use symmetric smoothing filters of odd dimension,\n *          typically use 3, 5, 7, etc.  The smoothing parameters\n *          for these are 1, 2, 3, etc.  The filter size is related\n *          to the smoothing parameter by\n *               size = 2 * smoothing + 1\n *      (2) Because we take the difference of two lowpass filters,\n *          this is actually a bandpass filter.\n *      (3) We allow both filters to be anisotropic.\n *      (4) Consider either the h or v component of the 2 filters.\n *          Depending on whether sm1 > sm2 or sm2 > sm1, we get\n *          different halves of the smoothed gradients (or \"edges\").\n *          This difference of smoothed signals looks more like\n *          a second derivative of a transition, which we rectify\n *          by not allowing the signal to go below zero.  If sm1 < sm2,\n *          the sm2 transition is broader, so the difference between\n *          sm1 and sm2 signals is positive on the upper half of\n *          the transition.  Likewise, if sm1 > sm2, the sm1 - sm2\n *          signal difference is positive on the lower half of\n *          the transition.\n */",
      "file" : "enhance.c"
   },
   {
      "function" : "pixHaustest",
      "comment" : "/*!\n *  pixHaustest()\n *\n *      Input:  pix1   (new pix, not dilated)\n *              pix2   (new pix, dilated)\n *              pix3   (exemplar pix, not dilated)\n *              pix4   (exemplar pix, dilated)\n *              delx   (x comp of centroid difference)\n *              dely   (y comp of centroid difference)\n *              maxdiffw (max width difference of pix1 and pix2)\n *              maxdiffh (max height difference of pix1 and pix2)\n *      Return: 0 (FALSE) if no match, 1 (TRUE) if the new\n *              pix is in the same class as the exemplar.\n *\n *  Note: we check first that the two pix are roughly\n *  the same size.  Only if they meet that criterion do\n *  we compare the bitmaps.  The Hausdorff is a 2-way\n *  check.  The centroid difference is used to align the two\n *  images to the nearest integer for each of the checks.\n *  These check that the dilated image of one contains\n *  ALL the pixels of the undilated image of the other.\n *  Checks are done in both direction.  A single pixel not\n *  contained in either direction results in failure of the test.\n */",
      "file" : "jbclass.c"
   },
   {
      "function" : "pixHolesByFilling",
      "comment" : "/*!\n *  pixHolesByFilling()\n *\n *      Input:  pixs (1 bpp)\n *              connectivity (4 or 8)\n *      Return: pixd  (inverted image of all holes), or null on error\n *\n * Action:\n *     (1) Start with 1-pixel black border on otherwise white pixd\n *     (2) Use the inverted pixs as the filling mask to fill in\n *         all the pixels from the border to the pixs foreground\n *     (3) OR the result with pixs to have an image with all\n *         ON pixels except for the holes.\n *     (4) Invert the result to get the holes as foreground\n *\n * Notes:\n *     (1) To get 4-c.c. holes of the 8-c.c. as foreground, use\n *         4-connected filling; to get 8-c.c. holes of the 4-c.c.\n *         as foreground, use 8-connected filling.\n */",
      "file" : "seedfill.c"
   },
   {
      "function" : "pixHtmlViewer",
      "comment" : "/*!\n *  pixHtmlViewer()\n *\n *      Input:  dirin:  directory of input image files\n *              dirout: directory for output files\n *              rootname: root name for output files\n *              thumbwidth:  width of thumb images\n *                           (in pixels; use 0 for default)\n *              viewwidth:  maximum width of view images (no up-scaling)\n *                           (in pixels; use 0 for default)\n *              copyorig:  1 to copy originals to dirout; 0 otherwise\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) The thumb and view reduced images are generated,\n *          along with two html files:\n *             <rootname>.html and <rootname>-links.html\n *      (2) The thumb and view files are named\n *             <rootname>_thumb_xxx.jpg\n *             <rootname>_view_xxx.jpg\n *          With this naming scheme, any number of input directories\n *          of images can be processed into views and thumbs\n *          and placed in the same output directory.\n */",
      "file" : "viewfiles.c"
   },
   {
      "function" : "pixInitAccumulate",
      "comment" : "/*!\n *  pixInitAccumulate()\n *\n *      Input:  w, h (of accumulate array)\n *              offset (initialize the 32 bpp to have this\n *                      value; not more than 0x40000000)\n *      Return: pixd (32 bpp), or null on error\n *\n *  Notes:\n *      (1) The offset must be >= 0.\n *      (2) The offset is used so that we can do arithmetic\n *          with negative number results on l_uint32 data; it\n *          prevents the l_uint32 data from going negative.\n *      (3) Because we use l_int32 intermediate data results,\n *          these should never exceed the max of l_int32 (0x7fffffff).\n *          We do not permit the offset to be above 0x40000000,\n *          which is half way between 0 and the max of l_int32.\n *      (4) The same offset should be used for initialization,\n *          multiplication by a constant, and final extraction!\n *      (5) If you're only adding positive values, offset can be 0.\n */",
      "file" : "pixarith.c"
   },
   {
      "function" : "pixInterlaceGIF",
      "comment" : "/* d == 8 */",
      "file" : "gifio.c"
   },
   {
      "function" : "pixIntersectionOfMorphOps",
      "comment" : "/*!\n *  pixIntersectionOfMorphOps()\n *\n *      Input:  pixs (binary)\n *              sela\n *              type (L_MORPH_DILATE, etc.)\n *      Return: pixd (intersection of the specified morphological operation\n *                    on pixs for each Sel in the Sela), or null on error\n */",
      "file" : "morphapp.c"
   },
   {
      "function" : "pixInvert",
      "comment" : "/*!\n *  pixInvert()\n *\n *      Input:  pixd  (<optional>; this can be null, equal to pixs,\n *                     or different from pixs)\n *              pixs\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This inverts pixs, for all pixel depths.\n *      (2) There are 3 cases:\n *           (a) pixd == null,   ~src --> new pixd\n *           (b) pixd == pixs,   ~src --> src  (in-place)\n *           (c) pixd != pixs,   ~src --> input pixd\n *      (3) For clarity, if the case is known, use these patterns:\n *           (a) pixd = pixInvert(NULL, pixs);\n *           (b) pixInvert(pixs, pixs);\n *           (c) pixInvert(pixd, pixs);\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixItalicWords",
      "comment" : "/*!\n *  pixItalicWords()\n *\n *      Input:  pixs (1 bpp)\n *              boxaw (<optional> word bounding boxes; can be NULL)\n *              pixw (<optional> word box mask; can be NULL)\n *              &boxa (<return> boxa of italic words)\n *              debugflag (1 for debug output; 0 otherwise)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) You can input the bounding boxes for the words in one of\n *          two forms: as bounding boxes (@boxaw) or as a word mask with\n *          the word bounding boxes filled (@pixw).  For example,\n *          to compute @pixw, you can use pixWordMaskByDilation().\n *      (2) Alternatively, you can set both of these inputs to NULL,\n *          in which case the word mask is generated here.  This is\n *          done by dilating and closing the input image to connect\n *          letters within a word, while leaving the words separated.\n *          The parameters are chosen under the assumption that the\n *          input is 10 to 12 pt text, scanned at about 300 ppi.\n *      (3) sel_ital1 and sel_ital2 detect the right edges that are\n *          nearly vertical, at approximately the angle of italic\n *          strokes.  We use the right edge to avoid getting seeds\n *          from lower-case 'y'.  The typical italic slant has a smaller\n *          angle with the vertical than the 'W', so in most cases we\n *          will not trigger on the slanted lines in the 'W'.\n *      (4) Note that sel_ital2 is shorter than sel_ital1.  It is\n *          more appropriate for a typical font scanned at 200 ppi.\n */",
      "file" : "finditalic.c"
   },
   {
      "function" : "pixLinearMapToTargetColor",
      "comment" : "/*!\n *  pixLinearMapToTargetColor()\n *\n *      Input:  pixd (<optional>; either NULL or equal to pixs for in-place)\n *              pixs (32 bpp rgb)\n *              srcval (source color: 0xrrggbb00)\n *              dstval (target color: 0xrrggbb00)\n *      Return: pixd (with all pixels mapped based on the srcval/destval\n *                    mapping), or pixd on error\n *\n *  Notes:\n *      (1) For each component (r, b, g) separately, this does a piecewise\n *          linear mapping of the colors in pixs to colors in pixd.\n *          If rs and rd are the red src and dest components in @srcval and\n *          @dstval, then the range [0 ... rs] in pixs is mapped to\n *          [0 ... rd] in pixd.  Likewise, the range [rs ... 255] in pixs\n *          is mapped to [rd ... 255] in pixd.  And similarly for green\n *          and blue.\n *      (2) The mapping will in general change the hue of the pixels.\n *          However, if the src and dst targets are related by\n *          a transformation given by pixelFractionalShift(), the hue\n *          is invariant.\n *      (3) For inplace operation, call it this way:\n *            pixLinearMapToTargetColor(pixs, pixs, ... )\n *      (4) For generating a new pixd:\n *            pixd = pixLinearMapToTargetColor(NULL, pixs, ...)\n */",
      "file" : "coloring.c"
   },
   {
      "function" : "pixLinearTRCTiled",
      "comment" : "/*!\n *  pixLinearTRCTiled()\n *\n *      Input:  pixd (<optional> 8 bpp)\n *              pixs (8 bpp, not colormapped)\n *              sx, sy (tile dimensions)\n *              pixmin (pix of min values in tiles)\n *              pixmax (pix of max values in tiles)\n *      Return: pixd always\n *\n *  Notes:\n *      (1) pixd can be equal to pixs (in-place operation) or\n *          null (makes a new pixd).\n *      (2) sx and sy give the tile size; they are typically at least 20.\n *      (3) pixmin and pixmax are generated by pixMinMaxTiles()\n *      (4) For each tile, this does a linear expansion of the dynamic\n *          range so that the min value in the tile becomes 0 and the\n *          max value in the tile becomes 255.\n *      (5) The LUTs that do the mapping are generated as needed\n *          and stored for reuse in an integer array within the ptr array iaa[].\n */",
      "file" : "adaptmap.c"
   },
   {
      "function" : "pixLocToColorTransform",
      "comment" : "/*!\n *  pixLocToColorTransform()\n *\n *      Input:   pixs (1 bpp)\n *      Return:  pixd (32 bpp rgb), or null on error\n *\n *  Notes:\n *      (1) This generates an RGB image where each component value\n *          is coded depending on the (x.y) location and the size\n *          of the fg connected component that the pixel in pixs belongs to.\n *          It is independent of the 4-fold orthogonal orientation, and\n *          only weakly depends on translations and small angle rotations.\n *          Background pixels are black.\n *      (2) Such encodings can be compared between two 1 bpp images\n *          by performing this transform and calculating the\n *          \"earth-mover\" distance on the resulting R,G,B histograms.\n */",
      "file" : "pixlabel.c"
   },
   {
      "function" : "pixLocalExtrema",
      "comment" : "/*!\n *  pixLocalExtrema()\n *\n *      Input:  pixs  (8 bpp)\n *              maxmin (max allowed for the min in a 3x3 neighborhood;\n *                      use 0 for default which is to have no upper bound)\n *              minmax (min allowed for the max in a 3x3 neighborhood;\n *                      use 0 for default which is to have no lower bound)\n *              &ppixmin (<optional return> mask of local minima)\n *              &ppixmax (<optional return> mask of local maxima)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This gives the actual local minima and maxima.\n *          A local minimum is a pixel whose surrounding pixels all\n *          have values at least as large, and likewise for a local\n *          maximum.  For the local minima, @maxmin is the upper\n *          bound for the value of pixs.  Likewise, for the local maxima,\n *          @minmax is the lower bound for the value of pixs.\n *      (2) The minima are found by starting with the erosion-and-equality\n *          approach of pixSelectedLocalExtrema().  This is followed\n *          by a qualification step, where each c.c. in the resulting\n *          minimum mask is extracted, the pixels bordering it are\n *          located, and they are queried.  If all of those pixels\n *          are larger than the value of that minimum, it is a true\n *          minimum and its c.c. is saved; otherwise the c.c. is\n *          rejected.  Note that if a bordering pixel has the\n *          same value as the minimum, it must then have a\n *          neighbor that is smaller, so the component is not a\n *          true minimum.\n *      (3) The maxima are found by inverting the image and looking\n *          for the minima there.\n *      (4) The generated masks can be used as markers for\n *          further operations.\n */",
      "file" : "seedfill.c"
   },
   {
      "function" : "pixLocateBarcodes",
      "comment" : "/*!\n *  pixLocateBarcodes()\n *\n *      Input:  pixs (any depth)\n *              thresh (for binarization of edge filter output; typ. 20)\n *              &pixb (<optional return> binarized edge filtered input image)\n *              &pixm (<optional return> mask over barcodes)\n *      Return: boxa (location of barcodes), or null if none found or on error\n */",
      "file" : "readbarcode.c"
   },
   {
      "function" : "pixMakeHistoHS",
      "comment" : "/*!\n *  pixMakeHistoHS()\n *\n *      Input:  pixs  (HSV colorspace)\n *              factor (subsampling factor; integer)\n *              &nahue (<optional return> hue histogram)\n *              &nasat (<optional return> saturation histogram)\n *      Return: pixd (32 bpp histogram in hue and saturation), or null on error\n *\n *  Notes:\n *      (1) pixs is a 32 bpp image in HSV colorspace; hue is in the \"red\"\n *          byte, saturation is in the \"green\" byte.\n *      (2) In pixd, hue is displayed vertically; saturation horizontally.\n *          The dimensions of pixd are w = 256, h = 240, and the depth\n *          is 32 bpp.  The value at each point is simply the number\n *          of pixels found at that value of hue and saturation.\n */",
      "file" : "colorspace.c"
   },
   {
      "function" : "pixMakeHistoHV",
      "comment" : "/*!\n *  pixMakeHistoHV()\n *\n *      Input:  pixs  (HSV colorspace)\n *              factor (subsampling factor; integer)\n *              &nahue (<optional return> hue histogram)\n *              &naval (<optional return> max intensity (value) histogram)\n *      Return: pixd (32 bpp histogram in hue and value), or null on error\n *\n *  Notes:\n *      (1) pixs is a 32 bpp image in HSV colorspace; hue is in the \"red\"\n *          byte, max intensity (\"value\") is in the \"blue\" byte.\n *      (2) In pixd, hue is displayed vertically; intensity horizontally.\n *          The dimensions of pixd are w = 256, h = 240, and the depth\n *          is 32 bpp.  The value at each point is simply the number\n *          of pixels found at that value of hue and intensity.\n */",
      "file" : "colorspace.c"
   },
   {
      "function" : "pixMakeHistoSV",
      "comment" : "/*!\n *  pixMakeHistoSV()\n *\n *      Input:  pixs  (HSV colorspace)\n *              factor (subsampling factor; integer)\n *              &nasat (<optional return> sat histogram)\n *              &naval (<optional return> max intensity (value) histogram)\n *      Return: pixd (32 bpp histogram in sat and value), or null on error\n *\n *  Notes:\n *      (1) pixs is a 32 bpp image in HSV colorspace; sat is in the \"green\"\n *          byte, max intensity (\"value\") is in the \"blue\" byte.\n *      (2) In pixd, sat is displayed vertically; intensity horizontally.\n *          The dimensions of pixd are w = 256, h = 256, and the depth\n *          is 32 bpp.  The value at each point is simply the number\n *          of pixels found at that value of saturation and intensity.\n */",
      "file" : "colorspace.c"
   },
   {
      "function" : "pixMakeMaskFromLUT",
      "comment" : "/*!\n *  pixMakeMaskFromLUT()\n *\n *      Input:  pixs (2, 4 or 8 bpp; can be colormapped)\n *              tab (256-entry LUT; 1 means to write to mask)\n *      Return: pixd (1 bpp mask), or null on error\n *\n *  Notes:\n *      (1) This generates a 1 bpp mask image, where a 1 is written in\n *          the mask for each pixel in pixs that has a value corresponding\n *          to a 1 in the LUT.\n *      (2) The LUT should be of size 256.\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixMakeRangeMaskHS",
      "comment" : "/*!\n *  pixMakeRangeMaskHS()\n *\n *      Input:  pixs  (32 bpp rgb)\n *              huecenter (center value of hue range)\n *              huehw (half-width of hue range)\n *              satcenter (center value of saturation range)\n *              sathw (half-width of saturation range)\n *              regionflag (L_INCLUDE_REGION, L_EXCLUDE_REGION)\n *      Return: pixd (1 bpp mask over selected pixels), or null on error\n *\n *  Notes:\n *      (1) The pixels are selected based on the specified ranges of\n *          hue and saturation.  For selection or exclusion, the pixel\n *          HS component values must be within both ranges.  Care must\n *          be taken in finding the hue range because of wrap-around.\n *      (2) Use @regionflag == L_INCLUDE_REGION to take only those\n *          pixels within the rectangular region specified in HS space.\n *          Use @regionflag == L_EXCLUDE_REGION to take all pixels except\n *          those within the rectangular region specified in HS space.\n */",
      "file" : "colorspace.c"
   },
   {
      "function" : "pixMakeRangeMaskHV",
      "comment" : "/*!\n *  pixMakeRangeMaskHV()\n *\n *      Input:  pixs  (32 bpp rgb)\n *              huecenter (center value of hue range)\n *              huehw (half-width of hue range)\n *              valcenter (center value of max intensity range)\n *              valhw (half-width of max intensity range)\n *              regionflag (L_INCLUDE_REGION, L_EXCLUDE_REGION)\n *      Return: pixd (1 bpp mask over selected pixels), or null on error\n *\n *  Notes:\n *      (1) The pixels are selected based on the specified ranges of\n *          hue and max intensity values.  For selection or exclusion,\n *          the pixel HV component values must be within both ranges.\n *          Care must be taken in finding the hue range because of wrap-around.\n *      (2) Use @regionflag == L_INCLUDE_REGION to take only those\n *          pixels within the rectangular region specified in HV space.\n *          Use @regionflag == L_EXCLUDE_REGION to take all pixels except\n *          those within the rectangular region specified in HV space.\n */",
      "file" : "colorspace.c"
   },
   {
      "function" : "pixMakeRangeMaskSV",
      "comment" : "/*!\n *  pixMakeRangeMaskSV()\n *\n *      Input:  pixs  (32 bpp rgb)\n *              satcenter (center value of saturation range)\n *              sathw (half-width of saturation range)\n *              valcenter (center value of max intensity range)\n *              valhw (half-width of max intensity range)\n *              regionflag (L_INCLUDE_REGION, L_EXCLUDE_REGION)\n *      Return: pixd (1 bpp mask over selected pixels), or null on error\n *\n *  Notes:\n *      (1) The pixels are selected based on the specified ranges of\n *          saturation and max intensity (val).  For selection or\n *          exclusion, the pixel SV component values must be within both ranges.\n *      (2) Use @regionflag == L_INCLUDE_REGION to take only those\n *          pixels within the rectangular region specified in SV space.\n *          Use @regionflag == L_EXCLUDE_REGION to take all pixels except\n *          those within the rectangular region specified in SV space.\n */",
      "file" : "colorspace.c"
   },
   {
      "function" : "pixMaskBoxa",
      "comment" : "/*!\n *  pixMaskBoxa()\n *\n *      Input:  pixd (<optional> may be null)\n *              pixs (any depth; not cmapped)\n *              boxa (of boxes, to paint)\n *              op (L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS)\n *      Return: pixd (with masking op over the boxes), or null on error\n *\n *  Notes:\n *      (1) This can be used with:\n *              pixd = NULL  (makes a new pixd)\n *              pixd = pixs  (in-place)\n *      (2) If pixd == NULL, this first makes a copy of pixs, and then\n *          bit-twiddles over the boxes.  Otherwise, it operates directly\n *          on pixs.\n *      (3) This simple function is typically used with 1 bpp images.\n *          It uses the 1-image rasterop function, rasteropUniLow(),\n *          to set, clear or flip the pixels in pixd.\n *      (4) If you want to generate a 1 bpp mask of ON pixels from the boxes\n *          in a Boxa, in a pix of size (w,h):\n *              pix = pixCreate(w, h, 1);\n *              pixMaskBoxa(pix, pix, boxa, L_SET_PIXELS);\n */",
      "file" : "boxfunc3.c"
   },
   {
      "function" : "pixMaskConnComp",
      "comment" : "/*!\n *  pixMaskConnComp()\n *\n *      Input:  pixs (1 bpp)\n *              connectivity (4 or 8)\n *              &boxa (<optional return> bounding boxes of c.c.)\n *      Return: pixd (1 bpp mask over the c.c.), or null on error\n *\n *  Notes:\n *      (1) This generates a mask image with ON pixels over the\n *          b.b. of the c.c. in pixs.  If there are no ON pixels in pixs,\n *          pixd will also have no ON pixels.\n */",
      "file" : "boxfunc3.c"
   },
   {
      "function" : "pixMaskOverColorPixels",
      "comment" : "/*!\n *  pixMaskOverColorPixels()\n *\n *      Input:  pixs  (32 bpp rgb or 8 bpp colormapped)\n *              threshdiff (threshold for minimum of the max difference\n *                          between components)\n *              mindist (minimum allowed distance from nearest non-color pixel)\n *      Return: pixd (1 bpp, mask over color pixels), or null on error\n *\n *  Notes:\n *      (1) The generated mask identifies each pixel as either color or\n *          non-color.  For a pixel to be color, it must satisfy two\n *          constraints:\n *            (a) The max difference between the r,g and b components must\n *                equal or exceed a threshold @threshdiff.\n *            (b) It must be at least @mindist (in an 8-connected way)\n *                from the nearest non-color pixel.\n *      (2) The distance constraint (b) is only applied if @mindist > 1.\n *          For example, if @mindist == 2, the color pixels identified\n *          by (a) are eroded by a 3x3 Sel.  In general, the Sel size\n *          for erosion is 2 * (@mindist - 1) + 1.\n *          Why have this constraint?  In scanned images that are\n *          essentially gray, color artifacts are typically introduced\n *          in transition regions near sharp edges that go from dark\n *          to light, so this allows these transition regions to be removed.\n */",
      "file" : "colorcontent.c"
   },
   {
      "function" : "pixMaskedThreshOnBackgroundNorm",
      "comment" : "/*!\n *  pixMaskedThreshOnBackgroundNorm()\n *\n *      Input:  pixs (8 bpp grayscale; not colormapped)\n *              pixim (<optional> 1 bpp 'image' mask; can be null)\n *              sx, sy (tile size in pixels)\n *              thresh (threshold for determining foreground)\n *              mincount (min threshold on counts in a tile)\n *              smoothx (half-width of block convolution kernel width)\n *              smoothy (half-width of block convolution kernel height)\n *              scorefract (fraction of the max Otsu score; typ. ~ 0.1)\n *              &thresh (<optional return> threshold value that was\n *                       used on the normalized image)\n *      Return: pixd (1 bpp thresholded image), or null on error\n *\n *  Notes:\n *      (1) This begins with a standard background normalization.\n *          Additionally, there is a flexible background norm, that\n *          will adapt to a rapidly varying background, and this\n *          puts white pixels in the background near regions with\n *          significant foreground.  The white pixels are turned into\n *          a 1 bpp selection mask by binarization followed by dilation.\n *          Otsu thresholding is performed on the input image to get an\n *          estimate of the threshold in the non-mask regions.\n *          The background normalized image is thresholded with two\n *          different values, and the result is combined using\n *          the selection mask.\n *      (2) Note that the numbers 255 (for bgval target) and 190 (for\n *          thresholding on pixn) are tied together, and explicitly\n *          defined in this function.\n *      (3) See pixBackgroundNorm() for meaning and typical values\n *          of input parameters.  For a start, you can try:\n *            sx, sy = 10, 15\n *            thresh = 100\n *            mincount = 50\n *            smoothx, smoothy = 2\n */",
      "file" : "binarize.c"
   },
   {
      "function" : "pixMaxDynamicRange",
      "comment" : "/*!\n *  pixMaxDynamicRange()\n *\n *      Input:  pixs  (4, 8, 16 or 32 bpp source)\n *              type  (L_LINEAR_SCALE or L_LOG_SCALE)\n *      Return: pixd (8 bpp), or null on error\n *\n *  Notes:\n *      (1) Scales pixel values to fit maximally within the dest 8 bpp pixd\n *      (2) Uses a LUT for log scaling\n */",
      "file" : "pixarith.c"
   },
   {
      "function" : "pixMeanInRectangle",
      "comment" : "/*!\n *  pixMeanInRectangle()\n *\n *      Input:  pix (8 bpp)\n *              box (region to compute mean value)\n *              pixma (mean accumulator)\n *              &val (<return> mean value\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This function is intended to be used for many rectangles\n *          on the same image.  It can find the mean within a\n *          rectangle in O(1), independent of the size of the rectangle.\n */",
      "file" : "quadtree.c"
   },
   {
      "function" : "pixMeanSquareAccum",
      "comment" : "/*!\n *  pixMeanSquareAccum()\n *\n *      Input:  pixs (8 bpp grayscale)\n *      Return: dpix (64 bit array), or null on error\n *\n *  Notes:\n *      (1) Similar to pixBlockconvAccum(), this computes the\n *          sum of the squares of the pixel values in such a way\n *          that the value at (i,j) is the sum of all squares in\n *          the rectangle from the origin to (i,j).\n *      (2) The general recursion relation (v are squared pixel values) is\n *            a(i,j) = v(i,j) + a(i-1, j) + a(i, j-1) - a(i-1, j-1)\n *          For the first line, this reduces to the special case\n *            a(i,j) = v(i,j) + a(i, j-1)\n *          For the first column, the special case is\n *            a(i,j) = v(i,j) + a(i-1, j)\n */",
      "file" : "convolve.c"
   },
   {
      "function" : "pixMeasureEdgeSmoothness",
      "comment" : "/*!\n *  pixMeasureEdgeSmoothness()\n *\n *      Input:  pixs (1 bpp)\n *              side (L_FROM_LEFT, L_FROM_RIGHT, L_FROM_TOP, L_FROM_BOT)\n *              minjump (minimum jump to be counted; >= 1)\n *              minreversal (minimum reversal size for new peak or valley)\n *              &jpl (<optional return> jumps/length: number of jumps,\n *                    normalized to length of component side)\n *              &jspl (<optional return> jumpsum/length: sum of all\n *                     sufficiently large jumps, normalized to length\n *                     of component side)\n *              &rpl (<optional return> reversals/length: number of\n *                    peak-to-valley or valley-to-peak reversals,\n *                    normalized to length of component side)\n *              debugfile (<optional> displays constructed edge; use NULL\n *                         for no output)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This computes three measures of smoothness of the edge of a\n *          connected component:\n *            * jumps/length: (jpl) the number of jumps of size >= @minjump,\n *              normalized to the length of the side\n *            * jump sum/length: (jspl) the sum of all jump lengths of\n *              size >= @minjump, normalized to the length of the side\n *            * reversals/length: (rpl) the number of peak <--> valley\n *              reversals, using @minreverse as a minimum deviation of\n *              the peak or valley from its preceeding extremum,\n *              normalized to the length of the side\n *      (2) The input pix should be a single connected component, but\n *          this is not required.\n */",
      "file" : "edge.c"
   },
   {
      "function" : "pixMeasureSaturation",
      "comment" : "/*!\n *  pixMeasureSaturation()\n *\n *      Input:  pixs (32 bpp rgb)\n *              factor (subsampling factor; integer >= 1)\n *              &sat (<return> average saturation)\n *      Return: pixd, or null on error\n */",
      "file" : "enhance.c"
   },
   {
      "function" : "pixMedianCutHisto",
      "comment" : "/*!\n *  pixMedianCutHisto()\n *\n *      Input:  pixs  (32 bpp; rgb color)\n *              sigbits (valid: 5 or 6)\n *              subsample (integer > 0)\n *      Return: histo (1-d array, giving the number of pixels in\n *                     each quantized region of color space), or null on error\n *\n *  Notes:\n *      (1) Array is indexed by (3 * sigbits) bits.  The array size\n *          is 2^(3 * sigbits).\n *      (2) Indexing into the array from rgb uses red sigbits as\n *          most significant and blue as least.\n */",
      "file" : "colorquant2.c"
   },
   {
      "function" : "pixMedianCutQuant",
      "comment" : "/*!\n *  pixMedianCutQuant()\n *\n *      Input:  pixs  (32 bpp; rgb color)\n *              ditherflag (1 for dither; 0 for no dither)\n *      Return: pixd (8 bit with colormap), or null on error\n *\n *  Notes:\n *      (1) Simple interface.  See pixMedianCutQuantGeneral() for\n *          use of defaulted parameters.\n */",
      "file" : "colorquant2.c"
   },
   {
      "function" : "pixMedianCutQuantGeneral",
      "comment" : "/*!\n *  pixMedianCutQuantGeneral()\n *\n *      Input:  pixs  (32 bpp; rgb color)\n *              ditherflag (1 for dither; 0 for no dither)\n *              outdepth (output depth; valid: 0, 1, 2, 4, 8)\n *              maxcolors (between 2 and 256)\n *              sigbits (valid: 5 or 6; use 0 for default)\n *              maxsub (max subsampling, integer; use 0 for default;\n *                      1 for no subsampling)\n *              checkbw (1 to check if color content is very small,\n *                       0 to assume there is sufficient color)\n *      Return: pixd (8 bit with colormap), or null on error\n *\n *  Notes:\n *      (1) @maxcolors must be in the range [2 ... 256].\n *      (2) Use @outdepth = 0 to have the output depth computed as the\n *          minimum required to hold the actual colors found, given\n *          the @maxcolors constraint.\n *      (3) Use @outdepth = 1, 2, 4 or 8 to specify the output depth.\n *          In that case, @maxcolors must not exceed 2^(outdepth).\n *      (4) If there are fewer quantized colors in the image than @maxcolors,\n *          the colormap is simply generated from those colors.\n *      (5) @maxsub is the maximum allowed subsampling to be used in the\n *          computation of the color histogram and region of occupied\n *          color space.  The subsampling is chosen internally for\n *          efficiency, based on the image size, but this parameter\n *          limits it.  Use @maxsub = 0 for the internal default, which is the\n *          maximum allowed subsampling.  Use @maxsub = 1 to prevent\n *          subsampling.  In general use @maxsub >= 1 to specify the\n *          maximum subsampling to be allowed, where the actual subsampling\n *          will be the minimum of this value and the internally\n *          determined default value.\n *      (6) If the image appears gray because either most of the pixels\n *          are gray or most of the pixels are essentially black or white,\n *          the image is trivially quantized with a grayscale colormap.  The\n *          reason is that median cut divides the color space into rectangular\n *          regions, and it does a very poor job if all the pixels are\n *          near the diagonal of the color space cube.\n */",
      "file" : "colorquant2.c"
   },
   {
      "function" : "pixMedianCutQuantMixed",
      "comment" : "/*!\n *  pixMedianCutQuantMixed()\n *\n *      Input:  pixs  (32 bpp; rgb color)\n *              ncolor (maximum number of colors assigned to pixels with\n *                      significant color)\n *              ngray (number of gray colors to be used; must be >= 2)\n *              darkthresh (threshold near black; if the lightest component\n *                          is below this, the pixel is not considered to\n *                          be gray or color; uses 0 for default)\n *              lightthresh (threshold near white; if the darkest component\n *                           is above this, the pixel is not considered to\n *                           be gray or color; use 0 for default)\n *              diffthresh (thresh for the max difference between component\n *                          values; for differences below this, the pixel\n *                          is considered to be gray; use 0 for default)\n *      Return: pixd (8 bpp cmapped), or null on error\n *\n *  Notes:\n *      (1) ncolor + ngray must not exceed 255.\n *      (2) The method makes use of pixMedianCutQuantGeneral() with\n *          minimal addition.\n *          (a) Preprocess the image, setting all pixels with little color\n *              to black, and populating an auxiliary 8 bpp image with the\n *              expected colormap values corresponding to the set of\n *              quantized gray values.\n *          (b) Color quantize the altered input image to n + 1 colors.\n *          (c) Augment the colormap with the gray indices, and\n *              substitute the gray quantized values from the auxiliary\n *              image for those in the color quantized output that had\n *              been quantized as black.\n *      (3) Median cut color quantization is relatively poor for grayscale\n *          images with many colors, when compared to octcube quantization.\n *          Thus, for images with both gray and color, it is important\n *          to quantize the gray pixels by another method.  Here, we\n *          are conservative in detecting color, preferring to use\n *          a few extra bits to encode colorful pixels that push them\n *          to gray.  This is particularly reasonable with this function,\n *          because it handles the gray and color pixels separately,\n *          using median cut color quantization for the color pixels\n *          and equal-bin grayscale quantization for the non-color pixels.\n */",
      "file" : "colorquant2.c"
   },
   {
      "function" : "pixMedianFilter",
      "comment" : "/*!\n *  pixMedianFilter()\n *\n *      Input:  pixs (8 or 32 bpp; no colormap)\n *              wf, hf  (width and height of filter; each is >= 1)\n *      Return: pixd (of median values), or null on error\n */",
      "file" : "rank.c"
   },
   {
      "function" : "pixMinMaxNearLine",
      "comment" : "/*!\n *  pixMinMaxNearLine()\n *\n *      Input:  pixs (8 bpp; no colormap)\n *              x1, y1 (starting pt for line)\n *              x2, y2 (end pt for line)\n *              dist (distance to search from line in each direction)\n *              direction (L_SCAN_NEGATIVE, L_SCAN_POSITIVE, L_SCAN_BOTH)\n *              &namin (<optional return> minimum values)\n *              &namax (<optional return> maximum values)\n *              &minave (<optional return> average of minimum values)\n *              &maxave (<optional return> average of maximum values)\n *      Return: 0 if OK; 1 on error or if there are no sampled points\n *              within the image.\n *\n *  Notes:\n *      (1) If the line is more horizontal than vertical, the values\n *          are computed for [x1, x2], and the pixels are taken\n *          below and/or above the local y-value.  Otherwise, the\n *          values are computed for [y1, y2] and the pixels are taken\n *          to the left and/or right of the local x value.\n *      (2) @direction specifies which side (or both sides) of the\n *          line are scanned for min and max values.\n *      (3) There are two ways to tell if the returned values of min\n *          and max averages are valid: the returned values cannot be\n *          negative and the function must return 0.\n *      (4) All accessed pixels are clipped to the pix.\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixMinMaxTiles",
      "comment" : "/*!\n *  pixMinMaxTiles()\n *\n *      Input:  pixs (8 bpp grayscale; not colormapped)\n *              sx, sy (tile dimensions)\n *              mindiff (minimum difference to accept as valid)\n *              smoothx, smoothy (half-width of convolution kernel applied to\n *                                min and max arrays: use 0 for no smoothing)\n *              &pixmin (<return> tiled minima)\n *              &pixmax (<return> tiled maxima)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This computes filtered and smoothed values for the min and\n *          max pixel values in each tile of the image.\n *      (2) See pixContrastNorm() for usage.\n */",
      "file" : "adaptmap.c"
   },
   {
      "function" : "pixMinOrMax",
      "comment" : "/*!\n *  pixMinOrMax()\n *\n *      Input:  pixd  (<optional> destination: this can be null,\n *                     equal to pixs1, or different from pixs1)\n *              pixs1 (can be == to pixd)\n *              pixs2\n *              type (L_CHOOSE_MIN, L_CHOOSE_MAX)\n *      Return: pixd always\n *\n *  Notes:\n *      (1) This gives the min or max of two images, component-wise.\n *      (2) The depth can be 8 or 16 bpp for 1 component, and 32 bpp\n *          for a 3 component image.  For 32 bpp, ignore the LSB\n *          of each word (the alpha channel)\n *      (3) There are 3 cases:\n *          -  if pixd == null,   Min(src1, src2) --> new pixd\n *          -  if pixd == pixs1,  Min(src1, src2) --> src1  (in-place)\n *          -  if pixd != pixs1,  Min(src1, src2) --> input pixd\n */",
      "file" : "pixarith.c"
   },
   {
      "function" : "pixMirrorDetect",
      "comment" : "/*!\n *  pixMirrorDetect()\n *\n *      Input:  pixs (1 bpp, deskewed, English text)\n *              &conf (<return> confidence that text is not LR mirror reversed)\n *              mincount (min number of left + right; use 0 for default)\n *              debug (1 for debug output; 0 otherwise)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) For this test, it is necessary that the text is horizontally\n *          oriented, with ascenders going up.\n *      (2) conf is the normalized difference between the number of\n *          right and left facing characters with ascenders.\n *          Left-facing are {d}; right-facing are {b, h, k}.\n *          At least that was the expectation.  In practice, we can\n *          really just say that it is the normalized difference in\n *          hits using two specific hit-miss filters, textsel1 and textsel2,\n *          after the image has been suitably pre-filtered so that\n *          these filters are effective.  See (4) for what's really happening.\n *      (3) A large positive conf value indicates normal text, whereas\n *          a large negative conf value means the page is mirror reversed.\n *      (4) The implementation is a bit tricky.  The general idea is\n *          to fill the x-height part of characters, but not the space\n *          between them, before doing the HMT.  This is done by\n *          finding pixels added using two different operations -- a\n *          horizontal close and a vertical dilation -- and adding\n *          the intersection of these sets to the original.  It turns\n *          out that the original intuition about the signal was largely\n *          in error: much of the signal for right-facing characters\n *          comes from the lower part of common x-height characters, like\n *          the e and c, that remain open after these operations.\n *          So it's important that the operations to close the x-height\n *          parts of the characters are purposely weakened sufficiently\n *          to allow these characters to remain open.  The wonders\n *          of morphology!\n */",
      "file" : "flipdetect.c"
   },
   {
      "function" : "pixMirrorDetectDwa",
      "comment" : "/*!\n *  pixMirrorDetectDwa()\n *\n *      Input:  pixs (1 bpp, deskewed, English text)\n *              &conf (<return> confidence that text is not LR mirror reversed)\n *              mincount (min number of left + right; use 0 for default)\n *              debug (1 for debug output; 0 otherwise)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) We assume the text is horizontally oriented, with\n *          ascenders going up.\n *      (2) See notes in pixMirrorDetect().\n */",
      "file" : "flipdetect.c"
   },
   {
      "function" : "pixMirroredTiling",
      "comment" : "/*!\n *  pixMirroredTiling()\n *\n *      Input:  pixs (8 or 32 bpp, small tile; to be replicated)\n *              w, h (dimensions of output pix)\n *      Return: pixd (usually larger pix, mirror-tiled with pixs),\n *              or null on error\n *\n *  Notes:\n *      (1) This uses mirrored tiling, where each row alternates\n *          with LR flips and every column alternates with TB\n *          flips, such that the result is a tiling with identical\n *          2 x 2 tiles, each of which is composed of these transforms:\n *                  -----------------\n *                  | 1    |  LR    |\n *                  -----------------\n *                  | TB   |  LR/TB |\n *                  -----------------\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixModifyBrightness",
      "comment" : "/*!\n *  pixModifyBrightness()\n *\n *      Input:  pixd (<optional> can be null, existing or equal to pixs)\n *              pixs (32 bpp rgb)\n *              fract (between -1.0 and 1.0)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) If fract > 0.0, it gives the fraction that the v-parameter,\n *          which is max(r,g,b), is moved from its initial value toward 255.\n *          If fract < 0.0, it gives the fraction that the v-parameter\n *          is moved from its initial value toward 0.\n *          The limiting values for fract = -1.0 (1.0) thus set the\n *          v-parameter to 0 (255).\n *      (2) If fract = 0, no modification is requested; return a copy\n *          unless in-place, in which case this is a no-op.\n *      (3) See discussion of color-modification methods, in coloring.c.\n */",
      "file" : "enhance.c"
   },
   {
      "function" : "pixModifyHue",
      "comment" : "/*!\n *  pixModifyHue()\n *\n *      Input:  pixd (<optional> can be null or equal to pixs)\n *              pixs (32 bpp rgb)\n *              fract (between -1.0 and 1.0)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) pixd must either be null or equal to pixs.\n *          For in-place operation, set pixd == pixs:\n *             pixEqualizeTRC(pixs, pixs, ...);\n *          To get a new image, set pixd == null:\n *             pixd = pixEqualizeTRC(NULL, pixs, ...);\n *      (1) Use fract > 0.0 to increase hue value; < 0.0 to decrease it.\n *          1.0 (or -1.0) represents a 360 degree rotation; i.e., no change.\n *      (2) If no modification is requested (fract = -1.0 or 0 or 1.0),\n *          return a copy unless in-place, in which case this is a no-op.\n *      (3) See discussion of color-modification methods, in coloring.c.\n */",
      "file" : "enhance.c"
   },
   {
      "function" : "pixModifySaturation",
      "comment" : "/*!\n *  pixModifySaturation()\n *\n *      Input:  pixd (<optional> can be null, existing or equal to pixs)\n *              pixs (32 bpp rgb)\n *              fract (between -1.0 and 1.0)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) If fract > 0.0, it gives the fraction that the pixel\n *          saturation is moved from its initial value toward 255.\n *          If fract < 0.0, it gives the fraction that the pixel\n *          saturation is moved from its initial value toward 0.\n *          The limiting values for fract = -1.0 (1.0) thus set the\n *          saturation to 0 (255).\n *      (2) If fract = 0, no modification is requested; return a copy\n *          unless in-place, in which case this is a no-op.\n *      (3) See discussion of color-modification methods, in coloring.c.\n */",
      "file" : "enhance.c"
   },
   {
      "function" : "pixMorphCompSequence",
      "comment" : "/*!\n *  pixMorphCompSequence()\n *\n *      Input:  pixs\n *              sequence (string specifying sequence)\n *              dispsep (controls debug display of each result in the sequence:\n *                       0: no output\n *                       > 0: gives horizontal separation in pixels between\n *                            successive displays\n *                       < 0: pdf output; abs(dispsep) is used for naming)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This does rasterop morphology on binary images, using composite\n *          operations for extra speed on large Sels.\n *      (2) Safe closing is used atomically.  However, if you implement a\n *          closing as a sequence with a dilation followed by an\n *          erosion, it will not be safe, and to ensure that you have\n *          no boundary effects you must add a border in advance and\n *          remove it at the end.\n *      (3) For other usage details, see the notes for pixMorphSequence().\n *      (4) The sequence string is formatted as follows:\n *            - An arbitrary number of operations,  each separated\n *              by a '+' character.  White space is ignored.\n *            - Each operation begins with a case-independent character\n *              specifying the operation:\n *                 d or D  (dilation)\n *                 e or E  (erosion)\n *                 o or O  (opening)\n *                 c or C  (closing)\n *                 r or R  (rank binary reduction)\n *                 x or X  (replicative binary expansion)\n *                 b or B  (add a border of 0 pixels of this size)\n *            - The args to the morphological operations are bricks of hits,\n *              and are formatted as a.b, where a and b are horizontal and\n *              vertical dimensions, rsp.\n *            - The args to the reduction are a sequence of up to 4 integers,\n *              each from 1 to 4.\n *            - The arg to the expansion is a power of two, in the set\n *              {2, 4, 8, 16}.\n */",
      "file" : "morphseq.c"
   },
   {
      "function" : "pixMorphCompSequenceDwa",
      "comment" : "/*!\n *  pixMorphCompSequenceDwa()\n *\n *      Input:  pixs\n *              sequence (string specifying sequence)\n *              dispsep (controls debug display of each result in the sequence:\n *                       0: no output\n *                       > 0: gives horizontal separation in pixels between\n *                            successive displays\n *                       < 0: pdf output; abs(dispsep) is used for naming)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This does dwa morphology on binary images, using brick Sels.\n *      (2) This runs a pipeline of operations; no branching is allowed.\n *      (3) It implements all brick Sels that have dimensions up to 63\n *          on each side, using a composite (linear + comb) when useful.\n *      (4) A new image is always produced; the input image is not changed.\n *      (5) This contains an interpreter, allowing sequences to be\n *          generated and run.\n *      (6) See pixMorphSequence() for further information about usage.\n */",
      "file" : "morphseq.c"
   },
   {
      "function" : "pixMorphDwa_1",
      "comment" : "/*!\n *  pixMorphDwa_1()\n *\n *      Input:  pixd (usual 3 choices: null, == pixs, != pixs)\n *              pixs (1 bpp)\n *              operation  (L_MORPH_DILATE, L_MORPH_ERODE,\n *                          L_MORPH_OPEN, L_MORPH_CLOSE)\n *              sel name\n *      Return: pixd\n *\n *  Notes:\n *      (1) This simply adds a border, calls the appropriate\n *          pixFMorphopGen_*(), and removes the border.\n *          See the notes for that function.\n *      (2) The size of the border depends on the operation\n *          and the boundary conditions.\n */",
      "file" : "fmorphgen.1.c"
   },
   {
      "function" : "pixMorphDwa_2",
      "comment" : "/*!\n *  pixMorphDwa_2()\n *\n *      Input:  pixd (usual 3 choices: null, == pixs, != pixs)\n *              pixs (1 bpp)\n *              operation  (L_MORPH_DILATE, L_MORPH_ERODE,\n *                          L_MORPH_OPEN, L_MORPH_CLOSE)\n *              sel name\n *      Return: pixd\n *\n *  Notes:\n *      (1) This simply adds a border, calls the appropriate\n *          pixFMorphopGen_*(), and removes the border.\n *          See the notes for that function.\n *      (2) The size of the border depends on the operation\n *          and the boundary conditions.\n */",
      "file" : "dwacomb.2.c"
   },
   {
      "function" : "pixMorphGradient",
      "comment" : "/*!\n *  pixMorphGradient()\n *\n *      Input:  pixs\n *              hsize (of Sel; must be odd; origin implicitly in center)\n *              vsize (ditto)\n *              smoothing  (half-width of convolution smoothing filter.\n *                          The width is (2 * smoothing + 1), so 0 is no-op.\n *      Return: pixd, or null on error\n */",
      "file" : "morphapp.c"
   },
   {
      "function" : "pixMorphSequence",
      "comment" : "/*!\n *  pixMorphSequence()\n *\n *      Input:  pixs\n *              sequence (string specifying sequence)\n *              dispsep (controls debug display of each result in the sequence:\n *                       0: no output\n *                       > 0: gives horizontal separation in pixels between\n *                            successive displays\n *                       < 0: pdf output; abs(dispsep) is used for naming)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This does rasterop morphology on binary images.\n *      (2) This runs a pipeline of operations; no branching is allowed.\n *      (3) This only uses brick Sels, which are created on the fly.\n *          In the future this will be generalized to extract Sels from\n *          a Sela by name.\n *      (4) A new image is always produced; the input image is not changed.\n *      (5) This contains an interpreter, allowing sequences to be\n *          generated and run.\n *      (6) The format of the sequence string is defined below.\n *      (7) In addition to morphological operations, rank order reduction\n *          and replicated expansion allow operations to take place\n *          downscaled by a power of 2.\n *      (8) Intermediate results can optionally be displayed.\n *      (9) Thanks to Dar-Shyang Lee, who had the idea for this and\n *          built the first implementation.\n *      (10) The sequence string is formatted as follows:\n *            - An arbitrary number of operations,  each separated\n *              by a '+' character.  White space is ignored.\n *            - Each operation begins with a case-independent character\n *              specifying the operation:\n *                 d or D  (dilation)\n *                 e or E  (erosion)\n *                 o or O  (opening)\n *                 c or C  (closing)\n *                 r or R  (rank binary reduction)\n *                 x or X  (replicative binary expansion)\n *                 b or B  (add a border of 0 pixels of this size)\n *            - The args to the morphological operations are bricks of hits,\n *              and are formatted as a.b, where a and b are horizontal and\n *              vertical dimensions, rsp.\n *            - The args to the reduction are a sequence of up to 4 integers,\n *              each from 1 to 4.\n *            - The arg to the expansion is a power of two, in the set\n *              {2, 4, 8, 16}.\n *      (11) An example valid sequence is:\n *               \"b32 + o1.3 + C3.1 + r23 + e2.2 + D3.2 + X4\"\n *           In this example, the following operation sequence is carried out:\n *             * b32: Add a 32 pixel border around the input image\n *             * o1.3: Opening with vert sel of length 3 (e.g., 1 x 3)\n *             * C3.1: Closing with horiz sel of length 3  (e.g., 3 x 1)\n *             * r23: Two successive 2x2 reductions with rank 2 in the first\n *                    and rank 3 in the second.  The result is a 4x reduced pix.\n *             * e2.2: Erosion with a 2x2 sel (origin will be at x,y: 0,0)\n *             * d3.2: Dilation with a 3x2 sel (origin will be at x,y: 1,0)\n *             * X4: 4x replicative expansion, back to original resolution\n *      (12) The safe closing is used.  However, if you implement a\n *           closing as separable dilations followed by separable erosions,\n *           it will not be safe.  For that situation, you need to add\n *           a sufficiently large border as the first operation in\n *           the sequence.  This will be removed automatically at the\n *           end.  There are two cautions:\n *              - When computing what is sufficient, remember that if\n *                reductions are carried out, the border is also reduced.\n *              - The border is removed at the end, so if a border is\n *                added at the beginning, the result must be at the\n *                same resolution as the input!\n */",
      "file" : "morphseq.c"
   },
   {
      "function" : "pixMorphSequenceByComponent",
      "comment" : "/*!\n *  pixMorphSequenceByComponent()\n *\n *      Input:  pixs (1 bpp)\n *              sequence (string specifying sequence)\n *              connectivity (4 or 8)\n *              minw  (minimum width to consider; use 0 or 1 for any width)\n *              minh  (minimum height to consider; use 0 or 1 for any height)\n *              &boxa (<optional> return boxa of c.c. in pixs)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) See pixMorphSequence() for composing operation sequences.\n *      (2) This operates separately on each c.c. in the input pix.\n *      (3) The dilation does NOT increase the c.c. size; it is clipped\n *          to the size of the original c.c.   This is necessary to\n *          keep the c.c. independent after the operation.\n *      (4) You can specify that the width and/or height must equal\n *          or exceed a minimum size for the operation to take place.\n *      (5) Use NULL for boxa to avoid returning the boxa.\n */",
      "file" : "morphapp.c"
   },
   {
      "function" : "pixMorphSequenceByRegion",
      "comment" : "/*!\n *  pixMorphSequenceByRegion()\n *\n *      Input:  pixs (1 bpp)\n *              pixm (mask specifying regions)\n *              sequence (string specifying sequence)\n *              connectivity (4 or 8, used on mask)\n *              minw  (minimum width to consider; use 0 or 1 for any width)\n *              minh  (minimum height to consider; use 0 or 1 for any height)\n *              &boxa (<optional> return boxa of c.c. in pixm)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) See pixMorphCompSequence() for composing operation sequences.\n *      (2) This operates separately on the region in pixs corresponding\n *          to each c.c. in the mask pixm.  It differs from\n *          pixMorphSequenceByComponent() in that the latter does not have\n *          a pixm (mask), but instead operates independently on each\n *          component in pixs.\n *      (3) Dilation will NOT increase the region size; the result\n *          is clipped to the size of the mask region.  This is necessary\n *          to make regions independent after the operation.\n *      (4) You can specify that the width and/or height of a region must\n *          equal or exceed a minimum size for the operation to take place.\n *      (5) Use NULL for @pboxa to avoid returning the boxa.\n */",
      "file" : "morphapp.c"
   },
   {
      "function" : "pixMorphSequenceDwa",
      "comment" : "/*!\n *  pixMorphSequenceDwa()\n *\n *      Input:  pixs\n *              sequence (string specifying sequence)\n *              dispsep (controls debug display of each result in the sequence:\n *                       0: no output\n *                       > 0: gives horizontal separation in pixels between\n *                            successive displays\n *                       < 0: pdf output; abs(dispsep) is used for naming)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This does dwa morphology on binary images.\n *      (2) This runs a pipeline of operations; no branching is allowed.\n *      (3) This only uses brick Sels that have been pre-compiled with\n *          dwa code.\n *      (4) A new image is always produced; the input image is not changed.\n *      (5) This contains an interpreter, allowing sequences to be\n *          generated and run.\n *      (6) See pixMorphSequence() for further information about usage.\n */",
      "file" : "morphseq.c"
   },
   {
      "function" : "pixMorphSequenceMasked",
      "comment" : "/*!\n *  pixMorphSequenceMasked()\n *\n *      Input:  pixs (1 bpp)\n *              pixm (<optional> 1 bpp mask)\n *              sequence (string specifying sequence of operations)\n *              dispsep (horizontal separation in pixels between\n *                       successive displays; use zero to suppress display)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This applies the morph sequence to the image, but only allows\n *          changes in pixs for pixels under the background of pixm.\n *      (5) If pixm is NULL, this is just pixMorphSequence().\n */",
      "file" : "morphapp.c"
   },
   {
      "function" : "pixMultConstAccumulate",
      "comment" : "/*!\n *  pixMultConstAccumulate()\n *\n *      Input:  pixs (32 bpp)\n *              factor\n *              offset (same as used for initialization)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) The offset must be >= 0 and should not exceed 0x40000000.\n *      (2) This multiplies each pixel, relative to offset, by the input factor\n *      (3) The result is returned with the offset back in place.\n */",
      "file" : "pixarith.c"
   },
   {
      "function" : "pixMultConstantColor",
      "comment" : "/*\n *  pixMultConstantColor()\n *\n *      Input:  pixs (colormapped or rgb)\n *              rfact, gfact, bfact (multiplicative factors on each component)\n *      Return: pixd (colormapped or rgb, with colors scaled), or null on error\n *\n *  Notes:\n *      (1) rfact, gfact and bfact can only have non-negative values.\n *          They can be greater than 1.0.  All transformed component\n *          values are clipped to the interval [0, 255].\n *      (2) For multiplication with a general 3x3 matrix of constants,\n *          use pixMultMatrixColor().\n */",
      "file" : "enhance.c"
   },
   {
      "function" : "pixMultConstantGray",
      "comment" : "/*!\n *  pixMultConstantGray()\n *\n *      Input:  pixs (8, 16 or 32 bpp)\n *              val  (>= 0.0; amount to multiply by each pixel)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) In-place operation; val must be >= 0.\n *      (2) No clipping for 32 bpp.\n *      (3) For 8 and 16 bpp, the result is clipped to 0xff and 0xffff, rsp.\n */",
      "file" : "pixarith.c"
   },
   {
      "function" : "pixMultMatrixColor",
      "comment" : "/*\n *  pixMultMatrixColor()\n *\n *      Input:  pixs (colormapped or rgb)\n *              kernel (3x3 matrix of floats)\n *      Return: pixd (colormapped or rgb), or null on error\n *\n *  Notes:\n *      (1) The kernel is a data structure used mostly for floating point\n *          convolution.  Here it is a 3x3 matrix of floats that are used\n *          to transform the pixel values by matrix multiplication:\n *            nrval = a[0,0] * rval + a[0,1] * gval + a[0,2] * bval\n *            ngval = a[1,0] * rval + a[1,1] * gval + a[1,2] * bval\n *            nbval = a[2,0] * rval + a[2,1] * gval + a[2,2] * bval\n *      (2) The matrix can be generated in several ways.\n *          See kernel.c for details.  Here are two of them:\n *            (a) kel = kernelCreate(3, 3);\n *                kernelSetElement(kel, 0, 0, val00);\n *                kernelSetElement(kel, 0, 1, val01);\n *                ...\n *            (b) from a static string; e.g.,:\n *                const char *kdata = \" 0.6  0.3 -0.2 \"\n *                                    \" 0.1  1.2  0.4 \"\n *                                    \" -0.4 0.2  0.9 \";\n *                kel = kernelCreateFromString(3, 3, 0, 0, kdata);\n *      (3) For the special case where the matrix is diagonal, it is easier\n *          to use pixMultConstantColor().\n *      (4) Matrix entries can have positive and negative values, and can\n *          be larger than 1.0.  All transformed component values\n *          are clipped to [0, 255].\n */",
      "file" : "enhance.c"
   },
   {
      "function" : "pixMultiplyByColor",
      "comment" : "/*!\n *  pixMultiplyByColor()\n *\n *      Input:  pixd (can be NULL or pixs)\n *              pixs (32 bpp rgb)\n *              box (region for filtering; can be NULL))\n *              color (32 bit color in 0xrrggbb00 format)\n *      Return: pixd always\n *\n *  Notes:\n *      (1) This filters all pixels in the specified region by\n *          multiplying each component by the input color.\n *          This leaves black invariant and transforms white to the\n *          input color.\n *      (2) If pixd == pixs, this is done in-place.\n *      (3) If box == NULL, this is performed on all of pixs.\n */",
      "file" : "blend.c"
   },
   {
      "function" : "pixNumColors",
      "comment" : "/*!\n *  pixNumColors()\n *      Input:  pixs (2, 4, 8, 32 bpp)\n *              factor (subsampling factor; integer)\n *              &ncolors (<return> the number of colors found, or 0 if\n *                        there are more than 256)\n *      Return: 0 if OK, 1 on error.\n *\n *  Notes:\n *      (1) This returns the actual number of colors found in the image,\n *          even if there is a colormap.  If @factor == 1 and the\n *          number of colors differs from the number of entries\n *          in the colormap, a warning is issued.\n *      (2) Use @factor == 1 to find the actual number of colors.\n *          Use @factor > 1 to quickly find the approximate number of colors.\n *      (3) For d = 2, 4 or 8 bpp grayscale, this returns the number\n *          of colors found in the image in 'ncolors'.\n *      (4) For d = 32 bpp (rgb), if the number of colors is\n *          greater than 256, this returns 0 in 'ncolors'.\n */",
      "file" : "colorcontent.c"
   },
   {
      "function" : "pixNumSignificantGrayColors",
      "comment" : "/*!\n *  pixNumSignificantGrayColors()\n *\n *      Input:  pixs  (8 bpp gray)\n *              darkthresh (dark threshold for minimum intensity to be\n *                          considered; typ. 20)\n *              lightthresh (threshold near white, for maximum intensity\n *                           to be considered; typ. 236)\n *              minfract (minimum fraction of all pixels to include a level\n *                        as significant; typ. 0.0001; should be < 0.001)\n *              factor (subsample factor; integer >= 1)\n *              &ncolors (<return> number of significant colors; 0 on error)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This function is asking the question: how many perceptually\n *          significant gray color levels is in this pix?\n *          A color level must meet 3 criteria to be significant:\n *            - it can't be too close to black\n *            - it can't be too close to white\n *            - it must have at least some minimum fractional population\n *      (2) Use -1 for default values for darkthresh, lightthresh and minfract.\n *      (3) Choose default of darkthresh = 20, because variations in very\n *          dark pixels are not visually significant.\n *      (4) Choose default of lightthresh = 236, because document images\n *          that have been jpeg'd typically have near-white pixels in the\n *          8x8 jpeg blocks, and these should not be counted.  It is desirable\n *          to obtain a clean image by quantizing this noise away.\n */",
      "file" : "colorcontent.c"
   },
   {
      "function" : "pixNumberOccupiedOctcubes",
      "comment" : "/*!\n *  pixNumberOccupiedOctcubes()\n *\n *      Input:  pix (32 bpp)\n *              level (of octcube)\n *              mincount (minimum num pixels in an octcube to be counted;\n *                        -1 to not use)\n *              minfract (minimum fract of pixels in an octcube to be\n *                        counted; -1 to not use)\n *              &ncolors (<return> number of occupied octcubes)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Exactly one of (@mincount, @minfract) must be -1, so, e.g.,\n *          if @mincount == -1, then we use @minfract.\n *      (2) If all occupied octcubes are to count, set @mincount == 1.\n *          Setting @minfract == 0.0 is taken to mean the same thing.\n */",
      "file" : "colorquant1.c"
   },
   {
      "function" : "pixOctcubeHistogram",
      "comment" : "/*!\n *  pixOctcubeHistogram()\n *\n *      Input:  pixs (32 bpp rgb)\n *              level (significant bits for each of RGB; valid in [1...6])\n *              &ncolors (<optional return> number of occupied cubes)\n *      Return: numa (histogram of color pixels, or null on error)\n *\n *  Notes:\n *      (1) Input NULL for &ncolors to prevent computation and return value.\n */",
      "file" : "colorquant1.c"
   },
   {
      "function" : "pixOctcubeQuantFromCmap",
      "comment" : "/*!\n *  pixOctcubeQuantFromCmap()\n *\n *      Input:  pixs  (32 bpp rgb)\n *              cmap  (to quantize to; insert copy into dest pix)\n *              mindepth (minimum depth of pixd: can be 2, 4 or 8 bpp)\n *              level (of octcube used for finding nearest color in cmap)\n *              metric (L_MANHATTAN_DISTANCE, L_EUCLIDEAN_DISTANCE)\n *      Return: pixd  (2, 4 or 8 bpp, colormapped), or null on error\n *\n *  Notes:\n *      (1) In typical use, we are doing an operation, such as\n *          interpolative scaling, on a colormapped pix, where it is\n *          necessary to remove the colormap before the operation.\n *          We then want to re-quantize the RGB result using the same\n *          colormap.\n *      (2) The level is used to divide the color space into octcubes.\n *          Each input pixel is, in effect, placed at the center of an\n *          octcube at the given level, and it is mapped into the\n *          exact color (given in the colormap) that is the closest\n *          to that location.  We need to know that distance, for each color\n *          in the colormap.  The higher the level of the octtree, the smaller\n *          the octcubes in the color space, and hence the more accurately\n *          we can determine the closest color in the colormap; however,\n *          the size of the LUT, which is the total number of octcubes,\n *          increases by a factor of 8 for each increase of 1 level.\n *          The time required to acquire a level 4 mapping table, which has\n *          about 4K entries, is less than 1 msec, so that is the\n *          recommended minimum size to be used.  At that size, the\n *          octcubes have their centers 16 units apart in each (r,g,b)\n *          direction.  If two colors are in the same octcube, the one\n *          closest to the center will always be chosen.  The maximum\n *          error for any component occurs when the correct color is\n *          at a cube corner and there is an incorrect color just inside\n *          the cube next to the opposite corner, giving an error of\n *          14 units (out of 256) for each component.   Using a level 5\n *          mapping table reduces the maximum error to 6 units.\n *      (3) Typically you should use the Euclidean metric, because the\n *          resulting voronoi cells (which are generated using the actual\n *          colormap values as seeds) are convex for Euclidean distance\n *          but not for Manhattan distance.  In terms of the octcubes,\n *          convexity of the voronoi cells means that if the 8 corners\n *          of any cube (of which the octcubes are special cases)\n *          are all within a cell, then every point in the cube will\n *          lie within the cell.\n *      (4) The depth of the output pixd is equal to the maximum of\n *          (a) @mindepth and (b) the minimum (2, 4 or 8 bpp) necessary\n *          to hold the indices in the colormap.\n *      (5) We build a mapping table from octcube to colormap index so\n *          that this function can run in a time (otherwise) independent\n *          of the number of colors in the colormap.  This avoids a\n *          brute-force search for the closest colormap color to each\n *          pixel in the image.\n *      (6) This is similar to the function pixAssignToNearestColor()\n *          used for color segmentation.\n *      (7) Except for very small images or when using level > 4,\n *          it takes very little time to generate the tables,\n *          compared to the generation of the colormapped dest pix,\n *          so one would not typically use the low-level version.\n */",
      "file" : "colorquant1.c"
   },
   {
      "function" : "pixOctcubeQuantFromCmapLUT",
      "comment" : "/*!\n *  pixOctcubeQuantFromCmapLUT()\n *\n *      Input:  pixs  (32 bpp rgb)\n *              cmap  (to quantize to; insert copy into dest pix)\n *              mindepth (minimum depth of pixd: can be 2, 4 or 8 bpp)\n *              cmaptab  (table mapping from octindex to colormap index)\n *              rtab, gtab, btab (tables mapping from RGB to octindex)\n *      Return: pixd  (2, 4 or 8 bpp, colormapped), or null on error\n *\n *  Notes:\n *      (1) See the notes in the higher-level function\n *          pixOctcubeQuantFromCmap().  The octcube level for\n *          the generated octree is specified there, along with\n *          the distance metric for determining the closest\n *          color in the colormap to each octcube.\n *      (2) If the colormap, level and metric information have already\n *          been used to construct the set of mapping tables,\n *          this low-level function can be used directly (i.e.,\n *          independently of pixOctcubeQuantFromCmap()) to build\n *          a colormapped pix that uses the specified colormap.\n */",
      "file" : "colorquant1.c"
   },
   {
      "function" : "pixOctcubeQuantMixedWithGray",
      "comment" : "/*!\n *  pixOctcubeQuantMixedWithGray()\n *\n *      Input:  pixs (32 bpp rgb)\n *              depth (of output pix)\n *              graylevels (grayscale)\n *              delta (threshold for deciding if a pix is color or grayscale)\n *      Return: pixd (quantized to octcube and gray levels) or null on error\n *\n *  Notes:\n *      (1) Generates a colormapped image, where the colormap table values\n *          have two components: octcube values representing pixels with\n *          color content, and grayscale values for the rest.\n *      (2) The threshold (delta) is the maximum allowable difference of\n *          the max abs value of | r - g |, | r - b | and | g - b |.\n *      (3) The octcube values are the averages of all pixels that are\n *          found in the octcube, and that are far enough from gray to\n *          be considered color.  This can roughly be visualized as all\n *          the points in the rgb color cube that are not within a \"cylinder\"\n *          of diameter approximately 'delta' along the main diagonal.\n *      (4) We want to guarantee full coverage of the rgb color space; thus,\n *          if the output depth is 4, the octlevel is 1 (2 x 2 x 2 = 8 cubes)\n *          and if the output depth is 8, the octlevel is 2 (4 x 4 x 4\n *          = 64 cubes).\n *      (5) Consequently, we have the following constraint on the number\n *          of allowed gray levels: for 4 bpp, 8; for 8 bpp, 192.\n */",
      "file" : "colorquant1.c"
   },
   {
      "function" : "pixOctreeColorQuant",
      "comment" : "/*!\n *  pixOctreeColorQuant()\n *\n *      Input:  pixs  (32 bpp; 24-bit color)\n *              colors  (in colormap; some number in range [128 ... 256];\n *                      the actual number of colors used will be smaller)\n *              ditherflag  (1 to dither, 0 otherwise)\n *      Return: pixd (8 bpp with colormap), or null on error\n *\n *  I found one description in the literature of octree color\n *  quantization, using progressive truncation of the octree,\n *  by M. Gervautz and W. Purgathofer in Graphics Gems, pp.\n *  287-293, ed. A. Glassner, Academic Press, 1990.\n *  Rather than setting up a fixed partitioning of the color\n *  space ab initio, as we do here, they allow the octree to be\n *  progressively truncated as new pixels are added.  They\n *  need to set up some data structures that are traversed\n *  with the addition of each 24 bit pixel, in order to decide\n *  either (1) in which cluster (sub-branch of the octree) to put\n *  the pixel, or (2) whether to truncate the octree further\n *  to place the pixel in an existing cluster, or (3) which\n *  two existing clusters should be merged so that the pixel\n *  can be left to start a truncated leaf of the octree.  Such dynamic\n *  truncation is considerably more complicated, and Gervautz et\n *  al. did not explain how they did it in anywhere near the\n *  detail required to check their implementation.\n *\n *  The simple method in pixFixedOctcubeQuant256() is very\n *  fast, and with dithering the results are good, but you\n *  can do better if the color clusters are selected adaptively\n *  from the image.  We want a method that makes much better\n *  use of color samples in regions of color space with high\n *  pixel density, while also fairly representing small numbers\n *  of color pixels in low density regions.  Such adaptation\n *  requires two passes through the image: the first for generating\n *  the pruned tree of color cubes and the second for computing the index\n *  into the color table for each pixel.\n *\n *  A relatively simple adaptive method is pixOctreeQuantByPopulation().\n *  That function first determines if the image has very few colors,\n *  and, if so, quantizes to those colors.  If there are more than\n *  256 colors, it generates a histogram of octcube leaf occupancy\n *  at level 4, chooses the 192 most populated such leaves as\n *  the first 192 colors, and sets the remaining 64 colors to the\n *  residual average pixel values in each of the 64 level 2 octcubes.\n *  This is a bit faster than pixOctreeColorQuant(), and does very\n *  well without dithering, but for most images with dithering it\n *  is clearly inferior.\n *\n *  We now describe pixOctreeColorQuant().  The first pass is done\n *  on a subsampled image, because we do not need to use all the\n *  pixels in the image to generate the tree.  Subsampling\n *  down to 0.25 (1/16 of the pixels) makes the program run\n *  about 1.3 times faster.\n *\n *  Instead of dividing the color space into 256 equal-sized\n *  regions, we initially divide it into 2^12 or 2^15 or 2^18\n *  equal-sized octcubes.  Suppose we choose to use 2^18 octcubes.\n *  This gives us 6 octree levels.  We then prune back,\n *  starting from level 6.  For every cube at level 6, there\n *  are 8 cubes at level 5.  Call the operation of putting a\n *  cube aside as a color table entry (CTE) a \"saving.\"\n *  We use a (in general) level-dependent threshold, and save\n *  those level 6 cubes that are above threshold.\n *  The rest are combined into the containing level 5 cube.\n *  If between 1 and 7 level 6 cubes within a level 5\n *  cube have been saved by thresholding, then the remaining\n *  level 6 cubes in that level 5 cube are automatically\n *  saved as well, without applying a threshold.  This greatly\n *  simplifies both the description of the CTEs and the later\n *  classification of each pixel as belonging to a CTE.\n *  This procedure is iterated through every cube, starting at\n *  level 5, and then 4, 3, and 2, successively.  The result is that\n *  each CTE contains the entirety of a set of from 1 to 7 cubes\n *  from a given level that all belong to a single cube at the\n *  level above.   We classify the CTEs in terms of the\n *  condition in which they are made as either being \"threshold\"\n *  or \"residual.\"  They are \"threshold\" CTEs if no subcubes\n *  are CTEs (that is, they contain every pixel within the cube)\n *  and the number of pixels exceeds the threshold for making\n *  a CTE.  They are \"residual\" CTEs if at least one but not more\n *  than 7 of the subcubes have already been determined to be CTEs;\n *  this happens automatically -- no threshold is applied.\n *  If all 8 subcubes are determined to be CTEs, the cube is\n *  marked as having all pixels accounted for ('bleaf' = 1) but\n *  is not saved as a CTE.\n *\n *  We stop the pruning at level 2, at which there are 64\n *  sub-cubes.  Any pixels not already claimed in a CTE are\n *  put in these cubes.\n *\n *  As the cubes are saved as color samples in the color table,\n *  the number of remaining pixels P and the number of\n *  remaining colors in the color table N are recomputed,\n *  along with the average number of pixels P/N (ppc) to go in\n *  each of the remaining colors.  This running average number is\n *  used to set the threshold at the current level.\n *\n *  Because we are going to very small cubes at levels 6 or 5,\n *  and will dither the colors for errors, it is not necessary\n *  to compute the color center of each cluster; we can simply\n *  use the center of the cube.  This gives us a minimax error\n *  condition: the maximum error is half the width of the\n *  level 2 cubes -- 32 color values out of 256 -- for each color\n *  sample.  In practice, most of the pixels will be very much\n *  closer to the center of their cells.  And with dithering,\n *  the average pixel color in a small region will be closer still.\n *  Thus with the octree quantizer, we are able to capture\n *  regions of high color pdf (probability density function) in small\n *  but accurate CTEs, and to have only a small number of pixels\n *  that end up a significant distance (with a guaranteed maximum)\n *  from their true color.\n *\n *  How should the threshold factor vary?  Threshold factors\n *  are required for levels 2, 3, 4 and 5 in the pruning stage.\n *  The threshold for level 5 is actually applied to cubes at\n *  level 6, etc.  From various experiments, it appears that\n *  the results do not vary appreciably for threshold values near 1.0.\n *  If you want more colors in smaller cubes, the threshold\n *  factors can be set lower than 1.0 for cubes at levels 4 and 5.\n *  However, if the factor is set much lower than 1.0 for\n *  levels 2 and 3, we can easily run out of colors.\n *  We put aside 64 colors in the calculation of the threshold\n *  values, because we must have 64 color centers at level 2,\n *  that will have very few pixels in most of them.\n *  If we reduce the factor for level 5 to 0.4, this will\n *  generate many level 6 CTEs, and consequently\n *  many residual cells will be formed up from those leaves,\n *  resulting in the possibility of running out of colors.\n *  Remember, the residual CTEs are mandatory, and are formed\n *  without using the threshold, regardless of the number of\n *  pixels that are absorbed.\n *\n *  The implementation logically has four parts:\n *\n *       (1) accumulation into small, fixed cells\n *       (2) pruning back into selected CTE cubes\n *       (3) organizing the CTEs for fast search to find\n *           the CTE to which any image pixel belongs\n *       (4) doing a second scan to code the image pixels by CTE\n *\n *  Step (1) is straightforward; we use 2^15 cells.\n *\n *  We've already discussed how the pruning step (2) will be performed.\n *\n *  Steps (3) and (4) are related, in that the organization\n *  used by step (3) determines how the search actually\n *  takes place for each pixel in step (4).\n *\n *  There are many ways to do step (3).  Let's explore a few.\n *\n *  (a) The simplest is to order the cubes from highest occupancy\n *      to lowest, and traverse the list looking for the deepest\n *      match.  To make this more efficient, so that we know when\n *      to stop looking, any cube that has separate CTE subcubes\n *      would be marked as such, so that we know when we hit a\n *      true leaf.\n *\n *  (b) Alternatively, we can order the cubes by highest\n *      occupancy separately each level, and work upward,\n *      starting at level 5, so that when we find a match we\n *      know that it will be correct.\n *\n *  (c) Another approach would be to order the cubes by\n *      \"address\" and use a hash table to find the cube\n *      corresponding to a pixel color.  I don't know how to\n *      do this with a variable length address, as each CTE\n *      will have 3*n bits, where n is the level.\n *\n *  (d) Another approach entirely is to put the CTE cubes into\n *      a tree, in such a way that starting from the root, and\n *      using 3 bits of address at a time, the correct branch of\n *      each octree can be taken until a leaf is found.  Because\n *      a given cube can be both a leaf and also have branches\n *      going to sub-cubes, the search stops only when no\n *      marked subcubes have addresses that match the given pixel.\n *\n *      In the tree method, we can start with a dense infrastructure,\n *      and place the leaves corresponding to the N colors\n *      in the tree, or we can grow from the root only those\n *      branches that end directly on leaves.\n *\n *  What we do here is to take approach (d), and implement the tree\n *  \"virtually\", as a set of arrays, one array for each level\n *  of the tree.   Initially we start at level 5, an array with\n *  2^15 cubes, each with 8 subcubes.  We then build nodes at\n *  levels closer to the root; at level 4 there are 2^12 nodes\n *  each with 8 subcubes; etc.  Using these arrays has\n *  several advantages:\n *\n *     -  We don't need to keep track of links between cubes\n *        and subcubes, because we can use the canonical\n *        addressing on the cell arrays directly to determine\n *        which nodes are parent cubes and which are sub-cubes.\n *\n *     -  We can prune directly on this tree\n *\n *     -  We can navigate the pruned tree quickly to classify\n *        each pixel in the image.\n *\n *  Canonical addressing guarantees that the i-th node at level k\n *  has 8 subnodes given by the 8*i ... 8*i+7 nodes at level k+1.\n *\n *  The pruning step works as follows.  We go from the lowest\n *  level up.  At each level, the threshold is found from the\n *  product of a factor near 1.0 and the ratio of unmarked pixels\n *  to remaining colors (minus the 64).  We march through\n *  the space, sequentially considering a cube and its 8 subcubes.\n *  We first check those subcubes that are not already\n *  marked as CTE to see if any are above threshold, and if so,\n *  generate a CTE and mark them as such.\n *  We then determine if any of the subcubes have been marked.\n *  If so, and there are subcubes that are not marked,\n *  we generate a CTE for the cube from the remaining unmarked\n *  subcubes; this is mandatory and does not depend on how many\n *  pixels are in the set of subcubes.  If none of the subcubes\n *  are marked, we aggregate their pixels into the cube\n *  containing them, but do not mark it as a CTE; that\n *  will be determined when iterating through the next level up.\n *\n *  When all the pixels in a cube are accounted for in one or more\n *  colors, we set the boolean 'bleaf' to true.  This is the\n *  flag used to mark the cubes in the pruning step.  If a cube\n *  is marked, and all 8 subcubes are marked, then it is not\n *  itself given a CTE because all pixels have already been\n *  accounted for.\n *\n *  Note that the pruning of the tree and labelling of the CTEs\n *  (step 2) accomplishes step 3 implicitly, because the marked\n *  and pruned tree is ready for use in labelling each pixel\n *  in step 4.  We now, for every pixel in the image, traverse\n *  the tree from the root, looking for the lowest cube that is a leaf.\n *  At each level we have a cube and subcube.  If we reach a subcube\n *  leaf that is marked 0, we know that the color is stored in the\n *  cube above, and we've found the CTE.  Otherwise, the subcube\n *  leaf is marked 1.  If we're at the last level, we've reached\n *  the final leaf and must use it.  Otherwise, continue the\n *  process at the next level down.\n *\n *  For robustness, efficiency and high quality output, we do the following:\n *\n *  (1) Measure the color content of the image.  If there is very little\n *      color, quantize in grayscale.\n *  (2) For efficiency, build the octree with a subsampled image if the\n *      image is larger than some threshold size.\n *  (3) Reserve an extra set of colors to prevent running out of colors\n *      when pruning the octree; specifically, during the assignment\n *      of those level 2 cells (out of the 64) that have unassigned\n *      pixels.  The problem of running out is more likely to happen\n *      with small images, because the estimation we use for the\n *      number of pixels available is not accurate.\n *  (4) In the unlikely event that we run out of colors, the dithered\n *      image can be very poor.  As this would only happen with very\n *      small images, and dithering is not particularly noticeable with\n *      such images, turn it off.\n */",
      "file" : "colorquant1.c"
   },
   {
      "function" : "pixOctreeColorQuantGeneral",
      "comment" : "/*!\n *  pixOctreeColorQuantGeneral()\n *\n *      Input:  pixs  (32 bpp; 24-bit color)\n *              colors  (in colormap; some number in range [128 ... 240];\n *                      the actual number of colors used will be smaller)\n *              ditherflag  (1 to dither, 0 otherwise)\n *              validthresh (minimum fraction of pixels neither near white\n *                           nor black, required for color quantization;\n *                           typically ~0.01, but smaller for images that have\n *                           color but are nearly all white)\n *              colorthresh (minimum fraction of pixels with color that are\n *                           not near white or black, that are required\n *                           for color quantization; typ. ~0.01, but smaller\n *                           for images that have color along with a\n *                           significant fraction of gray)\n *      Return: pixd (8 bit with colormap), or null on error\n *\n *  Notes:\n *      (1) The parameters @validthresh and @colorthresh are used to\n *          determine if color quantization should be used on an image,\n *          or whether, instead, it should be quantized in grayscale.\n *          If the image has very few non-white and non-black pixels, or\n *          if those pixels that are non-white and non-black are all\n *          very close to either white or black, it is usually better\n *          to treat the color as accidental and to quantize the image\n *          to gray only.  These parameters are useful if you know\n *          something a priori about the image.  Perhaps you know that\n *          there is only a very small fraction of color pixels, but they're\n *          important to preserve; then you want to use a smaller value for\n *          these parameters.  To disable conversion to gray and force\n *          color quantization, use @validthresh = 0.0 and @colorthresh = 0.0.\n *      (2) See pixOctreeColorQuant() for algorithmic and implementation\n *          details.  This function has a more general interface.\n *      (3) See pixColorFraction() for computing the fraction of pixels\n *          that are neither white nor black, and the fraction of those\n *          pixels that have little color.  From the documentation there:\n *             If pixfract is very small, there are few pixels that are\n *             neither black nor white.  If colorfract is very small,\n *             the pixels that are neither black nor white have very\n *             little color content.  The product 'pixfract * colorfract'\n *             gives the fraction of pixels with significant color content.\n *          We test against the product @validthresh * @colorthresh\n *          to find color in images that have either very few\n *          intermediate gray pixels or that have many such gray pixels.\n */",
      "file" : "colorquant1.c"
   },
   {
      "function" : "pixOctreeQuantByPopulation",
      "comment" : "/*!\n *  pixOctreeQuantByPopulation()\n *\n *      Input:  pixs (32 bpp rgb)\n *              level (significant bits for each of RGB; valid for {3,4},\n *                     Use 0 for default (level 4; recommended)\n *              ditherflag  (1 to dither, 0 otherwise)\n *      Return: pixd (quantized to octcubes) or null on error\n *\n *  Notes:\n *      (1) This color quantization method works very well without\n *          dithering, using octcubes at two different levels:\n *            (a) the input @level, which is either 3 or 4\n *            (b) level 2 (64 octcubes to cover the entire color space)\n *      (2) For best results, using @level = 4 is recommended.\n *          Why do we provide an option for using level 3?  Because\n *          there are 512 octcubes at level 3, and for many images\n *          not more than 256 are filled.  As a result, on some images\n *          a very accurate quantized representation is possible using\n *          @level = 3.\n *      (3) This first breaks up the color space into octcubes at the\n *          input @level, and computes, for each octcube, the average\n *          value of the pixels that are in it.\n *      (4) Then there are two possible situations:\n *            (a) If there are not more than 256 populated octcubes,\n *                it returns a cmapped pix with those values assigned.\n *            (b) Otherwise, it selects 192 octcubes containing the largest\n *                number of pixels and quantizes pixels within those octcubes\n *                to their average.  Then, to handle the residual pixels\n *                that are not in those 192 octcubes, it generates a\n *                level 2 octree consisting of 64 octcubes, and within\n *                each octcube it quantizes the residual pixels to their\n *                average within each of those level 2 octcubes.\n *      (5) Unpopulated level 2 octcubes are represented in the colormap\n *          by their centers.  This, of course, has no effect unless\n *          dithering is used for the output image.\n *      (6) The depth of pixd is the minumum required to suppport the\n *          number of colors found at @level; namely, 2, 4 or 8.\n *      (7) This function works particularly well on images such as maps,\n *          where there are a relatively small number of well-populated\n *          colors, but due to antialiasing and compression artifacts\n *          there may be a large number of different colors.  This will\n *          pull out and represent accurately the highly populated colors,\n *          while still making a reasonable approximation for the others.\n *      (8) The highest level of octcubes allowed is 4.  Use of higher\n *          levels typically results in having a small fraction of\n *          pixels in the most populated 192 octcubes.  As a result,\n *          most of the pixels are represented at level 2, which is\n *          not sufficiently accurate.\n *      (9) Dithering shows artifacts on some images.  If you plan to\n *          dither, pixOctreeColorQuant() and pixFixedOctcubeQuant256()\n *          usually give better results.\n */",
      "file" : "colorquant1.c"
   },
   {
      "function" : "pixOctreeQuantNumColors",
      "comment" : "/*!\n *  pixOctreeQuantNumColors()\n *\n *      Input:  pixs (32 bpp rgb)\n *              maxcolors (8 to 256; the actual number of colors used\n *                         may be less than this)\n *              subsample (factor for computing color distribution;\n *                         use 0 for default)\n *      Return: pixd (4 or 8 bpp, colormapped), or null on error\n *\n *  pixOctreeColorQuant() is very flexible in terms of the relative\n *  depth of different cubes of the octree.   By contrast, this function,\n *  pixOctreeQuantNumColors() is also adaptive, but it supports octcube\n *  leaves at only two depths: a smaller depth that guarantees\n *  full coverage of the color space and octcubes at one level\n *  deeper for more accurate colors.  Its main virutes are simplicity\n *  and speed, which are both derived from the natural indexing of\n *  the octcubes from the RGB values.\n *\n *  Before describing pixOctreeQuantNumColors(), consider an even simpler\n *  approach for 4 bpp with either 8 or 16 colors.  With 8 colors,\n *  you simply go to level 1 octcubes and use the average color\n *  found in each cube.  For 16 colors, you find which of the three\n *  colors has the largest variance at the second level, and use two\n *  indices for that color.  The result is quite poor, because (1) some\n *  of the cubes are nearly empty and (2) you don't get much color\n *  differentiation for the extra 8 colors.  Trust me, this method may\n *  be simple, but it isn't worth anything.\n *\n *  In pixOctreeQuantNumColors(), we generate colormapped images at\n *  either 4 bpp or 8 bpp.  For 4 bpp, we have a minimum of 8 colors\n *  for the level 1 octcubes, plus up to 8 additional colors that\n *  are determined from the level 2 popularity.  If the number of colors\n *  is between 8 and 16, the output is a 4 bpp image.  If the number of\n *  colors is greater than 16, the output is a 8 bpp image.\n *\n *  We use a priority queue, implemented with a heap, to select the\n *  requisite number of most populated octcubes at the deepest level\n *  (level 2 for 64 or fewer colors; level 3 for more than 64 colors).\n *  These are combined with one color for each octcube one level above,\n *  which is used to span the color space of octcubes that were not\n *  included at the deeper level.\n *\n *  If the deepest level is 2, we combine the popular level 2 octcubes\n *  (out of a total of 64) with the 8 level 1 octcubes.  If the deepest\n *  level is 3, we combine the popular level 3 octcubes (out of a\n *  total 512) with the 64 level 2 octcubes that span the color space.\n *  In the latter case, we require a minimum of 64 colors for the level 2\n *  octcubes, plus up to 192 additional colors determined from level 3\n *  popularity.\n *\n *  The parameter 'maxlevel' is the deepest octcube level that is used.\n *  The implementation also uses two LUTs, which are employed in\n *  two successive traversals of the dest image.  The first maps\n *  from the src octindex at 'maxlevel' to the color table index,\n *  which is the value that is stored in the 4 or 8 bpp dest pixel.\n *  The second LUT maps from that colormap value in the dest to a\n *  new colormap value for a minimum sized colormap, stored back in\n *  the dest.  It is used to remove any color map entries that\n *  correspond to color space regions that have no pixels in the\n *  source image.  These regions can be either from the higher level\n *  (e.g., level 1 for 4 bpp), or from octcubes at 'maxlevel' that\n *  are unoccupied.  This remapping results in the minimum number\n *  of colors used according to the constraints induced by the\n *  input 'maxcolors'.  We also compute the average R, G and B color\n *  values in each region of the color space represented by a\n *  colormap entry, and store them in the colormap.\n *\n *  The maximum number of colors is input, which determines the\n *  following properties of the dest image and octcube regions used:\n *\n *     Number of colors      dest image depth      maxlevel\n *     ----------------      ----------------      --------\n *       8 to 16                  4 bpp               2\n *       17 to 64                 8 bpp               2\n *       65 to 256                8 bpp               3\n *\n *  It may turn out that the number of extra colors, beyond the\n *  minimum (8 and 64 for maxlevel 2 and 3, respectively), is larger\n *  than the actual number of occupied cubes at these levels\n *  In that case, all the pixels are contained in this\n *  subset of cubes at maxlevel, and no colormap colors are needed\n *  to represent the remainder pixels one level above.  Thus, for\n *  example, in use one often finds that the pixels in an image\n *  occupy less than 192 octcubes at level 3, so they can be represented\n *  by a colormap for octcubes at level 3 only.\n */",
      "file" : "colorquant1.c"
   },
   {
      "function" : "pixOctreeQuantizePixels",
      "comment" : "/*!\n *  pixOctreeQuantizePixels()\n *\n *      Input:  pixs (32 bpp)\n *              octree in array format\n *              ditherflag (1 for dithering, 0 for no dithering)\n *      Return: pixd or null on error\n *\n *  Notes:\n *      (1) This routine doesn't need to use the CTEs (colormap\n *          table entries) because the color indices are embedded\n *          in the octree.  Thus, the calling program must make\n *          and attach the colormap to pixd after it is returned.\n *      (2) Dithering is performed in integers, effectively rounding\n *          to 1/8 sample increment.  The data in the integer buffers is\n *          64 times the sample values.  The 'dif' is 8 times the\n *          sample values, and this spread, multiplied by 8, to the\n *          integer buffers.  Because the dif is truncated to an\n *          integer, the dither is accurate to 1/8 of a sample increment,\n *          or 1/2048 of the color range.\n */",
      "file" : "colorquant1.c"
   },
   {
      "function" : "pixOpen",
      "comment" : "/*!\n *  pixOpen()\n *\n *      Input:  pixd  (<optional>; this can be null, equal to pixs,\n *                     or different from pixs)\n *              pixs (1 bpp)\n *              sel\n *      Return: pixd\n *\n *  Notes:\n *      (1) Generic morphological opening, using hits in the Sel.\n *      (2) There are three cases:\n *          (a) pixd == null   (result into new pixd)\n *          (b) pixd == pixs   (in-place; writes result back to pixs)\n *          (c) pixd != pixs   (puts result into existing pixd)\n *      (3) For clarity, if the case is known, use these patterns:\n *          (a) pixd = pixOpen(NULL, pixs, ...);\n *          (b) pixOpen(pixs, pixs, ...);\n *          (c) pixOpen(pixd, pixs, ...);\n *      (4) The size of the result is determined by pixs.\n */",
      "file" : "morph.c"
   },
   {
      "function" : "pixOpenBrick",
      "comment" : "/*!\n *  pixOpenBrick()\n *\n *      Input:  pixd  (<optional>; this can be null, equal to pixs,\n *                     or different from pixs)\n *              pixs (1 bpp)\n *              hsize (width of brick Sel)\n *              vsize (height of brick Sel)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Sel is a brick with all elements being hits\n *      (2) The origin is at (x, y) = (hsize/2, vsize/2)\n *      (3) Do separably if both hsize and vsize are > 1.\n *      (4) There are three cases:\n *          (a) pixd == null   (result into new pixd)\n *          (b) pixd == pixs   (in-place; writes result back to pixs)\n *          (c) pixd != pixs   (puts result into existing pixd)\n *      (5) For clarity, if the case is known, use these patterns:\n *          (a) pixd = pixOpenBrick(NULL, pixs, ...);\n *          (b) pixOpenBrick(pixs, pixs, ...);\n *          (c) pixOpenBrick(pixd, pixs, ...);\n *      (6) The size of the result is determined by pixs.\n */",
      "file" : "morph.c"
   },
   {
      "function" : "pixOpenBrickDwa",
      "comment" : "/*!\n *  pixOpenBrickDwa()\n *\n *      Input:  pixd  (<optional>; this can be null, equal to pixs,\n *                     or different from pixs)\n *              pixs (1 bpp)\n *              hsize (width of brick Sel)\n *              vsize (height of brick Sel)\n *      Return: pixd\n *\n *  Notes:\n *      (1) These implement 2D brick Sels, using linear Sels generated\n *          with selaAddBasic().\n *      (2) A brick Sel has hits for all elements.\n *      (3) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)\n *      (4) Do separably if both hsize and vsize are > 1.\n *      (5) It is necessary that both horizontal and vertical Sels\n *          of the input size are defined in the basic sela.\n *      (6) Note that we must always set or clear the border pixels\n *          before each operation, depending on the the b.c.\n *          (symmetric or asymmetric).\n *      (7) There are three cases:\n *          (a) pixd == null   (result into new pixd)\n *          (b) pixd == pixs   (in-place; writes result back to pixs)\n *          (c) pixd != pixs   (puts result into existing pixd)\n *      (8) For clarity, if the case is known, use these patterns:\n *          (a) pixd = pixOpenBrickDwa(NULL, pixs, ...);\n *          (b) pixOpenBrickDwa(pixs, pixs, ...);\n *          (c) pixOpenBrickDwa(pixd, pixs, ...);\n *      (9) The size of the result is determined by pixs.\n *      (10) If either linear Sel is not found, this calls\n *           the appropriate decomposible function.\n */",
      "file" : "morphdwa.c"
   },
   {
      "function" : "pixOpenCompBrick",
      "comment" : "/*!\n *  pixOpenCompBrick()\n *\n *      Input:  pixd  (<optional>; this can be null, equal to pixs,\n *                     or different from pixs)\n *              pixs (1 bpp)\n *              hsize (width of brick Sel)\n *              vsize (height of brick Sel)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Sel is a brick with all elements being hits\n *      (2) The origin is at (x, y) = (hsize/2, vsize/2)\n *      (3) Do compositely for each dimension > 1.\n *      (4) Do separably if both hsize and vsize are > 1.\n *      (5) There are three cases:\n *          (a) pixd == null   (result into new pixd)\n *          (b) pixd == pixs   (in-place; writes result back to pixs)\n *          (c) pixd != pixs   (puts result into existing pixd)\n *      (6) For clarity, if the case is known, use these patterns:\n *          (a) pixd = pixOpenCompBrick(NULL, pixs, ...);\n *          (b) pixOpenCompBrick(pixs, pixs, ...);\n *          (c) pixOpenCompBrick(pixd, pixs, ...);\n *      (7) The dimensions of the resulting image are determined by pixs.\n *      (8) CAUTION: both hsize and vsize are being decomposed.\n *          The decomposer chooses a product of sizes (call them\n *          'terms') for each that is close to the input size,\n *          but not necessarily equal to it.  It attempts to optimize:\n *             (a) for consistency with the input values: the product\n *                 of terms is close to the input size\n *             (b) for efficiency of the operation: the sum of the\n *                 terms is small; ideally about twice the square\n *                 root of the input size.\n *          So, for example, if the input hsize = 37, which is\n *          a prime number, the decomposer will break this into two\n *          terms, 6 and 6, so that the net result is a dilation\n *          with hsize = 36.\n */",
      "file" : "morph.c"
   },
   {
      "function" : "pixOpenCompBrickDwa",
      "comment" : "/*!\n *  pixOpenCompBrickDwa()\n *\n *      Input:  pixd  (<optional>; this can be null, equal to pixs,\n *                     or different from pixs)\n *              pixs (1 bpp)\n *              hsize (width of brick Sel)\n *              vsize (height of brick Sel)\n *      Return: pixd\n *\n *  Notes:\n *      (1) These implement a separable composite opening with 2D brick Sels.\n *      (2) For efficiency, it may decompose each linear morphological\n *          operation into two (brick + comb).\n *      (3) A brick Sel has hits for all elements.\n *      (4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)\n *      (5) Do separably if both hsize and vsize are > 1.\n *      (6) It is necessary that both horizontal and vertical Sels\n *          of the input size are defined in the basic sela.\n *      (7) There are three cases:\n *          (a) pixd == null   (result into new pixd)\n *          (b) pixd == pixs   (in-place; writes result back to pixs)\n *          (c) pixd != pixs   (puts result into existing pixd)\n *      (8) For clarity, if the case is known, use these patterns:\n *          (a) pixd = pixOpenCompBrickDwa(NULL, pixs, ...);\n *          (b) pixOpenCompBrickDwa(pixs, pixs, ...);\n *          (c) pixOpenCompBrickDwa(pixd, pixs, ...);\n *      (9) The size of pixd is determined by pixs.\n *      (10) CAUTION: both hsize and vsize are being decomposed.\n *          The decomposer chooses a product of sizes (call them\n *          'terms') for each that is close to the input size,\n *           but not necessarily equal to it.  It attempts to optimize:\n *              (a) for consistency with the input values: the product\n *                  of terms is close to the input size\n *              (b) for efficiency of the operation: the sum of the\n *                  terms is small; ideally about twice the square\n *                   root of the input size.\n *           So, for example, if the input hsize = 37, which is\n *           a prime number, the decomposer will break this into two\n *           terms, 6 and 6, so that the net result is a dilation\n *           with hsize = 36.\n */",
      "file" : "morphdwa.c"
   },
   {
      "function" : "pixOpenCompBrickExtendDwa",
      "comment" : "/*!\n *  pixOpenCompBrickExtendDwa()\n *\n *      Input:  pixd  (<optional>; this can be null, equal to pixs,\n *                     or different from pixs)\n *              pixs (1 bpp)\n *              hsize (width of brick Sel)\n *              vsize (height of brick Sel)\n *      Return: pixd\n *\n *      (1) There are three cases:\n *          (a) pixd == null   (result into new pixd)\n *          (b) pixd == pixs   (in-place; writes result back to pixs)\n *          (c) pixd != pixs   (puts result into existing pixd)\n *      (2) There is no need to call this directly:  pixOpenCompBrickDwa()\n *          calls this function if either brick dimension exceeds 63.\n */",
      "file" : "morphdwa.c"
   },
   {
      "function" : "pixOpenGeneralized",
      "comment" : "/*!\n *  pixOpenGeneralized()\n *\n *      Input:  pixd (<optional>; this can be null, equal to pixs,\n *                    or different from pixs)\n *              pixs (1 bpp)\n *              sel\n *      Return: pixd\n *\n *  Notes:\n *      (1) Generalized morphological opening, using both hits and\n *          misses in the Sel.\n *      (2) This does a hit-miss transform, followed by a dilation\n *          using the hits.\n *      (3) There are three cases:\n *          (a) pixd == null   (result into new pixd)\n *          (b) pixd == pixs   (in-place; writes result back to pixs)\n *          (c) pixd != pixs   (puts result into existing pixd)\n *      (4) For clarity, if the case is known, use these patterns:\n *          (a) pixd = pixOpenGeneralized(NULL, pixs, ...);\n *          (b) pixOpenGeneralized(pixs, pixs, ...);\n *          (c) pixOpenGeneralized(pixd, pixs, ...);\n *      (5) The size of the result is determined by pixs.\n */",
      "file" : "morph.c"
   },
   {
      "function" : "pixOpenGray",
      "comment" : "/*!\n *  pixOpenGray()\n *\n *      Input:  pixs\n *              hsize  (of Sel; must be odd; origin implicitly in center)\n *              vsize  (ditto)\n *      Return: pixd\n *\n *  Notes:\n *      (1) Sel is a brick with all elements being hits\n *      (2) If hsize = vsize = 1, just returns a copy.\n */",
      "file" : "graymorph.c"
   },
   {
      "function" : "pixOpenGray3",
      "comment" : "/*!\n *  pixOpenGray3()\n *\n *      Input:  pixs (8 bpp, not cmapped)\n *              hsize  (1 or 3)\n *              vsize  (1 or 3)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Special case for 1x3, 3x1 or 3x3 brick sel (all hits)\n *      (2) If hsize = vsize = 1, just returns a copy.\n *      (3) It would be nice not to add a border, but it is required\n *          to get the same results as for the general case.\n */",
      "file" : "graymorph.c"
   },
   {
      "function" : "pixOr",
      "comment" : "/*!\n *  pixOr()\n *\n *      Input:  pixd  (<optional>; this can be null, equal to pixs1,\n *                     different from pixs1)\n *              pixs1 (can be == pixd)\n *              pixs2 (must be != pixd)\n *      Return: pixd always\n *\n *  Notes:\n *      (1) This gives the union of two images with equal depth,\n *          aligning them to the the UL corner.  pixs1 and pixs2\n *          need not have the same width and height.\n *      (2) There are 3 cases:\n *            (a) pixd == null,   (src1 | src2) --> new pixd\n *            (b) pixd == pixs1,  (src1 | src2) --> src1  (in-place)\n *            (c) pixd != pixs1,  (src1 | src2) --> input pixd\n *      (3) For clarity, if the case is known, use these patterns:\n *            (a) pixd = pixOr(NULL, pixs1, pixs2);\n *            (b) pixOr(pixs1, pixs1, pixs2);\n *            (c) pixOr(pixd, pixs1, pixs2);\n *      (4) The size of the result is determined by pixs1.\n *      (5) The depths of pixs1 and pixs2 must be equal.\n *      (6) Note carefully that the order of pixs1 and pixs2 only matters\n *          for the in-place case.  For in-place, you must have\n *          pixd == pixs1.  Setting pixd == pixs2 gives an incorrect\n *          result: the copy puts pixs1 image data in pixs2, and\n *          the rasterop is then between pixs2 and pixs2 (a no-op).\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixOrientDetect",
      "comment" : "/*!\n *  pixOrientDetect()\n *\n *      Input:  pixs (1 bpp, deskewed, English text, 150 - 300 ppi)\n *              &upconf (<optional return> ; may be null)\n *              &leftconf (<optional return> ; may be null)\n *              mincount (min number of up + down; use 0 for default)\n *              debug (1 for debug output; 0 otherwise)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) See \"Measuring document image skew and orientation\"\n *          Dan S. Bloomberg, Gary E. Kopec and Lakshmi Dasari\n *          IS&T/SPIE EI'95, Conference 2422: Document Recognition II\n *          pp 302-316, Feb 6-7, 1995, San Jose, CA\n *      (2) upconf is the normalized difference between up ascenders\n *          and down ascenders.  The image is analyzed without rotation\n *          for being rightside-up or upside-down.  Set &upconf to null\n *          to skip this operation.\n *      (3) leftconf is the normalized difference between up ascenders\n *          and down ascenders in the image after it has been\n *          rotated 90 degrees clockwise.  With that rotation, ascenders\n *          projecting to the left in the source image will project up\n *          in the rotated image.  We compute this by rotating 90 degrees\n *          clockwise and testing for up and down ascenders.  Set\n *          &leftconf to null to skip this operation.\n *      (4) Note that upconf and leftconf are not linear measures of\n *          confidence, e.g., in a range between 0 and 100.  They\n *          measure how far you are out on the tail of a (presumably)\n *          normal distribution.  For example, a confidence of 10 means\n *          that it is nearly certain that the difference did not\n *          happen at random.  However, these values must be interpreted\n *          cautiously, taking into consideration the estimated prior\n *          for a particular orientation or mirror flip.   The up-down\n *          signal is very strong if applied to text with ascenders\n *          up and down, and relatively weak for text at 90 degrees,\n *          but even at 90 degrees, the difference can look significant.\n *          For example, suppose the ascenders are oriented horizontally,\n *          but the test is done vertically.  Then upconf can\n *          be < -MIN_CONF_FOR_UP_DOWN, suggesting the text may be\n *          upside-down.  However, if instead the test were done\n *          horizontally, leftconf will be very much larger\n *          (in absolute value), giving the correct orientation.\n *      (5) If you compute both upconf and leftconf, and there is\n *          sufficient signal, the following table determines the\n *          cw angle necessary to rotate pixs so that the text is\n *          rightside-up:\n *             0 deg :           upconf >> 1,    abs(upconf) >> abs(leftconf)\n *             90 deg :          leftconf >> 1,  abs(leftconf) >> abs(upconf)\n *             180 deg :         upconf << -1,   abs(upconf) >> abs(leftconf)\n *             270 deg :         leftconf << -1, abs(leftconf) >> abs(upconf)\n *      (6) One should probably not interpret the direction unless\n *          there are a sufficient number of counts for both orientations,\n *          in which case neither upconf nor leftconf will be 0.0.\n *      (7) Uses rasterop implementation of HMT.\n */",
      "file" : "flipdetect.c"
   },
   {
      "function" : "pixOrientDetectDwa",
      "comment" : "/*!\n *  pixOrientDetectDwa()\n *\n *      Input:  pixs (1 bpp, deskewed, English text)\n *              &upconf (<optional return> ; may be null)\n *              &leftconf (<optional return> ; may be null)\n *              mincount (min number of up + down; use 0 for default)\n *              debug (1 for debug output; 0 otherwise)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Same interface as for pixOrientDetect().  See notes\n *          there for usage.\n *      (2) Uses auto-gen'd code for the Sels defined at the\n *          top of this file, with some renaming of functions.\n *          The auto-gen'd code is in fliphmtgen.c, and can\n *          be generated by a simple executable; see prog/flipselgen.c.\n *      (3) This runs about 2.5 times faster than the pixOrientDetect().\n */",
      "file" : "flipdetect.c"
   },
   {
      "function" : "pixOtsuAdaptiveThreshold",
      "comment" : "/*!\n *  pixOtsuAdaptiveThreshold()\n *\n *      Input:  pixs (8 bpp)\n *              sx, sy (desired tile dimensions; actual size may vary)\n *              smoothx, smoothy (half-width of convolution kernel applied to\n *                                threshold array: use 0 for no smoothing)\n *              scorefract (fraction of the max Otsu score; typ. 0.1;\n *                          use 0.0 for standard Otsu)\n *              &pixth (<optional return> array of threshold values\n *                      found for each tile)\n *              &pixd (<optional return> thresholded input pixs, based on\n *                     the threshold array)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The Otsu method finds a single global threshold for an image.\n *          This function allows a locally adapted threshold to be\n *          found for each tile into which the image is broken up.\n *      (2) The array of threshold values, one for each tile, constitutes\n *          a highly downscaled image.  This array is optionally\n *          smoothed using a convolution.  The full width and height of the\n *          convolution kernel are (2 * @smoothx + 1) and (2 * @smoothy + 1).\n *      (3) The minimum tile dimension allowed is 16.  If such small\n *          tiles are used, it is recommended to use smoothing, because\n *          without smoothing, each small tile determines the splitting\n *          threshold independently.  A tile that is entirely in the\n *          image bg will then hallucinate fg, resulting in a very noisy\n *          binarization.  The smoothing should be large enough that no\n *          tile is only influenced by one type (fg or bg) of pixels,\n *          because it will force a split of its pixels.\n *      (4) To get a single global threshold for the entire image, use\n *          input values of @sx and @sy that are larger than the image.\n *          For this situation, the smoothing parameters are ignored.\n *      (5) The threshold values partition the image pixels into two classes:\n *          one whose values are less than the threshold and another\n *          whose values are greater than or equal to the threshold.\n *          This is the same use of 'threshold' as in pixThresholdToBinary().\n *      (6) The scorefract is the fraction of the maximum Otsu score, which\n *          is used to determine the range over which the histogram minimum\n *          is searched.  See numaSplitDistribution() for details on the\n *          underlying method of choosing a threshold.\n *      (7) This uses enables a modified version of the Otsu criterion for\n *          splitting the distribution of pixels in each tile into a\n *          fg and bg part.  The modification consists of searching for\n *          a minimum in the histogram over a range of pixel values where\n *          the Otsu score is within a defined fraction, @scorefract,\n *          of the max score.  To get the original Otsu algorithm, set\n *          @scorefract == 0.\n */",
      "file" : "binarize.c"
   },
   {
      "function" : "pixOtsuThreshOnBackgroundNorm",
      "comment" : "/*!\n *  pixOtsuThreshOnBackgroundNorm()\n *\n *      Input:  pixs (8 bpp grayscale; not colormapped)\n *              pixim (<optional> 1 bpp 'image' mask; can be null)\n *              sx, sy (tile size in pixels)\n *              thresh (threshold for determining foreground)\n *              mincount (min threshold on counts in a tile)\n *              bgval (target bg val; typ. > 128)\n *              smoothx (half-width of block convolution kernel width)\n *              smoothy (half-width of block convolution kernel height)\n *              scorefract (fraction of the max Otsu score; typ. 0.1)\n *              &thresh (<optional return> threshold value that was\n *                       used on the normalized image)\n *      Return: pixd (1 bpp thresholded image), or null on error\n *\n *  Notes:\n *      (1) This does background normalization followed by Otsu\n *          thresholding.  Otsu binarization attempts to split the\n *          image into two roughly equal sets of pixels, and it does\n *          a very poor job when there are large amounts of dark\n *          background.  By doing a background normalization first,\n *          to get the background near 255, we remove this problem.\n *          Then we use a modified Otsu to estimate the best global\n *          threshold on the normalized image.\n *      (2) See pixBackgroundNorm() for meaning and typical values\n *          of input parameters.  For a start, you can try:\n *            sx, sy = 10, 15\n *            thresh = 100\n *            mincount = 50\n *            bgval = 255\n *            smoothx, smoothy = 2\n */",
      "file" : "binarize.c"
   },
   {
      "function" : "pixPaintBoxa",
      "comment" : "/*!\n *  pixPaintBoxa()\n *\n *      Input:  pixs (any depth, can be cmapped)\n *              boxa (of boxes, to paint)\n *              val (rgba color to paint)\n *      Return: pixd (with painted boxes), or null on error\n *\n *  Notes:\n *      (1) If pixs is 1 bpp or is colormapped, it is converted to 8 bpp\n *          and the boxa is painted using a colormap; otherwise,\n *          it is converted to 32 bpp rgb.\n *      (2) There are several ways to display a box on an image:\n *            * Paint it as a solid color\n *            * Draw the outline\n *            * Blend the outline or region with the existing image\n *          We provide painting and drawing here; blending is in blend.c.\n *          When painting or drawing, the result can be either a\n *          cmapped image or an rgb image.  The dest will be cmapped\n *          if the src is either 1 bpp or has a cmap that is not full.\n *          To force RGB output, use pixConvertTo8(pixs, FALSE)\n *          before calling any of these paint and draw functions.\n */",
      "file" : "boxfunc3.c"
   },
   {
      "function" : "pixPaintBoxaRandom",
      "comment" : "/*!\n *  pixPaintBoxaRandom()\n *\n *      Input:  pixs (any depth, can be cmapped)\n *              boxa (of boxes, to paint)\n *      Return: pixd (with painted boxes), or null on error\n *\n *  Notes:\n *      (1) If pixs is 1 bpp, we paint the boxa using a colormap;\n *          otherwise, we convert to 32 bpp.\n *      (2) We use up to 254 different colors for painting the regions.\n *      (3) If boxes overlap, the later ones paint over earlier ones.\n */",
      "file" : "boxfunc3.c"
   },
   {
      "function" : "pixPaintSelfThroughMask",
      "comment" : "/*!\n *  pixPaintSelfThroughMask()\n *\n *      Input:  pixd (8 bpp gray or 32 bpp rgb; not colormapped)\n *              pixm (1 bpp mask)\n *              x, y (origin of pixm relative to pixd; must not be negative)\n *              tilesize (requested size for tiling)\n *              searchdir (L_HORIZ, L_VERT)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) In-place operation; pixd is changed.\n *      (2) If pixm == NULL, it's a no-op.\n *      (3) The mask origin is placed at (x,y) on pixd, and the\n *          operation is clipped to the intersection of pixd and the\n *          fg of the mask.\n *      (4) The tilesize is the the requested size for tiling.  The\n *          actual size for each c.c. will be bounded by the minimum\n *          dimension of the c.c. and the distance at which the tile\n *          center is located.\n *      (5) searchdir is the direction with respect to the b.b. of each\n *          mask component, from which the square patch is chosen and\n *          tiled onto the image, clipped by the mask component.\n *      (6) Specifically, a mirrored tiling, generated from pixd,\n *          is used to construct the pixels that are painted onto\n *          pixd through pixm.\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixPaintThroughMask",
      "comment" : "/*!\n *  pixPaintThroughMask()\n *\n *      Input:  pixd (1, 2, 4, 8, 16 or 32 bpp; or colormapped)\n *              pixm (<optional> 1 bpp mask)\n *              x, y (origin of pixm relative to pixd; can be negative)\n *              val (pixel value to set at each masked pixel)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) In-place operation.  Calls pixSetMaskedCmap() for colormapped\n *          images.\n *      (2) For 1, 2, 4, 8 and 16 bpp gray, we take the appropriate\n *          number of least significant bits of val.\n *      (3) If pixm == NULL, it's a no-op.\n *      (4) The mask origin is placed at (x,y) on pixd, and the\n *          operation is clipped to the intersection of rectangles.\n *      (5) For rgb, the components in val are in the canonical locations,\n *          with red in location COLOR_RED, etc.\n *      (6) Implementation detail 1:\n *          For painting with val == 0 or val == maxval, you can use rasterop.\n *          If val == 0, invert the mask so that it's 0 over the region\n *          into which you want to write, and use PIX_SRC & PIX_DST to\n *          clear those pixels.  To write with val = maxval (all 1's),\n *          use PIX_SRC | PIX_DST to set all bits under the mask.\n *      (7) Implementation detail 2:\n *          The rasterop trick can be used for depth > 1 as well.\n *          For val == 0, generate the mask for depth d from the binary\n *          mask using\n *              pixmd = pixUnpackBinary(pixm, d, 1);\n *          and use pixRasterop() with PIX_MASK.  For val == maxval,\n *              pixmd = pixUnpackBinary(pixm, d, 0);\n *          and use pixRasterop() with PIX_PAINT.\n *          But note that if d == 32 bpp, it is about 3x faster to use\n *          the general implementation (not pixRasterop()).\n *      (8) Implementation detail 3:\n *          It might be expected that the switch in the inner loop will\n *          cause large branching delays and should be avoided.\n *          This is not the case, because the entrance is always the\n *          same and the compiler can correctly predict the jump.\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixPlotAlongPta",
      "comment" : "/*!\n *  pixPlotAlongPta()\n *\n *      Input: pixs (any depth)\n *             pta (set of points on which to plot)\n *             outformat (GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_X11,\n *                        GPLOT_LATEX)\n *             title (<optional> for plot; can be null)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) We remove any existing colormap and clip the pta to the input pixs.\n *      (2) This is a debugging function, and does not remove temporary\n *          plotting files that it generates.\n *      (3) If the image is RGB, three separate plots are generated.\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "pixPrintStreamInfo",
      "comment" : "/*!\n *  pixPrintStreamInfo()\n *\n *      Input:  fp (file stream)\n *              pix\n *              text (<optional> identifying string; can be null)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixProcessBarcodes",
      "comment" : "/*!\n *  pixProcessBarcodes()\n *\n *      Input:  pixs (any depth)\n *              format (L_BF_ANY, L_BF_CODEI2OF5, L_BF_CODE93, ...)\n *              method (L_USE_WIDTHS, L_USE_WINDOWS)\n *              &saw (<optional return> sarray of bar widths)\n *              debugflag (use 1 to generate debug output)\n *      Return: sarray (text of barcodes), or null if none found or on error\n */",
      "file" : "readbarcode.c"
   },
   {
      "function" : "pixProjective",
      "comment" : "/*!\n *  pixProjective()\n *\n *      Input:  pixs (all depths; colormap ok)\n *              vc  (vector of 8 coefficients for projective transformation)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Brings in either black or white pixels from the boundary\n *      (2) Removes any existing colormap, if necessary, before transforming\n */",
      "file" : "projective.c"
   },
   {
      "function" : "pixProjectiveColor",
      "comment" : "/*!\n *  pixProjectiveColor()\n *\n *      Input:  pixs (32 bpp)\n *              vc  (vector of 8 coefficients for projective transformation)\n *              colorval (e.g., 0 to bring in BLACK, 0xffffff00 for WHITE)\n *      Return: pixd, or null on error\n */",
      "file" : "projective.c"
   },
   {
      "function" : "pixProjectiveGray",
      "comment" : "/*!\n *  pixProjectiveGray()\n *\n *      Input:  pixs (8 bpp)\n *              vc  (vector of 8 coefficients for projective transformation)\n *              grayval (0 to bring in BLACK, 255 for WHITE)\n *      Return: pixd, or null on error\n */",
      "file" : "projective.c"
   },
   {
      "function" : "pixProjectivePta",
      "comment" : "/*!\n *  pixProjectivePta()\n *\n *      Input:  pixs (all depths; colormap ok)\n *              ptad  (4 pts of final coordinate space)\n *              ptas  (4 pts of initial coordinate space)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Brings in either black or white pixels from the boundary\n *      (2) Removes any existing colormap, if necessary, before transforming\n */",
      "file" : "projective.c"
   },
   {
      "function" : "pixProjectivePtaColor",
      "comment" : "/*!\n *  pixProjectivePtaColor()\n *\n *      Input:  pixs (32 bpp)\n *              ptad  (4 pts of final coordinate space)\n *              ptas  (4 pts of initial coordinate space)\n *              colorval (e.g., 0 to bring in BLACK, 0xffffff00 for WHITE)\n *      Return: pixd, or null on error\n */",
      "file" : "projective.c"
   },
   {
      "function" : "pixProjectivePtaGray",
      "comment" : "/*!\n *  pixProjectivePtaGray()\n *\n *      Input:  pixs (8 bpp)\n *              ptad  (4 pts of final coordinate space)\n *              ptas  (4 pts of initial coordinate space)\n *              grayval (0 to bring in BLACK, 255 for WHITE)\n *      Return: pixd, or null on error\n */",
      "file" : "projective.c"
   },
   {
      "function" : "pixProjectivePtaWithAlpha",
      "comment" : "/*!\n *  pixProjectivePtaWithAlpha()\n *\n *      Input:  pixs (32 bpp rgb)\n *              ptad  (4 pts of final coordinate space)\n *              ptas  (4 pts of initial coordinate space)\n *              pixg (<optional> 8 bpp, for alpha channel, can be null)\n *              fract (between 0.0 and 1.0, with 0.0 fully transparent\n *                     and 1.0 fully opaque)\n *              border (of pixels added to capture transformed source pixels)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) The alpha channel is transformed separately from pixs,\n *          and aligns with it, being fully transparent outside the\n *          boundary of the transformed pixs.  For pixels that are fully\n *          transparent, a blending function like pixBlendWithGrayMask()\n *          will give zero weight to corresponding pixels in pixs.\n *      (2) If pixg is NULL, it is generated as an alpha layer that is\n *          partially opaque, using @fract.  Otherwise, it is cropped\n *          to pixs if required and @fract is ignored.  The alpha channel\n *          in pixs is never used.\n *      (3) Colormaps are removed.\n *      (4) When pixs is transformed, it doesn't matter what color is brought\n *          in because the alpha channel will be transparent (0) there.\n *      (5) To avoid losing source pixels in the destination, it may be\n *          necessary to add a border to the source pix before doing\n *          the projective transformation.  This can be any non-negative\n *          number.\n *      (6) The input @ptad and @ptas are in a coordinate space before\n *          the border is added.  Internally, we compensate for this\n *          before doing the projective transform on the image after\n *          the border is added.\n *      (7) The default setting for the border values in the alpha channel\n *          is 0 (transparent) for the outermost ring of pixels and\n *          (0.5 * fract * 255) for the second ring.  When blended over\n *          a second image, this\n *          (a) shrinks the visible image to make a clean overlap edge\n *              with an image below, and\n *          (b) softens the edges by weakening the aliasing there.\n *          Use l_setAlphaMaskBorder() to change these values.\n *      (8) A subtle use of gamma correction is to remove gamma correction\n *          before scaling and restore it afterwards.  This is done\n *          by sandwiching this function between a gamma/inverse-gamma\n *          photometric transform:\n *              pixt = pixGammaTRCWithAlpha(NULL, pixs, 1.0 / gamma, 0, 255);\n *              pixd = pixProjectivePtaWithAlpha(pixt, ptad, ptas,\n *                                               NULL, fract, border);\n *              pixGammaTRCWithAlpha(pixd, pixd, gamma, 0, 255);\n *              pixDestroy(&pixt);\n *          This has the side-effect of producing artifacts in the very\n *          dark regions.\n */",
      "file" : "projective.c"
   },
   {
      "function" : "pixProjectiveSampled",
      "comment" : "/*!\n *  pixProjectiveSampled()\n *\n *      Input:  pixs (all depths)\n *              vc  (vector of 8 coefficients for projective transformation)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Brings in either black or white pixels from the boundary.\n *      (2) Retains colormap, which you can do for a sampled transform..\n *      (3) For 8 or 32 bpp, much better quality is obtained by the\n *          somewhat slower pixProjective().  See that function\n *          for relative timings between sampled and interpolated.\n */",
      "file" : "projective.c"
   },
   {
      "function" : "pixProjectiveSampledPta",
      "comment" : "/*!\n *  pixProjectiveSampledPta()\n *\n *      Input:  pixs (all depths)\n *              ptad  (4 pts of final coordinate space)\n *              ptas  (4 pts of initial coordinate space)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Brings in either black or white pixels from the boundary.\n *      (2) Retains colormap, which you can do for a sampled transform..\n *      (3) No 3 of the 4 points may be collinear.\n *      (4) For 8 and 32 bpp pix, better quality is obtained by the\n *          somewhat slower pixProjectivePta().  See that\n *          function for relative timings between sampled and interpolated.\n */",
      "file" : "projective.c"
   },
   {
      "function" : "pixQuadraticVShear",
      "comment" : "/*!\n *  pixQuadraticVShear()\n *\n *      Input:  pixs (1, 8 or 32 bpp)\n *              dir (L_WARP_TO_LEFT or L_WARP_TO_RIGHT)\n *              vmaxt (max vertical displacement at edge and at top)\n *              vmaxb (max vertical displacement at edge and at bottom)\n *              operation (L_SAMPLED or L_INTERPOLATED)\n *              incolor (L_BRING_IN_WHITE or L_BRING_IN_BLACK)\n *      Return: pixd (stretched), or null on error\n *\n *  Notes:\n *      (1) This gives a quadratic bending, upward or downward, as you\n *          move to the left or right.\n *      (2) If @dir == L_WARP_TO_LEFT, the right edge is unchanged, and\n *          the left edge pixels are moved maximally up or down.\n *      (3) Parameters @vmaxt and @vmaxb control the maximum amount of\n *          vertical pixel shear at the top and bottom, respectively.\n *          If @vmaxt > 0, the vertical displacement of pixels at the\n *          top is downward.  Likewise, if @vmaxb > 0, the vertical\n *          displacement of pixels at the bottom is downward.\n *      (4) If @operation == L_SAMPLED, the dest pixels are taken from\n *          the nearest src pixel.  Otherwise, we use linear interpolation\n *          between pairs of sampled pixels.\n *      (5) This is for quadratic shear.  For uniform (linear) shear,\n *          use the standard shear operators.\n */",
      "file" : "warper.c"
   },
   {
      "function" : "pixQuadraticVShearLI",
      "comment" : "/*!\n *  pixQuadraticVShearLI()\n *\n *      Input:  pixs (8 or 32 bpp, or colormapped)\n *              dir (L_WARP_TO_LEFT or L_WARP_TO_RIGHT)\n *              vmaxt (max vertical displacement at edge and at top)\n *              vmaxb (max vertical displacement at edge and at bottom)\n *              incolor (L_BRING_IN_WHITE or L_BRING_IN_BLACK)\n *      Return: pixd (stretched), or null on error\n *\n *  Notes:\n *      (1) See pixQuadraticVShear() for details.\n */",
      "file" : "warper.c"
   },
   {
      "function" : "pixQuadraticVShearSampled",
      "comment" : "/*!\n *  pixQuadraticVShearSampled()\n *\n *      Input:  pixs (1, 8 or 32 bpp)\n *              dir (L_WARP_TO_LEFT or L_WARP_TO_RIGHT)\n *              vmaxt (max vertical displacement at edge and at top)\n *              vmaxb (max vertical displacement at edge and at bottom)\n *              incolor (L_BRING_IN_WHITE or L_BRING_IN_BLACK)\n *      Return: pixd (stretched), or null on error\n *\n *  Notes:\n *      (1) See pixQuadraticVShear() for details.\n */",
      "file" : "warper.c"
   },
   {
      "function" : "pixQuadtreeMean",
      "comment" : "/*!\n *  pixQuadtreeMean()\n *\n *      Input:  pixs (8 bpp, no colormap)\n *              nlevels (in quadtree; max allowed depends on image size)\n *             *pix_ma (input mean accumulator; can be null)\n *             *pfpixa (<return> mean values in quadtree)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The returned fpixa has @nlevels of fpix, each containing\n *          the mean values at its level.  Level 0 has a\n *          single value; level 1 has 4 values; level 2 has 16; etc.\n */",
      "file" : "quadtree.c"
   },
   {
      "function" : "pixQuadtreeVariance",
      "comment" : "/*!\n *  pixQuadtreeVariance()\n *\n *      Input:  pixs (8 bpp, no colormap)\n *              nlevels (in quadtree)\n *             *pix_ma (input mean accumulator; can be null)\n *             *dpix_msa (input mean square accumulator; can be null)\n *             *pfpixa_v (<optional return> variance values in quadtree)\n *             *pfpixa_rv (<optional return> root variance values in quadtree)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The returned fpixav and fpixarv have @nlevels of fpix,\n *          each containing at the respective levels the variance\n *          and root variance values.\n */",
      "file" : "quadtree.c"
   },
   {
      "function" : "pixQualifyLocalMinima",
      "comment" : "/*!\n *  pixQualifyLocalMinima()\n *\n *      Input:  pixs  (8 bpp image from which pixm has been extracted)\n *              pixm  (1 bpp mask of values equal to min in 3x3 neighborhood)\n *              maxval (max allowed for the min in a 3x3 neighborhood;\n *                      use 0 for default which is to have no upper bound)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This function acts in-place to remove all c.c. in pixm\n *          that are not true local minima in pixs.  As seen in\n *          pixLocalExtrema(), the input pixm are found by selecting those\n *          pixels of pixs whose values do not change with a 3x3\n *          grayscale erosion.  Here, we require that for each c.c.\n *          in pixm, all pixels in pixs that correspond to the exterior\n *          boundary pixels of the c.c. have values that are greater\n *          than the value within the c.c.\n *      (2) The maximum allowed value for each local minimum can be\n *          bounded with @maxval.  Use 0 for default, which is to have\n *          no upper bound (equivalent to maxval == 254).\n */",
      "file" : "seedfill.c"
   },
   {
      "function" : "pixQuantFromCmap",
      "comment" : "/*!\n *  pixQuantFromCmap()\n *\n *      Input:  pixs  (8 bpp grayscale without cmap, or 32 bpp rgb)\n *              cmap  (to quantize to; insert copy into dest pix)\n *              mindepth (minimum depth of pixd: can be 2, 4 or 8 bpp)\n *              level (of octcube used for finding nearest color in cmap)\n *              metric (L_MANHATTAN_DISTANCE, L_EUCLIDEAN_DISTANCE)\n *      Return: pixd  (2, 4 or 8 bpp, colormapped), or null on error\n *\n *  Notes:\n *      (1) This is a top-level wrapper for quantizing either grayscale\n *          or rgb images to a specified colormap.\n *      (2) The actual output depth is constrained by @mindepth and\n *          by the number of colors in @cmap.\n *      (3) For grayscale, @level and @metric are ignored.\n *      (4) If the cmap has color and pixs is grayscale, the color is\n *          removed from the cmap before quantizing pixs.\n */",
      "file" : "colorquant1.c"
   },
   {
      "function" : "pixQuantizeIfFewColors",
      "comment" : "/*!\n *  pixQuantizeIfFewColors()\n *\n *      Input:  pixs (8 bpp gray or 32 bpp rgb)\n *              maxcolors (max number of colors allowed to be returned\n *                         from pixColorsForQuantization(); use 0 for default)\n *              mingraycolors (min number of gray levels that a grayscale\n *                             image is quantized to; use 0 for default)\n *              octlevel (for octcube quantization: 3 or 4)\n *              &pixd (2, 4 or 8 bpp quantized; null if too many colors)\n *      Return: 0 if OK, 1 on error or if pixs can't be quantized into\n *              a small number of colors.\n *\n *  Notes:\n *      (1) This is a wrapper that tests if the pix can be quantized\n *          with good quality using a small number of colors.  If so,\n *          it does the quantization, defining a colormap and using\n *          pixels whose value is an index into the colormap.\n *      (2) If the image has color, it is quantized with 8 bpp pixels.\n *          If the image is essentially grayscale, the pixels are\n *          either 4 or 8 bpp, depending on the size of the required\n *          colormap.\n *      (3) @octlevel = 3 works well for most images.  However, for best\n *          quality, at a cost of more colors in the colormap, use\n *          @octlevel = 4.\n *      (4) If the image already has a colormap, it returns a clone.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixQuantizeWithColormap",
      "comment" : "/*!\n *  pixQuantizeWithColormap()\n *\n *      Input:  pixs  (32 bpp; rgb color)\n *              ditherflag (1 for dither; 0 for no dither)\n *              outdepth\n *              cmap\n *              indexmap\n *              histosize\n *              sigbits\n *      Return: pixd (quantized to colormap), or null on error\n *\n *  Notes:\n *      (1) The indexmap is a LUT that takes the rgb indices of the\n *          pixel and returns the index into the colormap.\n *      (2) If ditherflag is 1, @outdepth is ignored and the output\n *          depth is set to 8.\n */",
      "file" : "colorquant2.c"
   },
   {
      "function" : "pixRandomHarmonicWarp",
      "comment" : "/*!\n *  pixRandomHarmonicWarp()\n *\n *      Input:  pixs (8 bpp; no colormap)\n *              xmag, ymag (maximum magnitude of x and y distortion)\n *              xfreq, yfreq (maximum magnitude of x and y frequency)\n *              nx, ny (number of x and y harmonic terms)\n *              seed (of random number generator)\n *              grayval (color brought in from the outside;\n *                       0 for black, 255 for white)\n *      Return: pixd (8 bpp; no colormap), or null on error\n *\n *  Notes:\n *      (1) To generate the warped image p(x',y'), set up the transforms\n *          that are in getWarpTransform().  For each (x',y') in the\n *          dest, the warp function computes the originating location\n *          (x, y) in the src.  The differences (x - x') and (y - y')\n *          are given as a sum of products of sinusoidal terms.  Each\n *          term is multiplied by a maximum amplitude (in pixels), and the\n *          angle is determined by a frequency and phase, and depends\n *          on the (x', y') value of the dest.  Random numbers with\n *          a variable input seed are used to allow the warping to be\n *          unpredictable.  A linear interpolation is used to find\n *          the value for the source at (x, y); this value is written\n *          into the dest.\n *      (2) This can be used to generate 'captcha's, which are somewhat\n *          randomly distorted images of text.  A typical set of parameters\n *          for a captcha are:\n *                    xmag = 4.0     ymag = 6.0\n *                    xfreq = 0.10   yfreq = 0.13\n *                    nx = 3         ny = 3\n *          Other examples can be found in prog/warptest.c.\n */",
      "file" : "warper.c"
   },
   {
      "function" : "pixRandomHarmonicWarpLUT",
      "comment" : "/*!\n *  pixRandomHarmonicWarpLUT()\n *\n *      Input:  pixs (8 bpp; no colormap)\n *              xmag, ymag (maximum magnitude of x and y distortion)\n *              xfreq, yfreq (maximum magnitude of x and y frequency)\n *              nx, ny (number of x and y harmonic terms)\n *              seed (of random number generator)\n *              grayval (color brought in from the outside;\n *                       0 for black, 255 for white)\n *      Return: pixd (8 bpp; no colormap), or null on error\n *\n *  Notes:\n *      (1) See notes and inline comments in pixRandomHarmonicWarp().\n *          This version uses a LUT for the sin function.  It is not\n *          appreciably faster than using the built-in sin function,\n *          and is here for comparison only.\n */",
      "file" : "warper.c"
   },
   {
      "function" : "pixRankColumnTransform",
      "comment" : "/*!\n *  pixRankColumnTransform()\n *\n *      Input:  pixs (8 bpp; no colormap)\n *      Return: pixd (with pixels sorted in each column, from\n *                    min to max value)\n *\n * Notes:\n *     (1) The time is O(n) in the number of pixels and runs about\n *         50 Mpixels/sec on a 3 GHz machine.\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixRankFilter",
      "comment" : "/*!\n *  pixRankFilter()\n *\n *      Input:  pixs (8 or 32 bpp; no colormap)\n *              wf, hf  (width and height of filter; each is >= 1)\n *              rank (in [0.0 ... 1.0])\n *      Return: pixd (of rank values), or null on error\n *\n *  Notes:\n *      (1) This defines, for each pixel in pixs, a neighborhood of\n *          pixels given by a rectangle \"centered\" on the pixel.\n *          This set of wf*hf pixels has a distribution of values.\n *          For each component, if the values are sorted in increasing\n *          order, we choose the component such that rank*(wf*hf-1)\n *          pixels have a lower or equal value and\n *          (1-rank)*(wf*hf-1) pixels have an equal or greater value.\n *      (2) See notes in pixRankFilterGray() for further details.\n */",
      "file" : "rank.c"
   },
   {
      "function" : "pixRankFilterGray",
      "comment" : "/*!\n *  pixRankFilterGray()\n *\n *      Input:  pixs (8 bpp; no colormap)\n *              wf, hf  (width and height of filter; each is >= 1)\n *              rank (in [0.0 ... 1.0])\n *      Return: pixd (of rank values), or null on error\n *\n *  Notes:\n *      (1) This defines, for each pixel in pixs, a neighborhood of\n *          pixels given by a rectangle \"centered\" on the pixel.\n *          This set of wf*hf pixels has a distribution of values,\n *          and if they are sorted in increasing order, we choose\n *          the pixel such that rank*(wf*hf-1) pixels have a lower\n *          or equal value and (1-rank)*(wf*hf-1) pixels have an equal\n *          or greater value.\n *      (2) By this definition, the rank = 0.0 pixel has the lowest\n *          value, and the rank = 1.0 pixel has the highest value.\n *      (3) We add mirrored boundary pixels to avoid boundary effects,\n *          and put the filter center at (0, 0).\n *      (4) This dispatches to grayscale erosion or dilation if the\n *          filter dimensions are odd and the rank is 0.0 or 1.0, rsp.\n *      (5) Returns a copy if both wf and hf are 1.\n *      (6) Uses row-major or column-major incremental updates to the\n *          histograms depending on whether hf > wf or hv <= wf, rsp.\n */",
      "file" : "rank.c"
   },
   {
      "function" : "pixRankFilterRGB",
      "comment" : "/*!\n *  pixRankFilterRGB()\n *\n *      Input:  pixs (32 bpp)\n *              wf, hf  (width and height of filter; each is >= 1)\n *              rank (in [0.0 ... 1.0])\n *      Return: pixd (of rank values), or null on error\n *\n *  Notes:\n *      (1) This defines, for each pixel in pixs, a neighborhood of\n *          pixels given by a rectangle \"centered\" on the pixel.\n *          This set of wf*hf pixels has a distribution of values.\n *          For each component, if the values are sorted in increasing\n *          order, we choose the component such that rank*(wf*hf-1)\n *          pixels have a lower or equal value and\n *          (1-rank)*(wf*hf-1) pixels have an equal or greater value.\n *      (2) Apply gray rank filtering to each component independently.\n *      (3) See notes in pixRankFilterGray() for further details.\n */",
      "file" : "rank.c"
   },
   {
      "function" : "pixRankFilterWithScaling",
      "comment" : "/*!\n *  pixRankFilterWithScaling()\n *\n *      Input:  pixs (8 or 32 bpp; no colormap)\n *              wf, hf  (width and height of filter; each is >= 1)\n *              rank (in [0.0 ... 1.0])\n *              scalefactor (scale factor; must be >= 0.2 and <= 0.7)\n *      Return: pixd (of rank values), or null on error\n *\n *  Notes:\n *      (1) This is a convenience function that downscales, does\n *          the rank filtering, and upscales.  Because the down-\n *          and up-scaling functions are very fast compared to\n *          rank filtering, the time it takes is reduced from that\n *          for the simple rank filtering operation by approximately\n *          the square of the scaling factor.\n */",
      "file" : "rank.c"
   },
   {
      "function" : "pixRankHaustest",
      "comment" : "/*!\n *  pixRankHaustest()\n *\n *      Input:  pix1   (new pix, not dilated)\n *              pix2   (new pix, dilated)\n *              pix3   (exemplar pix, not dilated)\n *              pix4   (exemplar pix, dilated)\n *              delx   (x comp of centroid difference)\n *              dely   (y comp of centroid difference)\n *              maxdiffw (max width difference of pix1 and pix2)\n *              maxdiffh (max height difference of pix1 and pix2)\n *              area1  (fg pixels in pix1)\n *              area3  (fg pixels in pix3)\n *              rank   (rank value of test, each way)\n *              tab8   (table of pixel sums for byte)\n *      Return: 0 (FALSE) if no match, 1 (TRUE) if the new\n *                 pix is in the same class as the exemplar.\n *\n *  Note: we check first that the two pix are roughly\n *  the same size.  Only if they meet that criterion do\n *  we compare the bitmaps.  We convert the rank value to\n *  a number of pixels by multiplying the rank fraction by the number\n *  of pixels in the undilated image.  The Hausdorff is a 2-way\n *  check.  The centroid difference is used to align the two\n *  images to the nearest integer for each of the checks.\n *  The rank hausdorff checks that the dilated image of one\n *  contains the rank fraction of the pixels of the undilated\n *  image of the other.   Checks are done in both direction.\n *  Failure of the test in either direction results in failure\n *  of the test.\n */",
      "file" : "jbclass.c"
   },
   {
      "function" : "pixRankRowTransform",
      "comment" : "/*!\n *  pixRankRowTransform()\n *\n *      Input:  pixs (8 bpp; no colormap)\n *      Return: pixd (with pixels sorted in each row, from\n *                    min to max value)\n *\n * Notes:\n *     (1) The time is O(n) in the number of pixels and runs about\n *         100 Mpixels/sec on a 3 GHz machine.\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixRasterop",
      "comment" : "/*!\n *  pixRasterop()\n *\n *      Input:  pixd   (dest pix)\n *              dx     (x val of UL corner of dest rectangle)\n *              dy     (y val of UL corner of dest rectangle)\n *              dw     (width of dest rectangle)\n *              dh     (height of dest rectangle)\n *              op     (op code)\n *              pixs   (src pix)\n *              sx     (x val of UL corner of src rectangle)\n *              sy     (y val of UL corner of src rectangle)\n *      Return: 0 if OK; 1 on error.\n *\n *  Notes:\n *      (1) This has the standard set of 9 args for rasterop.\n *          This function is your friend; it is worth memorizing!\n *      (2) If the operation involves only dest, this calls\n *          rasteropUniLow().  Otherwise, checks depth of the\n *          src and dest, and if they match, calls rasteropLow().\n *      (3) For the two-image operation, where both pixs and pixd\n *          are defined, they are typically different images.  However\n *          there are cases, such as pixSetMirroredBorder(), where\n *          in-place operations can be done, blitting pixels from\n *          one part of pixd to another.  Consequently, we permit\n *          such operations.  If you use them, be sure that there\n *          is no overlap between the source and destination rectangles\n *          in pixd (!)\n *\n *  Background:\n *  -----------\n *\n *  There are 18 operations, described by the op codes in pix.h.\n *\n *  One, PIX_DST, is a no-op.\n *\n *  Three, PIX_CLR, PIX_SET, and PIX_NOT(PIX_DST) operate only on the dest.\n *  These are handled by the low-level rasteropUniLow().\n *\n *  The other 14 involve the both the src and the dest, and depend on\n *  the bit values of either just the src or the bit values of both\n *  src and dest.  They are handled by rasteropLow():\n *\n *          PIX_SRC                             s\n *          PIX_NOT(PIX_SRC)                   ~s\n *          PIX_SRC | PIX_DST                   s | d\n *          PIX_SRC & PIX_DST                   s & d\n *          PIX_SRC ^ PIX_DST                   s ^ d\n *          PIX_NOT(PIX_SRC) | PIX_DST         ~s | d\n *          PIX_NOT(PIX_SRC) & PIX_DST         ~s & d\n *          PIX_NOT(PIX_SRC) ^ PIX_DST         ~s ^ d\n *          PIX_SRC | PIX_NOT(PIX_DST)          s | ~d\n *          PIX_SRC & PIX_NOT(PIX_DST)          s & ~d\n *          PIX_SRC ^ PIX_NOT(PIX_DST)          s ^ ~d\n *          PIX_NOT(PIX_SRC | PIX_DST)         ~(s | d)\n *          PIX_NOT(PIX_SRC & PIX_DST)         ~(s & d)\n *          PIX_NOT(PIX_SRC ^ PIX_DST)         ~(s ^ d)\n *\n *  Each of these is implemented with one of three low-level\n *  functions, depending on the alignment of the left edge\n *  of the src and dest rectangles:\n *      * a fastest implementation if both left edges are\n *        (32-bit) word aligned\n *      * a very slightly slower implementation if both left\n *        edges have the same relative (32-bit) word alignment\n *      * the general routine that is invoked when\n *        both left edges have different word alignment\n *\n *  Of the 14 binary rasterops above, only 12 are unique\n *  logical combinations (out of a possible 16) of src\n *  and dst bits:\n *\n *        (sd)         (11)   (10)   (01)   (00)\n *   -----------------------------------------------\n *         s            1      1      0      0\n *        ~s            0      1      0      1\n *       s | d          1      1      1      0\n *       s & d          1      0      0      0\n *       s ^ d          0      1      1      0\n *      ~s | d          1      0      1      1\n *      ~s & d          0      0      1      0\n *      ~s ^ d          1      0      0      1\n *       s | ~d         1      1      0      1\n *       s & ~d         0      1      0      0\n *       s ^ ~d         1      0      0      1\n *      ~(s | d)        0      0      0      1\n *      ~(s & d)        0      1      1      1\n *      ~(s ^ d)        1      0      0      1\n *\n *  Note that the following three operations are equivalent:\n *      ~(s ^ d)\n *      ~s ^ d\n *      s ^ ~d\n *  and in the implementation, we call them out with the first form;\n *  namely, ~(s ^ d).\n *\n *  Of the 16 possible binary combinations of src and dest bits,\n *  the remaining 4 unique ones are independent of the src bit.\n *  They depend on either just the dest bit or on neither\n *  the src nor dest bits:\n *\n *         d            1      0      1      0    (indep. of s)\n *        ~d            0      1      0      1    (indep. of s)\n *        CLR           0      0      0      0    (indep. of both s & d)\n *        SET           1      1      1      1    (indep. of both s & d)\n *\n *  As mentioned above, three of these are implemented by\n *  rasteropUniLow(), and one is a no-op.\n *\n *  How can these operation codes be represented by bits\n *  in such a way that when the basic operations are performed\n *  on the bits the results are unique for unique\n *  operations, and mimic the logic table given above?\n *\n *  The answer is to choose a particular order of the pairings:\n *         (sd)         (11)   (10)   (01)   (00)\n *  (which happens to be the same as in the above table)\n *  and to translate the result into 4-bit representations\n *  of s and d.  For example, the Sun rasterop choice\n *  (omitting the extra bit for clipping) is\n *\n *      PIX_SRC      0xc\n *      PIX_DST      0xa\n *\n *  This corresponds to our pairing order given above:\n *         (sd)         (11)   (10)   (01)   (00)\n *  where for s = 1 we get the bit pattern\n *       PIX_SRC:        1      1      0      0     (0xc)\n *  and for d = 1 we get the pattern\n *       PIX_DST:         1      0      1      0    (0xa)\n *\n *  OK, that's the pairing order that Sun chose.  How many different\n *  ways can we assign bit patterns to PIX_SRC and PIX_DST to get\n *  the boolean ops to work out?  Any of the 4 pairs can be put\n *  in the first position, any of the remaining 3 pairs can go\n *  in the second; and one of the remaining 2 pairs can go the the third.\n *  There is a total of 4*3*2 = 24 ways these pairs can be permuted.\n */",
      "file" : "rop.c"
   },
   {
      "function" : "pixRasteropFullImage",
      "comment" : "/*!\n *  pixRasteropFullImage()\n *\n *      Input:  pixd\n *              pixs\n *              op (any of the op-codes)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      - this is a wrapper for a common 2-image raster operation\n *      - both pixs and pixd must be defined\n *      - the operation is performed with aligned UL corners of pixs and pixd\n *      - the operation clips to the smallest pix; if the width or height\n *        of pixd is larger than pixs, some pixels in pixd will be unchanged\n */",
      "file" : "rop.c"
   },
   {
      "function" : "pixRasteropHip",
      "comment" : "/*!\n *  pixRasteropHip()\n *\n *      Input:  pixd (in-place operation)\n *              by  (top of horizontal band)\n *              bh  (height of horizontal band)\n *              hshift (horizontal shift of band; hshift > 0 is to right)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This rasterop translates a horizontal band of the\n *          image either left or right, bringing in either white\n *          or black pixels from outside the image.\n *      (2) The horizontal band extends the full width of pixd.\n *      (3) If a colormap exists, the nearest color to white or black\n *          is brought in.\n */",
      "file" : "rop.c"
   },
   {
      "function" : "pixRasteropIP",
      "comment" : "/*!\n *  pixRasteropIP()\n *\n *      Input:  pixd (in-place translation)\n *              hshift (horizontal shift; hshift > 0 is to right)\n *              vshift (vertical shift; vshift > 0 is down)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "rop.c"
   },
   {
      "function" : "pixRasteropVip",
      "comment" : "/*!\n *  pixRasteropVip()\n *\n *      Input:  pixd (in-place)\n *              bx  (left edge of vertical band)\n *              bw  (width of vertical band)\n *              vshift (vertical shift of band; vshift > 0 is down)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This rasterop translates a vertical band of the\n *          image either up or down, bringing in either white\n *          or black pixels from outside the image.\n *      (2) The vertical band extends the full height of pixd.\n *      (3) If a colormap exists, the nearest color to white or black\n *          is brought in.\n */",
      "file" : "rop.c"
   },
   {
      "function" : "pixRead",
      "comment" : "/*!\n *  pixRead()\n *\n *      Input:  filename (with full pathname or in local directory)\n *      Return: pix if OK; null on error\n *\n *  Notes:\n *      (1) See at top of file for supported formats.\n */",
      "file" : "readfile.c"
   },
   {
      "function" : "pixReadBarcodeWidths",
      "comment" : "/*!\n *  pixReadBarcodeWidths()\n *\n *      Input:  pixs (of 8 bpp deskewed and cropped barcode)\n *              method (L_USE_WIDTHS, L_USE_WINDOWS);\n *              debugflag (use 1 to generate debug output)\n *      Return: na (numa of widths (each in set {1,2,3,4}), or null on error\n */",
      "file" : "readbarcode.c"
   },
   {
      "function" : "pixReadBarcodes",
      "comment" : "/*!\n *  pixReadBarcodes()\n *\n *      Input:  pixa (of 8 bpp deskewed and cropped barcodes)\n *              format (L_BF_ANY, L_BF_CODEI2OF5, L_BF_CODE93, ...)\n *              method (L_USE_WIDTHS, L_USE_WINDOWS);\n *              &saw (<optional return> sarray of bar widths)\n *              debugflag (use 1 to generate debug output)\n *      Return: sa (sarray of widths, one string for each barcode found),\n *                  or null on error\n */",
      "file" : "readbarcode.c"
   },
   {
      "function" : "pixReadFromTiffStream",
      "comment" : "/*!\n *  pixReadFromTiffStream()\n *\n *      Input:  stream\n *      Return: pix, or null on error\n *\n *  Notes:\n *      (1) We handle pixels up to 32 bits.  This includes:\n *          1 spp (grayscale): 1, 2, 4, 8, 16 bpp\n *          1 spp (colormapped): 1, 2, 4, 8 bpp\n *          3 spp (color): 8 bpp\n *          We do not handle 3 spp, 16 bpp (48 bits/pixel)\n *      (2) For colormapped images, we support 8 bits/color in the palette.\n *          Tiff colormaps have 16 bits/color, and we reduce them to 8.\n *      (3) Quoting the libtiff documenation at\n *               http://libtiff.maptools.org/libtiff.html\n *          \"libtiff provides a high-level interface for reading image data\n *          from a TIFF file. This interface handles the details of data\n *          organization and format for a wide variety of TIFF files;\n *          at least the large majority of those files that one would\n *          normally encounter. Image data is, by default, returned as\n *          ABGR pixels packed into 32-bit words (8 bits per sample).\n *          Rectangular rasters can be read or data can be intercepted\n *          at an intermediate level and packed into memory in a format\n *          more suitable to the application. The library handles all\n *          the details of the format of data stored on disk and,\n *          in most cases, if any colorspace conversions are required:\n *          bilevel to RGB, greyscale to RGB, CMYK to RGB, YCbCr to RGB,\n *          16-bit samples to 8-bit samples, associated/unassociated alpha,\n *          etc.\"\n */",
      "file" : "tiffio.c"
   },
   {
      "function" : "pixReadHeader",
      "comment" : "/*!\n *  pixReadHeader()\n *\n *      Input:  filename (with full pathname or in local directory)\n *              &format (<optional return> file format)\n *              &w, &h (<optional returns> width and height)\n *              &bps <optional return> bits/sample\n *              &spp <optional return> samples/pixel (1, 3 or 4)\n *              &iscmap (<optional return> 1 if cmap exists; 0 otherwise)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This reads the actual headers for jpeg, png, tiff and pnm.\n *          For bmp and gif, we cheat and read the entire file into a pix,\n *          from which we extract the \"header\" information.\n */",
      "file" : "readfile.c"
   },
   {
      "function" : "pixReadHeaderMem",
      "comment" : "/*!\n *  pixReadHeaderMem()\n *\n *      Input:  data (const; encoded)\n *              datasize (size of data)\n *              &format (<optional returns> image format)\n *              &w, &h (<optional returns> width and height)\n *              &bps <optional return> bits/sample\n *              &spp <optional return> samples/pixel (1, 3 or 4)\n *              &iscmap (<optional return> 1 if cmap exists; 0 otherwise)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This reads the actual headers for jpeg, png, tiff and pnm.\n *          For bmp and gif, we cheat and read all the data into a pix,\n *          from which we extract the \"header\" information.\n *      (2) On windows, this will only read tiff formatted files from\n *          memory.  For other formats, it requires fmemopen(3).\n *          Attempts to read those formats will fail at runtime.\n *      (3) findFileFormatBuffer() requires up to 8 bytes to decide on\n *          the format.  That determines the constraint here.\n */",
      "file" : "readfile.c"
   },
   {
      "function" : "pixReadIndexed",
      "comment" : "/*!\n *  pixReadIndexed()\n *\n *      Input:  sarray (of full pathnames)\n *              index (into pathname array)\n *      Return: pix if OK; null if not found\n *\n *  Notes:\n *      (1) This function is useful for selecting image files from a\n *          directory, where the integer @index is embedded into\n *          the file name.\n *      (2) This is typically done by generating the sarray using\n *          getNumberedPathnamesInDirectory(), so that the @index\n *          pathname would have the number @index in it.  The size\n *          of the sarray should be the largest number (plus 1) appearing\n *          in the file names, respecting the constraints in the\n *          call to getNumberedPathnamesInDirectory().\n *      (3) Consequently, for some indices into the sarray, there may\n *          be no pathnames in the directory containing that number.\n *          By convention, we place empty C strings (\"\") in those\n *          locations in the sarray, and it is not an error if such\n *          a string is encountered and no pix is returned.\n *          Therefore, the caller must verify that a pix is returned.\n *      (4) See convertSegmentedPagesToPS() in src/psio1.c for an\n *          example of usage.\n */",
      "file" : "readfile.c"
   },
   {
      "function" : "pixReadJpeg",
      "comment" : "/*!\n *  pixReadJpeg()\n *\n *      Input:  filename\n *              colormap flag (0 means return RGB image if color;\n *                             1 means create colormap and return 8 bpp\n *                               palette image if color)\n *              reduction (scaling factor: 1, 2, 4 or 8)\n *              &nwarn (<optional return> number of warnings about\n *                       corrupted data)\n *      Return: pix, or null on error\n *\n *  Images reduced by factors of 2, 4 or 8 can be returned\n *  significantly faster than full resolution images.\n *\n *  The jpeg library will return warnings (or exit) if\n *  the jpeg data is bad.  Use this function if you want the\n *  jpeg library to create an 8 bpp palette image, or to\n *  tell if the jpeg data has been corrupted.  For corrupt jpeg\n *  data, there are two possible outcomes:\n *    (1) a damaged pix will be returned, along with a nonzero\n *        number of warnings, or\n *    (2) for sufficiently serious problems, the library will attempt\n *        to exit (caught by our error handler) and no pix will be returned.\n */",
      "file" : "jpegio.c"
   },
   {
      "function" : "pixReadMem",
      "comment" : "/*!\n *  pixReadMem()\n *\n *      Input:  data (const; encoded)\n *              datasize (size of data)\n *      Return: pix, or null on error\n *\n *  Notes:\n *      (1) This is a variation of pixReadStream(), where the data is read\n *          from a memory buffer rather than a file.\n *      (2) On windows, this will only read tiff formatted files from\n *          memory.  For other formats, it requires fmemopen(3).\n *          Attempts to read those formats will fail at runtime.\n *      (3) findFileFormatBuffer() requires up to 8 bytes to decide on\n *          the format.  That determines the constraint here.\n */",
      "file" : "readfile.c"
   },
   {
      "function" : "pixReadMemBmp",
      "comment" : "/*!\n *  pixReadMemBmp()\n *\n *      Input:  cdata (const; bmp-encoded)\n *              size (of data)\n *      Return: pix, or null on error\n *\n *  Notes:\n *      (1) The @size byte of @data must be a null character.\n */",
      "file" : "bmpio.c"
   },
   {
      "function" : "pixReadMemGif",
      "comment" : "/*!\n *  pixReadMemGif()\n *\n *      Input:  data (const; gif-encoded)\n *              size (of data)\n *      Return: pix, or null on error\n *\n *  Notes:\n *      (1) Of course, we are cheating here -- writing the data to file\n *          in gif format and reading it back in.  We can't use the\n *          GNU runtime extension fmemopen() to avoid writing to a file\n *          because libgif doesn't have a file stream interface!\n *      (2) This should not be assumed to be safe from a sophisticated\n *          attack, even though we have attempted to make the filename\n *          difficult to guess by embedding the process number and the\n *          current time in microseconds.  The best way to handle\n *          temporary files is to use file descriptors (capabilities)\n *          or file handles.  However, I know of no way to do this\n *          for gif files because of the way that libgif handles the\n *          file descriptors.  The canonical approach would be to do this:\n *              char templ[] = \"hiddenfilenameXXXXXX\";\n *              l_int32 fd = mkstemp(templ);\n *              FILE *fp = fdopen(fd, \"w+b\");\n *              fwrite(data, 1, size, fp);\n *              rewind(fp);\n *              Pix *pix = pixReadStreamGif(fp);\n *          but this fails because fp is in a bad state after writing.\n */",
      "file" : "gifio.c"
   },
   {
      "function" : "pixReadMemJpeg",
      "comment" : "/*!\n *  pixReadMemJpeg()\n *\n *      Input:  cdata (const; jpeg-encoded)\n *              size (of data)\n *              colormap flag (0 means return RGB image if color;\n *                             1 means create colormap and return 8 bpp\n *                               palette image if color)\n *              reduction (scaling factor: 1, 2, 4 or 8)\n *              &nwarn (<optional return> number of warnings)\n *              hint (bitwise OR of L_HINT_* values; use 0 for no hint)\n *      Return: pix, or null on error\n *\n *  Notes:\n *      (1) The @size byte of @data must be a null character.\n *      (2) See pixReadJpeg() for usage.\n */",
      "file" : "jpegio.c"
   },
   {
      "function" : "pixReadMemPng",
      "comment" : "/*!\n *  pixReadMemPng()\n *\n *      Input:  cdata (const; png-encoded)\n *              size (of data)\n *      Return: pix, or null on error\n *\n *  Notes:\n *      (1) The @size byte of @data must be a null character.\n */",
      "file" : "pngio.c"
   },
   {
      "function" : "pixReadMemPnm",
      "comment" : "/*!\n *  pixReadMemPnm()\n *\n *      Input:  cdata (const; pnm-encoded)\n *              size (of data)\n *      Return: pix, or null on error\n *\n *  Notes:\n *      (1) The @size byte of @data must be a null character.\n */",
      "file" : "pnmio.c"
   },
   {
      "function" : "pixReadMemSpix",
      "comment" : "/*!\n *  pixReadMemSpix()\n *\n *      Input:  data (const; uncompressed)\n *              size (of data)\n *      Return: pix, or null on error\n */",
      "file" : "spixio.c"
   },
   {
      "function" : "pixReadMemTiff",
      "comment" : "/*!\n *  pixReadMemTiff()\n *\n *      Input:  data (const; tiff-encoded)\n *              datasize (size of data)\n *              n (page image number: 0-based)\n *      Return: pix, or null on error\n *\n *  Notes:\n *      (1) This is a version of pixReadTiff(), where the data is read\n *          from a memory buffer and uncompressed.\n *      (2) Use TIFFClose(); TIFFCleanup() doesn't free internal memstream.\n */",
      "file" : "tiffio.c"
   },
   {
      "function" : "pixReadMemWebP",
      "comment" : "/*!\n *  pixReadMemWebP()\n *\n *      Input:  filedata (webp compressed data in memory)\n *              filesize (number of bytes in data)\n *      Return: pix (32 bpp), or null on error\n *\n *  Notes:\n *      (1) When the encoded data only has 3 channels (no alpha),\n *          WebPDecodeRGBAInto() generates a raster of 32-bit pixels, with\n *          the alpha channel set to opaque (255).\n *      (2) We don't need to use the gnu runtime functions like fmemopen()\n *          for redirecting data from a stream to memory, because\n *          the webp library has been written with memory-to-memory\n *          functions at the lowest level (which is good!).  And, in\n *          any event, fmemopen() doesn't work with l_binaryReadStream().\n */",
      "file" : "webpio.c"
   },
   {
      "function" : "pixReadStream",
      "comment" : "/*!\n *  pixReadStream()\n *\n *      Input:  fp (file stream)\n *              hint (bitwise OR of L_HINT_* values for jpeg; use 0 for no hint)\n *      Return: pix if OK; null on error\n *\n *  Notes:\n *      (1) The hint only applies to jpeg.\n */",
      "file" : "readfile.c"
   },
   {
      "function" : "pixReadStreamBmp",
      "comment" : "/*!\n *  pixReadStreamBmp()\n *\n *      Input:  stream opened for read\n *      Return: pix, or null on error\n *\n *  Notes:\n *      (1) Here are references on the bmp file format:\n *          http://en.wikipedia.org/wiki/BMP_file_format\n *          http://www.fortunecity.com/skyscraper/windows/364/bmpffrmt.html\n */",
      "file" : "bmpio.c"
   },
   {
      "function" : "pixReadStreamGif",
      "comment" : "/*!\n *  pixReadStreamGif()\n *\n *      Input:  stream\n *      Return: pix, or null on error\n */",
      "file" : "gifio.c"
   },
   {
      "function" : "pixReadStreamJpeg",
      "comment" : "/*!\n *  pixReadStreamJpeg()\n *\n *      Input:  stream\n *              colormap flag (0 means return RGB image if color;\n *                             1 means create colormap and return 8 bpp\n *                               palette image if color)\n *              reduction (scaling factor: 1, 2, 4 or 8)\n *              &nwarn (<optional return> number of warnings)\n *              hint: (a bitwise OR of L_HINT_* values); use 0 for no hints\n *      Return: pix, or null on error\n *\n *  Usage: see pixReadJpeg()\n *  Notes:\n *      (1) This does not get the jpeg comment.\n */",
      "file" : "jpegio.c"
   },
   {
      "function" : "pixReadStreamPng",
      "comment" : "/*!\n *  pixReadStreamPng()\n *\n *      Input:  stream\n *      Return: pix, or null on error\n *\n *  Notes:\n *      (1) If called from pixReadStream(), the stream is positioned\n *          at the beginning of the file.\n *      (2) To do sequential reads of png format images from a stream,\n *          use pixReadStreamPng()\n *      (3) Grayscale-with-alpha pngs (spp = 2) are converted to RGBA\n *          on read; the returned pix has spp = 4 and equal red, green and\n *          blue channels.\n *      (4) spp = 1 with alpha (palette) is converted to RGBA with spp = 4.\n *      (5) We use the high level png interface, where the transforms are set\n *          up in advance and the header and image are read with a single\n *          call.  The more complicated interface, where the header is\n *          read first and the buffers for the raster image are user-\n *          allocated before reading the image, works OK for single images,\n *          but I could not get it to work properly for the successive\n *          png reads that are required by pixaReadStream().\n */",
      "file" : "pngio.c"
   },
   {
      "function" : "pixReadStreamPnm",
      "comment" : "/*!\n *  pixReadStreamPnm()\n *\n *      Input:  stream opened for read\n *      Return: pix, or null on error\n */",
      "file" : "pnmio.c"
   },
   {
      "function" : "pixReadStreamSpix",
      "comment" : "/*!\n *  pixReadStreamSpix()\n *\n *      Input:  stream\n *      Return: pix, or null on error.\n *\n *  Notes:\n *      (1) If called from pixReadStream(), the stream is positioned\n *          at the beginning of the file.\n */",
      "file" : "spixio.c"
   },
   {
      "function" : "pixReadStreamTiff",
      "comment" : "/*!\n *  pixReadStreamTiff()\n *\n *      Input:  stream\n *              n (page number: 0 based)\n *      Return: pix, or null on error (e.g., if the page number is invalid)\n */",
      "file" : "tiffio.c"
   },
   {
      "function" : "pixReadStreamWebP",
      "comment" : "/*!\n *  pixReadStreamWebP()\n *\n *      Input:  stream corresponding to WebP image\n *      Return: pix (32 bpp), or null on error\n */",
      "file" : "webpio.c"
   },
   {
      "function" : "pixReadTiff",
      "comment" : "/*!\n *  pixReadTiff()\n *\n *      Input:  filename\n *              page number (0 based)\n *      Return: pix, or null on error\n *\n *  Notes:\n *      (1) This is a version of pixRead(), specialized for tiff\n *          files, that allows specification of the page to be returned\n */",
      "file" : "tiffio.c"
   },
   {
      "function" : "pixReadWithHint",
      "comment" : "/*!\n *  pixReadWithHint()\n *\n *      Input:  filename (with full pathname or in local directory)\n *              hint (bitwise OR of L_HINT_* values for jpeg; use 0 for no hint)\n *      Return: pix if OK; null on error\n *\n *  Notes:\n *      (1) The hint is not binding, but may be used to optimize jpeg decoding.\n *          Use 0 for no hinting.\n */",
      "file" : "readfile.c"
   },
   {
      "function" : "pixReduceBinary2",
      "comment" : "/*!\n *  pixReduceBinary2()\n *\n *      Input:  pixs\n *              tab (<optional>; if null, a table is made here\n *                   and destroyed before exit)\n *      Return: pixd (2x subsampled), or null on error\n *\n *  Notes:\n *      (1) After folding, the data is in bytes 0 and 2 of the word,\n *          and the bits in each byte are in the following order\n *          (with 0 being the leftmost originating pair and 7 being\n *          the rightmost originating pair):\n *               0 4 1 5 2 6 3 7\n *          These need to be permuted to\n *               0 1 2 3 4 5 6 7\n *          which is done with an 8-bit table generated by makeSubsampleTab2x().\n */",
      "file" : "binreduce.c"
   },
   {
      "function" : "pixReduceRankBinary2",
      "comment" : "/*!\n *  pixReduceRankBinary2()\n *\n *      Input:  pixs (1 bpp)\n *              level (rank threshold: 1, 2, 3, 4)\n *              intab (<optional>; if null, a table is made here\n *                     and destroyed before exit)\n *      Return: pixd (1 bpp, 2x rank threshold reduced), or null on error\n *\n *  Notes:\n *      (1) pixd is downscaled by 2x from pixs.\n *      (2) The rank threshold specifies the minimum number of ON\n *          pixels in each 2x2 region of pixs that are required to\n *          set the corresponding pixel ON in pixd.\n *      (3) Rank filtering is done to the UL corner of each 2x2 pixel block,\n *          using only logical operations.  Then these pixels are chosen\n *          in the 2x subsampling process, subsampled, as described\n *          above in pixReduceBinary2().\n */",
      "file" : "binreduce.c"
   },
   {
      "function" : "pixReduceRankBinaryCascade",
      "comment" : "/*!\n *  pixReduceRankBinaryCascade()\n *\n *      Input:  pixs (1 bpp)\n *              level1, ... level 4 (thresholds, in the set {0, 1, 2, 3, 4})\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This performs up to four cascaded 2x rank reductions.\n *      (2) Use level = 0 to truncate the cascade.\n */",
      "file" : "binreduce.c"
   },
   {
      "function" : "pixRemoveAlpha",
      "comment" : "/*!\n *  pixRemoveAlpha()\n *\n *      Input:  pixs (any depth)\n *      Return: pixd (if 32 bpp rgba, pixs blended over a white background;\n *                    a clone of pixs otherwise), and null on error\n *\n *  Notes:\n *      (1) This is a wrapper on pixAlphaBlendUniform()\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixRemoveBorder",
      "comment" : "/*!\n *  pixRemoveBorder()\n *\n *      Input:  pixs (all depths; colormap ok)\n *              npix (number to be removed from each of the 4 sides)\n *      Return: pixd (with pixels removed around border), or null on error\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixRemoveBorderConnComps",
      "comment" : "/*!\n *  pixRemoveBorderConnComps()\n *\n *      Input:  pixs (1 bpp)\n *              filling connectivity (4 or 8)\n *      Return: pixd  (all pixels in the src that are not touching the\n *                     border) or null on error\n *\n *  Notes:\n *      (1) This removes all fg components touching the border.\n */",
      "file" : "seedfill.c"
   },
   {
      "function" : "pixRemoveBorderGeneral",
      "comment" : "/*!\n *  pixRemoveBorderGeneral()\n *\n *      Input:  pixs (all depths; colormap ok)\n *              left, right, top, bot  (number of pixels added)\n *      Return: pixd (with pixels removed around border), or null on error\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixRemoveBorderToSize",
      "comment" : "/*!\n *  pixRemoveBorderToSize()\n *\n *      Input:  pixs (all depths; colormap ok)\n *              wd  (target width; use 0 if only removing from height)\n *              hd  (target height; use 0 if only removing from width)\n *      Return: pixd (with pixels removed around border), or null on error\n *\n *  Notes:\n *      (1) Removes pixels as evenly as possible from the sides of the\n *          image, leaving the central part.\n *      (2) Returns clone if no pixels requested removed, or the target\n *          sizes are larger than the image.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixRemoveColormap",
      "comment" : "/*!\n *  pixRemoveColormap()\n *\n *      Input:  pixs (see restrictions below)\n *              type (REMOVE_CMAP_TO_BINARY,\n *                    REMOVE_CMAP_TO_GRAYSCALE,\n *                    REMOVE_CMAP_TO_FULL_COLOR,\n *                    REMOVE_CMAP_WITH_ALPHA,\n *                    REMOVE_CMAP_BASED_ON_SRC)\n *      Return: pixd (without colormap), or null on error\n *\n *  Notes:\n *      (1) If pixs does not have a colormap, a clone is returned.\n *      (2) Otherwise, the input pixs is restricted to 1, 2, 4 or 8 bpp.\n *      (3) Use REMOVE_CMAP_TO_BINARY only on 1 bpp pix.\n *      (4) For grayscale conversion from RGB, use a weighted average\n *          of RGB values, and always return an 8 bpp pix, regardless\n *          of whether the input pixs depth is 2, 4 or 8 bpp.\n *      (5) REMOVE_CMAP_BASED_ON_SRC and REMOVE_CMAP_TO_FULL_COLOR\n *          ignore the alpha components.  For 32-bit pixel output,\n *          the alpha byte is set to 0 and spp = 3.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixRemoveColormapGeneral",
      "comment" : "/*!\n *  pixRemoveColormapGeneral()\n *\n *      Input:  pixs (any depth, with or without colormap)\n *              type (REMOVE_CMAP_TO_BINARY,\n *                    REMOVE_CMAP_TO_GRAYSCALE,\n *                    REMOVE_CMAP_TO_FULL_COLOR,\n *                    REMOVE_CMAP_WITH_ALPHA,\n *                    REMOVE_CMAP_BASED_ON_SRC)\n *              ifnocmap (L_CLONE, L_COPY)\n *      Return: pixd (always a new pix; without colormap), or null on error\n *\n *  Notes:\n *      (1) Convenience function that allows choice between returning\n *          a clone or a copy if pixs does not have a colormap.\n *      (2) See pixRemoveColormap().\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixRemoveMatchedPattern",
      "comment" : "/*!\n *  pixRemoveMatchedPattern()\n *\n *      Input:  pixs (input image, 1 bpp)\n *              pixp (pattern to be removed from image, 1 bpp)\n *              pixe (image after erosion by Sel that approximates pixp, 1 bpp)\n *              x0, y0 (center of Sel)\n *              dsize (number of pixels on each side by which pixp is\n *                     dilated before being subtracted from pixs;\n *                     valid values are {0, 1, 2, 3, 4})\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *    (1) This is in-place.\n *    (2) You can use various functions in selgen to create a Sel\n *        that is used to generate pixe from pixs.\n *    (3) This function is applied after pixe has been computed.\n *        It finds the centroid of each c.c., and subtracts\n *        (the appropriately dilated version of) pixp, with the center\n *        of the Sel used to align pixp with pixs.\n */",
      "file" : "morphapp.c"
   },
   {
      "function" : "pixRemoveSeededComponents",
      "comment" : "/*!\n *  pixRemoveSeededComponents()\n *\n *      Input:  pixd  (<optional>; this can be null or equal to pixm; 1 bpp)\n *              pixs  (1 bpp seed)\n *              pixm  (1 bpp filling mask)\n *              connectivity  (4 or 8)\n *              bordersize (amount of border clearing)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This removes each component in pixm for which there is\n *          at least one seed in pixs.  If pixd == NULL, this returns\n *          the result in a new pixd.  Otherwise, it is an in-place\n *          operation on pixm.  In no situation is pixs altered,\n *          because we do the filling with a copy of pixs.\n *      (2) If bordersize > 0, it also clears all pixels within a\n *          distance @bordersize of the edge of pixd.  This is here\n *          because pixLocalExtrema() typically finds local minima\n *          at the border.  Use @bordersize >= 2 to remove these.\n */",
      "file" : "seedfill.c"
   },
   {
      "function" : "pixRemoveUnusedColors",
      "comment" : "/*!\n *  pixRemoveUnusedColors()\n *\n *      Input:  pixs  (colormapped)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is an in-place operation.\n *      (2) If the image doesn't have a colormap, returns without error.\n *      (3) Unusued colors are removed from the colormap, and the\n *          image pixels are re-numbered.\n */",
      "file" : "colorquant1.c"
   },
   {
      "function" : "pixRemoveWithIndicator",
      "comment" : "/*!\n *  pixRemoveWithIndicator()\n *\n *      Input:  pixs (1 bpp pix from which components are removed; in-place)\n *              pixa (of connected components in pixs)\n *              na (numa indicator: remove components corresponding to 1s)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This complements pixAddWithIndicator().   Here, the selected\n *          components are set subtracted from pixs.\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixRenderBox",
      "comment" : "/*!\n *  pixRenderBox()\n *\n *      Input:  pix\n *              box\n *              width  (thickness of box lines)\n *              op  (one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "pixRenderBoxArb",
      "comment" : "/*!\n *  pixRenderBoxArb()\n *\n *      Input:  pix (any depth, cmapped ok)\n *              box\n *              width  (thickness of box lines)\n *              rval, gval, bval\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "pixRenderBoxBlend",
      "comment" : "/*!\n *  pixRenderBoxBlend()\n *\n *      Input:  pix\n *              box\n *              width  (thickness of box lines)\n *              rval, gval, bval\n *              fract (in [0.0 - 1.0]; complete transparency (no effect)\n *                     if 0.0; no transparency if 1.0)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "pixRenderBoxa",
      "comment" : "/*!\n *  pixRenderBoxa()\n *\n *      Input:  pix\n *              boxa\n *              width  (thickness of line)\n *              op  (one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "pixRenderBoxaArb",
      "comment" : "/*!\n *  pixRenderBoxaArb()\n *\n *      Input:  pix\n *              boxa\n *              width  (thickness of line)\n *              rval, gval, bval\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "pixRenderBoxaBlend",
      "comment" : "/*!\n *  pixRenderBoxaBlend()\n *\n *      Input:  pix\n *              boxa\n *              width  (thickness of line)\n *              rval, gval, bval\n *              fract (in [0.0 - 1.0]; complete transparency (no effect)\n *                     if 0.0; no transparency if 1.0)\n *              removedups  (1 to remove; 0 otherwise)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "pixRenderContours",
      "comment" : "/*!\n *  pixRenderContours()\n *\n *      Input:  pixs (8 or 16 bpp; no colormap)\n *              startval (value of lowest contour; must be in [0 ... maxval])\n *              incr  (increment to next contour; must be > 0)\n *              outdepth (either 1 or depth of pixs)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) The output can be either 1 bpp, showing just the contour\n *          lines, or a copy of the input pixs with the contour lines\n *          superposed.\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "pixRenderHashBox",
      "comment" : "/*!\n *  pixRenderHashBox()\n *\n *      Input:  pix\n *              box\n *              spacing (spacing between lines; must be > 1)\n *              width  (thickness of box and hash lines)\n *              orient  (orientation of lines: L_HORIZONTAL_LINE, ...)\n *              outline  (0 to skip drawing box outline)\n *              op  (one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "pixRenderHashBoxArb",
      "comment" : "/*!\n *  pixRenderHashBoxArb()\n *\n *      Input:  pix\n *              box\n *              spacing (spacing between lines; must be > 1)\n *              width  (thickness of box and hash lines)\n *              orient  (orientation of lines: L_HORIZONTAL_LINE, ...)\n *              outline  (0 to skip drawing box outline)\n *              rval, gval, bval\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "pixRenderHashBoxBlend",
      "comment" : "/*!\n *  pixRenderHashBoxBlend()\n *\n *      Input:  pix\n *              box\n *              spacing (spacing between lines; must be > 1)\n *              width  (thickness of box and hash lines)\n *              orient  (orientation of lines: L_HORIZONTAL_LINE, ...)\n *              outline  (0 to skip drawing box outline)\n *              rval, gval, bval\n *              fract (in [0.0 - 1.0]; complete transparency (no effect)\n *                     if 0.0; no transparency if 1.0)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "pixRenderHashBoxa",
      "comment" : "/*!\n *  pixRenderHashBoxa()\n *\n *      Input:  pix\n *              boxa\n *              spacing (spacing between lines; must be > 1)\n *              width  (thickness of box and hash lines)\n *              orient  (orientation of lines: L_HORIZONTAL_LINE, ...)\n *              outline  (0 to skip drawing box outline)\n *              op  (one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "pixRenderHashBoxaArb",
      "comment" : "/*!\n *  pixRenderHashBoxaArb()\n *\n *      Input:  pix\n *              boxa\n *              spacing (spacing between lines; must be > 1)\n *              width  (thickness of box and hash lines)\n *              orient  (orientation of lines: L_HORIZONTAL_LINE, ...)\n *              outline  (0 to skip drawing box outline)\n *              rval, gval, bval\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "pixRenderHashBoxaBlend",
      "comment" : "/*!\n *  pixRenderHashBoxaBlend()\n *\n *      Input:  pix\n *              boxa\n *              spacing (spacing between lines; must be > 1)\n *              width  (thickness of box and hash lines)\n *              orient  (orientation of lines: L_HORIZONTAL_LINE, ...)\n *              outline  (0 to skip drawing box outline)\n *              rval, gval, bval\n *              fract (in [0.0 - 1.0]; complete transparency (no effect)\n *                     if 0.0; no transparency if 1.0)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "pixRenderHorizEndPoints",
      "comment" : "/*!\n *  pixRenderHorizEndPoints()\n *\n *      Input:  pixs (32 bpp)\n *              ptal (left side line end points)\n *              ptar (right side line end points)\n *              color (0xrrggbb00)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "dewarp2.c"
   },
   {
      "function" : "pixRenderLine",
      "comment" : "/*!\n *  pixRenderLine()\n *\n *      Input:  pix\n *              x1, y1\n *              x2, y2\n *              width  (thickness of line)\n *              op  (one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "pixRenderLineArb",
      "comment" : "/*!\n *  pixRenderLineArb()\n *\n *      Input:  pix\n *              x1, y1\n *              x2, y2\n *              width  (thickness of line)\n *              rval, gval, bval\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "pixRenderLineBlend",
      "comment" : "/*!\n *  pixRenderLineBlend()\n *\n *      Input:  pix\n *              x1, y1\n *              x2, y2\n *              width  (thickness of line)\n *              rval, gval, bval\n *              fract\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "pixRenderMidYs",
      "comment" : "/*!\n *  pixRenderMidYs()\n *\n *      Input:  pixs (32 bpp)\n *              namidys (y location of reference lines for vertical disparity)\n *              linew (width of rendered line; typ 2)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "dewarp2.c"
   },
   {
      "function" : "pixRenderPolygon",
      "comment" : "/*!\n *  pixRenderPolygon()\n *\n *      Input:  ptas (of vertices, none repeated)\n *              width (of polygon outline)\n *              &xmin (<optional return> min x value of input pts)\n *              &ymin (<optional return> min y value of input pts)\n *      Return: pix (1 bpp, with outline generated), or null on error\n *\n *  Notes:\n *      (1) The pix is the minimum size required to contain the origin\n *          and the polygon.  For example, the max x value of the input\n *          points is w - 1, where w is the pix width.\n *      (2) The rendered line is 4-connected, so that an interior or\n *          exterior 8-c.c. flood fill operation works properly.\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "pixRenderPolyline",
      "comment" : "/*!\n *  pixRenderPolyline()\n *\n *      Input:  pix\n *              ptas\n *              width  (thickness of line)\n *              op  (one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS)\n *              closeflag (1 to close the contour; 0 otherwise)\n *      Return: 0 if OK, 1 on error\n *\n *  Note: this renders a closed contour.\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "pixRenderPolylineArb",
      "comment" : "/*!\n *  pixRenderPolylineArb()\n *\n *      Input:  pix\n *              ptas\n *              width  (thickness of line)\n *              rval, gval, bval\n *              closeflag (1 to close the contour; 0 otherwise)\n *      Return: 0 if OK, 1 on error\n *\n *  Note: this renders a closed contour.\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "pixRenderPolylineBlend",
      "comment" : "/*!\n *  pixRenderPolylineBlend()\n *\n *      Input:  pix\n *              ptas\n *              width  (thickness of line)\n *              rval, gval, bval\n *              fract (in [0.0 - 1.0]; complete transparency (no effect)\n *                     if 0.0; no transparency if 1.0)\n *              closeflag (1 to close the contour; 0 otherwise)\n *              removedups  (1 to remove; 0 otherwise)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "pixRenderPta",
      "comment" : "/*!\n *  pixRenderPta()\n *\n *      Input:  pix\n *              pta (arbitrary set of points)\n *              op   (one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) L_SET_PIXELS puts all image bits in each pixel to 1\n *          (black for 1 bpp; white for depth > 1)\n *      (2) L_CLEAR_PIXELS puts all image bits in each pixel to 0\n *          (white for 1 bpp; black for depth > 1)\n *      (3) L_FLIP_PIXELS reverses all image bits in each pixel\n *      (4) This function clips the rendering to the pix.  It performs\n *          clipping for functions such as pixRenderLine(),\n *          pixRenderBox() and pixRenderBoxa(), that call pixRenderPta().\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "pixRenderPtaArb",
      "comment" : "/*!\n *  pixRenderPtaArb()\n *\n *      Input:  pix (any depth, cmapped ok)\n *              pta (arbitrary set of points)\n *              rval, gval, bval\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If pix is colormapped, render this color (or the nearest\n *          color if the cmap is full) on each pixel.\n *      (2) If pix is not colormapped, do the best job you can using\n *          the input colors:\n *          - d = 1: set the pixels\n *          - d = 2, 4, 8: average the input rgb value\n *          - d = 32: use the input rgb value\n *      (3) This function clips the rendering to the pix.\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "pixRenderPtaBlend",
      "comment" : "/*!\n *  pixRenderPtaBlend()\n *\n *      Input:  pix (32 bpp rgb)\n *              pta  (arbitrary set of points)\n *              rval, gval, bval\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This function clips the rendering to the pix.\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "pixRenderRandomCmapPtaa",
      "comment" : "/*!\n *  pixRenderRandomCmapPtaa()\n *\n *      Input:  pix (1, 2, 4, 8, 16, 32 bpp)\n *              ptaa\n *              polyflag (1 to interpret each Pta as a polyline; 0 to simply\n *                        render the Pta as a set of pixels)\n *              width  (thickness of line; use only for polyline)\n *              closeflag (1 to close the contour; 0 otherwise;\n *                         use only for polyline mode)\n *      Return: pixd (cmapped, 8 bpp) or null on error\n *\n *  Notes:\n *      (1) This is a debugging routine, that displays a set of\n *          pixels, selected by the set of Ptas in a Ptaa,\n *          in a random color in a pix.\n *      (2) If @polyflag == 1, each Pta is considered to be a polyline,\n *          and is rendered using @width and @closeflag.  Each polyline\n *          is rendered in a random color.\n *      (3) If @polyflag == 0, all points in each Pta are rendered in a\n *          random color.  The @width and @closeflag parameters are ignored.\n *      (4) The output pix is 8 bpp and colormapped.  Up to 254\n *          different, randomly selected colors, can be used.\n *      (5) The rendered pixels replace the input pixels.  They will\n *          be clipped silently to the input pix.\n */",
      "file" : "graphics.c"
   },
   {
      "function" : "pixResizeImageData",
      "comment" : "/*!\n *  pixResizeImageData()\n *\n *      Input:  pixd (gets new uninitialized buffer for image data)\n *              pixs (determines the size of the buffer; not changed)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This removes any existing image data from pixd and\n *          allocates an uninitialized buffer that will hold the\n *          amount of image data that is in pixs.\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixResizeToMatch",
      "comment" : "/*!\n *  pixResizeToMatch()\n *\n *      Input:  pixs (1, 2, 4, 8, 16, 32 bpp; colormap ok)\n *              pixt  (can be null; we use only the size)\n *              w, h (ignored if pixt is defined)\n *      Return: pixd (resized to match) or null on error\n *\n *  Notes:\n *      (1) This resizes pixs to make pixd, without scaling, by either\n *          cropping or extending separately in both width and height.\n *          Extension is done by replicating the last row or column.\n *          This is useful in a situation where, due to scaling\n *          operations, two images that are expected to be the\n *          same size can differ slightly in each dimension.\n *      (2) You can use either an existing pixt or specify\n *          both @w and @h.  If pixt is defined, the values\n *          in @w and @h are ignored.\n *      (3) If pixt is larger than pixs (or if w and/or d is larger\n *          than the dimension of pixs, replicate the outer row and\n *          column of pixels in pixs into pixd.\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixReversalProfile",
      "comment" : "/*!\n *  pixReversalProfile()\n *\n *      Input:  pixs (any depth; colormap OK)\n *              fract (fraction of image width or height to be used)\n *              dir (profile direction: L_HORIZONTAL_LINE or L_VERTICAL_LINE)\n *              first, last (span of rows or columns to measure)\n *              minreversal (minimum change in intensity to trigger a reversal)\n *              factor1 (sampling along raster line (fast scan); >= 1)\n *              factor2 (sampling of raster lines (slow scan); >= 1)\n *      Return: na (of reversal profile), or null on error.\n *\n *  Notes:\n *      (1) If d != 1 bpp, colormaps are removed and the result\n *          is converted to 8 bpp.\n *      (2) If @dir == L_HORIZONTAL_LINE, the the reversals are counted\n *          along each horizontal raster line (sampled by @factor1),\n *          and the profile is the array of these sums in the\n *          vertical direction between @first and @last raster lines,\n *          and sampled by @factor2.\n *      (3) If @dir == L_VERTICAL_LINE, the the reversals are counted\n *          along each vertical column (sampled by @factor1),\n *          and the profile is the array of these sums in the\n *          horizontal direction between @first and @last columns,\n *          and sampled by @factor2.\n *      (4) For each row or column, the reversals are summed over the\n *          central @fract of the image.  Use @fract == 1.0 to sum\n *          across the entire width (of row) or height (of column).\n *      (5) @minreversal is the relative change in intensity that is\n *          required to resolve peaks and valleys.  A typical number for\n *          locating text in 8 bpp might be 50.  For 1 bpp, minreversal\n *          must be 1.\n *      (6) The reversal profile is simply the number of reversals\n *          in a row or column, vs the row or column index.\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixRotate",
      "comment" : "/*!\n *  pixRotate()\n *\n *      Input:  pixs (1, 2, 4, 8, 32 bpp rgb)\n *              angle (radians; clockwise is positive)\n *              type (L_ROTATE_AREA_MAP, L_ROTATE_SHEAR, L_ROTATE_SAMPLING)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)\n *              width (original width; use 0 to avoid embedding)\n *              height (original height; use 0 to avoid embedding)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This is a high-level, simple interface for rotating images\n *          about their center.\n *      (2) For very small rotations, just return a clone.\n *      (3) Rotation brings either white or black pixels in\n *          from outside the image.\n *      (4) The rotation type is adjusted if necessary for the image\n *          depth and size of rotation angle.  For 1 bpp images, we\n *          rotate either by shear or sampling.\n *      (5) Colormaps are removed for rotation by area mapping.\n *      (6) The dest can be expanded so that no image pixels\n *          are lost.  To invoke expansion, input the original\n *          width and height.  For repeated rotation, use of the\n *          original width and height allows the expansion to\n *          stop at the maximum required size, which is a square\n *          with side = sqrt(w*w + h*h).\n *\n *  *** Warning: implicit assumption about RGB component ordering ***\n */",
      "file" : "rotate.c"
   },
   {
      "function" : "pixRotate180",
      "comment" : "/*!\n *  pixRotate180()\n *\n *      Input:  pixd  (<optional>; can be null, equal to pixs,\n *                     or different from pixs)\n *              pixs (all depths)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This does a 180 rotation of the image about the center,\n *          which is equivalent to a left-right flip about a vertical\n *          line through the image center, followed by a top-bottom\n *          flip about a horizontal line through the image center.\n *      (2) There are 3 cases for input:\n *          (a) pixd == null (creates a new pixd)\n *          (b) pixd == pixs (in-place operation)\n *          (c) pixd != pixs (existing pixd)\n *      (3) For clarity, use these three patterns, respectively:\n *          (a) pixd = pixRotate180(NULL, pixs);\n *          (b) pixRotate180(pixs, pixs);\n *          (c) pixRotate180(pixd, pixs);\n */",
      "file" : "rotateorth.c"
   },
   {
      "function" : "pixRotate2Shear",
      "comment" : "/*!\n *  pixRotate2Shear()\n *\n *      Input:  pixs\n *              xcen, ycen (center of rotation)\n *              angle (radians)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK);\n *      Return: pixd, or null on error.\n *\n *  Notes:\n *      (1) This rotates the image about the given point, using the 2-shear\n *          method.  It should only be used for angles smaller than\n *          MAX_2_SHEAR_ANGLE.  For larger angles, a warning is issued.\n *      (2) A positive angle gives a clockwise rotation.\n *      (3) 2-shear rotation by a specified angle is equivalent\n *          to the sequential transformations\n *             x' = x + tan(angle) * (y - ycen)     for x-shear\n *             y' = y + tan(angle) * (x - xcen)     for y-shear\n *      (4) Computation of tan(angle) is performed within the shear operation.\n *      (5) This brings in 'incolor' pixels from outside the image.\n *      (6) If the image has an alpha layer, it is rotated separately by\n *          two shears.\n */",
      "file" : "rotateshear.c"
   },
   {
      "function" : "pixRotate3Shear",
      "comment" : "/*!\n *  pixRotate3Shear()\n *\n *      Input:  pixs\n *              xcen, ycen (center of rotation)\n *              angle (radians)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK);\n *      Return: pixd, or null on error.\n *\n *  Notes:\n *      (1) This rotates the image about the given point, using the 3-shear\n *          method.  It should only be used for angles smaller than\n *          LIMIT_SHEAR_ANGLE.  For larger angles, a warning is issued.\n *      (2) A positive angle gives a clockwise rotation.\n *      (3) 3-shear rotation by a specified angle is equivalent\n *          to the sequential transformations\n *            y' = y + tan(angle/2) * (x - xcen)     for first y-shear\n *            x' = x + sin(angle) * (y - ycen)       for x-shear\n *            y' = y + tan(angle/2) * (x - xcen)     for second y-shear\n *      (4) Computation of tan(angle) is performed in the shear operations.\n *      (5) This brings in 'incolor' pixels from outside the image.\n *      (6) If the image has an alpha layer, it is rotated separately by\n *          two shears.\n *      (7) The algorithm was published by Alan Paeth: \"A Fast Algorithm\n *          for General Raster Rotation,\" Graphics Interface '86,\n *          pp. 77-81, May 1986.  A description of the method, along with\n *          an implementation, can be found in Graphics Gems, p. 179,\n *          edited by Andrew Glassner, published by Academic Press, 1990.\n */",
      "file" : "rotateshear.c"
   },
   {
      "function" : "pixRotate90",
      "comment" : "/*!\n *  pixRotate90()\n *\n *      Input:  pixs (all depths)\n *              direction (1 = clockwise,  -1 = counter-clockwise)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This does a 90 degree rotation of the image about the center,\n *          either cw or ccw, returning a new pix.\n *      (2) The direction must be either 1 (cw) or -1 (ccw).\n */",
      "file" : "rotateorth.c"
   },
   {
      "function" : "pixRotateAM",
      "comment" : "/*!\n *  pixRotateAM()\n *\n *      Input:  pixs (2, 4, 8 bpp gray or colormapped, or 32 bpp RGB)\n *              angle (radians; clockwise is positive)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Rotates about image center.\n *      (2) A positive angle gives a clockwise rotation.\n *      (3) Brings in either black or white pixels from the boundary.\n */",
      "file" : "rotateam.c"
   },
   {
      "function" : "pixRotateAMColor",
      "comment" : "/*!\n *  pixRotateAMColor()\n *\n *      Input:  pixs (32 bpp)\n *              angle (radians; clockwise is positive)\n *              colorval (e.g., 0 to bring in BLACK, 0xffffff00 for WHITE)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Rotates about image center.\n *      (2) A positive angle gives a clockwise rotation.\n *      (3) Specify the color to be brought in from outside the image.\n */",
      "file" : "rotateam.c"
   },
   {
      "function" : "pixRotateAMColorCorner",
      "comment" : "/*!\n *  pixRotateAMColorCorner()\n *\n *      Input:  pixs\n *              angle (radians; clockwise is positive)\n *              colorval (e.g., 0 to bring in BLACK, 0xffffff00 for WHITE)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Rotates the image about the UL corner.\n *      (2) A positive angle gives a clockwise rotation.\n *      (3) Specify the color to be brought in from outside the image.\n */",
      "file" : "rotateam.c"
   },
   {
      "function" : "pixRotateAMColorFast",
      "comment" : "/*!\n *  pixRotateAMColorFast()\n *\n *      Input:  pixs\n *              angle (radians; clockwise is positive)\n *              colorval (e.g., 0 to bring in BLACK, 0xffffff00 for WHITE)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This rotates a color image about the image center.\n *      (2) A positive angle gives a clockwise rotation.\n *      (3) It uses area mapping, dividing each pixel into\n *          16 subpixels.\n *      (4) It is about 10% to 20% faster than the more accurate linear\n *          interpolation function pixRotateAMColor(),\n *          which uses 256 subpixels.\n *      (5) For some reason it shifts the image center.\n *          No attempt is made to rotate the alpha component.\n *\n *  *** Warning: implicit assumption about RGB component ordering ***\n */",
      "file" : "rotateam.c"
   },
   {
      "function" : "pixRotateAMCorner",
      "comment" : "/*!\n *  pixRotateAMCorner()\n *\n *      Input:  pixs (1, 2, 4, 8 bpp gray or colormapped, or 32 bpp RGB)\n *              angle (radians; clockwise is positive)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Rotates about the UL corner of the image.\n *      (2) A positive angle gives a clockwise rotation.\n *      (3) Brings in either black or white pixels from the boundary.\n */",
      "file" : "rotateam.c"
   },
   {
      "function" : "pixRotateAMGray",
      "comment" : "/*!\n *  pixRotateAMGray()\n *\n *      Input:  pixs (8 bpp)\n *              angle (radians; clockwise is positive)\n *              grayval (0 to bring in BLACK, 255 for WHITE)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Rotates about image center.\n *      (2) A positive angle gives a clockwise rotation.\n *      (3) Specify the grayvalue to be brought in from outside the image.\n */",
      "file" : "rotateam.c"
   },
   {
      "function" : "pixRotateAMGrayCorner",
      "comment" : "/*!\n *  pixRotateAMGrayCorner()\n *\n *      Input:  pixs\n *              angle (radians; clockwise is positive)\n *              grayval (0 to bring in BLACK, 255 for WHITE)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Rotates the image about the UL corner.\n *      (2) A positive angle gives a clockwise rotation.\n *      (3) Specify the grayvalue to be brought in from outside the image.\n */",
      "file" : "rotateam.c"
   },
   {
      "function" : "pixRotateBinaryNice",
      "comment" : "/*!\n *  pixRotateBinaryNice()\n *\n *      Input:  pixs (1 bpp)\n *              angle (radians; clockwise is positive; about the center)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) For very small rotations, just return a clone.\n *      (2) This does a computationally expensive rotation of 1 bpp images.\n *          The fastest rotators (using shears or subsampling) leave\n *          visible horizontal and vertical shear lines across which\n *          the image shear changes by one pixel.  To ameliorate the\n *          visual effect one can introduce random dithering.  One\n *          way to do this in a not-too-random fashion is given here.\n *          We convert to 8 bpp, do a very small blur, rotate using\n *          linear interpolation (same as area mapping), do a\n *          small amount of sharpening to compensate for the initial\n *          blur, and threshold back to binary.  The shear lines\n *          are magically removed.\n *      (3) This operation is about 5x slower than rotation by sampling.\n */",
      "file" : "rotate.c"
   },
   {
      "function" : "pixRotateBySampling",
      "comment" : "/*!\n *  pixRotateBySampling()\n *\n *      Input:  pixs (1, 2, 4, 8, 16, 32 bpp rgb; can be cmapped)\n *              xcen (x value of center of rotation)\n *              ycen (y value of center of rotation)\n *              angle (radians; clockwise is positive)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) For very small rotations, just return a clone.\n *      (2) Rotation brings either white or black pixels in\n *          from outside the image.\n *      (3) Colormaps are retained.\n */",
      "file" : "rotate.c"
   },
   {
      "function" : "pixRotateOrth",
      "comment" : "/*!\n *  pixRotateOrth()\n *\n *      Input:  pixs (all depths)\n *              quads (0-3; number of 90 degree cw rotations)\n *      Return: pixd, or null on error\n */",
      "file" : "rotateorth.c"
   },
   {
      "function" : "pixRotateShear",
      "comment" : "/*!\n *  pixRotateShear()\n *\n *      Input:  pixs\n *              xcen (x value for which there is no horizontal shear)\n *              ycen (y value for which there is no vertical shear)\n *              angle (radians)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK);\n *      Return: pixd, or null on error.\n *\n *  Notes:\n *      (1) This rotates an image about the given point, using\n *          either 2 or 3 shears.\n *      (2) A positive angle gives a clockwise rotation.\n *      (3) This brings in 'incolor' pixels from outside the image.\n *      (4) For rotation angles larger than about 0.35 radians, we issue\n *          a warning because you should probably be using another method\n *          (either sampling or area mapping)\n */",
      "file" : "rotateshear.c"
   },
   {
      "function" : "pixRotateShearCenter",
      "comment" : "/*!\n *  pixRotateShearCenter()\n *\n *      Input:  pixs\n *              angle (radians)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)\n *      Return: pixd, or null on error\n */",
      "file" : "rotateshear.c"
   },
   {
      "function" : "pixRotateShearCenterIP",
      "comment" : "/*!\n *  pixRotateShearCenterIP()\n *\n *      Input:  pixs\n *              angle (radians)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "rotateshear.c"
   },
   {
      "function" : "pixRotateShearIP",
      "comment" : "/*!\n *  pixRotateShearIP()\n *\n *      Input:  pixs (any depth; not colormapped)\n *              xcen, ycen (center of rotation)\n *              angle (radians)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This does an in-place rotation of the image about the\n *          specified point, using the 3-shear method.  It should only\n *          be used for angles smaller than LIMIT_SHEAR_ANGLE.\n *          For larger angles, a warning is issued.\n *      (2) A positive angle gives a clockwise rotation.\n *      (3) 3-shear rotation by a specified angle is equivalent\n *          to the sequential transformations\n *            y' = y + tan(angle/2) * (x - xcen)      for first y-shear\n *            x' = x + sin(angle) * (y - ycen)        for x-shear\n *            y' = y + tan(angle/2) * (x - xcen)      for second y-shear\n *      (4) Computation of tan(angle) is performed in the shear operations.\n *      (5) This brings in 'incolor' pixels from outside the image.\n *      (6) The pix cannot be colormapped, because the in-place operation\n *          only blits in 0 or 1 bits, not an arbitrary colormap index.\n */",
      "file" : "rotateshear.c"
   },
   {
      "function" : "pixRotateWithAlpha",
      "comment" : "/*!\n *  pixRotateWithAlpha()\n *\n *      Input:  pixs (32 bpp rgb or cmapped)\n *              angle (radians; clockwise is positive)\n *              pixg (<optional> 8 bpp, can be null)\n *              fract (between 0.0 and 1.0, with 0.0 fully transparent\n *                     and 1.0 fully opaque)\n *      Return: pixd (32 bpp rgba), or null on error\n *\n *  Notes:\n *      (1) The alpha channel is transformed separately from pixs,\n *          and aligns with it, being fully transparent outside the\n *          boundary of the transformed pixs.  For pixels that are fully\n *          transparent, a blending function like pixBlendWithGrayMask()\n *          will give zero weight to corresponding pixels in pixs.\n *      (2) Rotation is about the center of the image; for very small\n *          rotations, just return a clone.  The dest is automatically\n *          expanded so that no image pixels are lost.\n *      (3) Rotation is by area mapping.  It doesn't matter what\n *          color is brought in because the alpha channel will\n *          be transparent (black) there.\n *      (4) If pixg is NULL, it is generated as an alpha layer that is\n *          partially opaque, using @fract.  Otherwise, it is cropped\n *          to pixs if required and @fract is ignored.  The alpha\n *          channel in pixs is never used.\n *      (4) Colormaps are removed to 32 bpp.\n *      (5) The default setting for the border values in the alpha channel\n *          is 0 (transparent) for the outermost ring of pixels and\n *          (0.5 * fract * 255) for the second ring.  When blended over\n *          a second image, this\n *          (a) shrinks the visible image to make a clean overlap edge\n *              with an image below, and\n *          (b) softens the edges by weakening the aliasing there.\n *          Use l_setAlphaMaskBorder() to change these values.\n *      (6) A subtle use of gamma correction is to remove gamma correction\n *          before rotation and restore it afterwards.  This is done\n *          by sandwiching this function between a gamma/inverse-gamma\n *          photometric transform:\n *              pixt = pixGammaTRCWithAlpha(NULL, pixs, 1.0 / gamma, 0, 255);\n *              pixd = pixRotateWithAlpha(pixt, angle, NULL, fract);\n *              pixGammaTRCWithAlpha(pixd, pixd, gamma, 0, 255);\n *              pixDestroy(&pixt);\n *          This has the side-effect of producing artifacts in the very\n *          dark regions.\n *\n *  *** Warning: implicit assumption about RGB component ordering ***\n */",
      "file" : "rotate.c"
   },
   {
      "function" : "pixRowStats",
      "comment" : "/*!\n *  pixRowStats()\n *\n *      Input:  pixs (8 bpp; not cmapped)\n *              box (<optional> clipping box; can be null)\n *              &namean (<optional return> numa of mean values)\n *              &namedian (<optional return> numa of median values)\n *              &namode (<optional return> numa of mode intensity values)\n *              &namodecount (<optional return> numa of mode counts)\n *              &navar (<optional return> numa of variance)\n *              &narootvar (<optional return> numa of square root of variance)\n *      Return: na (numa of requested statistic for each row), or null on error\n *\n *  Notes:\n *      (1) This computes numas that represent column vectors of statistics,\n *          with each of its values derived from the corresponding row of a Pix.\n *      (2) Use NULL on input to prevent computation of any of the 5 numas.\n *      (3) Other functions that compute pixel row statistics are:\n *             pixCountPixelsByRow()\n *             pixAverageByRow()\n *             pixVarianceByRow()\n *             pixGetRowStats()\n */",
      "file" : "pix4.c"
   },
   {
      "function" : "pixRunHistogramMorph",
      "comment" : "/*!\n *  pixRunHistogramMorph()\n *\n *      Input:  pixs\n *              runtype (L_RUN_OFF, L_RUN_ON)\n *              direction (L_HORIZ, L_VERT)\n *              maxsize  (size of largest runlength counted)\n *      Return: numa of run-lengths\n */",
      "file" : "morphapp.c"
   },
   {
      "function" : "pixRunlengthTransform",
      "comment" : "/*!\n *  pixRunlengthTransform()\n *\n *      Input:   pixs (1 bpp)\n *               color (0 for white runs, 1 for black runs)\n *               direction (L_HORIZONTAL_RUNS, L_VERTICAL_RUNS)\n *               depth (8 or 16 bpp)\n *      Return:  pixd (8 or 16 bpp), or null on error\n *\n *  Notes:\n *      (1) The dest Pix is 8 or 16 bpp, with the pixel values\n *          equal to the runlength in which it is a member.\n *          The length is clipped to the max pixel value if necessary.\n *      (2) The color determines if we're labelling white or black runs.\n *      (3) A pixel that is not a member of the chosen color gets\n *          value 0; it belongs to a run of length 0 of the\n *          chosen color.\n *      (4) To convert for maximum dynamic range, either linear or\n *          log, use pixMaxDynamicRange().\n */",
      "file" : "runlength.c"
   },
   {
      "function" : "pixSauvolaBinarize",
      "comment" : "/*!\n *  pixSauvolaBinarize()\n *\n *      Input:  pixs (8 bpp grayscale; not colormapped)\n *              whsize (window half-width for measuring local statistics)\n *              factor (factor for reducing threshold due to variance; >= 0)\n *              addborder (1 to add border of width (@whsize + 1) on all sides)\n *              &pixm (<optional return> local mean values)\n *              &pixsd (<optional return> local standard deviation values)\n *              &pixth (<optional return> threshold values)\n *              &pixd (<optional return> thresholded image)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The window width and height are 2 * @whsize + 1.  The minimum\n *          value for @whsize is 2; typically it is >= 7..\n *      (2) The local statistics, measured over the window, are the\n *          average and standard deviation.\n *      (3) The measurements of the mean and standard deviation are\n *          performed inside a border of (@whsize + 1) pixels.  If pixs does\n *          not have these added border pixels, use @addborder = 1 to add\n *          it here; otherwise use @addborder = 0.\n *      (4) The Sauvola threshold is determined from the formula:\n *            t = m * (1 - k * (1 - s / 128))\n *          where:\n *            t = local threshold\n *            m = local mean\n *            k = @factor (>= 0)   [ typ. 0.35 ]\n *            s = local standard deviation, which is maximized at\n *                127.5 when half the samples are 0 and half are 255.\n *      (5) The basic idea of Niblack and Sauvola binarization is that\n *          the local threshold should be less than the median value,\n *          and the larger the variance, the closer to the median\n *          it should be chosen.  Typical values for k are between\n *          0.2 and 0.5.\n */",
      "file" : "binarize.c"
   },
   {
      "function" : "pixSauvolaBinarizeTiled",
      "comment" : "/*!\n *  pixSauvolaBinarizeTiled()\n *\n *      Input:  pixs (8 bpp grayscale, not colormapped)\n *              whsize (window half-width for measuring local statistics)\n *              factor (factor for reducing threshold due to variance; >= 0)\n *              nx, ny (subdivision into tiles; >= 1)\n *              &pixth (<optional return> Sauvola threshold values)\n *              &pixd (<optional return> thresholded image)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The window width and height are 2 * @whsize + 1.  The minimum\n *          value for @whsize is 2; typically it is >= 7..\n *      (2) For nx == ny == 1, this defaults to pixSauvolaBinarize().\n *      (3) Why a tiled version?\n *          (a) Because the mean value accumulator is a uint32, overflow\n *              can occur for an image with more than 16M pixels.\n *          (b) The mean value accumulator array for 16M pixels is 64 MB.\n *              The mean square accumulator array for 16M pixels is 128 MB.\n *              Using tiles reduces the size of these arrays.\n *          (c) Each tile can be processed independently, in parallel,\n *              on a multicore processor.\n *      (4) The Sauvola threshold is determined from the formula:\n *              t = m * (1 - k * (1 - s / 128))\n *          See pixSauvolaBinarize() for details.\n */",
      "file" : "binarize.c"
   },
   {
      "function" : "pixSauvolaGetThreshold",
      "comment" : "/*!\n *  pixSauvolaGetThreshold()\n *\n *      Input:  pixm (8 bpp grayscale; not colormapped)\n *              pixms (32 bpp)\n *              factor (factor for reducing threshold due to variance; >= 0)\n *              &pixsd (<optional return> local standard deviation)\n *      Return: pixd (8 bpp, sauvola threshold values), or null on error\n *\n *  Notes:\n *      (1) The Sauvola threshold is determined from the formula:\n *            t = m * (1 - k * (1 - s / 128))\n *          where:\n *            t = local threshold\n *            m = local mean\n *            k = @factor (>= 0)   [ typ. 0.35 ]\n *            s = local standard deviation, which is maximized at\n *                127.5 when half the samples are 0 and half are 255.\n *      (2) See pixSauvolaBinarize() for other details.\n *      (3) Important definitions and relations for computing averages:\n *            v == pixel value\n *            E(p) == expected value of p == average of p over some pixel set\n *            S(v) == square of v == v * v\n *            mv == E(v) == expected pixel value == mean value\n *            ms == E(S(v)) == expected square of pixel values\n *               == mean square value\n *            var == variance == expected square of deviation from mean\n *                == E(S(v - mv)) = E(S(v) - 2 * S(v * mv) + S(mv))\n *                                = E(S(v)) - S(mv)\n *                                = ms - mv * mv\n *            s == standard deviation = sqrt(var)\n *          So for evaluating the standard deviation in the Sauvola\n *          threshold, we take\n *            s = sqrt(ms - mv * mv)\n */",
      "file" : "binarize.c"
   },
   {
      "function" : "pixSaveTiled",
      "comment" : "/*!\n *  pixSaveTiled()\n *\n *      Input:  pixs (1, 2, 4, 8, 32 bpp)\n *              pixa (the pix are accumulated here)\n *              scalefactor (0.0 to disable; otherwise this is a scale factor)\n *              newrow (0 if placed on the same row as previous; 1 otherwise)\n *              space (horizontal and vertical spacing, in pixels)\n *              dp (depth of pixa; 8 or 32 bpp; only used on first call)\n *      Return: 0 if OK, 1 on error.\n */",
      "file" : "writefile.c"
   },
   {
      "function" : "pixSaveTiledOutline",
      "comment" : "/*!\n *  pixSaveTiledOutline()\n *\n *      Input:  pixs (1, 2, 4, 8, 32 bpp)\n *              pixa (the pix are accumulated here)\n *              scalefactor (0.0 to disable; otherwise this is a scale factor)\n *              newrow (0 if placed on the same row as previous; 1 otherwise)\n *              space (horizontal and vertical spacing, in pixels)\n *              linewidth (width of added outline for image; 0 for no outline)\n *              dp (depth of pixa; 8 or 32 bpp; only used on first call)\n *      Return: 0 if OK, 1 on error.\n *\n *  Notes:\n *      (1) Before calling this function for the first time, use\n *          pixaCreate() to make the @pixa that will accumulate the pix.\n *          This is passed in each time pixSaveTiled() is called.\n *      (2) @scalefactor scales the input image.  After scaling and\n *          possible depth conversion, the image is saved in the input\n *          pixa, along with a box that specifies the location to\n *          place it when tiled later.  Disable saving the pix by\n *          setting @scalefactor == 0.0.\n *      (3) @newrow and @space specify the location of the new pix\n *          with respect to the last one(s) that were entered.\n *      (4) @dp specifies the depth at which all pix are saved.  It can\n *          be only 8 or 32 bpp.  Any colormap is removed.  This is only\n *          used at the first invocation.\n *      (5) This function uses two variables from call to call.\n *          If they were static, the function would not be .so or thread\n *          safe, and furthermore, there would be interference with two or\n *          more pixa accumulating images at a time.  Consequently,\n *          we use the first pix in the pixa to store and obtain both\n *          the depth and the current position of the bottom (one pixel\n *          below the lowest image raster line when laid out using\n *          the boxa).  The bottom variable is stored in the input format\n *          field, which is the only field available for storing an int.\n */",
      "file" : "writefile.c"
   },
   {
      "function" : "pixSaveTiledWithText",
      "comment" : "/*!\n *  pixSaveTiledWithText()\n *\n *      Input:  pixs (1, 2, 4, 8, 32 bpp)\n *              pixa (the pix are accumulated here; as 32 bpp)\n *              outwidth (in pixels; use 0 to disable entirely)\n *              newrow (1 to start a new row; 0 to go on same row as previous)\n *              space (horizontal and vertical spacing, in pixels)\n *              linewidth (width of added outline for image; 0 for no outline)\n *              bmf (<optional> font struct)\n *              textstr (<optional> text string to be added)\n *              val (color to set the text)\n *              location (L_ADD_ABOVE, L_ADD_AT_TOP, L_ADD_AT_BOT, L_ADD_BELOW)\n *      Return: 0 if OK, 1 on error.\n *\n *  Notes:\n *      (1) Before calling this function for the first time, use\n *          pixaCreate() to make the @pixa that will accumulate the pix.\n *          This is passed in each time pixSaveTiled() is called.\n *      (2) @outwidth is the scaled width.  After scaling, the image is\n *          saved in the input pixa, along with a box that specifies\n *          the location to place it when tiled later.  Disable saving\n *          the pix by setting @outwidth == 0.\n *      (3) @newrow and @space specify the location of the new pix\n *          with respect to the last one(s) that were entered.\n *      (4) All pix are saved as 32 bpp RGB.\n *      (5) If both @bmf and @textstr are defined, this generates a pix\n *          with the additional text; otherwise, no text is written.\n *      (6) The text is written before scaling, so it is properly\n *          antialiased in the scaled pix.  However, if the pix on\n *          different calls have different widths, the size of the\n *          text will vary.\n *      (7) See pixSaveTiledOutline() for other implementation details.\n */",
      "file" : "writefile.c"
   },
   {
      "function" : "pixScale",
      "comment" : "/*!\n *  pixScale()\n *\n *      Input:  pixs (1, 2, 4, 8, 16 and 32 bpp)\n *              scalex, scaley\n *      Return: pixd, or null on error\n *\n *  This function scales 32 bpp RGB; 2, 4 or 8 bpp palette color;\n *  2, 4, 8 or 16 bpp gray; and binary images.\n *\n *  When the input has palette color, the colormap is removed and\n *  the result is either 8 bpp gray or 32 bpp RGB, depending on whether\n *  the colormap has color entries.  Images with 2, 4 or 16 bpp are\n *  converted to 8 bpp.\n *\n *  Because pixScale() is meant to be a very simple interface to a\n *  number of scaling functions, including the use of unsharp masking,\n *  the type of scaling and the sharpening parameters are chosen\n *  by default.  Grayscale and color images are scaled using one\n *  of four methods, depending on the scale factors:\n *   (1) antialiased subsampling (lowpass filtering followed by\n *       subsampling, implemented here by area mapping), for scale factors\n *       less than 0.2\n *   (2) antialiased subsampling with sharpening, for scale factors\n *       between 0.2 and 0.7\n *   (3) linear interpolation with sharpening, for scale factors between\n *       0.7 and 1.4\n *   (4) linear interpolation without sharpening, for scale factors >= 1.4.\n *\n *  One could use subsampling for scale factors very close to 1.0,\n *  because it preserves sharp edges.  Linear interpolation blurs\n *  edges because the dest pixels will typically straddle two src edge\n *  pixels.  Subsmpling removes entire columns and rows, so the edge is\n *  not blurred.  However, there are two reasons for not doing this.\n *  First, it moves edges, so that a straight line at a large angle to\n *  both horizontal and vertical will have noticable kinks where\n *  horizontal and vertical rasters are removed.  Second, although it\n *  is very fast, you get good results on sharp edges by applying\n *  a sharpening filter.\n *\n *  For images with sharp edges, sharpening substantially improves the\n *  image quality for scale factors between about 0.2 and about 2.0.\n *  pixScale() uses a small amount of sharpening by default because\n *  it strengthens edge pixels that are weak due to anti-aliasing.\n *  The default sharpening factors are:\n *      * for scaling factors < 0.7:   sharpfract = 0.2    sharpwidth = 1\n *      * for scaling factors >= 0.7:  sharpfract = 0.4    sharpwidth = 2\n *  The cases where the sharpening halfwidth is 1 or 2 have special\n *  implementations and are about twice as fast as the general case.\n *\n *  However, sharpening is computationally expensive, and one needs\n *  to consider the speed-quality tradeoff:\n *      * For upscaling of RGB images, linear interpolation plus default\n *        sharpening is about 5 times slower than upscaling alone.\n *      * For downscaling, area mapping plus default sharpening is\n *        about 10 times slower than downscaling alone.\n *  When the scale factor is larger than 1.4, the cost of sharpening,\n *  which is proportional to image area, is very large compared to the\n *  incremental quality improvement, so we cut off the default use of\n *  sharpening at 1.4.  Thus, for scale factors greater than 1.4,\n *  pixScale() only does linear interpolation.\n *\n *  In many situations you will get a satisfactory result by scaling\n *  without sharpening: call pixScaleGeneral() with @sharpfract = 0.0.\n *  Alternatively, if you wish to sharpen but not use the default\n *  value, first call pixScaleGeneral() with @sharpfract = 0.0, and\n *  then sharpen explicitly using pixUnsharpMasking().\n *\n *  Binary images are scaled to binary by sampling the closest pixel,\n *  without any low-pass filtering (averaging of neighboring pixels).\n *  This will introduce aliasing for reductions.  Aliasing can be\n *  prevented by using pixScaleToGray() instead.\n *\n *  *** Warning: implicit assumption about RGB component order\n *               for LI color scaling\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleAndTransferAlpha",
      "comment" : "/*!\n *  pixScaleAndTransferAlpha()\n *\n *      Input:  pixd  (32 bpp, scaled image)\n *              pixs  (32 bpp, original unscaled image)\n *              scalex, scaley (both > 0.0)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This scales the alpha component of pixs and inserts into pixd.\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleAreaMap",
      "comment" : "/*!\n *  pixScaleAreaMap()\n *\n *      Input:  pixs (2, 4, 8 or 32 bpp; and 2, 4, 8 bpp with colormap)\n *              scalex, scaley (must both be <= 0.7)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This function should only be used when the scale factors are less\n *          than or equal to 0.7 (i.e., more than about 1.42x reduction).\n *          If either scale factor is larger than 0.7, we issue a warning\n *          and invoke pixScale().\n *      (2) This works only on 2, 4, 8 and 32 bpp images.  If there is\n *          a colormap, it is removed by converting to RGB.  In other\n *          cases, we issue a warning and invoke pixScale().\n *      (3) It does a relatively expensive area mapping computation, to\n *          avoid antialiasing.  It is about 2x slower than pixScaleSmooth(),\n *          but the results are much better on fine text.\n *      (4) This is typically about 20% faster for the special cases of\n *          2x, 4x, 8x and 16x reduction.\n *      (5) Surprisingly, there is no speedup (and a slight quality\n *          impairment) if you do as many successive 2x reductions as\n *          possible, ending with a reduction with a scale factor larger\n *          than 0.5.\n *\n *  *** Warning: implicit assumption about RGB component ordering ***\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleAreaMap2",
      "comment" : "/*!\n *  pixScaleAreaMap2()\n *\n *      Input:  pixs (2, 4, 8 or 32 bpp; and 2, 4, 8 bpp with colormap)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This function does an area mapping (average) for 2x\n *          reduction.\n *      (2) This works only on 2, 4, 8 and 32 bpp images.  If there is\n *          a colormap, it is removed by converting to RGB.\n *      (3) Speed on 3 GHz processor:\n *             Color: 160 Mpix/sec\n *             Gray: 700 Mpix/sec\n *          This contrasts with the speed of the general pixScaleAreaMap():\n *             Color: 35 Mpix/sec\n *             Gray: 50 Mpix/sec\n *      (4) From (3), we see that this special function is about 4.5x\n *          faster for color and 14x faster for grayscale\n *      (5) Consequently, pixScaleAreaMap2() is incorporated into the\n *          general area map scaling function, for the special cases\n *          of 2x, 4x, 8x and 16x reduction.\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleBinary",
      "comment" : "/*!\n *  pixScaleBinary()\n *\n *      Input:  pixs (1 bpp)\n *              scalex, scaley (both > 0.0)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This function samples from the source without\n *          filtering.  As a result, aliasing will occur for\n *          subsampling (scalex and scaley < 1.0).\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleByIntSubsampling",
      "comment" : "/*!\n *  pixScaleByIntSubsampling()\n *\n *      Input:  pixs (1, 2, 4, 8, 16, 32 bpp)\n *              factor (integer subsampling)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Simple interface to pixScaleBySampling(), for\n *          isotropic integer reduction.\n *      (2) If @factor == 1, returns a copy.\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleBySampling",
      "comment" : "/*!\n *  pixScaleBySampling()\n *\n *      Input:  pixs (1, 2, 4, 8, 16, 32 bpp)\n *              scalex, scaley (both > 0.0)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This function samples from the source without\n *          filtering.  As a result, aliasing will occur for\n *          subsampling (@scalex and/or @scaley < 1.0).\n *      (2) If @scalex == 1.0 and @scaley == 1.0, returns a copy.\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleBySamplingToSize",
      "comment" : "/*!\n *  pixScaleBySamplingToSize()\n *\n *      Input:  pixs (1, 2, 4, 8, 16 and 32 bpp)\n *              wd  (target width; use 0 if using height as target)\n *              hd  (target height; use 0 if using width as target)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This guarantees that the output scaled image has the\n *          dimension(s) you specify.\n *           - To specify the width with isotropic scaling, set @hd = 0.\n *           - To specify the height with isotropic scaling, set @wd = 0.\n *           - If both @wd and @hd are specified, the image is scaled\n *             (in general, anisotropically) to that size.\n *           - It is an error to set both @wd and @hd to 0.\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleColor2xLI",
      "comment" : "/*!\n *  pixScaleColor2xLI()\n *\n *      Input:  pixs  (32 bpp, representing rgb)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This is a special case of linear interpolated scaling,\n *          for 2x upscaling.  It is about 8x faster than using\n *          the generic pixScaleColorLI(), and about 4x faster than\n *          using the special 2x scale function pixScaleGray2xLI()\n *          on each of the three components separately.\n *      (2) The speed on intel hardware is about\n *          80 * 10^6 dest-pixels/sec/GHz.\n *\n *  *** Warning: implicit assumption about RGB component ordering ***\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleColor4xLI",
      "comment" : "/*!\n *  pixScaleColor4xLI()\n *\n *      Input:  pixs  (32 bpp, representing rgb)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This is a special case of color linear interpolated scaling,\n *          for 4x upscaling.  It is about 3x faster than using\n *          the generic pixScaleColorLI().\n *      (2) The speed on intel hardware is about\n *          30 * 10^6 dest-pixels/sec/GHz\n *      (3) This scales each component separately, using pixScaleGray4xLI().\n *          It would be about 4x faster to inline the color code properly,\n *          in analogy to scaleColor4xLILow(), and I leave this as\n *          an exercise for someone who really needs it.\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleColorLI",
      "comment" : "/*!\n *  pixScaleColorLI()\n *\n *      Input:  pixs  (32 bpp, representing rgb)\n *              scalex, scaley (must both be >= 0.7)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) If this is used for scale factors less than 0.7,\n *          it will suffer from antialiasing.  A warning is issued.\n *          Particularly for document images with sharp edges,\n *          use pixScaleSmooth() or pixScaleAreaMap() instead.\n *      (2) For the general case, it's about 4x faster to manipulate\n *          the color pixels directly, rather than to make images\n *          out of each of the 3 components, scale each component\n *          using the pixScaleGrayLI(), and combine the results back\n *          into an rgb image.\n *      (3) The speed on intel hardware for the general case (not 2x)\n *          is about 10 * 10^6 dest-pixels/sec/GHz.  (The special 2x\n *          case runs at about 80 * 10^6 dest-pixels/sec/GHz.)\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleGeneral",
      "comment" : "/*!\n *  pixScaleGeneral()\n *\n *      Input:  pixs (1, 2, 4, 8, 16 and 32 bpp)\n *              scalex, scaley (both > 0.0)\n *              sharpfract (use 0.0 to skip sharpening)\n *              sharpwidth (halfwidth of low-pass filter; typ. 1 or 2)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) See pixScale() for usage.\n *      (2) This interface may change in the future, as other special\n *          cases are added.\n *      (3) The actual sharpening factors used depend on the maximum\n *          of the two scale factors (maxscale):\n *            maxscale <= 0.2:        no sharpening\n *            0.2 < maxscale < 1.4:   uses the input parameters\n *            maxscale >= 1.4:        no sharpening\n *      (4) To avoid sharpening for grayscale and color images with\n *          scaling factors between 0.2 and 1.4, call this function\n *          with @sharpfract == 0.0.\n *      (5) To use arbitrary sharpening in conjunction with scaling,\n *          call this function with @sharpfract = 0.0, and follow this\n *          with a call to pixUnsharpMasking() with your chosen parameters.\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleGray2xLI",
      "comment" : "/*!\n *  pixScaleGray2xLI()\n *\n *      Input:  pixs (8 bpp grayscale, not cmapped)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This is a special case of gray linear interpolated scaling,\n *          for 2x upscaling.  It is about 6x faster than using\n *          the generic pixScaleGrayLI().\n *      (2) The speed on intel hardware is about\n *          100 * 10^6 dest-pixels/sec/GHz\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleGray2xLIDither",
      "comment" : "/*!\n *  pixScaleGray2xLIDither()\n *\n *      Input:  pixs (8 bpp, not cmapped)\n *      Return: pixd (1 bpp), or null on error\n *\n *  Notes:\n *      (1) This does 2x upscale on pixs, using linear interpolation,\n *          followed by Floyd-Steinberg dithering to binary.\n *      (2) Buffers are used to avoid making a large grayscale image.\n *          - Two line buffers are used for the src, required for the 2x\n *            LI upscale.\n *          - Three line buffers are used for the intermediate image.\n *            Two are filled with each 2xLI row operation; the third is\n *            needed because the upscale and dithering ops are out of sync.\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleGray2xLIThresh",
      "comment" : "/*!\n *  pixScaleGray2xLIThresh()\n *\n *      Input:  pixs (8 bpp, not cmapped)\n *              thresh  (between 0 and 256)\n *      Return: pixd (1 bpp), or null on error\n *\n *  Notes:\n *      (1) This does 2x upscale on pixs, using linear interpolation,\n *          followed by thresholding to binary.\n *      (2) Buffers are used to avoid making a large grayscale image.\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleGray4xLI",
      "comment" : "/*!\n *  pixScaleGray4xLI()\n *\n *      Input:  pixs (8 bpp grayscale, not cmapped)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This is a special case of gray linear interpolated scaling,\n *          for 4x upscaling.  It is about 12x faster than using\n *          the generic pixScaleGrayLI().\n *      (2) The speed on intel hardware is about\n *          160 * 10^6 dest-pixels/sec/GHz.\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleGray4xLIDither",
      "comment" : "/*!\n *  pixScaleGray4xLIDither()\n *\n *      Input:  pixs (8 bpp, not cmapped)\n *      Return: pixd (1 bpp), or null on error\n *\n *  Notes:\n *      (1) This does 4x upscale on pixs, using linear interpolation,\n *          followed by Floyd-Steinberg dithering to binary.\n *      (2) Buffers are used to avoid making a large grayscale image.\n *          - Two line buffers are used for the src, required for the\n *            4xLI upscale.\n *          - Five line buffers are used for the intermediate image.\n *            Four are filled with each 4xLI row operation; the fifth\n *            is needed because the upscale and dithering ops are\n *            out of sync.\n *      (3) If a full 4x expanded grayscale image can be kept in memory,\n *          this function is only about 5% faster than separately doing\n *          a linear interpolation to a large grayscale image, followed\n *          by error-diffusion dithering to binary.\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleGray4xLIThresh",
      "comment" : "/*!\n *  pixScaleGray4xLIThresh()\n *\n *      Input:  pixs (8 bpp)\n *              thresh  (between 0 and 256)\n *      Return: pixd (1 bpp), or null on error\n *\n *  Notes:\n *      (1) This does 4x upscale on pixs, using linear interpolation,\n *          followed by thresholding to binary.\n *      (2) Buffers are used to avoid making a large grayscale image.\n *      (3) If a full 4x expanded grayscale image can be kept in memory,\n *          this function is only about 10% faster than separately doing\n *          a linear interpolation to a large grayscale image, followed\n *          by thresholding to binary.\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleGrayLI",
      "comment" : "/*!\n *  pixScaleGrayLI()\n *\n *      Input:  pixs (8 bpp grayscale, no cmap)\n *              scalex, scaley (must both be >= 0.7)\n *      Return: pixd, or null on error\n *\n *  This function is appropriate for upscaling\n *  (magnification: scale factors > 1), and for a\n *  small amount of downscaling (reduction: scale\n *  factors > 0.5).   For scale factors less than 0.5,\n *  the best result is obtained by area mapping,\n *  but this is very expensive.  So for such large\n *  reductions, it is more appropriate to do low pass\n *  filtering followed by subsampling, a combination\n *  which is effectively a cheap form of area mapping.\n *\n *  Some details follow.\n *\n *  For each pixel in the dest, this does a linear\n *  interpolation of 4 neighboring pixels in the src.\n *  Specifically, consider the UL corner of src and\n *  dest pixels.  The UL corner of the dest falls within\n *  a src pixel, whose four corners are the UL corners\n *  of 4 adjacent src pixels.  The value of the dest\n *  is taken by linear interpolation using the values of\n *  the four src pixels and the distance of the UL corner\n *  of the dest from each corner.\n *\n *  If the image is expanded so that the dest pixel is\n *  smaller than the src pixel, such interpolation\n *  is a reasonable approach.  This interpolation is\n *  also good for a small image reduction factor that\n *  is not more than a 2x reduction.\n *\n *  Note that the linear interpolation algorithm for scaling\n *  is identical in form to the area-mapping algorithm\n *  for grayscale rotation.  The latter corresponds to a\n *  translation of each pixel without scaling.\n *\n *  This function is NOT optimal if the scaling involves\n *  a large reduction.    If the image is significantly\n *  reduced, so that the dest pixel is much larger than\n *  the src pixels, this interpolation, which is over src\n *  pixels only near the UL corner of the dest pixel,\n *  is not going to give a good area-mapping average.\n *  Because area mapping for image scaling is considerably\n *  more computationally intensive than linear interpolation,\n *  we choose not to use it.   For large image reduction,\n *  linear interpolation over adjacent src pixels\n *  degenerates asymptotically to subsampling.  But\n *  subsampling without a low-pass pre-filter causes\n *  aliasing by the nyquist theorem.  To avoid aliasing,\n *  a low-pass filter (e.g., an averaging filter) of\n *  size roughly equal to the dest pixel (i.e., the\n *  reduction factor) should be applied to the src before\n *  subsampling.\n *\n *  As an alternative to low-pass filtering and subsampling\n *  for large reduction factors, linear interpolation can\n *  also be done between the (widely separated) src pixels in\n *  which the corners of the dest pixel lie.  This also is\n *  not optimal, as it samples src pixels only near the\n *  corners of the dest pixel, and it is not implemented.\n *\n *  Summary:\n *    (1) If this is used for scale factors less than 0.7,\n *        it will suffer from antialiasing.  A warning is issued.\n *        Particularly for document images with sharp edges,\n *        use pixScaleSmooth() or pixScaleAreaMap() instead.\n *    (2) The speed on intel hardware for the general case (not 2x)\n *        is about 13 * 10^6 dest-pixels/sec/GHz.  (The special 2x\n *        case runs at about 100 * 10^6 dest-pixels/sec/GHz.)\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleGrayMinMax",
      "comment" : "/*!\n *  pixScaleGrayMinMax()\n *\n *      Input:  pixs (8 bpp, not cmapped)\n *              xfact (x downscaling factor; integer)\n *              yfact (y downscaling factor; integer)\n *              type (L_CHOOSE_MIN, L_CHOOSE_MAX, L_CHOOSE_MAX_MIN_DIFF)\n *      Return: pixd (8 bpp)\n *\n *  Notes:\n *      (1) The downscaled pixels in pixd are the min, max or (max - min)\n *          of the corresponding set of xfact * yfact pixels in pixs.\n *      (2) Using L_CHOOSE_MIN is equivalent to a grayscale erosion,\n *          using a brick Sel of size (xfact * yfact), followed by\n *          subsampling within each (xfact * yfact) cell.  Using\n *          L_CHOOSE_MAX is equivalent to the corresponding dilation.\n *      (3) Using L_CHOOSE_MAX_MIN_DIFF finds the difference between max\n *          and min values in each cell.\n *      (4) For the special case of downscaling by 2x in both directions,\n *          pixScaleGrayMinMax2() is about 2x more efficient.\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleGrayMinMax2",
      "comment" : "/*!\n *  pixScaleGrayMinMax2()\n *\n *      Input:  pixs (8 bpp, not cmapped)\n *              type (L_CHOOSE_MIN, L_CHOOSE_MAX, L_CHOOSE_MAX_MIN_DIFF)\n *      Return: pixd (8 bpp downscaled by 2x)\n *\n *  Notes:\n *      (1) Special version for 2x reduction.  The downscaled pixels\n *          in pixd are the min, max or (max - min) of the corresponding\n *          set of 4 pixels in pixs.\n *      (2) The max and min operations are a special case (for levels 1\n *          and 4) of grayscale analog to the binary rank scaling operation\n *          pixReduceRankBinary2().  Note, however, that because of\n *          the photometric definition that higher gray values are\n *          lighter, the erosion-like L_CHOOSE_MIN will darken\n *          the resulting image, corresponding to a threshold level 1\n *          in the binary case.  Likewise, L_CHOOSE_MAX will lighten\n *          the pixd, corresponding to a threshold level of 4.\n *      (3) To choose any of the four rank levels in a 2x grayscale\n *          reduction, use pixScaleGrayRank2().\n *      (4) This runs at about 70 MPix/sec/GHz of source data for\n *          erosion and dilation.\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleGrayRank2",
      "comment" : "/*!\n *  pixScaleGrayRank2()\n *\n *      Input:  pixs (8 bpp, no cmap)\n *              rank (1 (darkest), 2, 3, 4 (lightest))\n *      Return: pixd (8 bpp, downscaled by 2x)\n *\n *  Notes:\n *      (1) Rank 2x reduction.  If rank == 1(4), the downscaled pixels\n *          in pixd are the min(max) of the corresponding set of\n *          4 pixels in pixs.  Values 2 and 3 are intermediate.\n *      (2) This is the grayscale analog to the binary rank scaling operation\n *          pixReduceRankBinary2().  Here, because of the photometric\n *          definition that higher gray values are lighter, rank 1 gives\n *          the darkest pixel, whereas rank 4 gives the lightest pixel.\n *          This is opposite to the binary rank operation.\n *      (3) For rank = 1 and 4, this calls pixScaleGrayMinMax2(),\n *          which runs at about 70 MPix/sec/GHz of source data.\n *          For rank 2 and 3, this runs 3x slower, at about 25 MPix/sec/GHz.\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleGrayRankCascade",
      "comment" : "/*!\n *  pixScaleGrayRankCascade()\n *\n *      Input:  pixs (8 bpp, not cmapped)\n *              level1, ... level4 (rank thresholds, in set {0, 1, 2, 3, 4})\n *      Return: pixd (8 bpp, downscaled by up to 16x)\n *\n *  Notes:\n *      (1) This performs up to four cascaded 2x rank reductions.\n *      (2) Use level = 0 to truncate the cascade.\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleGrayToBinaryFast",
      "comment" : "/*!\n *  pixScaleGrayToBinaryFast()\n *\n *      Input:  pixs (8 bpp grayscale)\n *              factor (integer reduction factor >= 1)\n *              thresh (binarization threshold)\n *      Return: pixd (1 bpp), or null on error\n *\n *  Notes:\n *      (1) This does simultaneous subsampling by an integer factor and\n *          thresholding from gray to binary.\n *      (2) It is designed for maximum speed, and is used for quickly\n *          generating a downsized binary image from a higher resolution\n *          gray image.  This would typically be used for image analysis.\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleLI",
      "comment" : "/*!\n *  pixScaleLI()\n *\n *      Input:  pixs (2, 4, 8 or 32 bpp; with or without colormap)\n *              scalex, scaley (must both be >= 0.7)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This function should only be used when the scale factors are\n *          greater than or equal to 0.7, and typically greater than 1.\n *          If either scale factor is smaller than 0.7, we issue a warning\n *          and invoke pixScale().\n *      (2) This works on 2, 4, 8, 16 and 32 bpp images, as well as on\n *          2, 4 and 8 bpp images that have a colormap.  If there is a\n *          colormap, it is removed to either gray or RGB, depending\n *          on the colormap.\n *      (3) This does a linear interpolation on the src image.\n *      (4) It dispatches to much faster implementations for\n *          the special cases of 2x and 4x expansion.\n *\n *  *** Warning: implicit assumption about RGB component ordering ***\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleMipmap",
      "comment" : "/*!\n *  pixScaleMipmap()\n *\n *      Input:  pixs1 (high res 8 bpp, no cmap)\n *              pixs2 (low res -- 2x reduced -- 8 bpp, no cmap)\n *              scale (reduction with respect to high res image, > 0.5)\n *      Return: 8 bpp pix, scaled down by reduction in each direction,\n *              or NULL on error.\n *\n *  Notes:\n *      (1) See notes in pixScaleToGrayMipmap().\n *      (2) This function suffers from aliasing effects that are\n *          easily seen in document images.\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleRGBToBinaryFast",
      "comment" : "/*!\n *  pixScaleRGBToBinaryFast()\n *\n *      Input:  pixs (32 bpp RGB)\n *              factor (integer reduction factor >= 1)\n *              thresh (binarization threshold)\n *      Return: pixd (1 bpp), or null on error\n *\n *  Notes:\n *      (1) This does simultaneous subsampling by an integer factor and\n *          conversion from RGB to gray to binary.\n *      (2) It is designed for maximum speed, and is used for quickly\n *          generating a downsized binary image from a higher resolution\n *          RGB image.  This would typically be used for image analysis.\n *      (3) It uses the green channel to represent the RGB pixel intensity.\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleRGBToGray2",
      "comment" : "/*!\n *  pixScaleRGBToGray2()\n *\n *      Input:  pixs (32 bpp rgb)\n *              rwt, gwt, bwt (must sum to 1.0)\n *      Return: pixd, (8 bpp, 2x reduced), or null on error\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleRGBToGrayFast",
      "comment" : "/*!\n *  pixScaleRGBToGrayFast()\n *\n *      Input:  pixs (32 bpp rgb)\n *              factor (integer reduction factor >= 1)\n *              color (one of COLOR_RED, COLOR_GREEN, COLOR_BLUE)\n *      Return: pixd (8 bpp), or null on error\n *\n *  Notes:\n *      (1) This does simultaneous subsampling by an integer factor and\n *          extraction of the color from the RGB pix.\n *      (2) It is designed for maximum speed, and is used for quickly\n *          generating a downsized grayscale image from a higher resolution\n *          RGB image.  This would typically be used for image analysis.\n *      (3) The standard color byte order (RGBA) is assumed.\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleResolution",
      "comment" : "/* no-op */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixScaleSmooth",
      "comment" : "/*!\n *  pixScaleSmooth()\n *\n *      Input:  pixs (2, 4, 8 or 32 bpp; and 2, 4, 8 bpp with colormap)\n *              scalex, scaley (must both be < 0.7)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This function should only be used when the scale factors are less\n *          than or equal to 0.7 (i.e., more than about 1.42x reduction).\n *          If either scale factor is larger than 0.7, we issue a warning\n *          and invoke pixScale().\n *      (2) This works only on 2, 4, 8 and 32 bpp images, and if there is\n *          a colormap, it is removed by converting to RGB.  In other\n *          cases, we issue a warning and invoke pixScale().\n *      (3) It does simple (flat filter) convolution, with a filter size\n *          commensurate with the amount of reduction, to avoid antialiasing.\n *      (4) It does simple subsampling after smoothing, which is appropriate\n *          for this range of scaling.  Linear interpolation gives essentially\n *          the same result with more computation for these scale factors,\n *          so we don't use it.\n *      (5) The result is the same as doing a full block convolution followed by\n *          subsampling, but this is faster because the results of the block\n *          convolution are only computed at the subsampling locations.\n *          In fact, the computation time is approximately independent of\n *          the scale factor, because the convolution kernel is adjusted\n *          so that each source pixel is summed approximately once.\n *\n *  *** Warning: implicit assumption about RGB component ordering ***\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleToGray",
      "comment" : "/*!\n *  pixScaleToGray()\n *\n *      Input:  pixs (1 bpp)\n *              scalefactor (reduction: must be > 0.0 and < 1.0)\n *      Return: pixd (8 bpp), scaled down by scalefactor in each direction,\n *              or NULL on error.\n *\n *  Notes:\n *\n *  For faster scaling in the range of scalefactors from 0.0625 to 0.5,\n *  with very little difference in quality, use pixScaleToGrayFast().\n *\n *  Binary images have sharp edges, so they intrinsically have very\n *  high frequency content.  To avoid aliasing, they must be low-pass\n *  filtered, which tends to blur the edges.  How can we keep relatively\n *  crisp edges without aliasing?  The trick is to do binary upscaling\n *  followed by a power-of-2 scaleToGray.  For large reductions, where\n *  you don't end up with much detail, some corners can be cut.\n *\n *  The intent here is to get high quality reduced grayscale\n *  images with relatively little computation.  We do binary\n *  pre-scaling followed by scaleToGrayN() for best results,\n *  esp. to avoid excess blur when the scale factor is near\n *  an inverse power of 2.  Where a low-pass filter is required,\n *  we use simple convolution kernels: either the hat filter for\n *  linear interpolation or a flat filter for larger downscaling.\n *  Other choices, such as a perfect bandpass filter with infinite extent\n *  (the sinc) or various approximations to it (e.g., lanczos), are\n *  unnecessarily expensive.\n *\n *  The choices made are as follows:\n *      (1) Do binary upscaling before scaleToGrayN() for scalefactors > 1/8\n *      (2) Do binary downscaling before scaleToGray8() for scalefactors\n *          between 1/16 and 1/8.\n *      (3) Use scaleToGray16() before grayscale downscaling for\n *          scalefactors less than 1/16\n *  Another reasonable choice would be to start binary downscaling\n *  for scalefactors below 1/4, rather than below 1/8 as we do here.\n *\n *  The general scaling rules, not all of which are used here, go as follows:\n *      (1) For grayscale upscaling, use pixScaleGrayLI().  However,\n *          note that edges will be visibly blurred for scalefactors\n *          near (but above) 1.0.  Replication will avoid edge blur,\n *          and should be considered for factors very near 1.0.\n *      (2) For grayscale downscaling with a scale factor larger than\n *          about 0.7, use pixScaleGrayLI().  For scalefactors near\n *          (but below) 1.0, you tread between Scylla and Charybdis.\n *          pixScaleGrayLI() again gives edge blurring, but\n *          pixScaleBySampling() gives visible aliasing.\n *      (3) For grayscale downscaling with a scale factor smaller than\n *          about 0.7, use pixScaleSmooth()\n *      (4) For binary input images, do as much scale to gray as possible\n *          using the special integer functions (2, 3, 4, 8 and 16).\n *      (5) It is better to upscale in binary, followed by scaleToGrayN()\n *          than to do scaleToGrayN() followed by an upscale using either\n *          LI or oversampling.\n *      (6) It may be better to downscale in binary, followed by\n *          scaleToGrayN() than to first use scaleToGrayN() followed by\n *          downscaling.  For downscaling between 8x and 16x, this is\n *          a reasonable option.\n *      (7) For reductions greater than 16x, it's reasonable to use\n *          scaleToGray16() followed by further grayscale downscaling.\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleToGray16",
      "comment" : "/*!\n *  pixScaleToGray16()\n *\n *      Input:  pixs (1 bpp)\n *      Return: pixd (8 bpp), scaled down by 16x in each direction,\n *              or null on error.\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleToGray2",
      "comment" : "/*!\n *  pixScaleToGray2()\n *\n *      Input:  pixs (1 bpp)\n *      Return: pixd (8 bpp), scaled down by 2x in each direction,\n *              or null on error.\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleToGray3",
      "comment" : "/*!\n *  pixScaleToGray3()\n *\n *      Input:  pixs (1 bpp)\n *      Return: pixd (8 bpp), scaled down by 3x in each direction,\n *              or null on error.\n *\n *  Notes:\n *      (1) Speed is about 100 x 10^6 src-pixels/sec/GHz.\n *          Another way to express this is it processes 1 src pixel\n *          in about 10 cycles.\n *      (2) The width of pixd is truncated is truncated to a factor of 8.\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleToGray4",
      "comment" : "/*!\n *  pixScaleToGray4()\n *\n *      Input:  pixs (1 bpp)\n *      Return: pixd (8 bpp), scaled down by 4x in each direction,\n *              or null on error.\n *\n *  Notes:\n *      (1) The width of pixd is truncated is truncated to a factor of 2.\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleToGray6",
      "comment" : "/*!\n *  pixScaleToGray6()\n *\n *      Input:  pixs (1 bpp)\n *      Return: pixd (8 bpp), scaled down by 6x in each direction,\n *              or null on error.\n *\n *  Notes:\n *      (1) The width of pixd is truncated is truncated to a factor of 8.\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleToGray8",
      "comment" : "/*!\n *  pixScaleToGray8()\n *\n *      Input:  pixs (1 bpp)\n *      Return: pixd (8 bpp), scaled down by 8x in each direction,\n *              or null on error\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleToGrayFast",
      "comment" : "/*!\n *  pixScaleToGrayFast()\n *\n *      Input:  pixs (1 bpp)\n *              scalefactor (reduction: must be > 0.0 and < 1.0)\n *      Return: pixd (8 bpp), scaled down by scalefactor in each direction,\n *              or NULL on error.\n *\n *  Notes:\n *      (1) See notes in pixScaleToGray() for the basic approach.\n *      (2) This function is considerably less expensive than pixScaleToGray()\n *          for scalefactor in the range (0.0625 ... 0.5), and the\n *          quality is nearly as good.\n *      (3) Unlike pixScaleToGray(), which does binary upscaling before\n *          downscaling for scale factors >= 0.0625, pixScaleToGrayFast()\n *          first downscales in binary for all scale factors < 0.5, and\n *          then does a 2x scale-to-gray as the final step.  For\n *          scale factors < 0.0625, both do a 16x scale-to-gray, followed\n *          by further grayscale reduction.\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleToGrayMipmap",
      "comment" : "/*!\n *  pixScaleToGrayMipmap()\n *\n *      Input:  pixs (1 bpp)\n *              scalefactor (reduction: must be > 0.0 and < 1.0)\n *      Return: pixd (8 bpp), scaled down by scalefactor in each direction,\n *              or NULL on error.\n *\n *  Notes:\n *\n *  This function is here mainly for pedagogical reasons.\n *  Mip-mapping is widely used in graphics for texture mapping, because\n *  the texture changes smoothly with scale.  This is accomplished by\n *  constructing a multiresolution pyramid and, for each pixel,\n *  doing a linear interpolation between corresponding pixels in\n *  the two planes of the pyramid that bracket the desired resolution.\n *  The computation is very efficient, and is implemented in hardware\n *  in high-end graphics cards.\n *\n *  We can use mip-mapping for scale-to-gray by using two scale-to-gray\n *  reduced images (we don't need the entire pyramid) selected from\n *  the set {2x, 4x, ... 16x}, and interpolating.  However, we get\n *  severe aliasing, probably because we are subsampling from the\n *  higher resolution image.  The method is very fast, but the result\n *  is very poor.  In fact, the results don't look any better than\n *  either subsampling off the higher-res grayscale image or oversampling\n *  on the lower-res image.  Consequently, this method should NOT be used\n *  for generating reduced images, scale-to-gray or otherwise.\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleToSize",
      "comment" : "/*!\n *  pixScaleToSize()\n *\n *      Input:  pixs (1, 2, 4, 8, 16 and 32 bpp)\n *              wd  (target width; use 0 if using height as target)\n *              hd  (target height; use 0 if using width as target)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This guarantees that the output scaled image has the\n *          dimension(s) you specify.\n *           - To specify the width with isotropic scaling, set @hd = 0.\n *           - To specify the height with isotropic scaling, set @wd = 0.\n *           - If both @wd and @hd are specified, the image is scaled\n *             (in general, anisotropically) to that size.\n *           - It is an error to set both @wd and @hd to 0.\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScaleWithAlpha",
      "comment" : "/*!\n *  pixScaleWithAlpha()\n *\n *      Input:  pixs (32 bpp rgb or cmapped)\n *              scalex, scaley (must be > 0.0)\n *              pixg (<optional> 8 bpp, can be null)\n *              fract (between 0.0 and 1.0, with 0.0 fully transparent\n *                     and 1.0 fully opaque)\n *      Return: pixd (32 bpp rgba), or null on error\n *\n *  Notes:\n *      (1) The alpha channel is transformed separately from pixs,\n *          and aligns with it, being fully transparent outside the\n *          boundary of the transformed pixs.  For pixels that are fully\n *          transparent, a blending function like pixBlendWithGrayMask()\n *          will give zero weight to corresponding pixels in pixs.\n *      (2) Scaling is done with area mapping or linear interpolation,\n *          depending on the scale factors.  Default sharpening is done.\n *      (3) If pixg is NULL, it is generated as an alpha layer that is\n *          partially opaque, using @fract.  Otherwise, it is cropped\n *          to pixs if required, and @fract is ignored.  The alpha\n *          channel in pixs is never used.\n *      (4) Colormaps are removed to 32 bpp.\n *      (5) The default setting for the border values in the alpha channel\n *          is 0 (transparent) for the outermost ring of pixels and\n *          (0.5 * fract * 255) for the second ring.  When blended over\n *          a second image, this\n *          (a) shrinks the visible image to make a clean overlap edge\n *              with an image below, and\n *          (b) softens the edges by weakening the aliasing there.\n *          Use l_setAlphaMaskBorder() to change these values.\n *      (6) A subtle use of gamma correction is to remove gamma correction\n *          before scaling and restore it afterwards.  This is done\n *          by sandwiching this function between a gamma/inverse-gamma\n *          photometric transform:\n *              pixt = pixGammaTRCWithAlpha(NULL, pixs, 1.0 / gamma, 0, 255);\n *              pixd = pixScaleWithAlpha(pixt, scalex, scaley, NULL, fract);\n *              pixGammaTRCWithAlpha(pixd, pixd, gamma, 0, 255);\n *              pixDestroy(&pixt);\n *          This has the side-effect of producing artifacts in the very\n *          dark regions.\n *\n *  *** Warning: implicit assumption about RGB component ordering ***\n */",
      "file" : "scale.c"
   },
   {
      "function" : "pixScanForEdge",
      "comment" : "/*!\n *  pixScanForEdge()\n *\n *      Input:  pixs (1 bpp)\n *              box  (<optional> within which the search is conducted)\n *              lowthresh (threshold to choose clipping location)\n *              highthresh (threshold required to find an edge)\n *              maxwidth (max allowed width between low and high thresh locs)\n *              factor (sampling factor along pixel counting direction)\n *              scanflag (direction of scan; e.g., L_FROM_LEFT)\n *              &loc (location in scan direction of first black pixel)\n *      Return: 0 if OK; 1 on error or if the edge is not found\n *\n *  Notes:\n *      (1) If there are no fg pixels, the position is set to 0.\n *          Caller must check the return value!\n *      (2) Use @box == NULL to scan from edge of pixs\n *      (3) As the scan progresses, the location where the sum of\n *          pixels equals or excees @lowthresh is noted (loc).  The\n *          scan is stopped when the sum of pixels equals or exceeds\n *          @highthresh.  If the scan distance between loc and that\n *          point does not exceed @maxwidth, an edge is found and\n *          its position is taken to be loc.  @maxwidth implicitly\n *          sets a minimum on the required gradient of the edge.\n *      (4) The thresholds must be at least 1, and the low threshold\n *          cannot be larger than the high threshold.\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixScanForForeground",
      "comment" : "/*!\n *  pixScanForForeground()\n *\n *      Input:  pixs (1 bpp)\n *              box  (<optional> within which the search is conducted)\n *              scanflag (direction of scan; e.g., L_FROM_LEFT)\n *              &loc (location in scan direction of first black pixel)\n *      Return: 0 if OK; 1 on error or if no fg pixels are found\n *\n *  Notes:\n *      (1) If there are no fg pixels, the position is set to 0.\n *          Caller must check the return value!\n *      (2) Use @box == NULL to scan from edge of pixs\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixSearchBinaryMaze",
      "comment" : "/*!\n *  pixSearchBinaryMaze()\n *\n *      Input:  pixs (1 bpp, maze)\n *              xi, yi  (beginning point; use same initial point\n *                       that was used to generate the maze)\n *              xf, yf  (end point, or close to it)\n *              &ppixd (<optional return> maze with path illustrated, or\n *                     if no path possible, the part of the maze\n *                     that was searched)\n *      Return: pta (shortest path), or null if either no path\n *              exists or on error\n *\n *  Notes:\n *      (1) Because of the overhead in calling pixGetPixel() and\n *          pixSetPixel(), we have used raster line pointers and the\n *          GET_DATA* and SET_DATA* macros for many of the pix accesses.\n *      (2) Commentary:\n *            The goal is to find the shortest path between beginning and\n *          end points, without going through walls, and there are many\n *          ways to solve this problem.\n *            We use a queue to implement a breadth-first search.  Two auxiliary\n *          \"image\" data structures can be used: one to mark the visited\n *          pixels and one to give the direction to the parent for each\n *          visited pixels.  The first structure is used to avoid putting\n *          pixels on the queue more than once, and the second is used\n *          for retracing back to the origin, like the breadcrumbs in\n *          Hansel and Gretel.  Each pixel taken off the queue is destroyed\n *          after it is used to locate the allowed neighbors.  In fact,\n *          only one distance image is required, if you initialize it\n *          to some value that signifies \"not yet visited.\"  (We use\n *          a binary image for marking visited pixels because it is clearer.)\n *          This method for a simple search of a binary maze is implemented in\n *          searchBinaryMaze().\n *            An alternative method would store the (manhattan) distance\n *          from the start point with each pixel on the queue.  The children\n *          of each pixel get a distance one larger than the parent.  These\n *          values can be stored in an auxiliary distance map image\n *          that is constructed simultaneously with the search.  Once the\n *          end point is reached, the distance map is used to backtrack\n *          along a minimum path.  There may be several equal length\n *          minimum paths, any one of which can be chosen this way.\n */",
      "file" : "maze.c"
   },
   {
      "function" : "pixSearchForRectangle",
      "comment" : "/*!\n *  pixSearchForRectangle()\n *\n *      Input:  pixs (1 bpp)\n *              boxs (current region to investigate)\n *              minsum  (minimum pixels to trigger propagation)\n *              skipdist (distance before computing sum for propagation)\n *              delta (difference required to stop propagation)\n *              maxbg (maximum number of allowed bg pixels in ref scan)\n *              sideflag (side to search from)\n *              boxat (add result of rectangular region found here)\n *              nascore (add score for this rectangle here)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) See pixSplitComponentIntoBoxa() for an explanation of the algorithm.\n *          This does the sweep from a single side.  For each iteration\n *          in pixSplitComponentIntoBoxa(), this will be called 4 times,\n *          for @sideflag = {0, 1, 2, 3}.\n *      (2) If a valid rectangle is not found, add a score of 0 and\n *          input a minimum box.\n */",
      "file" : "boxfunc3.c"
   },
   {
      "function" : "pixSearchGrayMaze",
      "comment" : "/*!\n *  pixSearchGrayMaze()\n *\n *      Input:  pixs (1 bpp, maze)\n *              xi, yi  (beginning point; use same initial point\n *                       that was used to generate the maze)\n *              xf, yf  (end point, or close to it)\n *              &ppixd (<optional return> maze with path illustrated, or\n *                     if no path possible, the part of the maze\n *                     that was searched)\n *      Return: pta (shortest path), or null if either no path\n *              exists or on error\n *\n *  Commentary:\n *      Consider first a slight generalization of the binary maze\n *      search problem.  Suppose that you can go through walls,\n *      but the cost is higher (say, an increment of 3 to go into\n *      a wall pixel rather than 1)?  You're still trying to find\n *      the shortest path.  One way to do this is with an ordered\n *      queue, and a simple way to visualize an ordered queue is as\n *      a set of stacks, each stack being marked with the distance\n *      of each pixel in the stack from the start.  We place the\n *      start pixel in stack 0, pop it, and process its 4 children.\n *      Each pixel is given a distance that is incremented from that\n *      of its parent (0 in this case), depending on if it is a wall\n *      pixel or not.  That value may be recorded on a distance map,\n *      according to the algorithm below.  For children of the first\n *      pixel, those not on a wall go in stack 1, and wall\n *      children go in stack 3.  Stack 0 being emptied, the process\n *      then continues with pixels being popped from stack 1.\n *      Here is the algorithm for each child pixel.  The pixel's\n *      distance value, were it to be placed on a stack, is compared\n *      with the value for it that is on the distance map.  There\n *      are three possible cases:\n *         (1) If the pixel has not yet been registered, it is pushed\n *             on its stack and the distance is written to the map.\n *         (2) If it has previously been registered with a higher distance,\n *             the distance on the map is relaxed to that of the\n *             current pixel, which is then placed on its stack.\n *         (3) If it has previously been registered with an equal\n *             or lower value, the pixel is discarded.\n *      The pixels are popped and processed successively from\n *      stack 1, and when stack 1 is empty, popping starts on stack 2.\n *      This continues until the destination pixel is popped off\n *      a stack.   The minimum path is then derived from the distance map,\n *      going back from the end point as before.  This is just Dijkstra's\n *      algorithm for a directed graph; here, the underlying graph\n *      (consisting of the pixels and four edges connecting each pixel\n *      to its 4-neighbor) is a special case of a directed graph, where\n *      each edge is bi-directional.  The implementation of this generalized\n *      maze search is left as an exercise to the reader.\n *\n *      Let's generalize a bit further.  Suppose the \"maze\" is just\n *      a grayscale image -- think of it as an elevation map.  The cost\n *      of moving on this surface depends on the height, or the gradient,\n *      or whatever you want.  All that is required is that the cost\n *      is specified and non-negative on each link between adjacent\n *      pixels.  Now the problem becomes: find the least cost path\n *      moving on this surface between two specified end points.\n *      For example, if the cost across an edge between two pixels\n *      depends on the \"gradient\", you can use:\n *           cost = 1 + L_ABS(deltaV)\n *      where deltaV is the difference in value between two adjacent\n *      pixels.  If the costs are all integers, we can still use an array\n *      of stacks to avoid ordering the queue (e.g., by using a heap sort.)\n *      This is a neat problem, because you don't even have to build a\n *      maze -- you can can use it on any grayscale image!\n *\n *      Rather than using an array of stacks, a more practical\n *      approach is to implement with a priority queue, which is\n *      a queue that is sorted so that the elements with the largest\n *      (or smallest) key values always come off first.  The\n *      priority queue is efficiently implemented as a heap, and\n *      this is how we do it.  Suppose you run the algorithm\n *      using a priority queue, doing the bookkeeping with an\n *      auxiliary image data structure that saves the distance of\n *      each pixel put on the queue as before, according to the method\n *      described above.  We implement it as a 2-way choice by\n *      initializing the distance array to a large value and putting\n *      a pixel on the queue if its distance is less than the value\n *      found on the array.  When you finally pop the end pixel from\n *      the queue, you're done, and you can trace the path backward,\n *      either always going downhill or using an auxiliary image to\n *      give you the direction to go at each step.  This is implemented\n *      here in searchGrayMaze().\n *\n *      Do we really have to use a sorted queue?  Can we solve this\n *      generalized maze with an unsorted queue of pixels?  (Or even\n *      an unsorted stack, doing a depth-first search (DFS)?)\n *      Consider a different algorithm for this generalized maze, where\n *      we travel again breadth first, but this time use a single,\n *      unsorted queue.  An auxiliary image is used as before to\n *      store the distances and to determine if pixels get pushed\n *      on the stack or dropped.  As before, we must allow pixels\n *      to be revisited, with relaxation of the distance if a shorter\n *      path arrives later.  As a result, we will in general have\n *      multiple instances of the same pixel on the stack with different\n *      distances.  However, because the queue is not ordered, some of\n *      these pixels will be popped when another instance with a lower\n *      distance is still on the stack.  Here, we're just popping them\n *      in the order they go on, rather than setting up a priority\n *      based on minimum distance.  Thus, unlike the priority queue,\n *      when a pixel is popped we have to check the distance map to\n *      see if a pixel with a lower distance has been put on the queue,\n *      and, if so, we discard the pixel we just popped.  So the\n *      \"while\" loop looks like this:\n *        - pop a pixel from the queue\n *        - check its distance against the distance stored in the\n *          distance map; if larger, discard\n *        - otherwise, for each of its neighbors:\n *            - compute its distance from the start pixel\n *            - compare this distance with that on the distance map:\n *                - if the distance map value higher, relax the distance\n *                  and push the pixel on the queue\n *                - if the distance map value is lower, discard the pixel\n *\n *      How does this loop terminate?  Before, with an ordered queue,\n *      it terminates when you pop the end pixel.  But with an unordered\n *      queue (or stack), the first time you hit the end pixel, the\n *      distance is not guaranteed to be correct, because the pixels\n *      along the shortest path may not have yet been visited and relaxed.\n *      Because the shortest path can theoretically go anywhere,\n *      we must keep going.  How do we know when to stop?   Dijkstra\n *      uses an ordered queue to systematically remove nodes from\n *      further consideration.  (Each time a pixel is popped, we're\n *      done with it; it's \"finalized\" in the Dijkstra sense because\n *      we know the shortest path to it.)  However, with an unordered\n *      queue, the brute force answer is: stop when the queue\n *      (or stack) is empty, because then every pixel in the image\n *      has been assigned its minimum \"distance\" from the start pixel.\n *\n *      This is similar to the situation when you use a stack for the\n *      simpler uniform-step problem: with breadth-first search (BFS)\n *      the pixels on the queue are automatically ordered, so you are\n *      done when you locate the end pixel as a neighbor of a popped pixel;\n *      whereas depth-first search (DFS), using a stack, requires,\n *      in general, a search of every accessible pixel.  Further, if\n *      a pixel is revisited with a smaller distance, that distance is\n *      recorded and the pixel is put on the stack again.\n *\n *      But surely, you ask, can't we stop sooner?  What if the\n *      start and end pixels are very close to each other?\n *      OK, suppose they are, and you have very high walls and a\n *      long snaking level path that is actually the minimum cost.\n *      That long path can wind back and forth across the entire\n *      maze many times before ending up at the end point, which\n *      could be just over a wall from the start.  With the unordered\n *      queue, you very quickly get a high distance for the end\n *      pixel, which will be relaxed to the minimum distance only\n *      after all the pixels of the path have been visited and placed\n *      on the queue, multiple times for many of them.  So that's the\n *      price for not ordering the queue!\n */",
      "file" : "maze.c"
   },
   {
      "function" : "pixSeedfill",
      "comment" : "/*!\n *  pixSeedfill()\n *\n *      Input:  pixs (1 bpp)\n *              stack (for holding fillsegs)\n *              x,y   (location of seed pixel)\n *              connectivity  (4 or 8)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This removes the component from pixs with a fg pixel at (x,y).\n *      (2) See pixSeedfill4() and pixSeedfill8() for details.\n */",
      "file" : "conncomp.c"
   },
   {
      "function" : "pixSeedfill4",
      "comment" : "/*!\n *  pixSeedfill4()\n *\n *      Input:  pixs (1 bpp)\n *              stack (for holding fillsegs)\n *              x,y   (location of seed pixel)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is Paul Heckbert's stack-based 4-cc seedfill algorithm.\n *      (2) This operates on the input 1 bpp pix to remove the fg seed\n *          pixel, at (x,y), and all pixels that are 4-connected to it.\n *          The seed pixel at (x,y) must initially be ON.\n *      (3) Reference: see pixSeedFill4BB()\n */",
      "file" : "conncomp.c"
   },
   {
      "function" : "pixSeedfill4BB",
      "comment" : "/*!\n *  pixSeedfill4BB()\n *\n *      Input:  pixs (1 bpp)\n *              stack (for holding fillsegs)\n *              x,y   (location of seed pixel)\n *      Return: box or null on error.\n *\n *  Notes:\n *      (1) This is Paul Heckbert's stack-based 4-cc seedfill algorithm.\n *      (2) This operates on the input 1 bpp pix to remove the fg seed\n *          pixel, at (x,y), and all pixels that are 4-connected to it.\n *          The seed pixel at (x,y) must initially be ON.\n *      (3) Returns the bounding box of the erased 4-cc component.\n *      (4) Reference: see Paul Heckbert's stack-based seed fill algorithm\n *          in \"Graphic Gems\", ed. Andrew Glassner, Academic\n *          Press, 1990.  The algorithm description is given\n *          on pp. 275-277; working C code is on pp. 721-722.)\n *          The code here follows Heckbert's exactly, except\n *          we use function calls instead of macros for\n *          pushing data on and popping data off the stack.\n *          This makes sense to do because Heckbert's fixed-size\n *          stack with macros is dangerous: images exist that\n *          will overrun the stack and crash.   The stack utility\n *          here grows dynamically as needed, and the fillseg\n *          structures that are not in use are stored in another\n *          stack for reuse.  It should be noted that the\n *          overhead in the function calls (vs. macros) is negligible.\n */",
      "file" : "conncomp.c"
   },
   {
      "function" : "pixSeedfill8",
      "comment" : "/*!\n *  pixSeedfill8()\n *\n *      Input:  pixs (1 bpp)\n *              stack (for holding fillsegs)\n *              x,y   (location of seed pixel)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is Paul Heckbert's stack-based 8-cc seedfill algorithm.\n *      (2) This operates on the input 1 bpp pix to remove the fg seed\n *          pixel, at (x,y), and all pixels that are 8-connected to it.\n *          The seed pixel at (x,y) must initially be ON.\n *      (3) Reference: see pixSeedFill8BB()\n */",
      "file" : "conncomp.c"
   },
   {
      "function" : "pixSeedfill8BB",
      "comment" : "/*!\n *  pixSeedfill8BB()\n *\n *      Input:  pixs (1 bpp)\n *              stack (for holding fillsegs)\n *              x,y   (location of seed pixel)\n *      Return: box or null on error.\n *\n *  Notes:\n *      (1) This is Paul Heckbert's stack-based 8-cc seedfill algorithm.\n *      (2) This operates on the input 1 bpp pix to remove the fg seed\n *          pixel, at (x,y), and all pixels that are 8-connected to it.\n *          The seed pixel at (x,y) must initially be ON.\n *      (3) Returns the bounding box of the erased 8-cc component.\n *      (4) Reference: see Paul Heckbert's stack-based seed fill algorithm\n *          in \"Graphic Gems\", ed. Andrew Glassner, Academic\n *          Press, 1990.  The algorithm description is given\n *          on pp. 275-277; working C code is on pp. 721-722.)\n *          The code here follows Heckbert's closely, except\n *          the leak checks are changed for 8 connectivity.\n *          See comments on pixSeedfill4BB() for more details.\n */",
      "file" : "conncomp.c"
   },
   {
      "function" : "pixSeedfillBB",
      "comment" : "/*!\n *  pixSeedfillBB()\n *\n *      Input:  pixs (1 bpp)\n *              stack (for holding fillsegs)\n *              x,y   (location of seed pixel)\n *              connectivity  (4 or 8)\n *      Return: box or null on error\n *\n *  Notes:\n *      (1) This is the high-level interface to Paul Heckbert's\n *          stack-based seedfill algorithm.\n */",
      "file" : "conncomp.c"
   },
   {
      "function" : "pixSeedfillBinary",
      "comment" : "/*!\n *  pixSeedfillBinary()\n *\n *      Input:  pixd  (<optional>; this can be null, equal to pixs,\n *                     or different from pixs; 1 bpp)\n *              pixs  (1 bpp seed)\n *              pixm  (1 bpp filling mask)\n *              connectivity  (4 or 8)\n *      Return: pixd always\n *\n *  Notes:\n *      (1) This is for binary seedfill (aka \"binary reconstruction\").\n *      (2) There are 3 cases:\n *            (a) pixd == null (make a new pixd)\n *            (b) pixd == pixs (in-place)\n *            (c) pixd != pixs\n *      (3) If you know the case, use these patterns for clarity:\n *            (a) pixd = pixSeedfillBinary(NULL, pixs, ...);\n *            (b) pixSeedfillBinary(pixs, pixs, ...);\n *            (c) pixSeedfillBinary(pixd, pixs, ...);\n *      (4) The resulting pixd contains the filled seed.  For some\n *          applications you want to OR it with the inverse of\n *          the filling mask.\n *      (5) The input seed and mask images can be different sizes, but\n *          in typical use the difference, if any, would be only\n *          a few pixels in each direction.  If the sizes differ,\n *          the clipping is handled by the low-level function\n *          seedfillBinaryLow().\n */",
      "file" : "seedfill.c"
   },
   {
      "function" : "pixSeedfillBinaryRestricted",
      "comment" : "/*!\n *  pixSeedfillBinaryRestricted()\n *\n *      Input:  pixd  (<optional>; this can be null, equal to pixs,\n *                     or different from pixs; 1 bpp)\n *              pixs  (1 bpp seed)\n *              pixm  (1 bpp filling mask)\n *              connectivity  (4 or 8)\n *              xmax (max distance in x direction of fill into the mask)\n *              ymax (max distance in y direction of fill into the mask)\n *      Return: pixd always\n *\n *  Notes:\n *      (1) See usage for pixSeedfillBinary(), which has unrestricted fill.\n *          In pixSeedfillBinary(), the filling distance is unrestricted\n *          and can be larger than pixs, depending on the topology of\n *          th mask.\n *      (2) There are occasions where it is useful not to permit the\n *          fill to go more than a certain distance into the mask.\n *          @xmax specifies the maximum horizontal distance allowed\n *          in the fill; @ymax does likewise in the vertical direction.\n *      (3) Operationally, the max \"distance\" allowed for the fill\n *          is a linear distance from the original seed, independent\n *          of the actual mask topology.\n *      (4) Another formulation of this problem, not implemented,\n *          would use the manhattan distance from the seed, as\n *          determined by a breadth-first search starting at the seed\n *          boundaries and working outward where the mask fg allows.\n *          How this might use the constraints of separate xmax and ymax\n *          is not clear.\n */",
      "file" : "seedfill.c"
   },
   {
      "function" : "pixSeedfillGray",
      "comment" : "/*!\n *  pixSeedfillGray()\n *\n *      Input:  pixs  (8 bpp seed; filled in place)\n *              pixm  (8 bpp filling mask)\n *              connectivity  (4 or 8)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is an in-place filling operation on the seed, pixs,\n *          where the clipping mask is always above or at the level\n *          of the seed as it is filled.\n *      (2) For details of the operation, see the description in\n *          seedfillGrayLow() and the code there.\n *      (3) As an example of use, see the description in pixHDome().\n *          There, the seed is an image where each pixel is a fixed\n *          amount smaller than the corresponding mask pixel.\n *      (4) Reference paper :\n *            L. Vincent, Morphological grayscale reconstruction in image\n *            analysis: applications and efficient algorithms, IEEE Transactions\n *            on  Image Processing, vol. 2, no. 2, pp. 176-201, 1993.\n */",
      "file" : "seedfill.c"
   },
   {
      "function" : "pixSeedfillGrayBasin",
      "comment" : "/*!\n *  pixSeedfillGrayBasin()\n *\n *      Input:  pixb  (binary mask giving seed locations)\n *              pixm  (8 bpp basin-type filling mask)\n *              delta (amount of seed value above mask)\n *              connectivity  (4 or 8)\n *      Return: pixd (filled seed) if OK, null on error\n *\n *  Notes:\n *      (1) This fills from a seed within basins defined by a filling mask.\n *          The seed value(s) are greater than the corresponding\n *          filling mask value, and the result has the bottoms of\n *          the basins raised by the initial seed value.\n *      (2) The seed has value 255 except where pixb has fg (1), which\n *          are the seed 'locations'.  At the seed locations, the seed\n *          value is the corresponding value of the mask pixel in pixm\n *          plus @delta.  If @delta == 0, we return a copy of pixm.\n *      (3) The actual filling is done using the standard grayscale filling\n *          operation on the inverse of the mask and using the inverse\n *          of the seed image.  After filling, we return the inverse of\n *          the filled seed.\n *      (4) As an example of use: pixm can describe a grayscale image\n *          of text, where the (dark) text pixels are basins of\n *          low values; pixb can identify the local minima in pixm (say, at\n *          the bottom of the basins); and delta is the amount that we wish\n *          to raise (lighten) the basins.  We construct the seed\n *          (a.k.a marker) image from pixb, pixm and @delta.\n */",
      "file" : "seedfill.c"
   },
   {
      "function" : "pixSeedfillGrayInv",
      "comment" : "/*!\n *  pixSeedfillGrayInv()\n *\n *      Input:  pixs  (8 bpp seed; filled in place)\n *              pixm  (8 bpp filling mask)\n *              connectivity  (4 or 8)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is an in-place filling operation on the seed, pixs,\n *          where the clipping mask is always below or at the level\n *          of the seed as it is filled.  Think of filling up a basin\n *          to a particular level, given by the maximum seed value\n *          in the basin.  Outside the filled region, the mask\n *          is above the filling level.\n *      (2) Contrast this with pixSeedfillGray(), where the clipping mask\n *          is always above or at the level of the fill.  An example\n *          of its use is the hdome fill, where the seed is an image\n *          where each pixel is a fixed amount smaller than the\n *          corresponding mask pixel.\n *      (3) The basin fill, pixSeedfillGrayBasin(), is a special case\n *          where the seed pixel values are generated from the mask,\n *          and where the implementation uses pixSeedfillGray() by\n *          inverting both the seed and mask.\n */",
      "file" : "seedfill.c"
   },
   {
      "function" : "pixSeedfillGrayInvSimple",
      "comment" : "/*!\n *  pixSeedfillGrayInvSimple()\n *\n *      Input:  pixs  (8 bpp seed; filled in place)\n *              pixm  (8 bpp filling mask)\n *              connectivity  (4 or 8)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is an in-place filling operation on the seed, pixs,\n *          where the clipping mask is always below or at the level\n *          of the seed as it is filled.  Think of filling up a basin\n *          to a particular level, given by the maximum seed value\n *          in the basin.  Outside the filled region, the mask\n *          is above the filling level.\n *      (2) Contrast this with pixSeedfillGraySimple(), where the clipping mask\n *          is always above or at the level of the fill.  An example\n *          of its use is the hdome fill, where the seed is an image\n *          where each pixel is a fixed amount smaller than the\n *          corresponding mask pixel.\n */",
      "file" : "seedfill.c"
   },
   {
      "function" : "pixSeedfillGraySimple",
      "comment" : "/*!\n *  pixSeedfillGraySimple()\n *\n *      Input:  pixs  (8 bpp seed; filled in place)\n *              pixm  (8 bpp filling mask)\n *              connectivity  (4 or 8)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is an in-place filling operation on the seed, pixs,\n *          where the clipping mask is always above or at the level\n *          of the seed as it is filled.\n *      (2) For details of the operation, see the description in\n *          seedfillGrayLowSimple() and the code there.\n *      (3) As an example of use, see the description in pixHDome().\n *          There, the seed is an image where each pixel is a fixed\n *          amount smaller than the corresponding mask pixel.\n *      (4) Reference paper :\n *            L. Vincent, Morphological grayscale reconstruction in image\n *            analysis: applications and efficient algorithms, IEEE Transactions\n *            on  Image Processing, vol. 2, no. 2, pp. 176-201, 1993.\n */",
      "file" : "seedfill.c"
   },
   {
      "function" : "pixSeedfillMorph",
      "comment" : "/*!\n *  pixSeedfillMorph()\n *\n *      Input:  pixs (seed)\n *              pixm (mask)\n *              maxiters (use 0 to go to completion)\n *              connectivity (4 or 8)\n *      Return: pixd (after filling into the mask) or null on error\n *\n *  Notes:\n *    (1) This is in general a very inefficient method for filling\n *        from a seed into a mask.  Use it for a small number of iterations,\n *        but if you expect more than a few iterations, use\n *        pixSeedfillBinary().\n *    (2) We use a 3x3 brick SEL for 8-cc filling and a 3x3 plus SEL for 4-cc.\n */",
      "file" : "morphapp.c"
   },
   {
      "function" : "pixSeedspread",
      "comment" : "/*!\n *  pixSeedspread()\n *\n *      Input:  pixs  (8 bpp source)\n *              connectivity  (4 or 8)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) The raster/anti-raster method for implementing this filling\n *          operation was suggested by Ray Smith.\n *      (2) This takes an arbitrary set of nonzero pixels in pixs, which\n *          can be sparse, and spreads (extrapolates) the values to\n *          fill all the pixels in pixd with the nonzero value it is\n *          closest to in pixs.  This is similar (though not completely\n *          equivalent) to doing a Voronoi tiling of the image, with a\n *          tile surrounding each pixel that has a nonzero value.\n *          All pixels within a tile are then closer to its \"central\"\n *          pixel than to any others.  Then assign the value of the\n *          \"central\" pixel to each pixel in the tile.\n *      (3) This is implemented by computing a distance function in parallel\n *          with the fill.  The distance function uses free boundary\n *          conditions (assumed maxval outside), and it controls the\n *          propagation of the pixels in pixd away from the nonzero\n *          (seed) values.  This is done in 2 traversals (raster/antiraster).\n *          In the raster direction, whenever the distance function\n *          is nonzero, the spread pixel takes on the value of its\n *          predecessor that has the minimum distance value.  In the\n *          antiraster direction, whenever the distance function is nonzero\n *          and its value is replaced by a smaller value, the spread\n *          pixel takes the value of the predecessor with the minimum\n *          distance value.\n *      (4) At boundaries where a pixel is equidistant from two\n *          nearest nonzero (seed) pixels, the decision of which value\n *          to use is arbitrary (greedy in search for minimum distance).\n *          This can give rise to strange-looking results, particularly\n *          for 4-connectivity where the L1 distance is computed from\n *          steps in N,S,E and W directions (no diagonals).\n */",
      "file" : "seedfill.c"
   },
   {
      "function" : "pixSelectByAreaFraction",
      "comment" : "/*!\n *  pixSelectByAreaFraction()\n *\n *      Input:  pixs (1 bpp)\n *              thresh (threshold ratio of fg pixels to (w * h))\n *              connectivity (4 or 8)\n *              type (L_SELECT_IF_LT, L_SELECT_IF_GT,\n *                    L_SELECT_IF_LTE, L_SELECT_IF_GTE)\n *              &changed (<optional return> 1 if changed; 0 if clone returned)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) The args specify constraints on the amount of foreground\n *          coverage of the components that are kept.\n *      (2) If unchanged, returns a copy of pixs.  Otherwise,\n *          returns a new pix with the filtered components.\n *      (3) This filters components based on the fraction of fg pixels\n *          of the component in its bounding box.\n *      (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save components\n *          with less than the threshold fraction of foreground, and\n *          L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixSelectByPerimSizeRatio",
      "comment" : "/*!\n *  pixSelectByPerimSizeRatio()\n *\n *      Input:  pixs (1 bpp)\n *              thresh (threshold ratio of fg boundary to fg pixels)\n *              connectivity (4 or 8)\n *              type (L_SELECT_IF_LT, L_SELECT_IF_GT,\n *                    L_SELECT_IF_LTE, L_SELECT_IF_GTE)\n *              &changed (<optional return> 1 if changed; 0 if clone returned)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) The args specify constraints on the size of the\n *          components that are kept.\n *      (2) If unchanged, returns a copy of pixs.  Otherwise,\n *          returns a new pix with the filtered components.\n *      (3) This filters components with smooth vs. dendritic shape, using\n *          the ratio of the fg boundary pixels to the circumference of\n *          the bounding box, and comparing it to a threshold value.\n *      (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save the smooth\n *          boundary components, and L_SELECT_IF_GT or L_SELECT_IF_GTE\n *          to remove them.\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixSelectByPerimToAreaRatio",
      "comment" : "/*!\n *  pixSelectByPerimToAreaRatio()\n *\n *      Input:  pixs (1 bpp)\n *              thresh (threshold ratio of fg boundary to fg pixels)\n *              connectivity (4 or 8)\n *              type (L_SELECT_IF_LT, L_SELECT_IF_GT,\n *                    L_SELECT_IF_LTE, L_SELECT_IF_GTE)\n *              &changed (<optional return> 1 if changed; 0 if clone returned)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) The args specify constraints on the size of the\n *          components that are kept.\n *      (2) If unchanged, returns a copy of pixs.  Otherwise,\n *          returns a new pix with the filtered components.\n *      (3) This filters \"thick\" components, where a thick component\n *          is defined to have a ratio of boundary to interior pixels\n *          that is smaller than a given threshold value.\n *      (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save the thicker\n *          components, and L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixSelectBySize",
      "comment" : "/*!\n *  pixSelectBySize()\n *\n *      Input:  pixs (1 bpp)\n *              width, height (threshold dimensions)\n *              connectivity (4 or 8)\n *              type (L_SELECT_WIDTH, L_SELECT_HEIGHT,\n *                    L_SELECT_IF_EITHER, L_SELECT_IF_BOTH)\n *              relation (L_SELECT_IF_LT, L_SELECT_IF_GT,\n *                        L_SELECT_IF_LTE, L_SELECT_IF_GTE)\n *              &changed (<optional return> 1 if changed; 0 otherwise)\n *      Return: filtered pixd, or null on error\n *\n *  Notes:\n *      (1) The args specify constraints on the size of the\n *          components that are kept.\n *      (2) If unchanged, returns a copy of pixs.  Otherwise,\n *          returns a new pix with the filtered components.\n *      (3) If the selection type is L_SELECT_WIDTH, the input\n *          height is ignored, and v.v.\n *      (4) To keep small components, use relation = L_SELECT_IF_LT or\n *          L_SELECT_IF_LTE.\n *          To keep large components, use relation = L_SELECT_IF_GT or\n *          L_SELECT_IF_GTE.\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixSelectByWidthHeightRatio",
      "comment" : "/*!\n *  pixSelectByWidthHeightRatio()\n *\n *      Input:  pixs (1 bpp)\n *              thresh (threshold ratio of width/height)\n *              connectivity (4 or 8)\n *              type (L_SELECT_IF_LT, L_SELECT_IF_GT,\n *                    L_SELECT_IF_LTE, L_SELECT_IF_GTE)\n *              &changed (<optional return> 1 if changed; 0 if clone returned)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) The args specify constraints on the width-to-height ratio\n *          for components that are kept.\n *      (2) If unchanged, returns a copy of pixs.  Otherwise,\n *          returns a new pix with the filtered components.\n *      (3) This filters components based on the width-to-height ratios.\n *      (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save components\n *          with less than the threshold ratio, and\n *          L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixSelectMinInConnComp",
      "comment" : "/*!\n *  pixSelectMinInConnComp()\n *\n *      Input:  pixs (8 bpp)\n *              pixm (1 bpp)\n *              &pta (<return> pta of min pixel locations)\n *              &nav (<optional return> numa of minima values)\n *      Return: 0 if OK, 1 on error.\n *\n *  Notes:\n *      (1) For each 8 connected component in pixm, this finds\n *          a pixel in pixs that has the lowest value, and saves\n *          it in a Pta.  If several pixels in pixs have the same\n *          minimum value, it picks the first one found.\n *      (2) For a mask pixm of true local minima, all pixels in each\n *          connected component have the same value in pixs, so it is\n *          fastest to select one of them using a special seedfill\n *          operation.  Not yet implemented.\n */",
      "file" : "seedfill.c"
   },
   {
      "function" : "pixSelectedLocalExtrema",
      "comment" : "/*!\n *  pixSelectedLocalExtrema()\n *\n *      Input:  pixs  (8 bpp)\n *              mindist (-1 for keeping all pixels; >= 0 specifies distance)\n *              &ppixmin (<return> mask of local minima)\n *              &ppixmax (<return> mask of local maxima)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This selects those local 3x3 minima that are at least a\n *          specified distance from the nearest local 3x3 maxima, and v.v.\n *          for the selected set of local 3x3 maxima.\n *          The local 3x3 minima is the set of pixels whose value equals\n *          the value after a 3x3 brick erosion, and the local 3x3 maxima\n *          is the set of pixels whose value equals the value after\n *          a 3x3 brick dilation.\n *      (2) mindist is the minimum distance allowed between\n *          local 3x3 minima and local 3x3 maxima, in an 8-connected sense.\n *          mindist == 1 keeps all pixels found in step 1.\n *          mindist == 0 removes all pixels from each mask that are\n *          both a local 3x3 minimum and a local 3x3 maximum.\n *          mindist == 1 removes any local 3x3 minimum pixel that touches a\n *          local 3x3 maximum pixel, and likewise for the local maxima.\n *          To make the decision, visualize each local 3x3 minimum pixel\n *          as being surrounded by a square of size (2 * mindist + 1)\n *          on each side, such that no local 3x3 maximum pixel is within\n *          that square; and v.v.\n *      (3) The generated masks can be used as markers for further operations.\n */",
      "file" : "seedfill.c"
   },
   {
      "function" : "pixSelectiveConnCompFill",
      "comment" : "/*!\n *  pixSelectiveConnCompFill()\n *\n *      Input:  pixs (binary)\n *              connectivity (4 or 8)\n *              minw  (minimum width to consider; use 0 or 1 for any width)\n *              minh  (minimum height to consider; use 0 or 1 for any height)\n *      Return: pix (with holes filled in selected c.c.), or null on error\n */",
      "file" : "morphapp.c"
   },
   {
      "function" : "pixSerializeToMemory",
      "comment" : "/*!\n *  pixSerializeToMemory()\n *\n *      Input:  pixs (all depths, colormap OK)\n *              &data (<return> serialized data in memory)\n *              &nbytes (<return> number of bytes in data string)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This does a fast serialization of the principal elements\n *          of the pix, as follows:\n *            \"spix\"    (4 bytes) -- ID for file type\n *            w         (4 bytes)\n *            h         (4 bytes)\n *            d         (4 bytes)\n *            wpl       (4 bytes)\n *            ncolors   (4 bytes) -- in colormap; 0 if there is no colormap\n *            cdata     (4 * ncolors)  -- size of serialized colormap array\n *            rdatasize (4 bytes) -- size of serialized raster data\n *                                   = 4 * wpl * h\n *            rdata     (rdatasize)\n */",
      "file" : "spixio.c"
   },
   {
      "function" : "pixSetAll",
      "comment" : "/*!\n *  pixSetAll()\n *\n *      Input:  pix (all depths; use cmapped with caution)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Sets all data to 1.  For 1 bpp, this is black; for grayscale\n *          or color, this is white.\n *      (2) Caution: for colormapped pix, this sets the pixel value to the\n *          maximum value supported by the colormap: 2^d - 1.  However, this\n *          color may not be defined, because the colormap may not be full.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixSetAllArbitrary",
      "comment" : "/*!\n *  pixSetAllArbitrary()\n *\n *      Input:  pix (all depths; use cmapped with caution)\n *              val  (value to set all pixels)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) Caution!  For colormapped pix, @val is used as an index\n *          into a colormap.  Be sure that index refers to the intended color.\n *          If the color is not in the colormap, you should first add it\n *          and then call this function.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixSetAllGray",
      "comment" : "/*!\n *  pixSetAllGray()\n *\n *      Input:  pix (all depths, cmap ok)\n *              grayval (in range 0 ... 255)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) N.B.  For all images, @grayval == 0 represents black and\n *          @grayval == 255 represents white.\n *      (2) For depth < 8, we do our best to approximate the gray level.\n *          For 1 bpp images, any @grayval < 128 is black; >= 128 is white.\n *          For 32 bpp images, each r,g,b component is set to @grayval,\n *          and the alpha component is preserved.\n *      (3) If pix is colormapped, it adds the gray value, replicated in\n *          all components, to the colormap if it's not there and there\n *          is room.  If the colormap is full, it finds the closest color in\n *          L2 distance of components.  This index is written to all pixels.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixSetAlphaOverWhite",
      "comment" : "/*!\n *  pixSetAlphaOverWhite()\n *\n *      Input:  pixs (colormapped or 32 bpp rgb; no alpha)\n *      Return: pixd (new pix with meaningful alpha component),\n *                   or null on error\n *\n *  Notes:\n *      (1) The generated alpha component is transparent over white\n *          (background) pixels in pixs, and quickly grades to opaque\n *          away from the transparent parts.  This is a cheap and\n *          dirty alpha generator.  The 2 pixel gradation is useful\n *          to blur the boundary between the transparent region\n *          (that will render entirely from a backing image) and\n *          the remainder which renders from pixs.\n *      (2) All alpha component bits in pixs are overwritten.\n */",
      "file" : "blend.c"
   },
   {
      "function" : "pixSetBlackOrWhite",
      "comment" : "/*!\n *  pixSetBlackOrWhite()\n *\n *      Input:  pixs (all depths; cmap ok)\n *              op (L_SET_BLACK, L_SET_WHITE)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) Function for setting all pixels in an image to either black\n *          or white.\n *      (2) If pixs is colormapped, it adds black or white to the\n *          colormap if it's not there and there is room.  If the colormap\n *          is full, it finds the closest color in intensity.\n *          This index is written to all pixels.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixSetBlackOrWhiteBoxa",
      "comment" : "/*!\n *  pixSetBlackOrWhiteBoxa()\n *\n *      Input:  pixs (any depth, can be cmapped)\n *              boxa (<optional> of boxes, to clear or set)\n *              op (L_SET_BLACK, L_SET_WHITE)\n *      Return: pixd (with boxes filled with white or black), or null on error\n */",
      "file" : "boxfunc3.c"
   },
   {
      "function" : "pixSetBorderRingVal",
      "comment" : "/*!\n *  pixSetBorderRingVal()\n *\n *      Input:  pixs (any depth; cmap OK)\n *              dist (distance from outside; must be > 0; first ring is 1)\n *              val (value to set at each border pixel)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) The rings are single-pixel-wide rectangular sets of\n *          pixels at a given distance from the edge of the pix.\n *          This sets all pixels in a given ring to a value.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixSetBorderVal",
      "comment" : "/*!\n *  pixSetBorderVal()\n *\n *      Input:  pixs (8, 16 or 32 bpp)\n *              left, right, top, bot (amount to set)\n *              val (value to set at each border pixel)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) The border region is defined to be the region in the\n *          image within a specific distance of each edge.  Here, we\n *          allow the pixels within a specified distance of each\n *          edge to be set independently.  This sets the pixels\n *          in the border region to the given input value.\n *      (2) For efficiency, use pixSetOrClearBorder() if\n *          you're setting the border to either black or white.\n *      (3) If d != 32, the input value should be masked off\n *          to the appropriate number of least significant bits.\n *      (4) The code is easily generalized for 2 or 4 bpp.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixSetChromaSampling",
      "comment" : "/*!\n *  pixSetChromaSampling()\n *\n *      Input:  pix\n *              sampling (1 for subsampling; 0 for no subsampling)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The default is for 2x2 chroma subsampling because the files are\n *          considerably smaller and the appearance is typically satisfactory.\n *          Call this with @sampling == 0 for full resolution output in\n *          chroma channels for jpeg writing.\n */",
      "file" : "jpegio.c"
   },
   {
      "function" : "pixSetColormap",
      "comment" : "/*!\n *  pixSetColormap()\n *\n *      Input:  pix\n *              colormap (to be assigned)\n *      Return: 0 if OK, 1 on error.\n *\n *  Notes:\n *      (1) Unlike with the pix data field, pixSetColormap() destroys\n *          any existing colormap before assigning the new one.\n *          Because colormaps are not ref counted, it is important that\n *          the new colormap does not belong to any other pix.\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixSetComponentArbitrary",
      "comment" : "/*!\n *  pixSetComponentArbitrary()\n *\n *      Input:  pix (32 bpp)\n *              comp (COLOR_RED, COLOR_GREEN, COLOR_BLUE, L_ALPHA_CHANNEL)\n *              val  (value to set this component)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) For example, this can be used to set the alpha component to opaque:\n *              pixSetComponentArbitrary(pix, L_ALPHA_CHANNEL, 255)\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixSetData",
      "comment" : "/*!\n *  pixSetData()\n *\n *  Notes:\n *      (1) This does not free any existing data.  To free existing\n *          data, use pixFreeData() before pixSetData().\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixSetDepth",
      "comment" : "/*--------------------------------------------------------------------*\n *                                Accessors                           *\n *--------------------------------------------------------------------*/",
      "file" : "pix1.c"
   },
   {
      "function" : "pixSetDimensions",
      "comment" : "/*!\n *  pixSetDimensions()\n *\n *      Input:  pix\n *              w, h, d (use 0 to skip the setting for any of these)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixSetHeight",
      "comment" : "/*--------------------------------------------------------------------*\n *                                Accessors                           *\n *--------------------------------------------------------------------*/",
      "file" : "pix1.c"
   },
   {
      "function" : "pixSetInRect",
      "comment" : "/*!\n *  pixSetInRect()\n *\n *      Input:  pix (all depths, can be cmapped)\n *              box (in which all pixels will be set)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Sets all data in rect to 1.  For 1 bpp, this is black;\n *          for grayscale or color, this is white.\n *      (2) Caution: for colormapped pix, this sets the pixel value to the\n *          maximum value supported by the colormap: 2^d - 1.  However, this\n *          color may not be defined, because the colormap may not be full.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixSetInRectArbitrary",
      "comment" : "/*!\n *  pixSetInRectArbitrary()\n *\n *      Input:  pix (all depths; can be cmapped)\n *              box (in which all pixels will be set to val)\n *              val  (value to set all pixels)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) For colormapped pix, be sure the value is the intended\n *          one in the colormap.\n *      (2) Caution: for colormapped pix, this sets each pixel in the\n *          rect to the color at the index equal to val.  Be sure that\n *          this index exists in the colormap and that it is the intended one!\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixSetInputFormat",
      "comment" : "/* no-op */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixSetLowContrast",
      "comment" : "/*!\n *  pixSetLowContrast()\n *\n *      Input:  pixs1 (8 bpp)\n *              pixs2 (8 bpp)\n *              mindiff (minimum difference to accept as valid)\n *      Return: 0 if OK; 1 if no pixel diffs are large enough, or on error\n *\n *  Notes:\n *      (1) This compares corresponding pixels in pixs1 and pixs2.\n *          When they differ by less than @mindiff, set the pixel\n *          values to 0 in each.  Each pixel typically represents a tile\n *          in a larger image, and a very small difference between\n *          the min and max in the tile indicates that the min and max\n *          values are not to be trusted.\n *      (2) If contrast (pixel difference) detection is expected to fail,\n *          caller should check return value.\n */",
      "file" : "adaptmap.c"
   },
   {
      "function" : "pixSetMasked",
      "comment" : "/*!\n *  pixSetMasked()\n *\n *      Input:  pixd (1, 2, 4, 8, 16 or 32 bpp; or colormapped)\n *              pixm (<optional> 1 bpp mask; no operation if NULL)\n *              val (value to set at each masked pixel)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) In-place operation.\n *      (2) NOTE: For cmapped images, this calls pixSetMaskedCmap().\n *          @val must be the 32-bit color representation of the RGB pixel.\n *          It is not the index into the colormap!\n *      (2) If pixm == NULL, a warning is given.\n *      (3) This is an implicitly aligned operation, where the UL\n *          corners of pixd and pixm coincide.  A warning is\n *          issued if the two image sizes differ significantly,\n *          but the operation proceeds.\n *      (4) Each pixel in pixd that co-locates with an ON pixel\n *          in pixm is set to the specified input value.\n *          Other pixels in pixd are not changed.\n *      (5) You can visualize this as painting the color through\n *          the mask, as a stencil.\n *      (6) If you do not want to have the UL corners aligned,\n *          use the function pixSetMaskedGeneral(), which requires\n *          you to input the UL corner of pixm relative to pixd.\n *      (7) Implementation details: see comments in pixPaintThroughMask()\n *          for when we use rasterop to do the painting.\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixSetMaskedCmap",
      "comment" : "/*!\n *  pixSetMaskedCmap()\n *\n *      Input:  pixs (2, 4 or 8 bpp, colormapped)\n *              pixm (<optional> 1 bpp mask; no-op if NULL)\n *              x, y (origin of pixm relative to pixs; can be negative)\n *              rval, gval, bval (new color to set at each masked pixel)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This is an in-place operation.\n *      (2) It paints a single color through the mask (as a stencil).\n *      (3) The mask origin is placed at (x,y) on pixs, and the\n *          operation is clipped to the intersection of the mask and pixs.\n *      (4) If pixm == NULL, a warning is given.\n *      (5) Typically, pixm is a small binary mask located somewhere\n *          on the larger pixs.\n *      (6) If the color is in the colormap, it is used.  Otherwise,\n *          it is added if possible; an error is returned if the\n *          colormap is already full.\n */",
      "file" : "paintcmap.c"
   },
   {
      "function" : "pixSetMaskedGeneral",
      "comment" : "/*!\n *  pixSetMaskedGeneral()\n *\n *      Input:  pixd (8, 16 or 32 bpp)\n *              pixm (<optional> 1 bpp mask; no operation if null)\n *              val (value to set at each masked pixel)\n *              x, y (location of UL corner of pixm relative to pixd;\n *                    can be negative)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This is an in-place operation.\n *      (2) Alignment is explicit.  If you want the UL corners of\n *          the two images to be aligned, use pixSetMasked().\n *      (3) A typical use would be painting through the foreground\n *          of a small binary mask pixm, located somewhere on a\n *          larger pixd.  Other pixels in pixd are not changed.\n *      (4) You can visualize this as painting the color through\n *          the mask, as a stencil.\n *      (5) This uses rasterop to handle clipping and different depths of pixd.\n *      (6) If pixd has a colormap, you should call pixPaintThroughMask().\n *      (7) Why is this function here, if pixPaintThroughMask() does the\n *          same thing, and does it more generally?  I've retained it here\n *          to show how one can paint through a mask using only full\n *          image rasterops, rather than pixel peeking in pixm and poking\n *          in pixd.  It's somewhat baroque, but I found it amusing.\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixSetMirroredBorder",
      "comment" : "/*!\n *  pixSetMirroredBorder()\n *\n *      Input:  pixs (all depths; colormap ok)\n *              left, right, top, bot (number of pixels to set)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This applies what is effectively mirror boundary conditions\n *          to a border region in the image.  It is in-place.\n *      (2) This is useful for setting pixels near the border to a\n *          value representative of the near pixels to the interior.\n *      (3) The general pixRasterop() is used for an in-place operation here\n *          because there is no overlap between the src and dest rectangles.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixSetOrClearBorder",
      "comment" : "/*!\n *  pixSetOrClearBorder()\n *\n *      Input:  pixs (all depths)\n *              left, right, top, bot (amount to set or clear)\n *              operation (PIX_SET or PIX_CLR)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) The border region is defined to be the region in the\n *          image within a specific distance of each edge.  Here, we\n *          allow the pixels within a specified distance of each\n *          edge to be set independently.  This either sets or\n *          clears all pixels in the border region.\n *      (2) For binary images, use PIX_SET for black and PIX_CLR for white.\n *      (3) For grayscale or color images, use PIX_SET for white\n *          and PIX_CLR for black.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixSetPadBits",
      "comment" : "/*!\n *  pixSetPadBits()\n *\n *      Input:  pix (1, 2, 4, 8, 16, 32 bpp)\n *              val  (0 or 1)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) The pad bits are the bits that expand each scanline to a\n *          multiple of 32 bits.  They are usually not used in\n *          image processing operations.  When boundary conditions\n *          are important, as in seedfill, they must be set properly.\n *      (2) This sets the value of the pad bits (if any) in the last\n *          32-bit word in each scanline.\n *      (3) For 32 bpp pix, there are no pad bits, so this is a no-op.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixSetPadBitsBand",
      "comment" : "/*!\n *  pixSetPadBitsBand()\n *\n *      Input:  pix (1, 2, 4, 8, 16, 32 bpp)\n *              by  (starting y value of band)\n *              bh  (height of band)\n *              val  (0 or 1)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) The pad bits are the bits that expand each scanline to a\n *          multiple of 32 bits.  They are usually not used in\n *          image processing operations.  When boundary conditions\n *          are important, as in seedfill, they must be set properly.\n *      (2) This sets the value of the pad bits (if any) in the last\n *          32-bit word in each scanline, within the specified\n *          band of raster lines.\n *      (3) For 32 bpp pix, there are no pad bits, so this is a no-op.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixSetPixel",
      "comment" : "/*!\n *  pixSetPixel()\n *\n *      Input:  pix\n *              (x,y) pixel coords\n *              val (value to be inserted)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) Warning: the input value is not checked for overflow with respect\n *          the the depth of @pix, and the sign bit (if any) is ignored.\n *          * For d == 1, @val > 0 sets the bit on.\n *          * For d == 2, 4, 8 and 16, @val is masked to the maximum allowable\n *            pixel value, and any (invalid) higher order bits are discarded.\n *      (2) See pixGetPixel() for information on performance.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixSetPixelColumn",
      "comment" : "/*!\n *  pixSetPixelColumn()\n *\n *      Input:  pix (8 bpp; not cmapped)\n *              col (column index)\n *              colvect (vector of floats)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pix4.c"
   },
   {
      "function" : "pixSetRGBComponent",
      "comment" : "/*!\n *  pixSetRGBComponent()\n *\n *      Input:  pixd  (32 bpp)\n *              pixs  (8 bpp)\n *              comp  (one of the set: {COLOR_RED, COLOR_GREEN,\n *                                      COLOR_BLUE, L_ALPHA_CHANNEL})\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This places the 8 bpp pixel in pixs into the\n *          specified component (properly interleaved) in pixd,\n *      (2) The two images are registered to the UL corner; the sizes\n *          need not be the same, but a warning is issued if they differ.\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixSetRGBPixel",
      "comment" : "/*!\n *  pixSetRGBPixel()\n *\n *      Input:  pix (32 bpp rgb)\n *              (x,y) pixel coords\n *              rval (red component)\n *              gval (green component)\n *              bval (blue component)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixSetResolution",
      "comment" : "/*!\n *  pixSetResolution()\n *\n *      Input:  pix\n *              xres, yres (use 0 to skip the setting for either of these)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixSetSelectCmap",
      "comment" : "/*!\n *  pixSetSelectCmap()\n *\n *      Input:  pixs (1, 2, 4 or 8 bpp, with colormap)\n *              box (<optional> region to set color; can be NULL)\n *              sindex (colormap index of pixels to be changed)\n *              rval, gval, bval (new color to paint)\n *      Return: 0 if OK, 1 on error\n *\n *  Note:\n *      (1) This is an in-place operation.\n *      (2) It sets all pixels in region that have the color specified\n *          by the colormap index 'sindex' to the new color.\n *      (3) sindex must be in the existing colormap; otherwise an\n *          error is returned.\n *      (4) If the new color exists in the colormap, it is used;\n *          otherwise, it is added to the colormap.  If it cannot be\n *          added because the colormap is full, an error is returned.\n *      (5) If box is NULL, applies function to the entire image; otherwise,\n *          clips the operation to the intersection of the box and pix.\n *      (6) An example of use would be to set to a specific color all\n *          the light (background) pixels within a certain region of\n *          a 3-level 2 bpp image, while leaving light pixels outside\n *          this region unchanged.\n */",
      "file" : "paintcmap.c"
   },
   {
      "function" : "pixSetSelectMaskedCmap",
      "comment" : "/*!\n *  pixSetSelectMaskedCmap()\n *\n *      Input:  pixs (2, 4 or 8 bpp, with colormap)\n *              pixm (<optional> 1 bpp mask; no-op if NULL)\n *              x, y (UL corner of mask relative to pixs)\n *              sindex (colormap index of pixels in pixs to be changed)\n *              rval, gval, bval (new color to substitute)\n *      Return: 0 if OK, 1 on error\n *\n *  Note:\n *      (1) This is an in-place operation.\n *      (2) This paints through the fg of pixm and replaces all pixels\n *          in pixs that have a particular value (sindex) with the new color.\n *      (3) If pixm == NULL, a warning is given.\n *      (4) sindex must be in the existing colormap; otherwise an\n *          error is returned.\n *      (5) If the new color exists in the colormap, it is used;\n *          otherwise, it is added to the colormap.  If the colormap\n *          is full, an error is returned.\n */",
      "file" : "paintcmap.c"
   },
   {
      "function" : "pixSetSpp",
      "comment" : "/*\n *  pixSetSpp()\n *      Input:  pix\n *              spp (1, 3 or 4)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) For a 32 bpp pix, this can be used to ignore the\n *          alpha sample (spp == 3) or to use it (spp == 4).\n *          For example, to write a spp == 4 image without the alpha\n *          sample (as an rgb pix), call pixSetSpp(pix, 3) and\n *          then write it out as a png.\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixSetText",
      "comment" : "/*!\n *  pixSetText()\n *\n *      Input:  pix\n *              textstring (can be null)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This removes any existing textstring and puts a copy of\n *          the input textstring there.\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixSetTextblock",
      "comment" : "/*!\n *  pixSetTextblock()\n *\n *      Input:  pixs (input image)\n *              bmf (bitmap font data)\n *              textstr (block text string to be set)\n *              val (color to set the text)\n *              x0 (left edge for each line of text)\n *              y0 (baseline location for the first text line)\n *              wtext (max width of each line of generated text)\n *              firstindent (indentation of first line, in x-widths)\n *              &overflow (<optional return> 0 if text is contained in\n *                         input pix; 1 if it is clipped)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This function paints a set of lines of text over an image.\n *      (2) @val is the pixel value to be painted through the font mask.\n *          It should be chosen to agree with the depth of pixs.\n *          If it is out of bounds, an intermediate value is chosen.\n *          For RGB, use hex notation: 0xRRGGBB00, where RR is the\n *          hex representation of the red intensity, etc.\n *          The last two hex digits are 00 (byte value 0), assigned to\n *          the A component.  Note that, as usual, RGBA proceeds from\n *          left to right in the order from MSB to LSB (see pix.h\n *          for details).\n *      (3) If there is a colormap, this does the best it can to use\n *          the requested color, or something similar to it.\n */",
      "file" : "textops.c"
   },
   {
      "function" : "pixSetTextline",
      "comment" : "/*!\n *  pixSetTextline()\n *\n *      Input:  pixs (input image)\n *              bmf (bitmap font data)\n *              textstr (text string to be set on the line)\n *              val (color to set the text)\n *              x0 (left edge for first char)\n *              y0 (baseline location for all text on line)\n *              &width (<optional return> width of generated text)\n *              &overflow (<optional return> 0 if text is contained in\n *                         input pix; 1 if it is clipped)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This function paints a line of text over an image.\n *      (2) @val is the pixel value to be painted through the font mask.\n *          It should be chosen to agree with the depth of pixs.\n *          If it is out of bounds, an intermediate value is chosen.\n *          For RGB, use hex notation: 0xRRGGBB00, where RR is the\n *          hex representation of the red intensity, etc.\n *          The last two hex digits are 00 (byte value 0), assigned to\n *          the A component.  Note that, as usual, RGBA proceeds from\n *          left to right in the order from MSB to LSB (see pix.h\n *          for details).\n *      (3) If there is a colormap, this does the best it can to use\n *          the requested color, or something similar to it.\n */",
      "file" : "textops.c"
   },
   {
      "function" : "pixSetUnderTransparency",
      "comment" : "/*!\n *  pixSetUnderTransparency()\n *\n *      Input:  pixs (32 bpp rgba)\n *              val (32 bit unsigned color to use where alpha == 0)\n *              debug (displays layers of pixs)\n *      Return: pixd (32 bpp rgba), or null on error\n *\n *  Notes:\n *      (1) This sets the r, g and b components under every fully\n *          transparent alpha component to @val.  The alpha components\n *          are unchanged.\n *      (2) Full transparency is denoted by alpha == 0.  Setting\n *          all pixels to a constant @val where alpha is transparent\n *          can improve compressibility by reducing the entropy.\n *      (3) The visual result depends on how the image is displayed.\n *          (a) For display devices that respect the use of the alpha\n *              layer, this will not affect the appearance.\n *          (b) For typical leptonica operations, alpha is ignored,\n *              so there will be a change in appearance because this\n *              resets the rgb values in the fully transparent region.\n *      (4) pixRead() and pixWrite() will, by default, read and write\n *          4-component (rgba) pix in png format.  To ignore the alpha\n *          component after reading, or omit it on writing, pixSetSpp(..., 3).\n *      (5) Here are some examples:\n *          * To convert all fully transparent pixels in a 4 component\n *            (rgba) png file to white:\n *              pixs = pixRead(<infile>);\n *              pixd = pixSetUnderTransparency(pixs, 0xffffff00, 0);\n *          * To write pixd with the alpha component:\n *              pixWrite(<outfile>, pixd, IFF_PNG);\n *          * To write and rgba image without the alpha component, first do:\n *              pixSetSpp(pixd, 3);\n *            If you later want to use the alpha, spp must be reset to 4.\n *          * (fancier) To remove the alpha by blending the image over\n *            a white background:\n *              pixRemoveAlpha()\n *            This changes all pixel values where the alpha component is\n *            not opaque (255).\n *      (6) Caution.  rgb images in leptonica typically have value 0 in\n *          the alpha channel, which is fully transparent.  If spp for\n *          such an image were changed from 3 to 4, the image becomes\n *          fully transparent, and this function will set each pixel to @val.\n *          If you really want to set every pixel to the same value,\n *          use pixSetAllArbitrary().\n *      (7) This is useful for compressing an RGBA image where the part\n *          of the image that is fully transparent is random junk; compression\n *          is typically improved by setting that region to a constant.\n *          For rendering as a 3 component RGB image over a uniform\n *          background of arbitrary color, use pixAlphaBlendUniform().\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixSetWidth",
      "comment" : "/*--------------------------------------------------------------------*\n *                                Accessors                           *\n *--------------------------------------------------------------------*/",
      "file" : "pix1.c"
   },
   {
      "function" : "pixSetWpl",
      "comment" : "/* no-op */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixSetXRes",
      "comment" : "/* no-op */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixSetYRes",
      "comment" : "/* no-op */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixSetZlibCompression",
      "comment" : "/*!\n *  pixSetZlibCompression()\n *\n *      Input:  pix\n *              compval (zlib compression value)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Valid zlib compression values are in the interval [0 ... 9],\n *          where, as defined in zlib.h:\n *            0         Z_NO_COMPRESSION\n *            1         Z_BEST_SPEED    (poorest compression)\n *            9         Z_BEST_COMPRESSION\n *          For the default value, use either of these:\n *            6         Z_DEFAULT_COMPRESSION\n *           -1         (resolves to Z_DEFAULT_COMPRESSION)\n *      (2) If you use the defined constants in zlib.h instead of the\n *          compression integers given above, you must include zlib.h.\n */",
      "file" : "pngio.c"
   },
   {
      "function" : "pixSetupByteProcessing",
      "comment" : "/*!\n *  pixSetupByteProcessing()\n *\n *      Input:  pix (8 bpp, no colormap)\n *              &w (<optional return> width)\n *              &h (<optional return> height)\n *      Return: line ptr array, or null on error\n *\n *  Notes:\n *      (1) This is a simple helper for processing 8 bpp images with\n *          direct byte access.  It can swap byte order within each word.\n *      (2) After processing, you must call pixCleanupByteProcessing(),\n *          which frees the lineptr array and restores byte order.\n *      (3) Usage:\n *              l_uint8 **lineptrs = pixSetupByteProcessing(pix, &w, &h);\n *              for (i = 0; i < h; i++) {\n *                  l_uint8 *line = lineptrs[i];\n *                  for (j = 0; j < w; j++) {\n *                      val = line[j];\n *                      ...\n *                  }\n *              }\n *              pixCleanupByteProcessing(pix, lineptrs);\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixShiftAndTransferAlpha",
      "comment" : "/*!\n *  pixShiftAndTransferAlpha()\n *\n *      Input:  pixd  (32 bpp)\n *              pixs  (32 bpp)\n *              shiftx, shifty\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "pixShiftByComponent",
      "comment" : "/*!\n *  pixShiftByComponent()\n *\n *      Input:  pixd (<optional>; either NULL or equal to pixs for in-place)\n *              pixs (32 bpp rgb)\n *              srcval (source color: 0xrrggbb00)\n *              dstval (target color: 0xrrggbb00)\n *      Return: pixd (with all pixels mapped based on the srcval/destval\n *                    mapping), or pixd on error\n *\n *  Notes:\n *      (1) For each component (r, b, g) separately, this does a linear\n *          mapping of the colors in pixs to colors in pixd.\n *          Let rs and rd be the red src and dest components in @srcval and\n *          @dstval, and rval is the red component of the src pixel.\n *          Then for all pixels in pixs, the mapping for the red\n *          component from pixs to pixd is:\n *             if (rd <= rs)   (shift toward black)\n *                 rval --> (rd/rs) * rval\n *             if (rd > rs)    (shift toward white)\n *                (255 - rval) --> ((255 - rs)/(255 - rd)) * (255 - rval)\n *          Thus if rd <= rs, the red component of all pixels is\n *          mapped by the same fraction toward white, and if rd > rs,\n *          they are mapped by the same fraction toward black.\n *          This is essentially a different linear TRC (gamma = 1)\n *          for each component.  The source and target color inputs are\n *          just used to generate the three fractions.\n *      (2) Note that this mapping differs from that in\n *          pixLinearMapToTargetColor(), which maps rs --> rd and does\n *          a piecewise stretching in between.\n *      (3) For inplace operation, call it this way:\n *            pixFractionalShiftByComponent(pixs, pixs, ... )\n *      (4) For generating a new pixd:\n *            pixd = pixLinearMapToTargetColor(NULL, pixs, ...)\n *      (5) A simple application is to color a grayscale image.\n *          A light background can be colored using srcval = 0xffffff00\n *          and picking a target background color for dstval.\n *          A dark foreground can be colored by using srcval = 0x0\n *          and choosing a target foreground color for dstval.\n */",
      "file" : "coloring.c"
   },
   {
      "function" : "pixSimpleCaptcha",
      "comment" : "/*!\n *  pixSimpleCaptcha()\n *\n *      Input:  pixs (8 bpp; no colormap)\n *              border (added white pixels on each side)\n *              nterms (number of x and y harmonic terms)\n *              seed (of random number generator)\n *              color (for colorizing; in 0xrrggbb00 format; use 0 for black)\n *              cmapflag (1 for colormap output; 0 for rgb)\n *      Return: pixd (8 bpp cmap or 32 bpp rgb), or null on error\n *\n *  Notes:\n *      (1) This uses typical default values for generating captchas.\n *          The magnitudes of the harmonic warp are typically to be\n *          smaller when more terms are used, even though the phases\n *          are random.  See, for example, prog/warptest.c.\n */",
      "file" : "warper.c"
   },
   {
      "function" : "pixSimpleColorQuantize",
      "comment" : "/*!\n *  pixSimpleColorQuantize()\n *      Input:  pixs (32 bpp rgb)\n *              sigbits (2-4, significant bits retained in the quantizer\n *                       for each component of the input image)\n *              factor (subsampling factor; use 1 for no subsampling)\n *              ncolors (the number of most populated colors to select)\n *      Return: pixd (8 bpp cmapped) or NULL on error\n *\n *  Notes:\n *      (1) If you want to do color quantization for real, use octcube\n *          or modified median cut.  This function shows that it is\n *          easy to make a simple quantizer based solely on the population\n *          in cells of a given size in rgb color space.\n *      (2) The @ncolors most populated cells at the @sigbits level form\n *          the colormap for quantizing, and this uses octcube indexing\n *          under the covers to assign each pixel to the nearest color.\n *      (3) @sigbits is restricted to 2, 3 and 4.  At the low end, the\n *          color discrimination is very crude; at the upper end, a set of\n *          similar colors can dominate the result.  Interesting results\n *          are generally found for @sigbits = 3 and ncolors ~ 20.\n *      (4) See also pixColorSegment() for a method of quantizing the\n *          colors to generate regions of similar color.\n */",
      "file" : "colorcontent.c"
   },
   {
      "function" : "pixSizesEqual",
      "comment" : "/*!\n *  pixSizesEqual()\n *\n *      Input:  two pix\n *      Return: 1 if the two pix have same {h, w, d}; 0 otherwise.\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixSmoothConnectedRegions",
      "comment" : "/*!\n *  pixSmoothConnectedRegions()\n *\n *      Input:  pixs (8 bpp grayscale; no colormap)\n *              pixm (<optional> 1 bpp; if null, this is a no-op)\n *              factor (subsampling factor for getting average; >= 1)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The pixels in pixs corresponding to those in each\n *          8-connected region in the mask are set to the average value.\n *      (2) This is required for adaptive mapping to avoid the\n *          generation of stripes in the background map, due to\n *          variations in the pixel values near the edges of mask regions.\n *      (3) This function is optimized for background smoothing, where\n *          there are a relatively small number of components.  It will\n *          be inefficient if used where there are many small components.\n */",
      "file" : "adaptmap.c"
   },
   {
      "function" : "pixSnapColor",
      "comment" : "/*!\n *  pixSnapColor()\n *\n *      Input:  pixd (<optional>; either NULL or equal to pixs for in-place)\n *              pixs (colormapped or 8 bpp gray or 32 bpp rgb)\n *              srcval (color center to be selected for change: 0xrrggbb00)\n *              dstval (target color for pixels: 0xrrggbb00)\n *              diff (max absolute difference, applied to all components)\n *      Return: pixd (with all pixels within diff of pixval set to pixval),\n *                    or pixd on error\n *\n *  Notes:\n *      (1) For inplace operation, call it this way:\n *           pixSnapColor(pixs, pixs, ... )\n *      (2) For generating a new pixd:\n *           pixd = pixSnapColor(NULL, pixs, ...)\n *      (3) If pixs has a colormap, it is handled by pixSnapColorCmap().\n *      (4) All pixels within 'diff' of 'srcval', componentwise,\n *          will be changed to 'dstval'.\n */",
      "file" : "coloring.c"
   },
   {
      "function" : "pixSnapColorCmap",
      "comment" : "/*!\n *  pixSnapColorCmap()\n *\n *      Input:  pixd (<optional>; either NULL or equal to pixs for in-place)\n *              pixs (colormapped)\n *              srcval (color center to be selected for change: 0xrrggbb00)\n *              dstval (target color for pixels: 0xrrggbb00)\n *              diff (max absolute difference, applied to all components)\n *      Return: pixd (with all pixels within diff of srcval set to dstval),\n *                    or pixd on error\n *\n *  Notes:\n *      (1) For inplace operation, call it this way:\n *           pixSnapCcmap(pixs, pixs, ... )\n *      (2) For generating a new pixd:\n *           pixd = pixSnapCmap(NULL, pixs, ...)\n *      (3) pixs must have a colormap.\n *      (4) All colors within 'diff' of 'srcval', componentwise,\n *          will be changed to 'dstval'.\n */",
      "file" : "coloring.c"
   },
   {
      "function" : "pixSobelEdgeFilter",
      "comment" : "/*!\n *  pixSobelEdgeFilter()\n *\n *      Input:  pixs (8 bpp; no colormap)\n *              orientflag (L_HORIZONTAL_EDGES, L_VERTICAL_EDGES, L_ALL_EDGES)\n *      Return: pixd (8 bpp, edges are brighter), or null on error\n *\n *  Notes:\n *      (1) Invert pixd to see larger gradients as darker (grayscale).\n *      (2) To generate a binary image of the edges, threshold\n *          the result using pixThresholdToBinary().  If the high\n *          edge values are to be fg (1), invert after running\n *          pixThresholdToBinary().\n *      (3) Label the pixels as follows:\n *              1    4    7\n *              2    5    8\n *              3    6    9\n *          Read the data incrementally across the image and unroll\n *          the loop.\n *      (4) This runs at about 45 Mpix/sec on a 3 GHz processor.\n */",
      "file" : "edge.c"
   },
   {
      "function" : "pixSplitComponentIntoBoxa",
      "comment" : "/*!\n *  pixSplitComponentIntoBoxa()\n *\n *      Input:  pixs (1 bpp)\n *              box (<optional> location of pixs w/rt an origin)\n *              minsum  (minimum pixels to trigger propagation)\n *              skipdist (distance before computing sum for propagation)\n *              delta (difference required to stop propagation)\n *              maxbg (maximum number of allowed bg pixels in ref scan)\n *              maxcomps (use 0 for unlimited number of subdivided components)\n *              remainder (set to 1 to get b.b. of remaining stuff)\n *      Return: boxa (of rectangles covering the fg of pixs), or null on error\n *\n *  Notes:\n *      (1) This generates a boxa of rectangles that covers\n *          the fg of a mask.  It does so by a greedy partitioning of\n *          the mask, choosing the largest rectangle found from\n *          each of the four directions at each step.\n *      (2) The input parameters give some flexibility for boundary\n *          noise.  The resulting set of rectangles must cover all\n *          the fg pixels and, in addition, may cover some bg pixels.\n *          Using small input parameters on a noiseless mask (i.e., one\n *          that has only large vertical and horizontal edges) will\n *          result in a proper covering of only the fg pixels of the mask.\n *      (3) The input is assumed to be a single connected component, that\n *          may have holes.  From each side, sweep inward, counting\n *          the pixels.  If the count becomes greater than @minsum,\n *          and we have moved forward a further amount @skipdist,\n *          record that count ('countref'), but don't accept if the scan\n *          contains more than @maxbg bg pixels.  Continue the scan\n *          until we reach a count that differs from countref by at\n *          least @delta, at which point the propagation stops.  The box\n *          swept out gets a score, which is the sum of fg pixels\n *          minus a penalty.  The penalty is the number of bg pixels\n *          in the box.  This is done from all four sides, and the\n *          side with the largest score is saved as a rectangle.\n *          The process repeats until there is either no rectangle\n *          left, or there is one that can't be captured from any\n *          direction.  For the latter case, we simply accept the\n *          last rectangle.\n *      (4) The input box is only used to specify the location of\n *          the UL corner of pixs, with respect to an origin that\n *          typically represents the UL corner of an underlying image,\n *          of which pixs is one component.  If @box is null,\n *          the UL corner is taken to be (0, 0).\n *      (5) The parameter @maxcomps gives the maximum number of allowed\n *          rectangles extracted from any single connected component.\n *          Use 0 if no limit is to be applied.\n *      (6) The flag @remainder specifies whether we take a final bounding\n *          box for anything left after the maximum number of allowed\n *          rectangle is extracted.\n *      (7) So if @maxcomps > 0, it specifies that we want no more than\n *          the first @maxcomps rectangles that satisfy the input\n *          criteria.  After this, we can get a final rectangle that\n *          bounds everything left over by setting @remainder == 1.\n *          If @remainder == 0, we only get rectangles that satisfy\n *          the input criteria.\n *      (8) It should be noted that the removal of rectangles can\n *          break the original c.c. into several c.c.\n *      (9) Summing up:\n *            * If @maxcomp == 0, the splitting proceeds as far as possible.\n *            * If @maxcomp > 0, the splitting stops when @maxcomps are\n *                found, or earlier if no more components can be selected.\n *            * If @remainder == 1 and components remain that cannot be\n *                selected, they are returned as a single final rectangle;\n *                otherwise, they are ignored.\n */",
      "file" : "boxfunc3.c"
   },
   {
      "function" : "pixSplitComponentWithProfile",
      "comment" : "/*!\n *  pixSplitComponentWithProfile()\n *\n *      Input:  pixs (1 bpp, exactly one connected component)\n *              delta (distance used in extrema finding in a numa; typ. 10)\n *              mindel (minimum required difference between profile minimum\n *                      and profile values +2 and -2 away; typ. 7)\n *              &pixdebug (<optional return> debug image of splitting)\n *      Return: boxa (of c.c. after splitting), or null on error\n *\n *  Notes:\n *      (1) This will split the most obvious cases of touching characters.\n *          The split points it is searching for are narrow and deep\n *          minimima in the vertical pixel projection profile, after a\n *          large vertical closing has been applied to the component.\n */",
      "file" : "pageseg.c"
   },
   {
      "function" : "pixSplitDistributionFgBg",
      "comment" : "/*!\n *  pixSplitDistributionFgBg()\n *\n *      Input:  pixs (any depth; cmapped ok)\n *              scorefract (fraction of the max score, used to determine\n *                          the range over which the histogram min is searched)\n *              factor (subsampling factor; integer >= 1)\n *              &thresh (<optional return> best threshold for separating)\n *              &fgval (<optional return> average foreground value)\n *              &bgval (<optional return> average background value)\n *              debugflag (1 for plotting of distribution and split point)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) See numaSplitDistribution() for details on the underlying\n *          method of choosing a threshold.\n */",
      "file" : "pix4.c"
   },
   {
      "function" : "pixSplitIntoBoxa",
      "comment" : "/*!\n *  pixSplitIntoBoxa()\n *\n *      Input:  pixs (1 bpp)\n *              minsum  (minimum pixels to trigger propagation)\n *              skipdist (distance before computing sum for propagation)\n *              delta (difference required to stop propagation)\n *              maxbg (maximum number of allowed bg pixels in ref scan)\n *              maxcomps (use 0 for unlimited number of subdivided components)\n *              remainder (set to 1 to get b.b. of remaining stuff)\n *      Return: boxa (of rectangles covering the fg of pixs), or null on error\n *\n *  Notes:\n *      (1) This generates a boxa of rectangles that covers\n *          the fg of a mask.  For each 8-connected component in pixs,\n *          it does a greedy partitioning, choosing the largest\n *          rectangle found from each of the four directions at each iter.\n *          See pixSplitComponentIntoBoxa() for details.\n *      (2) The input parameters give some flexibility for boundary\n *          noise.  The resulting set of rectangles may cover some\n *          bg pixels.\n *      (3) This should be used when there are a small number of\n *          mask components, each of which has sides that are close\n *          to horizontal and vertical.  The input parameters @delta\n *          and @maxbg determine whether or not holes in the mask are covered.\n *      (4) The parameter @maxcomps gives the maximum number of allowed\n *          rectangles extracted from any single connected component.\n *          Use 0 if no limit is to be applied.\n *      (5) The flag @remainder specifies whether we take a final bounding\n *          box for anything left after the maximum number of allowed\n *          rectangle is extracted.\n */",
      "file" : "boxfunc3.c"
   },
   {
      "function" : "pixSplitIntoCharacters",
      "comment" : "/*!\n *  pixSplitIntoCharacters()\n *\n *      Input:  pixs (1 bpp, contains only deskewed text)\n *              minw (minimum component width for initial filtering; typ. 4)\n *              minh (minimum component height for initial filtering; typ. 4)\n *              &boxa (<optional return> character bounding boxes)\n *              &pixa (<optional return> character images)\n *              &pixdebug (<optional return> showing splittings)\n *\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is a simple function that attempts to find split points\n *          based on vertical pixel profiles.\n *      (2) It should be given an image that has an arbitrary number\n *          of text characters.\n *      (3) The returned pixa includes the boxes from which the\n *          (possibly split) components are extracted.\n */",
      "file" : "pageseg.c"
   },
   {
      "function" : "pixStereoFromPair",
      "comment" : "/*!\n *  pixStereoFromPair()\n *\n *      Input:  pix1 (32 bpp rgb)\n *              pix2 (32 bpp rgb)\n *              rwt, gwt, bwt (weighting factors used for each component in\n                               pix1 to determine the output red channel)\n *      Return: pixd (stereo enhanced), or null on error\n *\n *  Notes:\n *      (1) pix1 and pix2 are a pair of stereo images, ideally taken\n *          concurrently in the same plane, with some lateral translation.\n *      (2) The output red channel is determined from @pix1.\n *          The output green and blue channels are taken from the green\n *          and blue channels, respectively, of @pix2.\n *      (3) The weights determine how much of each component in @pix1\n *          goes into the output red channel.  The sum of weights\n *          must be 1.0.  If it's not, we scale the weights to\n *          satisfy this criterion.\n *      (4) The most general pixel mapping allowed here is:\n *            rval = rwt * r1 + gwt * g1 + bwt * b1  (from pix1)\n *            gval = g2   (from pix2)\n *            bval = b2   (from pix2)\n *      (5) The simplest method is to use rwt = 1.0, gwt = 0.0, bwt = 0.0,\n *          but this causes unpleasant visual artifacts with red in the image.\n *          Use of green and blue from @pix1 in the red channel,\n *          instead of red, tends to fix that problem.\n */",
      "file" : "warper.c"
   },
   {
      "function" : "pixStretchHorizontal",
      "comment" : "/*!\n *  pixStretchHorizontal()\n *\n *      Input:  pixs (1, 8 or 32 bpp)\n *              dir (L_WARP_TO_LEFT or L_WARP_TO_RIGHT)\n *              type (L_LINEAR_WARP or L_QUADRATIC_WARP)\n *              hmax (horizontal displacement at edge)\n *              operation (L_SAMPLED or L_INTERPOLATED)\n *              incolor (L_BRING_IN_WHITE or L_BRING_IN_BLACK)\n *      Return: pixd (stretched/compressed), or null on error\n *\n *  Notes:\n *      (1) If @hmax > 0, this is an increase in the coordinate value of\n *          pixels in pixd, relative to the same pixel in pixs.\n *      (2) If @dir == L_WARP_TO_LEFT, the pixels on the right edge of\n *          the image are not moved. So, for example, if @hmax > 0\n *          and @dir == L_WARP_TO_LEFT, the pixels in pixd are\n *          contracted toward the right edge of the image, relative\n *          to those in pixs.\n *      (3) If @type == L_LINEAR_WARP, the pixel positions are moved\n *          to the left or right by an amount that varies linearly with\n *          the horizontal location.\n *      (4) If @operation == L_SAMPLED, the dest pixels are taken from\n *          the nearest src pixel.  Otherwise, we use linear interpolation\n *          between pairs of sampled pixels.\n */",
      "file" : "warper.c"
   },
   {
      "function" : "pixStretchHorizontalLI",
      "comment" : "/*!\n *  pixStretchHorizontalLI()\n *\n *      Input:  pixs (1, 8 or 32 bpp)\n *              dir (L_WARP_TO_LEFT or L_WARP_TO_RIGHT)\n *              type (L_LINEAR_WARP or L_QUADRATIC_WARP)\n *              hmax (horizontal displacement at edge)\n *              incolor (L_BRING_IN_WHITE or L_BRING_IN_BLACK)\n *      Return: pixd (stretched/compressed), or null on error\n *\n *  Notes:\n *      (1) See pixStretchHorizontal() for details.\n */",
      "file" : "warper.c"
   },
   {
      "function" : "pixStretchHorizontalSampled",
      "comment" : "/*!\n *  pixStretchHorizontalSampled()\n *\n *      Input:  pixs (1, 8 or 32 bpp)\n *              dir (L_WARP_TO_LEFT or L_WARP_TO_RIGHT)\n *              type (L_LINEAR_WARP or L_QUADRATIC_WARP)\n *              hmax (horizontal displacement at edge)\n *              incolor (L_BRING_IN_WHITE or L_BRING_IN_BLACK)\n *      Return: pixd (stretched/compressed), or null on error\n *\n *  Notes:\n *      (1) See pixStretchHorizontal() for details.\n */",
      "file" : "warper.c"
   },
   {
      "function" : "pixStrokeWidthTransform",
      "comment" : "/*!\n *  pixStrokeWidthTransform()\n *\n *      Input:   pixs (1 bpp)\n *               color (0 for white runs, 1 for black runs)\n *               depth (of pixd: 8 or 16 bpp)\n *               nangles (2, 4, 6 or 8)\n *      Return:  pixd (8 or 16 bpp), or null on error\n *\n *  Notes:\n *      (1) The dest Pix is 8 or 16 bpp, with the pixel values\n *          equal to the stroke width in which it is a member.\n *          The values are clipped to the max pixel value if necessary.\n *      (2) The color determines if we're labelling white or black strokes.\n *      (3) A pixel that is not a member of the chosen color gets\n *          value 0; it belongs to a width of length 0 of the\n *          chosen color.\n *      (4) This chooses, for each dest pixel, the minimum of sets\n *          of runlengths through each pixel.  Here are the sets:\n *            nangles    increment          set\n *            -------    ---------    --------------------------------\n *               2          90       {0, 90}\n *               4          45       {0, 45, 90, 135}\n *               6          30       {0, 30, 60, 90, 120, 150}\n *               8          22.5     {0, 22.5, 45, 67.5, 90, 112.5, 135, 157.5}\n *      (5) Runtime scales linearly with (nangles - 2).\n */",
      "file" : "runlength.c"
   },
   {
      "function" : "pixSubsampleBoundaryPixels",
      "comment" : "/*!\n *  pixSubsampleBoundaryPixels()\n *\n *      Input:  pixs (1 bpp, with only boundary pixels in fg)\n *              skip (number to skip between samples as you traverse boundary)\n *      Return: pta, or null on error\n *\n *  Notes:\n *      (1) If skip = 0, we take all the fg pixels.\n *      (2) We try to traverse the boundaries in a regular way.\n *          Some pixels may be missed, and these are then subsampled\n *          randomly with a fraction determined by 'skip'.\n *      (3) The most natural approach is to use a depth first (stack-based)\n *          method to find the fg pixels.  However, the pixel runs are\n *          4-connected and there are relatively few branches.  So\n *          instead of doing a proper depth-first search, we get nearly\n *          the same result using two nested while loops: the outer\n *          one continues a raster-based search for the next fg pixel,\n *          and the inner one does a reasonable job running along\n *          each 4-connected coutour.\n */",
      "file" : "selgen.c"
   },
   {
      "function" : "pixSubtract",
      "comment" : "/*!\n *  pixSubtract()\n *\n *      Input:  pixd  (<optional>; this can be null, equal to pixs1,\n *                     equal to pixs2, or different from both pixs1 and pixs2)\n *              pixs1 (can be == pixd)\n *              pixs2 (can be == pixd)\n *      Return: pixd always\n *\n *  Notes:\n *      (1) This gives the set subtraction of two images with equal depth,\n *          aligning them to the the UL corner.  pixs1 and pixs2\n *          need not have the same width and height.\n *      (2) Source pixs2 is always subtracted from source pixs1.\n *          The result is\n *                  pixs1 \\ pixs2 = pixs1 & (~pixs2)\n *      (3) There are 4 cases:\n *            (a) pixd == null,   (src1 - src2) --> new pixd\n *            (b) pixd == pixs1,  (src1 - src2) --> src1  (in-place)\n *            (c) pixd == pixs2,  (src1 - src2) --> src2  (in-place)\n *            (d) pixd != pixs1 && pixd != pixs2),\n *                                 (src1 - src2) --> input pixd\n *      (4) For clarity, if the case is known, use these patterns:\n *            (a) pixd = pixSubtract(NULL, pixs1, pixs2);\n *            (b) pixSubtract(pixs1, pixs1, pixs2);\n *            (c) pixSubtract(pixs2, pixs1, pixs2);\n *            (d) pixSubtract(pixd, pixs1, pixs2);\n *      (5) The size of the result is determined by pixs1.\n *      (6) The depths of pixs1 and pixs2 must be equal.\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixSubtractGray",
      "comment" : "/*!\n *  pixSubtractGray()\n *\n *      Input:  pixd (<optional>; this can be null, equal to pixs1, or\n *                    different from pixs1)\n *              pixs1 (can be == to pixd)\n *              pixs2\n *      Return: pixd always\n *\n *  Notes:\n *      (1) Arithmetic subtraction of two 8, 16 or 32 bpp images.\n *      (2) Source pixs2 is always subtracted from source pixs1.\n *      (3) Do explicit clipping to 0.\n *      (4) Alignment is to UL corner.\n *      (5) There are 3 cases.  The result can go to a new dest,\n *          in-place to pixs1, or to an existing input dest:\n *          (a) pixd == null   (src1 - src2) --> new pixd\n *          (b) pixd == pixs1  (src1 - src2) --> src1  (in-place)\n *          (d) pixd != pixs1  (src1 - src2) --> input pixd\n *      (6) pixs2 must be different from both pixd and pixs1.\n */",
      "file" : "pixarith.c"
   },
   {
      "function" : "pixSwapAndDestroy",
      "comment" : "/*!\n *  pixSwapAndDestroy()\n *\n *      Input:  &pixd (<optional, return> input pixd can be null,\n *                     and it must be different from pixs)\n *              &pixs (will be nulled after the swap)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Simple operation to change the handle name safely.\n *          After this operation, the original image in pixd has\n *          been destroyed, pixd points to what was pixs, and\n *          the input pixs ptr has been nulled.\n *      (2) This works safely whether or not pixs and pixd are cloned.\n *          If pixs is cloned, the other handles still point to\n *          the original image, with the ref count reduced by 1.\n *      (3) Usage example:\n *            Pix *pix1 = pixRead(\"...\");\n *            Pix *pix2 = function(pix1, ...);\n *            pixSwapAndDestroy(&pix1, &pix2);\n *            pixDestroy(&pix1);  // holds what was in pix2\n *          Example with clones ([] shows ref count of image generated\n *                               by the function):\n *            Pix *pixs = pixRead(\"...\");\n *            Pix *pix1 = pixClone(pixs);\n *            Pix *pix2 = function(pix1, ...);   [1]\n *            Pix *pix3 = pixClone(pix2);   [1] --> [2]\n *            pixSwapAndDestroy(&pix1, &pix2);\n *            pixDestroy(&pixs);  // still holds read image\n *            pixDestroy(&pix1);  // holds what was in pix2  [2] --> [1]\n *            pixDestroy(&pix3);  // holds what was in pix2  [1] --> [0]\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixTRCMap",
      "comment" : "/*!\n *  pixTRCMap()\n *\n *      Input:  pixs (8 grayscale or 32 bpp rgb; not colormapped)\n *              pixm (<optional> 1 bpp mask)\n *              na (mapping array)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) This operation is in-place on pixs.\n *      (2) For 32 bpp, this applies the same map to each of the r,g,b\n *          components.\n *      (3) The mapping array is of size 256, and it maps the input\n *          index into values in the range [0, 255].\n *      (4) If defined, the optional 1 bpp mask pixm has its origin\n *          aligned with pixs, and the map function is applied only\n *          to pixels in pixs under the fg of pixm.\n *      (5) For 32 bpp, this does not save the alpha channel.\n */",
      "file" : "enhance.c"
   },
   {
      "function" : "pixTestClipToForeground",
      "comment" : "/*!\n *  pixTestClipToForeground()\n *\n *      Input:  pixs (1 bpp)\n *              &canclip (<return> 1 if fg does not extend to all four edges)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This is a lightweight test to determine if a 1 bpp image\n *          can be further cropped without loss of fg pixels.\n *          If it cannot, canclip is set to 0.\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixTestForSimilarity",
      "comment" : "/*!\n *  pixTestForSimilarity()\n *\n *      Input:  pix1 (8 bpp gray or 32 bpp rgb, or colormapped)\n *              pix2 (8 bpp gray or 32 bpp rgb, or colormapped)\n *              factor (subsampling factor; use 0 or 1 for no subsampling)\n *              mindiff (minimum pixel difference to be counted; > 0)\n *              maxfract (maximum fraction of pixels allowed to have\n *                        diff greater than or equal to mindiff)\n *              maxave (maximum average difference of pixels allowed for\n *                      pixels with diff greater than or equal to mindiff,\n *                      after subtracting mindiff)\n *              &similar (<return> 1 if similar, 0 otherwise)\n *              printstats (use 1 to print normalized histogram to stderr)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This takes 2 pix that are the same size and determines using\n *          3 input parameters if they are \"similar\".  The first parameter\n *          @mindiff establishes a criterion of pixel-to-pixel similarity:\n *          two pixels are not similar if their difference in value is\n *          at least mindiff.  Then @maxfract and @maxave are thresholds\n *          on the number and distribution of dissimilar pixels\n *          allowed for the two pix to be similar.   If the pix are\n *          to be similar, neither threshold can be exceeded.\n *      (2) In setting the @maxfract and @maxave thresholds, you have\n *          these options:\n *            (a) Base the comparison only on @maxfract.  Then set\n *                @maxave = 0.0 or 256.0.  (If 0, we always ignore it.)\n *            (b) Base the comparison only on @maxave.  Then set\n *                @maxfract = 1.0.\n *            (c) Base the comparison on both thresholds.\n *      (3) Example of values that can be expected at mindiff = 15 when\n *          comparing lossless png encoding with jpeg encoding, q=75:\n *             (smoothish bg)       fractdiff = 0.01, avediff = 2.5\n *             (natural scene)      fractdiff = 0.13, avediff = 3.5\n *          To identify these images as 'similar', select maxfract\n *          and maxave to be upper bounds of what you expect.\n *      (4) See pixGetDifferenceStats() for a discussion of why we subtract\n *          mindiff from the computed average diff of the nonsimilar pixels\n *          to get the 'avediff' returned by that function.\n *      (5) If there is a colormap, it is removed and the result\n *          is either gray or RGB depending on the colormap.\n *      (6) If RGB, the maximum difference between pixel components is\n *          saved in the histogram.\n */",
      "file" : "compare.c"
   },
   {
      "function" : "pixThin",
      "comment" : "/*!\n *  pixThin()\n *\n *      Input:  pixs (1 bpp)\n *              type (L_THIN_FG, L_THIN_BG)\n *              connectivity (4 or 8)\n *              maxiters (max number of iters allowed; use 0 to iterate\n *                        until completion)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) See \"Connectivity-preserving morphological image transformations,\"\n *          Dan S. Bloomberg, in SPIE Visual Communications and Image\n *          Processing, Conference 1606, pp. 320-334, November 1991,\n *          Boston, MA.   A web version is available at\n *              http://www.leptonica.com/papers/conn.pdf\n *      (2) We implement here two of the best iterative\n *          morphological thinning algorithms, for 4 c.c and 8 c.c.\n *          Each iteration uses a mixture of parallel operations\n *          (using several different 3x3 Sels) and serial operations.\n *          Specifically, each thinning iteration consists of\n *          four sequential thinnings from each of four directions.\n *          Each of these thinnings is a parallel composite\n *          operation, where the union of a set of HMTs are set\n *          subtracted from the input.  For 4-cc thinning, we\n *          use 3 HMTs in parallel, and for 8-cc thinning we use 4 HMTs.\n *      (3) A \"good\" thinning algorithm is one that generates a skeleton\n *          that is near the medial axis and has neither pruned\n *          real branches nor left extra dendritic branches.\n *      (4) To thin the foreground, which is the usual situation,\n *          use type == L_THIN_FG.  Thickening the foreground is equivalent\n *          to thinning the background (type == L_THIN_BG), where the\n *          opposite connectivity gets preserved.  For example, to thicken\n *          the fg using 4-connectivity, we thin the bg using Sels that\n *          preserve 8-connectivity.\n */",
      "file" : "ccthin.c"
   },
   {
      "function" : "pixThinExamples",
      "comment" : "/*!\n *  pixThinExamples()\n *\n *      Input:  pixs (1 bpp)\n *              type (L_THIN_FG, L_THIN_BG)\n *              index (into specific examples; valid 1-9; see notes)\n *              maxiters (max number of iters allowed; use 0 to iterate\n *                        until completion)\n *              selfile (<optional> filename for output sel display)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) See notes in pixThin().  The examples are taken from\n *          the paper referenced there.\n *      (2) Here we allow specific sets of HMTs to be used in\n *          parallel for thinning from each of four directions.\n *          One iteration consists of four such parallel thins.\n *      (3) The examples are indexed as follows:\n *          Thinning  (e.g., run to completion):\n *              index = 1     sel_4_1, sel_4_5, sel_4_6\n *              index = 2     sel_4_1, sel_4_7, sel_4_7_rot\n *              index = 3     sel_48_1, sel_48_1_rot, sel_48_2\n *              index = 4     sel_8_2, sel_8_3, sel_48_2\n *              index = 5     sel_8_1, sel_8_5, sel_8_6\n *              index = 6     sel_8_2, sel_8_3, sel_8_8, sel_8_9\n *              index = 7     sel_8_5, sel_8_6, sel_8_7, sel_8_7_rot\n *          Thickening:\n *              index = 8     sel_4_2, sel_4_3 (e.g,, do just a few iterations)\n *              index = 9     sel_8_4 (e.g., do just a few iterations)\n */",
      "file" : "ccthin.c"
   },
   {
      "function" : "pixThinGeneral",
      "comment" : "/*!\n *  pixThinGeneral()\n *\n *      Input:  pixs (1 bpp)\n *              type (L_THIN_FG, L_THIN_BG)\n *              sela (of Sels for parallel composite HMTs)\n *              maxiters (max number of iters allowed; use 0 to iterate\n *                        until completion)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) See notes in pixThin().  That function chooses among\n *          the best of the Sels for thinning.\n *      (2) This is a general function that takes a Sela of HMTs\n *          that are used in parallel for thinning from each\n *          of four directions.  One iteration consists of four\n *          such parallel thins.\n */",
      "file" : "ccthin.c"
   },
   {
      "function" : "pixThreshold8",
      "comment" : "/*!\n *  pixThreshold8()\n *\n *      Input:  pix (8 bpp grayscale)\n *              d (destination depth: 1, 2, 4 or 8)\n *              nlevels (number of levels to be used for colormap)\n *              cmapflag (1 if makes colormap; 0 otherwise)\n *      Return: pixd (thresholded with standard dest thresholds),\n *              or null on error\n *\n *  Notes:\n *      (1) This uses, by default, equally spaced \"target\" values\n *          that depend on the number of levels, with thresholds\n *          halfway between.  For N levels, with separation (N-1)/255,\n *          there are N-1 fixed thresholds.\n *      (2) For 1 bpp destination, the number of levels can only be 2\n *          and if a cmap is made, black is (0,0,0) and white\n *          is (255,255,255), which is opposite to the convention\n *          without a colormap.\n *      (3) For 1, 2 and 4 bpp, the nlevels arg is used if a colormap\n *          is made; otherwise, we take the most significant bits\n *          from the src that will fit in the dest.\n *      (4) For 8 bpp, the input pixs is quantized to nlevels.  The\n *          dest quantized with that mapping, either through a colormap\n *          table or directly with 8 bit values.\n *      (5) Typically you should not use make a colormap for 1 bpp dest.\n *      (6) This is not dithering.  Each pixel is treated independently.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixThresholdForFgBg",
      "comment" : "/*!\n *  pixThresholdForFgBg()\n *\n *      Input:  pixs (any depth; cmapped ok)\n *              factor (subsampling factor; integer >= 1)\n *              thresh (threshold for generating foreground mask)\n *              &fgval (<optional return> average foreground value)\n *              &bgval (<optional return> average background value)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pix4.c"
   },
   {
      "function" : "pixThresholdGrayArb",
      "comment" : "/*!\n *  pixThresholdGrayArb()\n *\n *      Input:  pixs (8 bpp grayscale; can have colormap)\n *              edgevals (string giving edge value of each bin)\n *              outdepth (0, 2, 4 or 8 bpp; 0 is default for min depth)\n *              use_average (1 if use the average pixel value in colormap)\n *              setblack (1 if darkest color is set to black)\n *              setwhite (1 if lightest color is set to white)\n *      Return: pixd (2, 4 or 8 bpp quantized image with colormap),\n *                    or null on error\n *\n *  Notes:\n *      (1) This function allows exact specification of the quantization bins.\n *          The string @edgevals is a space-separated set of values\n *          specifying the dividing points between output quantization bins.\n *          These threshold values are assigned to the bin with higher\n *          values, so that each of them is the smallest value in their bin.\n *      (2) The output image (pixd) depth is specified by @outdepth.  The\n *          number of bins is the number of edgevals + 1.  The\n *          relation between outdepth and the number of bins is:\n *               outdepth = 2       nbins <= 4\n *               outdepth = 4       nbins <= 16\n *               outdepth = 8       nbins <= 256\n *          With @outdepth == 0, the minimum required depth for the\n *          given number of bins is used.\n *          The output pixd has a colormap.\n *      (3) The last 3 args determine the specific values that go into\n *          the colormap.\n *      (4) For @use_average:\n *            - if TRUE, the average value of pixels falling in the bin is\n *              chosen as the representative gray value.  Otherwise,\n *            - if FALSE, the central value of each bin is chosen as\n *              the representative value.\n *          The colormap holds the representative value.\n *      (5) For @setblack, if TRUE the darkest color is set to (0,0,0).\n *      (6) For @setwhite, if TRUE the lightest color is set to (255,255,255).\n *      (7) An alternative to using this function to quantize to\n *          unequally-spaced bins is to first transform the 8 bpp pixs\n *          using pixGammaTRC(), and follow this with pixThresholdTo4bpp().\n */",
      "file" : "grayquant.c"
   },
   {
      "function" : "pixThresholdOn8bpp",
      "comment" : "/*!\n *  pixThresholdOn8bpp()\n *\n *      Input:  pixs (8 bpp, can have colormap)\n *              nlevels (equally spaced; must be between 2 and 256)\n *              cmapflag (1 to build colormap; 0 otherwise)\n *      Return: pixd (8 bpp, optionally with colormap), or null on error\n *\n *  Notes:\n *      (1) Valid values for nlevels is the set {2,...,256}.\n *      (2) Any colormap on the input pixs is removed to 8 bpp grayscale.\n *      (3) If cmapflag == 1, a colormap of size 'nlevels' is made,\n *          and the pixel values in pixs are replaced by their\n *          appropriate color indices.  Otherwise, the pixel values\n *          are the actual thresholded (i.e., quantized) grayscale values.\n *      (4) If you don't want the thresholding to be equally spaced,\n *          first transform the input 8 bpp src using pixGammaTRC().\n */",
      "file" : "grayquant.c"
   },
   {
      "function" : "pixThresholdPixelSum",
      "comment" : "/*!\n *  pixThresholdPixelSum()\n *\n *      Input:  pix (1 bpp)\n *              threshold\n *              &above (<return> 1 if above threshold;\n *                               0 if equal to or less than threshold)\n *              tab8  (<optional> 8-bit pixel lookup table)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This sums the ON pixels and returns immediately if the count\n *          goes above threshold.  It is therefore more efficient\n *          for matching images (by running this function on the xor of\n *          the 2 images) than using pixCountPixels(), which counts all\n *          pixels before returning.\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixThresholdSpreadNorm",
      "comment" : "/*!\n *  pixThresholdSpreadNorm()\n *\n *      Input:  pixs (8 bpp grayscale; not colormapped)\n *              filtertype (L_SOBEL_EDGE or L_TWO_SIDED_EDGE);\n *              edgethresh (threshold on magnitude of edge filter; typ 10-20)\n *              smoothx, smoothy (half-width of convolution kernel applied to\n *                                spread threshold: use 0 for no smoothing)\n *              gamma (gamma correction; typ. about 0.7)\n *              minval  (input value that gives 0 for output; typ. -25)\n *              maxval  (input value that gives 255 for output; typ. 255)\n *              targetthresh (target threshold for normalization)\n *              &pixth (<optional return> computed local threshold value)\n *              &pixb (<optional return> thresholded normalized image)\n *              &pixd (<optional return> normalized image)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The basis of this approach is the use of seed spreading\n *          on a (possibly) sparse set of estimates for the local threshold.\n *          The resulting dense estimates are smoothed by convolution\n *          and used to either threshold the input image or normalize it\n *          with a local transformation that linearly maps the pixels so\n *          that the local threshold estimate becomes constant over the\n *          resulting image.  This approach is one of several that\n *          have been suggested (and implemented) by Ray Smith.\n *      (2) You can use either the Sobel or TwoSided edge filters.\n *          The results appear to be similar, using typical values\n *          of edgethresh in the rang 10-20.\n *      (3) To skip the trc enhancement, use gamma = 1.0, minval = 0\n *          and maxval = 255.\n *      (4) For the normalized image pixd, each pixel is linearly mapped\n *          in such a way that the local threshold is equal to targetthresh.\n *      (5) The full width and height of the convolution kernel\n *          are (2 * smoothx + 1) and (2 * smoothy + 1).\n *      (6) This function can be used with the pixtiling utility if the\n *          images are too large.  See pixOtsuAdaptiveThreshold() for\n *          an example of this.\n */",
      "file" : "adaptmap.c"
   },
   {
      "function" : "pixThresholdTo2bpp",
      "comment" : "/*!\n *  pixThresholdTo2bpp()\n *\n *      Input:  pixs (8 bpp)\n *              nlevels (equally spaced; must be between 2 and 4)\n *              cmapflag (1 to build colormap; 0 otherwise)\n *      Return: pixd (2 bpp, optionally with colormap), or null on error\n *\n *  Notes:\n *      (1) Valid values for nlevels is the set {2, 3, 4}.\n *      (2) Any colormap on the input pixs is removed to 8 bpp grayscale.\n *      (3) This function is typically invoked with cmapflag == 1.\n *          In the situation where no colormap is desired, nlevels is\n *          ignored and pixs is thresholded to 4 levels.\n *      (4) The target output colors are equally spaced, with the\n *          darkest at 0 and the lightest at 255.  The thresholds are\n *          chosen halfway between adjacent output values.  A table\n *          is built that specifies the mapping from src to dest.\n *      (5) If cmapflag == 1, a colormap of size 'nlevels' is made,\n *          and the pixel values in pixs are replaced by their\n *          appropriate color indices.  The number of holdouts,\n *          4 - nlevels, will be between 0 and 2.\n *      (6) If you don't want the thresholding to be equally spaced,\n *          either first transform the 8 bpp src using pixGammaTRC().\n *          or, if cmapflag == 1, after calling this function you can use\n *          pixcmapResetColor() to change any individual colors.\n *      (7) If a colormap is generated, it will specify (to display\n *          programs) exactly how each level is to be represented in RGB\n *          space.  When representing text, 3 levels is far better than\n *          2 because of the antialiasing of the single gray level,\n *          and 4 levels (black, white and 2 gray levels) is getting\n *          close to the perceptual quality of a (nearly continuous)\n *          grayscale image.  With 2 bpp, you can set up a colormap\n *          and allocate from 2 to 4 levels to represent antialiased text.\n *          Any left over colormap entries can be used for coloring regions.\n *          For the same number of levels, the file size of a 2 bpp image\n *          is about 10% smaller than that of a 4 bpp result for the same\n *          number of levels.  For both 2 bpp and 4 bpp, using 4 levels you\n *          get compression far better than that of jpeg, because the\n *          quantization to 4 levels will remove the jpeg ringing in the\n *          background near character edges.\n */",
      "file" : "grayquant.c"
   },
   {
      "function" : "pixThresholdTo4bpp",
      "comment" : "/*!\n *  pixThresholdTo4bpp()\n *\n *      Input:  pixs (8 bpp, can have colormap)\n *              nlevels (equally spaced; must be between 2 and 16)\n *              cmapflag (1 to build colormap; 0 otherwise)\n *      Return: pixd (4 bpp, optionally with colormap), or null on error\n *\n *  Notes:\n *      (1) Valid values for nlevels is the set {2, ... 16}.\n *      (2) Any colormap on the input pixs is removed to 8 bpp grayscale.\n *      (3) This function is typically invoked with cmapflag == 1.\n *          In the situation where no colormap is desired, nlevels is\n *          ignored and pixs is thresholded to 16 levels.\n *      (4) The target output colors are equally spaced, with the\n *          darkest at 0 and the lightest at 255.  The thresholds are\n *          chosen halfway between adjacent output values.  A table\n *          is built that specifies the mapping from src to dest.\n *      (5) If cmapflag == 1, a colormap of size 'nlevels' is made,\n *          and the pixel values in pixs are replaced by their\n *          appropriate color indices.  The number of holdouts,\n *          16 - nlevels, will be between 0 and 14.\n *      (6) If you don't want the thresholding to be equally spaced,\n *          either first transform the 8 bpp src using pixGammaTRC().\n *          or, if cmapflag == 1, after calling this function you can use\n *          pixcmapResetColor() to change any individual colors.\n *      (7) If a colormap is generated, it will specify, to display\n *          programs, exactly how each level is to be represented in RGB\n *          space.  When representing text, 3 levels is far better than\n *          2 because of the antialiasing of the single gray level,\n *          and 4 levels (black, white and 2 gray levels) is getting\n *          close to the perceptual quality of a (nearly continuous)\n *          grayscale image.  Therefore, with 4 bpp, you can set up a\n *          colormap, allocate a relatively small fraction of the 16\n *          possible values to represent antialiased text, and use the\n *          other colormap entries for other things, such as coloring\n *          text or background.  Two other reasons for using a small number\n *          of gray values for antialiased text are (1) PNG compression\n *          gets worse as the number of levels that are used is increased,\n *          and (2) using a small number of levels will filter out most of\n *          the jpeg ringing that is typically introduced near sharp edges\n *          of text.  This filtering is partly responsible for the improved\n *          compression.\n */",
      "file" : "grayquant.c"
   },
   {
      "function" : "pixThresholdToBinary",
      "comment" : "/*!\n *  pixThresholdToBinary()\n *\n *      Input:  pixs (4 or 8 bpp)\n *              threshold value\n *      Return: pixd (1 bpp), or null on error\n *\n *  Notes:\n *      (1) If the source pixel is less than the threshold value,\n *          the dest will be 1; otherwise, it will be 0\n */",
      "file" : "grayquant.c"
   },
   {
      "function" : "pixThresholdToValue",
      "comment" : "/*!\n *  pixThresholdToValue()\n *\n *      Input:  pixd (<optional>; if not null, must be equal to pixs)\n *              pixs (8, 16, 32 bpp)\n *              threshval\n *              setval\n *      Return: pixd always\n *\n *  Notes:\n *    - operation can be in-place (pixs == pixd) or to a new pixd\n *    - if setval > threshval, sets pixels with a value >= threshval to setval\n *    - if setval < threshval, sets pixels with a value <= threshval to setval\n *    - if setval == threshval, no-op\n */",
      "file" : "pixarith.c"
   },
   {
      "function" : "pixTilingCreate",
      "comment" : "/*!\n *  pixTilingCreate()\n *\n *      Input:  pixs  (pix to be tiled; any depth; colormap OK)\n *              nx    (number of tiles across image)\n *              ny    (number of tiles down image)\n *              w     (desired width of each tile)\n *              h     (desired height of each tile)\n *              overlap (amount of overlap into neighboring tile on each side)\n *      Return: pixtiling, or null on error\n *\n *  Notes:\n *      (1) We put a clone of pixs in the PixTiling.\n *      (2) The input to pixTilingCreate() for horizontal tiling can be\n *          either the number of tiles across the image or the approximate\n *          width of the tiles.  If the latter, the actual width will be\n *          determined by making all tiles but the last of equal width, and\n *          making the last as close to the others as possible.  The same\n *          consideration is applied independently to the vertical tiling.\n *          To specify tile width, set nx = 0; to specify the number of\n *          tiles horizontally across the image, set w = 0.\n *      (3) If pixs is to be tiled in one-dimensional strips, use ny = 1 for\n *          vertical strips and nx = 1 for horizontal strips.\n *      (4) The overlap must not be larger than the width or height of\n *          the leftmost or topmost tile(s).\n */",
      "file" : "pixtiling.c"
   },
   {
      "function" : "pixTilingDestroy",
      "comment" : "/*!\n *  pixTilingDestroy()\n *\n *      Input:  &pt (<will be set to null before returning>)\n *      Return: void\n */",
      "file" : "pixtiling.c"
   },
   {
      "function" : "pixTilingGetCount",
      "comment" : "/*!\n *  pixTilingGetCount()\n *\n *      Input:  pt (pixtiling)\n *              &nx (<optional return> nx; can be null)\n *              &ny (<optional return> ny; can be null)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pixtiling.c"
   },
   {
      "function" : "pixTilingGetSize",
      "comment" : "/*!\n *  pixTilingGetSize()\n *\n *      Input:  pt (pixtiling)\n *              &w (<optional return> tile width; can be null)\n *              &h (<optional return> tile height; can be null)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pixtiling.c"
   },
   {
      "function" : "pixTilingGetTile",
      "comment" : "/*!\n *  pixTilingGetTile()\n *\n *      Input:  pt (pixtiling)\n *              i (tile row index)\n *              j (tile column index)\n *      Return: pixd (tile with appropriate boundary (overlap) pixels added),\n *                    or null on error\n */",
      "file" : "pixtiling.c"
   },
   {
      "function" : "pixTilingNoStripOnPaint",
      "comment" : "/*!\n *  pixTilingNoStripOnPaint()\n *\n *      Input:  pt (pixtiling)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The default for paint is to strip out the overlap pixels\n *          that are added by pixTilingGetTile().  However, some\n *          operations will generate an image with these pixels\n *          stripped off.  This tells the paint operation not\n *          to strip the added boundary pixels when painting.\n */",
      "file" : "pixtiling.c"
   },
   {
      "function" : "pixTilingPaintTile",
      "comment" : "/*!\n *  pixTilingPaintTile()\n *\n *      Input:  pixd (dest: paint tile onto this, without overlap)\n *              i (tile row index)\n *              j (tile column index)\n *              pixs (source: tile to be painted from)\n *              pt (pixtiling struct)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pixtiling.c"
   },
   {
      "function" : "pixTophat",
      "comment" : "/*!\n *  pixTophat()\n *\n *      Input:  pixs\n *              hsize (of Sel; must be odd; origin implicitly in center)\n *              vsize (ditto)\n *              type   (L_TOPHAT_WHITE: image - opening\n *                      L_TOPHAT_BLACK: closing - image)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Sel is a brick with all elements being hits\n *      (2) If hsize = vsize = 1, returns an image with all 0 data.\n *      (3) The L_TOPHAT_WHITE flag emphasizes small bright regions,\n *          whereas the L_TOPHAT_BLACK flag emphasizes small dark regions.\n *          The L_TOPHAT_WHITE tophat can be accomplished by doing a\n *          L_TOPHAT_BLACK tophat on the inverse, or v.v.\n */",
      "file" : "morphapp.c"
   },
   {
      "function" : "pixTransferAllData",
      "comment" : "/*!\n *  pixTransferAllData()\n *\n *      Input:  pixd (must be different from pixs)\n *              &pixs (will be nulled if refcount goes to 0)\n *              copytext (1 to copy the text field; 0 to skip)\n *              copyformat (1 to copy the informat field; 0 to skip)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This does a complete data transfer from pixs to pixd,\n *          followed by the destruction of pixs (refcount permitting).\n *      (2) If the refcount of pixs is 1, pixs is destroyed.  Otherwise,\n *          the data in pixs is copied (rather than transferred) to pixd.\n *      (3) This operation, like all others with a pre-existing pixd,\n *          will side-effect any existing clones of pixd.  The pixd\n *          refcount does not change.\n *      (4) When might you use this?  Suppose you have an in-place Pix\n *          function (returning void) with the typical signature:\n *              void function-inplace(PIX *pix, ...)\n *          where \"...\" are non-pointer input parameters, and suppose\n *          further that you sometimes want to return an arbitrary Pix\n *          in place of the input Pix.  There are two ways you can do this:\n *          (a) The straightforward way is to change the function\n *              signature to take the address of the Pix ptr:\n *                  void function-inplace(PIX **ppix, ...) {\n *                      PIX *pixt = function-makenew(*ppix);\n *                      pixDestroy(ppix);\n *                      *ppix = pixt;\n *                      return;\n *                  }\n *              Here, the input and returned pix are different, as viewed\n *              by the calling function, and the inplace function is\n *              expected to destroy the input pix to avoid a memory leak.\n *          (b) Keep the signature the same and use pixTransferAllData()\n *              to return the new Pix in the input Pix struct:\n *                  void function-inplace(PIX *pix, ...) {\n *                      PIX *pixt = function-makenew(pix);\n *                      pixTransferAllData(pix, &pixt, 0, 0);\n *                               // pixDestroy() is called on pixt\n *                      return;\n *                  }\n *              Here, the input and returned pix are the same, as viewed\n *              by the calling function, and the inplace function must\n *              never destroy the input pix, because the calling function\n *              maintains an unchanged handle to it.\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "pixTranslate",
      "comment" : "/*!\n *  pixTranslate()\n *\n *      Input:  pixd (<optional> destination: this can be null,\n *                    equal to pixs, or different from pixs)\n *              pixs\n *              hshift (horizontal shift; hshift > 0 is to right)\n *              vshift (vertical shift; vshift > 0 is down)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)\n *      Return: pixd, or null on error.\n *\n *  Notes:\n *      (1) The general pattern is:\n *            pixd = pixTranslate(pixd, pixs, ...);\n *          For clarity, when you know the case, use one of these:\n *            pixd = pixTranslate(NULL, pixs, ...);  // new\n *            pixTranslate(pixs, pixs, ...);         // in-place\n *            pixTranslate(pixd, pixs, ...);         // to existing pixd\n *      (2) If an existing pixd is not the same size as pixs, the\n *          image data will be reallocated.\n */",
      "file" : "rop.c"
   },
   {
      "function" : "pixTwoSidedEdgeFilter",
      "comment" : "/*!\n *  pixTwoSidedEdgeFilter()\n *\n *      Input:  pixs (8 bpp; no colormap)\n *              orientflag (L_HORIZONTAL_EDGES, L_VERTICAL_EDGES)\n *      Return: pixd (8 bpp, edges are brighter), or null on error\n *\n *  Notes:\n *      (1) For detecting vertical edges, this considers the\n *          difference of the central pixel from those on the left\n *          and right.  For situations where the gradient is the same\n *          sign on both sides, this computes and stores the minimum\n *          (absolute value of the) difference.  The reason for\n *          checking the sign is that we are looking for pixels within\n *          a transition.  By contrast, for single pixel noise, the pixel\n *          value is either larger than or smaller than its neighbors,\n *          so the gradient would change direction on each side.  Horizontal\n *          edges are handled similarly, looking for vertical gradients.\n *      (2) To generate a binary image of the edges, threshold\n *          the result using pixThresholdToBinary().  If the high\n *          edge values are to be fg (1), invert after running\n *          pixThresholdToBinary().\n *      (3) This runs at about 60 Mpix/sec on a 3 GHz processor.\n *          It is about 30% faster than Sobel, and the results are\n *          similar.\n */",
      "file" : "edge.c"
   },
   {
      "function" : "pixUnionOfMorphOps",
      "comment" : "/*!\n *  pixUnionOfMorphOps()\n *\n *      Input:  pixs (binary)\n *              sela\n *              type (L_MORPH_DILATE, etc.)\n *      Return: pixd (union of the specified morphological operation\n *                    on pixs for each Sel in the Sela), or null on error\n */",
      "file" : "morphapp.c"
   },
   {
      "function" : "pixUnpackBinary",
      "comment" : "/*!\n *  pixUnpackBinary()\n *\n *      Input:  pixs (1 bpp)\n *              depth (of destination: 2, 4, 8, 16 or 32 bpp)\n *              invert (0:  binary 0 --> grayscale 0\n *                          binary 1 --> grayscale 0xff...\n *                      1:  binary 0 --> grayscale 0xff...\n *                          binary 1 --> grayscale 0)\n *      Return: pixd (2, 4, 8, 16 or 32 bpp), or null on error\n *\n *  Notes:\n *      (1) This function calls special cases of pixConvert1To*(),\n *          for 2, 4, 8, 16 and 32 bpp destinations.\n */",
      "file" : "pixconv.c"
   },
   {
      "function" : "pixUnsharpMasking",
      "comment" : "/*!\n *  pixUnsharpMasking()\n *\n *      Input:  pixs (all depths except 1 bpp; with or without colormaps)\n *              halfwidth  (\"half-width\" of smoothing filter)\n *              fract  (fraction of edge added back into image)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) We use symmetric smoothing filters of odd dimension,\n *          typically use sizes of 3, 5, 7, etc.  The @halfwidth parameter\n *          for these is (size - 1)/2; i.e., 1, 2, 3, etc.\n *      (2) The fract parameter is typically taken in the\n *          range:  0.2 < fract < 0.7\n *      (3) Returns a clone if no sharpening is requested.\n */",
      "file" : "enhance.c"
   },
   {
      "function" : "pixUnsharpMaskingFast",
      "comment" : "/*!\n *  pixUnsharpMaskingFast()\n *\n *      Input:  pixs (all depths except 1 bpp; with or without colormaps)\n *              halfwidth  (\"half-width\" of smoothing filter; 1 and 2 only)\n *              fract  (fraction of high frequency added to image)\n *              direction (L_HORIZ, L_VERT, L_BOTH_DIRECTIONS)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) The fast version uses separable 1-D filters directly on\n *          the input image.  The halfwidth is either 1 (full width = 3)\n *          or 2 (full width = 5).\n *      (2) The fract parameter is typically taken in the\n *            range:  0.2 < fract < 0.7\n *      (3) To skip horizontal sharpening, use @fracth = 0.0; ditto for @fractv\n *      (4) For one dimensional filtering (as an example):\n *          For @halfwidth = 1, the low-pass filter is\n *              L:    1/3    1/3   1/3\n *          and the high-pass filter is\n *              H = I - L:   -1/3   2/3   -1/3\n *          For @halfwidth = 2, the low-pass filter is\n *              L:    1/5    1/5   1/5    1/5    1/5\n *          and the high-pass filter is\n *              H = I - L:   -1/5  -1/5   4/5  -1/5   -1/5\n *          The new sharpened pixel value is found by adding some fraction\n *          of the high-pass filter value (which sums to 0) to the\n *          initial pixel value:\n *              N = I + fract * H\n *      (5) For 2D, the sharpening filter is not separable, because the\n *          vertical filter depends on the horizontal location relative\n *          to the filter origin, and v.v.   So we either do the full\n *          2D filter (for @halfwidth == 1) or do the low-pass\n *          convolution separably and then compose with the original pix.\n *      (6) Returns a clone if no sharpening is requested.\n */",
      "file" : "enhance.c"
   },
   {
      "function" : "pixUnsharpMaskingGray",
      "comment" : "/*!\n *  pixUnsharpMaskingGray()\n *\n *      Input:  pixs (8 bpp; no colormap)\n *              halfwidth  (\"half-width\" of smoothing filter)\n *              fract  (fraction of edge added back into image)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) We use symmetric smoothing filters of odd dimension,\n *          typically use sizes of 3, 5, 7, etc.  The @halfwidth parameter\n *          for these is (size - 1)/2; i.e., 1, 2, 3, etc.\n *      (2) The fract parameter is typically taken in the range:\n *          0.2 < fract < 0.7\n *      (3) Returns a clone if no sharpening is requested.\n */",
      "file" : "enhance.c"
   },
   {
      "function" : "pixUnsharpMaskingGray1D",
      "comment" : "/*!\n *  pixUnsharpMaskingGray1D()\n *\n *      Input:  pixs (8 bpp; no colormap)\n *              halfwidth  (\"half-width\" of smoothing filter: 1 or 2)\n *              fract  (fraction of high frequency added to image)\n *              direction (of filtering; use L_HORIZ or L_VERT)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) For usage and explanation of the algorithm, see notes\n *          in pixUnsharpMaskingFast().\n *      (2) Returns a clone if no sharpening is requested.\n */",
      "file" : "enhance.c"
   },
   {
      "function" : "pixUnsharpMaskingGray2D",
      "comment" : "/*!\n *  pixUnsharpMaskingGray2D()\n *\n *      Input:  pixs (8 bpp; no colormap)\n *              halfwidth  (\"half-width\" of smoothing filter: 1 or 2)\n *              fract  (fraction of high frequency added to image)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) For halfwidth == 1, we implement the full sharpening filter\n *          directly.  For halfwidth == 2, we implement the the lowpass\n *          filter separably and then compute the sharpening result locally.\n *      (2) Returns a clone if no sharpening is requested.\n */",
      "file" : "enhance.c"
   },
   {
      "function" : "pixUnsharpMaskingGrayFast",
      "comment" : "/*!\n *  pixUnsharpMaskingGrayFast()\n *\n *      Input:  pixs (8 bpp; no colormap)\n *              halfwidth  (\"half-width\" of smoothing filter: 1 or 2)\n *              fract  (fraction of high frequency added to image)\n *              direction (L_HORIZ, L_VERT, L_BOTH_DIRECTIONS)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) For usage and explanation of the algorithm, see notes\n *          in pixUnsharpMaskingFast().\n *      (2) Returns a clone if no sharpening is requested.\n */",
      "file" : "enhance.c"
   },
   {
      "function" : "pixUpDownDetect",
      "comment" : "/*!\n *  pixUpDownDetect()\n *\n *      Input:  pixs (1 bpp, deskewed, English text, 150 - 300 ppi)\n *              &conf (<return> confidence that text is rightside-up)\n *              mincount (min number of up + down; use 0 for default)\n *              debug (1 for debug output; 0 otherwise)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Special (typical, slightly faster) case, where the pixels\n *          identified through the HMT (hit-miss transform) are not\n *          clipped by a truncated word mask pixm.  See pixOrientDetect()\n *          and pixUpDownDetectGeneral() for details.\n *      (2) The returned confidence is the normalized difference\n *          between the number of detected up and down ascenders,\n *          assuming that the text is either rightside-up or upside-down\n *          and not rotated at a 90 degree angle.\n */",
      "file" : "flipdetect.c"
   },
   {
      "function" : "pixUpDownDetectDwa",
      "comment" : "/*!\n *  pixUpDownDetectDwa()\n *\n *      Input:  pixs (1 bpp, deskewed, English text, 150 - 300 ppi)\n *              &conf (<return> confidence that text is rightside-up)\n *              mincount (min number of up + down; use 0 for default)\n *              debug (1 for debug output; 0 otherwise)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Faster (DWA) version of pixUpDownDetect().\n *      (2) This is a special case (but typical and slightly faster) of\n *          pixUpDownDetectGeneralDwa(), where the pixels identified\n *          through the HMT (hit-miss transform) are not clipped by\n *          a truncated word mask pixm.  See pixUpDownDetectGeneral()\n *          for usage and other details.\n *      (3) The returned confidence is the normalized difference\n *          between the number of detected up and down ascenders,\n *          assuming that the text is either rightside-up or upside-down\n *          and not rotated at a 90 degree angle.\n */",
      "file" : "flipdetect.c"
   },
   {
      "function" : "pixUpDownDetectGeneral",
      "comment" : "/*!\n *  pixUpDownDetectGeneral()\n *\n *      Input:  pixs (1 bpp, deskewed, English text, 150 - 300 ppi)\n *              &conf (<return> confidence that text is rightside-up)\n *              mincount (min number of up + down; use 0 for default)\n *              npixels (number of pixels removed from each side of word box)\n *              debug (1 for debug output; 0 otherwise)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) See pixOrientDetect() for other details.\n *      (2) @conf is the normalized difference between the number of\n *          detected up and down ascenders, assuming that the text\n *          is either rightside-up or upside-down and not rotated\n *          at a 90 degree angle.\n *      (3) The typical mode of operation is @npixels == 0.\n *          If @npixels > 0, this removes HMT matches at the\n *          beginning and ending of \"words.\"  This is useful for\n *          pages that may have mostly digits, because if npixels == 0,\n *          leading \"1\" and \"3\" digits can register as having\n *          ascenders or descenders, and \"7\" digits can match descenders.\n *          Consequently, a page image of only digits may register\n *          as being upside-down.\n *      (4) We want to count the number of instances found using the HMT.\n *          An expensive way to do this would be to count the\n *          number of connected components.  A cheap way is to do a rank\n *          reduction cascade that reduces each component to a single\n *          pixel, and results (after two or three 2x reductions)\n *          in one pixel for each of the original components.\n *          After the reduction, you have a much smaller pix over\n *          which to count pixels.  We do only 2 reductions, because\n *          this function is designed to work for input pix between\n *          150 and 300 ppi, and an 8x reduction on a 150 ppi image\n *          is going too far -- components will get merged.\n */",
      "file" : "flipdetect.c"
   },
   {
      "function" : "pixUpDownDetectGeneralDwa",
      "comment" : "/*!\n *  pixUpDownDetectGeneralDwa()\n *\n *      Input:  pixs (1 bpp, deskewed, English text)\n *              &conf (<return> confidence that text is rightside-up)\n *              mincount (min number of up + down; use 0 for default)\n *              npixels (number of pixels removed from each side of word box)\n *              debug (1 for debug output; 0 otherwise)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) See the notes in pixUpDownDetectGeneral() for usage.\n */",
      "file" : "flipdetect.c"
   },
   {
      "function" : "pixUsesCmapColor",
      "comment" : "/*!\n *  pixUsesCmapColor()\n *\n *      Input:  pixs\n *              &color (<return>)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This returns color = TRUE if three things are obtained:\n *          (a) the pix has a colormap\n *          (b) the colormap has at least one color entry\n *          (c) a color entry is actually used\n *      (2) It is used in pixEqual() for comparing two images, in a\n *          situation where it is required to know if the colormap\n *          has color entries that are actually used in the image.\n */",
      "file" : "compare.c"
   },
   {
      "function" : "pixVShear",
      "comment" : "/*!\n *  pixVShear()\n *\n *      Input:  pixd (<optional>, this can be null, equal to pixs,\n *                    or different from pixs)\n *              pixs (no restrictions on depth)\n *              xloc (location of vertical line, measured from origin)\n *              angle (in radians; not too close to +-(pi / 2))\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK);\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) There are 3 cases:\n *            (a) pixd == null (make a new pixd)\n *            (b) pixd == pixs (in-place)\n *            (c) pixd != pixs\n *      (2) For these three cases, use these patterns, respectively:\n *              pixd = pixVShear(NULL, pixs, ...);\n *              pixVShear(pixs, pixs, ...);\n *              pixVShear(pixd, pixs, ...);\n *      (3) This shear leaves the vertical line of pixels at x = xloc\n *          invariant.  For a positive shear angle, pixels to the right\n *          of this line are shoved downward, and pixels to the left\n *          of the line move upward.\n *      (4) With positive shear angle, this can be used, along with\n *          pixHShear(), to perform a cw rotation, either with 2 shears\n *          (for small angles) or in the general case with 3 shears.\n *      (5) Changing the value of xloc is equivalent to translating\n *          the result vertically.\n *      (6) This brings in 'incolor' pixels from outside the image.\n *      (7) For in-place operation, pixs cannot be colormapped,\n *          because the in-place operation only blits in 0 or 1 bits,\n *          not an arbitrary colormap index.\n *      (8) The angle is brought into the range [-pi, -pi].  It is\n *          not permitted to be within MIN_DIFF_FROM_HALF_PI radians\n *          from either -pi/2 or pi/2.\n */",
      "file" : "shear.c"
   },
   {
      "function" : "pixVShearCenter",
      "comment" : "/*!\n *  pixVShearCenter()\n *\n *      Input:  pixd (<optional>, if not null, must be equal to pixs)\n *              pixs\n *              angle (in radians)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK);\n *      Return: pixd, or null on error.\n *\n *  Notes:\n *      (1) See pixVShear() for usage.\n *      (2) This does a vertical shear about the center, with (+) shear\n *          pushing increasingly downward (+y) with increasing x.\n */",
      "file" : "shear.c"
   },
   {
      "function" : "pixVShearCorner",
      "comment" : "/*!\n *  pixVShearCorner()\n *\n *      Input:  pixd (<optional>, if not null, must be equal to pixs)\n *              pixs\n *              angle (in radians)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK);\n *      Return: pixd, or null on error.\n *\n *  Notes:\n *      (1) See pixVShear() for usage.\n *      (2) This does a vertical shear about the UL corner, with (+) shear\n *          pushing increasingly downward (+y) with increasing x.\n */",
      "file" : "shear.c"
   },
   {
      "function" : "pixVShearIP",
      "comment" : "/*!\n *  pixVShearIP()\n *\n *      Input:  pixs (all depths; not colormapped)\n *              xloc  (location of vertical line, measured from origin)\n *              angle (in radians)\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK);\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This is an in-place version of pixVShear(); see comments there.\n *      (2) This brings in 'incolor' pixels from outside the image.\n *      (3) pixs cannot be colormapped, because the in-place operation\n *          only blits in 0 or 1 bits, not an arbitrary colormap index.\n *      (4) Does a vertical full-band shear about the line with (+) shear\n *          pushing increasingly downward (+y) with increasing x.\n */",
      "file" : "shear.c"
   },
   {
      "function" : "pixVShearLI",
      "comment" : "/*!\n *  pixVShearLI()\n *\n *      Input:  pixs (8 bpp or 32 bpp, or colormapped)\n *              xloc  (location of vertical line, measured from origin)\n *              angle (in radians, in range (-pi/2 ... pi/2))\n *              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK);\n *      Return: pixd (sheared), or null on error\n *\n *  Notes:\n *      (1) This does vertical shear with linear interpolation for\n *          accurate results on 8 bpp gray, 32 bpp rgb, or cmapped images.\n *          It is relatively slow compared to the sampled version\n *          implemented by rasterop, but the result is much smoother.\n *      (2) This shear leaves the vertical line of pixels at x = xloc\n *          invariant.  For a positive shear angle, pixels to the right\n *          of this line are shoved downward, and pixels to the left\n *          of the line move upward.\n *      (3) Any colormap is removed.\n *      (4) The angle is brought into the range [-pi/2 + del, pi/2 - del],\n *          where del == MIN_DIFF_FROM_HALF_PI.\n */",
      "file" : "shear.c"
   },
   {
      "function" : "pixVarThresholdToBinary",
      "comment" : "/*!\n *  pixVarThresholdToBinary()\n *\n *      Input:  pixs (8 bpp)\n *              pixg (8 bpp; contains threshold values for each pixel)\n *      Return: pixd (1 bpp), or null on error\n *\n *  Notes:\n *      (1) If the pixel in pixs is less than the corresponding pixel\n *          in pixg, the dest will be 1; otherwise it will be 0.\n */",
      "file" : "grayquant.c"
   },
   {
      "function" : "pixVarianceByColumn",
      "comment" : "/*!\n *  pixVarianceByColumn()\n *\n *      Input:  pix (8 or 16 bpp; no colormap)\n *              box (<optional> clipping box for variance; can be null)\n *      Return: na of rmsdev by column, or null on error\n *\n *  Notes:\n *      (1) To resample for a bin size different from 1, use\n *          numaUniformSampling() on the result of this function.\n *      (2) We are actually computing the RMS deviation in each row.\n *          This is the square root of the variance.\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixVarianceByRow",
      "comment" : "/*!\n *  pixVarianceByRow()\n *\n *      Input:  pix (8 or 16 bpp; no colormap)\n *              box (<optional> clipping box for variance; can be null)\n *      Return: na of rmsdev by row, or null on error\n *\n *  Notes:\n *      (1) To resample for a bin size different from 1, use\n *          numaUniformSampling() on the result of this function.\n *      (2) We are actually computing the RMS deviation in each row.\n *          This is the square root of the variance.\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixVarianceInRect",
      "comment" : "/*!\n *  pixVarianceInRect()\n *\n *      Input:  pix (1, 2, 4, 8 bpp; not cmapped)\n *              box (<optional> if null, use entire image)\n *              &rootvar (<return> sqrt variance of pixel values in region)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixVarianceInRectangle",
      "comment" : "/*!\n *  pixVarianceInRectangle()\n *\n *      Input:  pix (8 bpp)\n *              box (region to compute variance and/or root variance)\n *              pix_ma (mean accumulator)\n *              dpix_msa (mean square accumulator)\n *              &var (<optional return> variance)\n *              &rvar (<optional return> root variance)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This function is intended to be used for many rectangles\n *          on the same image.  It can find the variance and/or the\n *          square root of the variance within a rectangle in O(1),\n *          independent of the size of the rectangle.\n */",
      "file" : "quadtree.c"
   },
   {
      "function" : "pixWarpStereoscopic",
      "comment" : "/*!\n *  pixWarpStereoscopic()\n *\n *      Input:  pixs (any depth, colormap ok)\n *              zbend (horizontal separation in pixels of red and cyan\n *                    at the left and right sides, that gives rise to\n *                    quadratic curvature out of the image plane)\n *              zshiftt (uniform pixel translation difference between\n *                      red and cyan, that pushes the top of the image\n *                      plane away from the viewer (zshiftt > 0) or\n *                      towards the viewer (zshiftt < 0))\n *              zshiftb (uniform pixel translation difference between\n *                      red and cyan, that pushes the bottom of the image\n *                      plane away from the viewer (zshiftb > 0) or\n *                      towards the viewer (zshiftb < 0))\n *              ybendt (multiplicative parameter for in-plane vertical\n *                      displacement at the left or right edge at the top:\n *                        y = ybendt * (2x/w - 1)^2 )\n *              ybendb (same as ybendt, except at the left or right edge\n *                      at the bottom)\n *              redleft (1 if the red filter is on the left; 0 otherwise)\n *      Return: pixd (32 bpp), or null on error\n *\n *  Notes:\n *      (1) This function splits out the red channel, mucks around with\n *          it, then recombines with the unmolested cyan channel.\n *      (2) By using a quadratically increasing shift of the red\n *          pixels horizontally and away from the vertical centerline,\n *          the image appears to bend quadratically out of the image\n *          plane, symmetrically with respect to the vertical center\n *          line.  A positive value of @zbend causes the plane to be\n *          curved away from the viewer.  We use linearly interpolated\n *          stretching to avoid the appearance of kinks in the curve.\n *      (3) The parameters @zshiftt and @zshiftb tilt the image plane\n *          about a horizontal line through the center, and at the\n *          same time move that line either in toward the viewer or away.\n *          This is implemented by a combination of horizontal shear\n *          about the center line (for the tilt) and horizontal\n *          translation (to move the entire plane in or out).\n *          A positive value of @zshiftt moves the top of the plane\n *          away from the viewer, and a positive value of @zshiftb\n *          moves the bottom of the plane away.  We use linear interpolated\n *          shear to avoid visible vertical steps in the tilted image.\n *      (4) The image can be bent in the plane and about the vertical\n *          centerline.  The centerline does not shift, and the\n *          parameter @ybend gives the relative shift at left and right\n *          edges, with a downward shift for positive values of @ybend.\n *      (6) When writing out a steroscopic (red/cyan) image in jpeg,\n *          first call pixSetChromaSampling(pix, 0) to get sufficient\n *          resolution in the red channel.\n *      (7) Typical values are:\n *             zbend = 20\n *             zshiftt = 15\n *             zshiftb = -15\n *             ybendt = 30\n *             ybendb = 0\n *          If the disparity z-values are too large, it is difficult for\n *          the brain to register the two images.\n *      (8) This function has been cleverly reimplemented by Jeff Breidenbach.\n *          The original implementation used two 32 bpp rgb images,\n *          and merged them at the end.  The result is somewhat faded,\n *          and has a parameter \"thresh\" that controls the amount of\n *          color in the result.  (The present implementation avoids these\n *          two problems, skipping both the colorization and the alpha\n *          blending at the end, and is about 3x faster)\n *          The basic operations with 32 bpp are as follows:\n *               // Immediate conversion to 32 bpp\n *            Pix *pixt1 = pixConvertTo32(pixs);\n *               // Do vertical shear\n *            Pix *pixr = pixQuadraticVerticalShear(pixt1, L_WARP_TO_RIGHT,\n *                                                  ybendt, ybendb,\n *                                                  L_BRING_IN_WHITE);\n *               // Colorize two versions, toward red and cyan\n *            Pix *pixc = pixCopy(NULL, pixr);\n *            l_int32 thresh = 150;  // if higher, get less original color\n *            pixColorGray(pixr, NULL, L_PAINT_DARK, thresh, 255, 0, 0);\n *            pixColorGray(pixc, NULL, L_PAINT_DARK, thresh, 0, 255, 255);\n *               // Shift the red pixels; e.g., by stretching\n *            Pix *pixrs = pixStretchHorizontal(pixr, L_WARP_TO_RIGHT,\n *                                              L_QUADRATIC_WARP, zbend,\n *                                              L_INTERPOLATED,\n *                                              L_BRING_IN_WHITE);\n *               // Blend the shifted red and unshifted cyan 50:50\n *            Pix *pixg = pixCreate(w, h, 8);\n *            pixSetAllArbitrary(pixg, 128);\n *            pixd = pixBlendWithGrayMask(pixrs, pixc, pixg, 0, 0);\n */",
      "file" : "warper.c"
   },
   {
      "function" : "pixWindowedMean",
      "comment" : "/*!\n *  pixWindowedMean()\n *\n *      Input:  pixs (8 or 32 bpp grayscale)\n *              wc, hc   (half width/height of convolution kernel)\n *              hasborder (use 1 if it already has (wc + 1) border pixels\n *                         on left and right, and (hc + 1) on top and bottom;\n *                         use 0 to add kernel-dependent border)\n *              normflag (1 for normalization to get average in window;\n *                        0 for the sum in the window (un-normalized))\n *      Return: pixd (8 or 32 bpp, average over kernel window)\n *\n *  Notes:\n *      (1) The input and output depths are the same.\n *      (2) A set of border pixels of width (wc + 1) on left and right,\n *          and of height (hc + 1) on top and bottom, must be on the\n *          pix before the accumulator is found.  The output pixd\n *          (after convolution) has this border removed.\n *          If @hasborder = 0, the required border is added.\n *      (3) Typically, @normflag == 1.  However, if you want the sum\n *          within the window, rather than a normalized convolution,\n *          use @normflag == 0.\n *      (4) This builds a block accumulator pix, uses it here, and\n *          destroys it.\n *      (5) The added border, along with the use of an accumulator array,\n *          allows computation without special treatment of pixels near\n *          the image boundary, and runs in a time that is independent\n *          of the size of the convolution kernel.\n */",
      "file" : "convolve.c"
   },
   {
      "function" : "pixWindowedMeanSquare",
      "comment" : "/*!\n *  pixWindowedMeanSquare()\n *\n *      Input:  pixs (8 bpp grayscale)\n *              wc, hc   (half width/height of convolution kernel)\n *              hasborder (use 1 if it already has (wc + 1) border pixels\n *                         on left and right, and (hc + 1) on top and bottom;\n *                         use 0 to add kernel-dependent border)\n *      Return: pixd (32 bpp, average over rectangular window of\n *                    width = 2 * wc + 1 and height = 2 * hc + 1)\n *\n *  Notes:\n *      (1) A set of border pixels of width (wc + 1) on left and right,\n *          and of height (hc + 1) on top and bottom, must be on the\n *          pix before the accumulator is found.  The output pixd\n *          (after convolution) has this border removed.\n *          If @hasborder = 0, the required border is added.\n *      (2) The advantage is that we are unaffected by the boundary, and\n *          it is not necessary to treat pixels within @wc and @hc of the\n *          border differently.  This is because processing for pixd\n *          only takes place for pixels in pixs for which the\n *          kernel is entirely contained in pixs.\n *      (3) Why do we have an added border of width (@wc + 1) and\n *          height (@hc + 1), when we only need @wc and @hc pixels\n *          to satisfy this condition?  Answer: the accumulators\n *          are asymmetric, requiring an extra row and column of\n *          pixels at top and left to work accurately.\n *      (4) The added border, along with the use of an accumulator array,\n *          allows computation without special treatment of pixels near\n *          the image boundary, and runs in a time that is independent\n *          of the size of the convolution kernel.\n */",
      "file" : "convolve.c"
   },
   {
      "function" : "pixWindowedStats",
      "comment" : "/*!\n *  pixWindowedStats()\n *\n *      Input:  pixs (8 bpp grayscale)\n *              wc, hc   (half width/height of convolution kernel)\n *              hasborder (use 1 if it already has (wc + 1) border pixels\n *                         on left and right, and (hc + 1) on top and bottom;\n *                         use 0 to add kernel-dependent border)\n *              &pixm (<optional return> 8 bpp mean value in window)\n *              &pixms (<optional return> 32 bpp mean square value in window)\n *              &fpixv (<optional return> float variance in window)\n *              &fpixrv (<optional return> float rms deviation from the mean)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is a high-level convenience function for calculating\n *          any or all of these derived images.\n *      (2) If @hasborder = 0, a border is added and the result is\n *          computed over all pixels in pixs.  Otherwise, no border is\n *          added and the border pixels are removed from the output images.\n *      (3) These statistical measures over the pixels in the\n *          rectangular window are:\n *            - average value: <p>  (pixm)\n *            - average squared value: <p*p> (pixms)\n *            - variance: <(p - <p>)*(p - <p>)> = <p*p> - <p>*<p>  (pixv)\n *            - square-root of variance: (pixrv)\n *          where the brackets < .. > indicate that the average value is\n *          to be taken over the window.\n *      (4) Note that the variance is just the mean square difference from\n *          the mean value; and the square root of the variance is the\n *          root mean square difference from the mean, sometimes also\n *          called the 'standard deviation'.\n *      (5) The added border, along with the use of an accumulator array,\n *          allows computation without special treatment of pixels near\n *          the image boundary, and runs in a time that is independent\n *          of the size of the convolution kernel.\n */",
      "file" : "convolve.c"
   },
   {
      "function" : "pixWindowedVariance",
      "comment" : "/*!\n *  pixWindowedVariance()\n *\n *      Input:  pixm (mean over window; 8 or 32 bpp grayscale)\n *              pixms (mean square over window; 32 bpp)\n *              &fpixv (<optional return> float variance -- the ms deviation\n *                      from the mean)\n *              &fpixrv (<optional return> float rms deviation from the mean)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The mean and mean square values are precomputed, using\n *          pixWindowedMean() and pixWindowedMeanSquare().\n *      (2) Either or both of the variance and square-root of variance\n *          are returned as an fpix, where the variance is the\n *          average over the window of the mean square difference of\n *          the pixel value from the mean:\n *                <(p - <p>)*(p - <p>)> = <p*p> - <p>*<p>\n *      (3) To visualize the results:\n *            - for both, use fpixDisplayMaxDynamicRange().\n *            - for rms deviation, simply convert the output fpix to pix,\n */",
      "file" : "convolve.c"
   },
   {
      "function" : "pixWindowedVarianceOnLine",
      "comment" : "/*!\n *  pixWindowedVarianceOnLine()\n *\n *      Input:  pixs (8 bpp; no colormap)\n *              dir (L_HORIZONTAL_LINE or L_VERTICAL_LINE)\n *              loc (location of the constant coordinate for the line)\n *              c1, c2 (end point coordinates for the line)\n *              size (window size; must be > 1)\n *              &nad (<return> windowed square root of variance)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) The returned variance array traverses the line starting\n *          from the smallest coordinate, min(c1,c2).\n *      (2) Line end points are clipped to pixs.\n *      (3) The reference point for the variance calculation is the center of\n *          the window.  Therefore, the numa start parameter from\n *          pixExtractOnLine() is incremented by @size/2,\n *          to align the variance values with the pixel coordinate.\n *      (4) The square root of the variance is the RMS deviation from the mean.\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixWordBoxesByDilation",
      "comment" : "/*!\n *  pixWordBoxesByDilation()\n *\n *      Input:  pixs (1 bpp; typ. at 75 to 150 ppi)\n *              maxdil (maximum dilation; 0 for default; warning if > 20)\n *              minwidth, minheight (of saved components; smaller are discarded)\n *              maxwidth, maxheight (of saved components; larger are discarded)\n *              &boxa (<return> dilated word mask)\n *              &size (<optional return> size of optimal horiz Sel)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Returns a pruned set of word boxes.\n *      (2) See pixWordMaskByDilation().\n */",
      "file" : "jbclass.c"
   },
   {
      "function" : "pixWordMaskByDilation",
      "comment" : "/*!\n *  pixWordMaskByDilation()\n *\n *      Input:  pixs (1 bpp; typ. at 75 to 150 ppi)\n *              maxdil (maximum dilation; 0 for default; warning if > 20)\n *              &mask (<optional return> dilated word mask)\n *              &size (<optional return> size of optimal horiz Sel)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This gives a crude estimate of the word masks.  See\n *          pixWordBoxesByDilation() for further filtering of the word boxes.\n *      (2) For 75 to 150 ppi, the optimal dilation will be between 5 and 11.\n *          For 200 to 300 ppi, it is advisable to use a larger value\n *          for @maxdil, say between 10 and 20.  Setting maxdil <= 0\n *          results in a default dilation of 16.\n *      (3) The best size for dilating to get word masks is optionally returned.\n */",
      "file" : "jbclass.c"
   },
   {
      "function" : "pixWrite",
      "comment" : "/*!\n *  pixWrite()\n *\n *      Input:  filename\n *              pix\n *              format  (defined in imageio.h)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) Open for write using binary mode (with the \"b\" flag)\n *          to avoid having Windows automatically translate the NL\n *          into CRLF, which corrupts image files.  On non-windows\n *          systems this flag should be ignored, per ISO C90.\n *          Thanks to Dave Bryan for pointing this out.\n *      (2) If the default image format is requested, we use the input format;\n *          if the input format is unknown, a lossless format is assigned.\n *      (3) There are two modes with respect to file naming.\n *          (a) The default code writes to @filename.\n *          (b) If WRITE_AS_NAMED is defined to 0, it's a bit fancier.\n *              Then, if @filename does not have a file extension, one is\n *              automatically appended, depending on the requested format.\n *          The original intent for providing option (b) was to insure\n *          that filenames on Windows have an extension that matches\n *          the image compression.  However, this is not the default.\n */",
      "file" : "writefile.c"
   },
   {
      "function" : "pixWriteImpliedFormat",
      "comment" : "/*!\n *  pixWriteImpliedFormat()\n *\n *      Input:  filename\n *              pix\n *              quality (iff JPEG; 1 - 100, 0 for default)\n *              progressive (iff JPEG; 0 for baseline seq., 1 for progressive)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This determines the output format from the filename extension.\n *      (2) The last two args are ignored except for requests for jpeg files.\n *      (3) The jpeg default quality is 75.\n */",
      "file" : "writefile.c"
   },
   {
      "function" : "pixWriteJpeg",
      "comment" : "/*!\n *  pixWriteJpeg()\n *\n *      Input:  filename\n *              pix\n *              quality (1 - 100; 75 is default)\n *              progressive (0 for baseline sequential; 1 for progressive)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "jpegio.c"
   },
   {
      "function" : "pixWriteMem",
      "comment" : "/*!\n *  pixWriteMem()\n *\n *      Input:  &data (<return> data of tiff compressed image)\n *              &size (<return> size of returned data)\n *              pix\n *              format  (defined in imageio.h)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) On windows, this will only write tiff and PostScript to memory.\n *          For other formats, it requires open_memstream(3).\n *      (2) PostScript output is uncompressed, in hex ascii.\n *          Most printers support level 2 compression (tiff_g4 for 1 bpp,\n *          jpeg for 8 and 32 bpp).\n */",
      "file" : "writefile.c"
   },
   {
      "function" : "pixWriteMemBmp",
      "comment" : "/*!\n *  pixWriteMemBmp()\n *\n *      Input:  &data (<return> data of tiff compressed image)\n *              &size (<return> size of returned data)\n *              pix\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) See pixWriteStreamBmp() for usage.  This version writes to\n *          memory instead of to a file stream.\n */",
      "file" : "bmpio.c"
   },
   {
      "function" : "pixWriteMemGif",
      "comment" : "/*!\n *  pixWriteMemGif()\n *\n *      Input:  &data (<return> data of gif compressed image)\n *              &size (<return> size of returned data)\n *              pix\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) See comments in pixReadMemGif()\n */",
      "file" : "gifio.c"
   },
   {
      "function" : "pixWriteMemJpeg",
      "comment" : "/*!\n *  pixWriteMemJpeg()\n *\n *      Input:  &data (<return> data of jpeg compressed image)\n *              &size (<return> size of returned data)\n *              pix\n *              quality  (1 - 100; 75 is default value; 0 is also default)\n *              progressive (0 for baseline sequential; 1 for progressive)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) See pixWriteStreamJpeg() for usage.  This version writes to\n *          memory instead of to a file stream.\n */",
      "file" : "jpegio.c"
   },
   {
      "function" : "pixWriteMemPS",
      "comment" : "/*!\n *  pixWriteMemPS()\n *\n *      Input:  &data (<return> data of tiff compressed image)\n *              &size (<return> size of returned data)\n *              pix\n *              box  (<optional>)\n *              res  (can use 0 for default of 300 ppi)\n *              scale (to prevent scaling, use either 1.0 or 0.0)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) See pixWriteStringPS() for usage.\n *      (2) This is just a wrapper for pixWriteStringPS(), which\n *          writes uncompressed image data to memory.\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "pixWriteMemPng",
      "comment" : "/*!\n *  pixWriteMemPng()\n *\n *      Input:  &data (<return> data of tiff compressed image)\n *              &size (<return> size of returned data)\n *              pix\n *              gamma (use 0.0 if gamma is not defined)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) See pixWriteStreamPng() for usage.  This version writes to\n *          memory instead of to a file stream.\n */",
      "file" : "pngio.c"
   },
   {
      "function" : "pixWriteMemPnm",
      "comment" : "/*!\n *  pixWriteMemPnm()\n *\n *      Input:  &data (<return> data of tiff compressed image)\n *              &size (<return> size of returned data)\n *              pix\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) See pixWriteStreamPnm() for usage.  This version writes to\n *          memory instead of to a file stream.\n */",
      "file" : "pnmio.c"
   },
   {
      "function" : "pixWriteMemSpix",
      "comment" : "/*!\n *  pixWriteMemSpix()\n *\n *      Input:  &data (<return> data of serialized, uncompressed pix)\n *              &size (<return> size of returned data)\n *              pix (all depths; colormap OK)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "spixio.c"
   },
   {
      "function" : "pixWriteMemTiff",
      "comment" : "/*!\n *  pixWriteMemTiff()\n *\n *      Input:  &data (<return> data of tiff compressed image)\n *              &size (<return> size of returned data)\n *              pix\n *              comptype (IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,\n *                        IFF_TIFF_G3, IFF_TIFF_G4,\n *                        IFF_TIFF_LZW, IFF_TIFF_ZIP)\n *      Return: 0 if OK, 1 on error\n *\n *  Usage:\n *      (1) See pixWriteTiff().  This version writes to\n *          memory instead of to a file.\n */",
      "file" : "tiffio.c"
   },
   {
      "function" : "pixWriteMemTiffCustom",
      "comment" : "/*!\n *  pixWriteMemTiffCustom()\n *\n *      Input:  &data (<return> data of tiff compressed image)\n *              &size (<return> size of returned data)\n *              pix\n *              comptype (IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,\n *                        IFF_TIFF_G3, IFF_TIFF_G4,\n *                        IFF_TIFF_LZW, IFF_TIFF_ZIP)\n *              natags (<optional> NUMA of custom tiff tags)\n *              savals (<optional> SARRAY of values)\n *              satypes (<optional> SARRAY of types)\n *              nasizes (<optional> NUMA of sizes)\n *      Return: 0 if OK, 1 on error\n *\n *  Usage:\n *      (1) See pixWriteTiffCustom().  This version writes to\n *          memory instead of to a file.\n *      (2) Use TIFFClose(); TIFFCleanup() doesn't free internal memstream.\n */",
      "file" : "tiffio.c"
   },
   {
      "function" : "pixWriteMemWebP",
      "comment" : "/*!\n *  pixWriteMemWebP()\n *\n *      Input:  &encdata (<return> webp encoded data of pixs)\n *              &encsize (<return> size of webp encoded data)\n *              pixs (any depth, cmapped OK)\n *              quality (0 - 100; default ~80)\n *              lossless (use 1 for lossless; 0 for lossy)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Lossless and lossy encoding are entirely different in webp.\n *          @quality applies to lossy, and is ignored for lossless.\n *      (2) The input image is converted to RGB if necessary.  If spp == 3,\n *          we set the alpha channel to fully opaque (255), and\n *          WebPEncodeRGBA() then removes the alpha chunk when encoding,\n *          setting the internal header field has_alpha to 0.\n */",
      "file" : "webpio.c"
   },
   {
      "function" : "pixWriteMixedToPS",
      "comment" : "/*\n *  pixWriteMixedToPS()\n *\n *      Input:  pixb (<optionall> 1 bpp \"mask\"; typically for text)\n *              pixc (<optional> 8 or 32 bpp image regions)\n *              scale (relative scale factor for rendering pixb\n *                    relative to pixc; typ. 4.0)\n *              pageno (page number in set; use 1 for new output file)\n *              fileout (output ps file)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This low level function generates the PS string for a mixed\n *          text/image page, and adds it to an existing file if\n *          @pageno > 1.\n *      (2) The two images (pixb and pixc) are typically generated at the\n *          resolution that they will be rendered in the PS file.\n *      (3) pixb is the text component.  In the PostScript world, we think of\n *          it as a mask through which we paint black.\n *      (4) pixc is the (typically halftone) image component.  It is\n *          white in the rest of the page.  To minimize the size of the\n *          PS file, it should be rendered at a resolution that is at\n *          least equal to its actual resolution.\n *      (5) @scale gives the ratio of resolution of pixb to pixc.\n *          Typical resolutions are: 600 ppi for pixb, 150 ppi for pixc;\n *          so @scale = 4.0.  If one of the images is not defined,\n *          the value of @scale is ignored.\n *      (6) We write pixc with DCT compression (jpeg).  This is followed\n *          by painting the text as black through the mask pixb.  If\n *          pixc doesn't exist (alltext), we write the text with the\n *          PS \"image\" operator instead of the \"imagemask\" operator,\n *          because ghostscript's ps2pdf is flaky when the latter is used.\n *      (7) The actual output resolution is determined by fitting the\n *          result to a letter-size (8.5 x 11 inch) page.\n */",
      "file" : "psio1.c"
   },
   {
      "function" : "pixWritePSEmbed",
      "comment" : "/*!\n *  pixWritePSEmbed()\n *\n *      Input:  filein (input file, all depths, colormap OK)\n *              fileout (output ps file)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is a simple wrapper function that generates an\n *          uncompressed PS file, with a bounding box.\n *      (2) The bounding box is required when a program such as TeX\n *          (through epsf) places and rescales the image.\n *      (3) The bounding box is sized for fitting the image to an\n *          8.5 x 11.0 inch page.\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "pixWritePng",
      "comment" : "/*!\n *  pixWritePng()\n *\n *      Input:  filename\n *              pix\n *              gamma\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) Special version for writing png with a specified gamma.\n *          When using pixWrite(), no field is given for gamma.\n */",
      "file" : "pngio.c"
   },
   {
      "function" : "pixWriteSegmentedPageToPS",
      "comment" : "/*\n *  pixWriteSegmentedPageToPS()\n *\n *      Input:  pixs (all depths; colormap ok)\n *              pixm (<optional> 1 bpp segmentation mask over image region)\n *              textscale (scale of text output relative to pixs)\n *              imagescale (scale of image output relative to pixs)\n *              threshold (threshold for binarization; typ. 190)\n *              pageno (page number in set; use 1 for new output file)\n *              fileout (output ps file)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This generates the PS string for a mixed text/image page,\n *          and adds it to an existing file if @pageno > 1.\n *          The PS output is determined by fitting the result to\n *          a letter-size (8.5 x 11 inch) page.\n *      (2) The two images (pixs and pixm) are at the same resolution\n *          (typically 300 ppi).  They are used to generate two compressed\n *          images, pixb and pixc, that are put directly into the output\n *          PS file.\n *      (3) pixb is the text component.  In the PostScript world, we think of\n *          it as a mask through which we paint black.  It is produced by\n *          scaling pixs by @textscale, and thresholding to 1 bpp.\n *      (4) pixc is the image component, which is that part of pixs under\n *          the mask pixm.  It is scaled from pixs by @imagescale.\n *      (5) Typical values are textscale = 2.0 and imagescale = 0.5.\n *      (6) If pixm == NULL, the page has only text.  If it is all black,\n *          the page is all image and has no text.\n *      (7) This can be used to write a multi-page PS file, by using\n *          sequential page numbers with the same output file.  It can\n *          also be used to write separate PS files for each page,\n *          by using different output files with @pageno = 0 or 1.\n */",
      "file" : "psio1.c"
   },
   {
      "function" : "pixWriteStream",
      "comment" : "/*!\n *  pixWriteStream()\n *\n *      Input:  stream\n *              pix\n *              format\n *      Return: 0 if OK; 1 on error.\n */",
      "file" : "writefile.c"
   },
   {
      "function" : "pixWriteStreamAsciiPnm",
      "comment" : "/*!\n *  pixWriteStreamAsciiPnm()\n *\n *      Input:  stream opened for write\n *              pix\n *      Return: 0 if OK; 1 on error\n *\n *  Writes \"ascii\" format only:\n *      1 bpp --> pbm (P1)\n *      2, 4, 8, 16 bpp, no colormap or grayscale colormap --> pgm (P2)\n *      2, 4, 8 bpp with color-valued colormap, or rgb --> rgb ppm (P3)\n */",
      "file" : "pnmio.c"
   },
   {
      "function" : "pixWriteStreamBmp",
      "comment" : "/*!\n *  pixWriteStreamBmp()\n *\n *      Input:  stream opened for write\n *              pix (1, 4, 8, 32 bpp)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) We position fp at the beginning of the stream, so it\n *          truncates any existing data\n *      (2) 2 bpp Bmp files are apparently not valid!.  We can\n *          write and read them, but nobody else can read ours.\n */",
      "file" : "bmpio.c"
   },
   {
      "function" : "pixWriteStreamGif",
      "comment" : "/*!\n *  pixWriteStreamGif()\n *\n *      Input:  stream\n *              pix (1, 2, 4, 8, 16 or 32 bpp)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) All output gif have colormaps.  If the pix is 32 bpp rgb,\n *          this quantizes the colors and writes out 8 bpp.\n *          If the pix is 16 bpp grayscale, it converts to 8 bpp first.\n *      (2) We can't write to memory using open_memstream() because\n *          the gif functions write through a file descriptor, not a\n *          file stream.\n */",
      "file" : "gifio.c"
   },
   {
      "function" : "pixWriteStreamJpeg",
      "comment" : "/*!\n *  pixWriteStreamJpeg()\n *\n *      Input:  stream\n *              pix  (8 or 32 bpp)\n *              quality  (1 - 100; 75 is default value; 0 is also default)\n *              progressive (0 for baseline sequential; 1 for progressive)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Under the covers, the library transforms rgb to a\n *          luminence-chromaticity triple, each component of which is\n *          also 8 bits, and compresses that.  It uses 2 Huffman tables,\n *          a higher resolution one (with more quantization levels)\n *          for luminosity and a lower resolution one for the chromas.\n *      (2) Progressive encoding gives better compression, at the\n *          expense of slower encoding and decoding.\n *      (3) Standard chroma subsampling is 2x2 on both the U and V\n *          channels.  For highest quality, use no subsampling; this\n *          option is set by pixSetChromaSampling(pix, 0).\n *      (4) There are three possibilities:\n *          * Grayscale image, no colormap: compress as 8 bpp image.\n *          * rgb full color image: copy each line into the color\n *            line buffer, and compress as three 8 bpp images.\n *          * 8 bpp colormapped image: convert each line to three\n *            8 bpp line images in the color line buffer, and\n *            compress as three 8 bpp images.\n *      (5) The only valid pixel depths in leptonica are 1, 2, 4, 8, 16\n *          and 32 bpp.  However, it is possible, and in some cases desirable,\n *          to write out a jpeg file using an rgb pix that has 24 bpp.\n *          This can be created by appending the raster data for a 24 bpp\n *          image (with proper scanline padding) directly to a 24 bpp\n *          pix that was created without a data array.  See note in\n *          pixWriteStreamPng() for an example.\n */",
      "file" : "jpegio.c"
   },
   {
      "function" : "pixWriteStreamPS",
      "comment" : "/*!\n *  pixWriteStreamPS()\n *\n *      Input:  stream\n *              pix\n *              box  (<optional>)\n *              res  (can use 0 for default of 300 ppi)\n *              scale (to prevent scaling, use either 1.0 or 0.0)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This writes image in PS format, optionally scaled,\n *          adjusted for the printer resolution, and with\n *          a bounding box.\n *      (2) For details on use of parameters, see pixWriteStringPS().\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "pixWriteStreamPdf",
      "comment" : "/*!\n *  pixWriteStreamPdf()\n *\n *      Input:  fp (stream opened for writing)\n *              pix (all depths, cmap OK)\n *              res (override the resolution of the input image, in ppi;\n *                   use 0 to respect the resolution embedded in the input)\n *              title (<optional> pdf title; taken from the first image\n *                     placed on a page; e.g., an input image filename)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is the simplest interface for writing a single image\n *          with pdf encoding.  It uses G4 encoding for 1 bpp,\n *          JPEG encoding for 8 bpp (no cmap) and 32 bpp, and FLATE\n *          encoding for everything else.\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "pixWriteStreamPng",
      "comment" : "/*!\n *  pixWriteStreamPng()\n *\n *      Input:  stream\n *              pix\n *              gamma (use 0.0 if gamma is not defined)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) If called from pixWriteStream(), the stream is positioned\n *          at the beginning of the file.\n *      (2) To do sequential writes of png format images to a stream,\n *          use pixWriteStreamPng() directly.\n *      (3) gamma is an optional png chunk.  If no gamma value is to be\n *          placed into the file, use gamma = 0.0.  Otherwise, if\n *          gamma > 0.0, its value is written into the header.\n *      (4) The use of gamma in png is highly problematic.  For an illuminating\n *          discussion, see:  http://hsivonen.iki.fi/png-gamma/\n *      (5) What is the effect/meaning of gamma in the png file?  This\n *          gamma, which we can call the 'source' gamma, is the\n *          inverse of the gamma that was used in enhance.c to brighten\n *          or darken images.  The 'source' gamma is supposed to indicate\n *          the intensity mapping that was done at the time the\n *          image was captured.  Display programs typically apply a\n *          'display' gamma of 2.2 to the output, which is intended\n *          to linearize the intensity based on the response of\n *          thermionic tubes (CRTs).  Flat panel LCDs have typically\n *          been designed to give a similar response as CRTs (call it\n *          \"backward compatibility\").  The 'display' gamma is\n *          in some sense the inverse of the 'source' gamma.\n *          jpeg encoders attached to scanners and cameras will lighten\n *          the pixels, applying a gamma corresponding to approximately\n *          a square-root relation of output vs input:\n *                output = input^(gamma)\n *          where gamma is often set near 0.4545  (1/gamma is 2.2).\n *          This is stored in the image file.  Then if the display\n *          program reads the gamma, it will apply a display gamma,\n *          typically about 2.2; the product is 1.0, and the\n *          display program produces a linear output.  This works because\n *          the dark colors were appropriately boosted by the scanner,\n *          as described by the 'source' gamma, so they should not\n *          be further boosted by the display program.\n *      (6) As an example, with xv and display, if no gamma is stored,\n *          the program acts as if gamma were 0.4545, multiplies this by 2.2,\n *          and does a linear rendering.  Taking this as a baseline\n *          brightness, if the stored gamma is:\n *              > 0.4545, the image is rendered lighter than baseline\n *              < 0.4545, the image is rendered darker than baseline\n *          In contrast, gqview seems to ignore the gamma chunk in png.\n *      (7) The only valid pixel depths in leptonica are 1, 2, 4, 8, 16\n *          and 32.  However, it is possible, and in some cases desirable,\n *          to write out a png file using an rgb pix that has 24 bpp.\n *          For example, the open source xpdf SplashBitmap class generates\n *          24 bpp rgb images.  Consequently, we enable writing 24 bpp pix.\n *          To generate such a pix, you can make a 24 bpp pix without data\n *          and assign the data array to the pix; e.g.,\n *              pix = pixCreateHeader(w, h, 24);\n *              pixSetData(pix, rgbdata);\n *          See pixConvert32To24() for an example, where we get rgbdata\n *          from the 32 bpp pix.  Caution: do not call pixSetPadBits(),\n *          because the alignment is wrong and you may erase part of the\n *          last pixel on each line.\n *      (8) If the pix has a colormap, it is written to file.  In most\n *          situations, the alpha component is 255 for each colormap entry,\n *          which is opaque and indicates that it should be ignored.\n *          However, if any alpha component is not 255, it is assumed that\n *          the alpha values are valid, and they are written to the png\n *          file in a tRNS segment.  On readback, the tRNS segment is\n *          identified, and the colormapped image with alpha is converted\n *          to a 4 spp rgba image.\n */",
      "file" : "pngio.c"
   },
   {
      "function" : "pixWriteStreamPnm",
      "comment" : "/*!\n *  pixWriteStreamPnm()\n *\n *      Input:  stream opened for write\n *              pix\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This writes \"raw\" packed format only:\n *          1 bpp --> pbm (P4)\n *          2, 4, 8, 16 bpp, no colormap or grayscale colormap --> pgm (P5)\n *          2, 4, 8 bpp with color-valued colormap, or rgb --> rgb ppm (P6)\n *      (2) 24 bpp rgb are not supported in leptonica, but this will\n *          write them out as a packed array of bytes (3 to a pixel).\n */",
      "file" : "pnmio.c"
   },
   {
      "function" : "pixWriteStreamSpix",
      "comment" : "/*!\n *  pixWriteStreamSpix()\n *\n *      Input:  stream\n *              pix\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "spixio.c"
   },
   {
      "function" : "pixWriteStreamTiff",
      "comment" : "/*!\n *  pixWriteStreamTiff()\n *\n *      Input:  stream (opened for append or write)\n *              pix\n *              comptype (IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,\n *                        IFF_TIFF_G3, IFF_TIFF_G4,\n *                        IFF_TIFF_LZW, IFF_TIFF_ZIP)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) For images with bpp > 1, this resets the comptype, if\n *          necessary, to write uncompressed data.\n *      (2) G3 and G4 are only defined for 1 bpp.\n *      (3) We only allow PACKBITS for bpp = 1, because for bpp > 1\n *          it typically expands images that are not synthetically generated.\n *      (4) G4 compression is typically about twice as good as G3.\n *          G4 is excellent for binary compression of text/line-art,\n *          but terrible for halftones and dithered patterns.  (In\n *          fact, G4 on halftones can give a file that is larger\n *          than uncompressed!)  If a binary image has dithered\n *          regions, it is usually better to compress with png.\n */",
      "file" : "tiffio.c"
   },
   {
      "function" : "pixWriteStreamWebP",
      "comment" : "/*!\n *  pixWriteStreampWebP()\n *\n *      Input:  stream\n *              pixs  (all depths)\n *              quality (0 - 100; default ~80)\n *              lossless (use 1 for lossless; 0 for lossy)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) See pixWriteMemWebP() for details.\n *      (2) Use 'free', and not leptonica's 'FREE', for all heap data\n *          that is returned from the WebP library.\n */",
      "file" : "webpio.c"
   },
   {
      "function" : "pixWriteStringPS",
      "comment" : "/*!\n *  pixWriteStringPS()\n *\n *      Input:  pixs:  all depths, colormap OK\n *              box:  (a) If box == null, image is placed, optionally scaled,\n *                        in a standard b.b. at the center of the page.\n *                        This is to be used when another program like\n *                        TeX (through epsf) places the image.\n *                    (b) If box != null, image is placed without a\n *                        b.b. at the specified page location and with\n *                        (optional) scaling.  This is to be used when\n *                        you want to specify exactly where (and optionally\n *                        how big) you want the image to be.\n *                        Note that all coordinates are in PS convention,\n *                        with (0,0) at LL corner of the page:\n *                            (x,y)    location of LL corner of image, in mils.\n *                            (w,h)    scaled size, in mils.  Use 0 to\n *                                     scale with \"scale\" and \"res\" input.\n *              res:  resolution, in printer ppi.  Use 0 for default (300 ppi).\n *              scale: scale factor.  If no scaling is desired, use\n *                     either 1.0 or 0.0.   Scaling just resets the resolution\n *                     parameter; the actual scaling is done in the\n *                     interpreter at rendering time.  This is important:\n *                     it allows you to scale the image up without\n *                     increasing the file size.\n *      Return: ps string if OK, or null on error\n *\n *  Notes:\n *      (1) OK, this seems a bit complicated, because there are various\n *          ways to scale and not to scale.  Here's a summary:\n *      (2) If you don't want any scaling at all:\n *           * if you are using a box:\n *               set w = 0, h = 0, and use scale = 1.0; it will print\n *               each pixel unscaled at printer resolution\n *           * if you are not using a box:\n *               set scale = 1.0; it will print at printer resolution\n *      (3) If you want the image to be a certain size in inches:\n *           * you must use a box and set the box (w,h) in mils\n *      (4) If you want the image to be scaled by a scale factor != 1.0:\n *           * if you are using a box:\n *               set w = 0, h = 0, and use the desired scale factor;\n *               the higher the printer resolution, the smaller the\n *               image will actually appear.\n *           * if you are not using a box:\n *               set the desired scale factor; the higher the printer\n *               resolution, the smaller the image will actually appear.\n *      (5) Another complication is the proliferation of distance units:\n *           * The interface distances are in milli-inches.\n *           * Three different units are used internally:\n *              - pixels  (units of 1/res inch)\n *              - printer pts (units of 1/72 inch)\n *              - inches\n *           * Here is a quiz on volume units from a reviewer:\n *             How many UK milli-cups in a US kilo-teaspoon?\n *               (Hint: 1.0 US cup = 0.75 UK cup + 0.2 US gill;\n *                      1.0 US gill = 24.0 US teaspoons)\n */",
      "file" : "psio2.c"
   },
   {
      "function" : "pixWriteTTFText",
      "comment" : "/* Mix 2 colors using level as alpha */",
      "file" : "freetype.c"
   },
   {
      "function" : "pixWriteTempfile",
      "comment" : "/*!\n *  pixWriteTempfile()\n *\n *      Input:  dir (directory name; use '.' for local dir; no trailing '/')\n *              tail (<optional> tailname, including extension if any)\n *              pix\n *              format\n *              &filename (<optional> return actual filename used; use\n *                         null to skip)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This generates a temp filename, writes the pix to it,\n *          and optionally returns the temp filename.\n *      (2) If the filename is returned to a windows program from a DLL,\n *          use lept_free() to free it.\n *      (3) See genTempFilename() for details.  We omit the time and pid\n *          here.\n */",
      "file" : "writefile.c"
   },
   {
      "function" : "pixWriteTiff",
      "comment" : "/*!\n *  pixWriteTiff()\n *\n *      Input:  filename (to write to)\n *              pix\n *              comptype (IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,\n *                        IFF_TIFF_G3, IFF_TIFF_G4,\n *                        IFF_TIFF_LZW, IFF_TIFF_ZIP)\n *              modestring (\"a\" or \"w\")\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) For multi-page tiff, write the first pix with mode \"w\" and\n *          all subsequent pix with mode \"a\".\n */",
      "file" : "tiffio.c"
   },
   {
      "function" : "pixWriteTiffCustom",
      "comment" : "/*!\n *  pixWriteTiffCustom()\n *\n *      Input:  filename (to write to)\n *              pix\n *              comptype (IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,\n *                        IFF_TIFF_G3, IFF_TIFF_G4)\n *                        IFF_TIFF_LZW, IFF_TIFF_ZIP)\n *              modestring (\"a\" or \"w\")\n *              natags (<optional> NUMA of custom tiff tags)\n *              savals (<optional> SARRAY of values)\n *              satypes (<optional> SARRAY of types)\n *              nasizes (<optional> NUMA of sizes)\n *      Return: 0 if OK, 1 on error\n *\n *  Usage:\n *      (1) This writes a page image to a tiff file, with optional\n *          extra tags defined in tiff.h\n *      (2) For multi-page tiff, write the first pix with mode \"w\" and\n *          all subsequent pix with mode \"a\".\n *      (3) For the custom tiff tags:\n *          (a) The three arrays {natags, savals, satypes} must all be\n *              either NULL or defined and of equal size.\n *          (b) If they are defined, the tags are an array of integers,\n *              the vals are an array of values in string format, and\n *              the types are an array of types in string format.\n *          (c) All valid tags are definined in tiff.h.\n *          (d) The types allowed are the set of strings:\n *                \"char*\"\n *                \"l_uint8*\"\n *                \"l_uint16\"\n *                \"l_uint32\"\n *                \"l_int32\"\n *                \"l_float64\"\n *                \"l_uint16-l_uint16\" (note the dash; use it between the\n *                                    two l_uint16 vals in the val string)\n *              Of these, \"char*\" and \"l_uint16\" are the most commonly used.\n *          (e) The last array, nasizes, is also optional.  It is for\n *              tags that take an array of bytes for a value, a number of\n *              elements in the array, and a type that is either \"char*\"\n *              or \"l_uint8*\" (probably either will work).\n *              Use NULL if there are no such tags.\n *          (f) VERY IMPORTANT: if there are any tags that require the\n *              extra size value, stored in nasizes, they must be\n *              written first!\n */",
      "file" : "tiffio.c"
   },
   {
      "function" : "pixWriteToTiffStream",
      "comment" : "/*!\n *  pixWriteToTiffStream()\n *\n *      Input:  tif (data structure, opened to a file)\n *              pix\n *              comptype  (IFF_TIFF: for any image; no compression\n *                         IFF_TIFF_RLE, IFF_TIFF_PACKBITS: for 1 bpp only\n *                         IFF_TIFF_G4 and IFF_TIFF_G3: for 1 bpp only\n *                         IFF_TIFF_LZW, IFF_TIFF_ZIP: for any image\n *              natags (<optional> NUMA of custom tiff tags)\n *              savals (<optional> SARRAY of values)\n *              satypes (<optional> SARRAY of types)\n *              nasizes (<optional> NUMA of sizes)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This static function should only be called through higher\n *          level functions in this file; namely, pixWriteTiffCustom(),\n *          pixWriteTiff(), pixWriteStreamTiff(), pixWriteMemTiff()\n *          and pixWriteMemTiffCustom().\n *      (2) We only allow PACKBITS for bpp = 1, because for bpp > 1\n *          it typically expands images that are not synthetically generated.\n *      (3) See pixWriteTiffCustom() for details on how to use\n *          the last four parameters for customized tiff tags.\n *      (4) The only valid pixel depths in leptonica are 1, 2, 4, 8, 16\n *          and 32.  However, it is possible, and in some cases desirable,\n *          to write out a tiff file using an rgb pix that has 24 bpp.\n *          This can be created by appending the raster data for a 24 bpp\n *          image (with proper scanline padding) directly to a 24 bpp\n *          pix that was created without a data array.  See note in\n *          pixWriteStreamPng() for an example.\n */",
      "file" : "tiffio.c"
   },
   {
      "function" : "pixWriteWebP",
      "comment" : "/*!\n *  pixWriteWebP()\n *\n *      Input:  filename\n *              pixs\n *              quality (0 - 100; default ~80)\n *              lossless (use 1 for lossless; 0 for lossy)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Special top-level function allowing specification of quality.\n */",
      "file" : "webpio.c"
   },
   {
      "function" : "pixXor",
      "comment" : "/*!\n *  pixXor()\n *\n *      Input:  pixd  (<optional>; this can be null, equal to pixs1,\n *                     different from pixs1)\n *              pixs1 (can be == pixd)\n *              pixs2 (must be != pixd)\n *      Return: pixd always\n *\n *  Notes:\n *      (1) This gives the XOR of two images with equal depth,\n *          aligning them to the the UL corner.  pixs1 and pixs2\n *          need not have the same width and height.\n *      (2) There are 3 cases:\n *            (a) pixd == null,   (src1 ^ src2) --> new pixd\n *            (b) pixd == pixs1,  (src1 ^ src2) --> src1  (in-place)\n *            (c) pixd != pixs1,  (src1 ^ src2) --> input pixd\n *      (3) For clarity, if the case is known, use these patterns:\n *            (a) pixd = pixXor(NULL, pixs1, pixs2);\n *            (b) pixXor(pixs1, pixs1, pixs2);\n *            (c) pixXor(pixd, pixs1, pixs2);\n *      (4) The size of the result is determined by pixs1.\n *      (5) The depths of pixs1 and pixs2 must be equal.\n *      (6) Note carefully that the order of pixs1 and pixs2 only matters\n *          for the in-place case.  For in-place, you must have\n *          pixd == pixs1.  Setting pixd == pixs2 gives an incorrect\n *          result: the copy puts pixs1 image data in pixs2, and\n *          the rasterop is then between pixs2 and pixs2 (a no-op).\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixZero",
      "comment" : "/*!\n *  pixZero()\n *\n *      Input:  pix (all depths; not colormapped)\n *              &empty  (<return> 1 if all bits in image are 0; 0 otherwise)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) For a binary image, if there are no fg (black) pixels, empty = 1.\n *      (2) For a grayscale image, if all pixels are black (0), empty = 1.\n *      (3) For an RGB image, if all 4 components in every pixel is 0,\n *          empty = 1.\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pix_free",
      "comment" : "/* _MSC_VER */",
      "file" : "pix1.c"
   },
   {
      "function" : "pix_malloc",
      "comment" : "/*-------------------------------------------------------------------------*\n *                        Pix Memory Management                            *\n *                                                                         *\n *  These functions give you the freedom to specify at compile or run      *\n *  time the allocator and deallocator to be used for pix.  It has no      *\n *  effect on memory management for other data structs, which are          *\n *  controlled by the #defines in environ.h.  Likewise, the #defines       *\n *  in environ.h have no effect on the pix memory management.              *\n *  The default functions are malloc and free.  Use setPixMemoryManager()  *\n *  to specify other functions to use.                                     *\n *-------------------------------------------------------------------------*/",
      "file" : "pix1.c"
   },
   {
      "function" : "pixaAccumulateSamples",
      "comment" : "/*!\n *  pixaAccumulateSamples()\n *\n *      Input:  pixa (of samples from the same class, 1 bpp)\n *              pta (<optional> of centroids of the samples)\n *              &ppixd (<return> accumulated samples, 8 bpp)\n *              &px (<optional return> average x coordinate of centroids)\n *              &py (<optional return> average y coordinate of centroids)\n *      Return: 0 on success, 1 on failure\n *\n *  Notes:\n *      (1) This generates an aligned (by centroid) sum of the input pix.\n *      (2) We use only the first 256 samples; that's plenty.\n *      (3) If pta is not input, we generate two tables, and discard\n *          after use.  If this is called many times, it is better\n *          to precompute the pta.\n */",
      "file" : "recogtrain.c"
   },
   {
      "function" : "pixaAddBorderGeneral",
      "comment" : "/*!\n *  pixaAddBorderGeneral()\n *\n *      Input:  pixad (can be null or equal to pixas)\n *              pixas (containing pix of all depths; colormap ok)\n *              left, right, top, bot  (number of pixels added)\n *              val   (value of added border pixels)\n *      Return: pixad (with border added to each pix), including on error\n *\n *  Notes:\n *      (1) For binary images:\n *             white:  val = 0\n *             black:  val = 1\n *          For grayscale images:\n *             white:  val = 2 ** d - 1\n *             black:  val = 0\n *          For rgb color images:\n *             white:  val = 0xffffff00\n *             black:  val = 0\n *          For colormapped images, use 'index' found this way:\n *             white: pixcmapGetRankIntensity(cmap, 1.0, &index);\n *             black: pixcmapGetRankIntensity(cmap, 0.0, &index);\n *      (2) For in-place replacement of each pix with a bordered version,\n *          use @pixad = @pixas.  To make a new pixa, use @pixad = NULL.\n *      (3) In both cases, the boxa has sides adjusted as if it were\n *          expanded by the border.\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixaAddBox",
      "comment" : "/*!\n *  pixaAddBox()\n *\n *      Input:  pixa\n *              box\n *              copyflag (L_INSERT, L_COPY, L_CLONE)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaAddPix",
      "comment" : "/*!\n *  pixaAddPix()\n *\n *      Input:  pixa\n *              pix  (to be added)\n *              copyflag (L_INSERT, L_COPY, L_CLONE)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaAddTextNumber",
      "comment" : "/*!\n *  pixaAddTextNumber()\n *\n *      Input:  pixas (input pixa; colormap ok)\n *              bmf (bitmap font data)\n *              numa (<optional> number array; use 1 ... n if null)\n *              val (color to set the text)\n *              location (L_ADD_ABOVE, L_ADD_BELOW, L_ADD_LEFT, L_ADD_RIGHT)\n *      Return: pixad (new pixa with rendered numbers), or null on error\n *\n *  Notes:\n *      (1) Typical usage is for labelling each pix in a pixa with a number.\n *      (2) This function paints numbers external to each pix, in a position\n *          given by @location.  In all cases, the pix is expanded on\n *          on side and the number is painted over white in the added region.\n *      (3) @val is the pixel value to be painted through the font mask.\n *          It should be chosen to agree with the depth of pixs.\n *          If it is out of bounds, an intermediate value is chosen.\n *          For RGB, use hex notation: 0xRRGGBB00, where RR is the\n *          hex representation of the red intensity, etc.\n *      (4) If na == NULL, number each pix sequentially, starting with 1.\n *      (5) If there is a colormap, this does the best it can to use\n *          the requested color, or something similar to it.\n */",
      "file" : "textops.c"
   },
   {
      "function" : "pixaAddTextline",
      "comment" : "/*!\n *  pixaAddTextline()\n *\n *      Input:  pixas (input pixa; colormap ok)\n *              bmf (bitmap font data)\n *              sa (<optional> sarray; use text embedded in each pix if null)\n *              val (color to set the text)\n *              location (L_ADD_ABOVE, L_ADD_BELOW, L_ADD_LEFT, L_ADD_RIGHT)\n *      Return: pixad (new pixa with rendered text), or null on error\n *\n *  Notes:\n *      (1) This function paints a line of text external to each pix,\n *          in a position given by @location.  In all cases, the pix is\n *          expanded as necessary to accommodate the text.\n *      (2) @val is the pixel value to be painted through the font mask.\n *          It should be chosen to agree with the depth of pixs.\n *          If it is out of bounds, an intermediate value is chosen.\n *          For RGB, use hex notation: 0xRRGGBB00, where RR is the\n *          hex representation of the red intensity, etc.\n *      (3) If sa == NULL, use the text embedded in each pix.\n *      (4) If sa has a smaller count than pixa, issue a warning\n *          but do not use any embedded text.\n *      (5) If there is a colormap, this does the best it can to use\n *          the requested color, or something similar to it.\n */",
      "file" : "textops.c"
   },
   {
      "function" : "pixaAnyColormaps",
      "comment" : "/*!\n *  pixaAnyColormaps()\n *\n *      Input:  pixa\n *              &hascmap (<return> 1 if any pix has a colormap; 0 otherwise)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixaBinSort",
      "comment" : "/*!\n *  pixaBinSort()\n *\n *      Input:  pixas\n *              sorttype (L_SORT_BY_X, L_SORT_BY_Y, L_SORT_BY_WIDTH,\n *                        L_SORT_BY_HEIGHT, L_SORT_BY_PERIMETER)\n *              sortorder  (L_SORT_INCREASING, L_SORT_DECREASING)\n *              &naindex (<optional return> index of sorted order into\n *                        original array)\n *              copyflag (L_COPY, L_CLONE)\n *      Return: pixad (sorted version of pixas), or null on error\n *\n *  Notes:\n *      (1) This sorts based on the data in the boxa.  If the boxa\n *          count is not the same as the pixa count, this returns an error.\n *      (2) The copyflag refers to the pix and box copies that are\n *          inserted into the sorted pixa.  These are either L_COPY\n *          or L_CLONE.\n *      (3) For a large number of boxes (say, greater than 1000), this\n *          O(n) binsort is much faster than the O(nlogn) shellsort.\n *          For 5000 components, this is over 20x faster than boxaSort().\n *      (4) Consequently, pixaSort() calls this function if it will\n *          likely go much faster.\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixaCentroids",
      "comment" : "/*!\n *  pixaCentroids()\n *\n *      Input:  pixa of components (1 or 8 bpp)\n *      Return: pta of centroids relative to the UL corner of\n *              each pix, or null on error\n *\n *  Notes:\n *      (1) An error message is returned if any pix has something other\n *          than 1 bpp or 8 bpp depth, and the centroid from that pix\n *          is saved as (0, 0).\n */",
      "file" : "morphapp.c"
   },
   {
      "function" : "pixaChangeRefcount",
      "comment" : "/*!\n *  pixaChangeRefcount()\n *\n *      Input:  pixa\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaClear",
      "comment" : "/*!\n *  pixaClear()\n *\n *      Input:  pixa\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This destroys all pix in the pixa, as well as\n *          all boxes in the boxa.  The ptrs in the pix ptr array\n *          are all null'd.  The number of allocated pix, n, is set to 0.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaClipToPix",
      "comment" : "/*!\n *  pixaClipToPix()\n *\n *      Input:  pixas\n *              pixs\n *      Return: pixad, or null on error\n *\n *  Notes:\n *      (1) This is intended for use in situations where pixas\n *          was originally generated from the input pixs.\n *      (2) Returns a pixad where each pix in pixas is ANDed\n *          with its associated region of the input pixs.  This\n *          region is specified by the the box that is associated\n *          with the pix.\n *      (3) In a typical application of this function, pixas has\n *          a set of region masks, so this generates a pixa of\n *          the parts of pixs that correspond to each region\n *          mask component, along with the bounding box for\n *          the region.\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixaConvertTo1",
      "comment" : "/*!\n *  pixaConvertTo1()\n *\n *      Input:  pixas\n *              thresh (threshold for final binarization from 8 bpp gray)\n *      Return: pixad, or null on error\n */",
      "file" : "pixafunc2.c"
   },
   {
      "function" : "pixaConvertTo32",
      "comment" : "/*!\n *  pixaConvertTo32()\n *\n *      Input:  pixas\n *      Return: pixad (32 bpp rgb), or null on error\n *\n *  Notes:\n *      (1) See notes for pixConvertTo32(), applied to each pix in pixas.\n */",
      "file" : "pixafunc2.c"
   },
   {
      "function" : "pixaConvertTo8",
      "comment" : "/*!\n *  pixaConvertTo8()\n *\n *      Input:  pixas\n *              cmapflag (1 to give pixd a colormap; 0 otherwise)\n *      Return: pixad (each pix is 8 bpp), or null on error\n *\n *  Notes:\n *      (1) See notes for pixConvertTo8(), applied to each pix in pixas.\n */",
      "file" : "pixafunc2.c"
   },
   {
      "function" : "pixaConvertTo8Color",
      "comment" : "/*!\n *  pixaConvertTo8Color()\n *\n *      Input:  pixas\n *              ditherflag (1 to dither if necessary; 0 otherwise)\n *      Return: pixad (each pix is 8 bpp), or null on error\n *\n *  Notes:\n *      (1) See notes for pixConvertTo8Color(), applied to each pix in pixas.\n */",
      "file" : "pixafunc2.c"
   },
   {
      "function" : "pixaConvertToPdf",
      "comment" : "/*!\n *  pixaConvertToPdf()\n *\n *      Input:  pixa (containing images all at the same resolution)\n *              res (override the resolution of each input image, in ppi;\n *                   use 0 to respect the resolution embedded in the input)\n *              scalefactor (scaling factor applied to each image; > 0.0)\n *              type (encoding type (L_JPEG_ENCODE, L_G4_ENCODE,\n *                    L_FLATE_ENCODE, or 0 for default)\n *              quality (used for JPEG only; 0 for default (75))\n *              title (<optional> pdf title; if null, taken from the first\n *                     image filename)\n *              fileout (pdf file of all images)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The images are encoded with G4 if 1 bpp; JPEG if 8 bpp without\n *          colormap and many colors, or 32 bpp; FLATE for anything else.\n *      (2) The scalefactor must be > 0.0; otherwise it is set to 1.0.\n *      (3) Specifying one of the three encoding types for @type forces\n *          all images to be compressed with that type.  Use 0 to have\n *          the type determined for each image based on depth and whether\n *          or not it has a colormap.\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "pixaConvertToPdfData",
      "comment" : "/*!\n *  pixaConvertToPdfData()\n *\n *      Input:  pixa (containing images all at the same resolution)\n *              res (input resolution of all images)\n *              scalefactor (scaling factor applied to each image; > 0.0)\n *              type (encoding type (L_JPEG_ENCODE, L_G4_ENCODE,\n *                    L_FLATE_ENCODE, or 0 for default)\n *              quality (used for JPEG only; 0 for default (75))\n *              title (<optional> pdf title)\n *              &data (<return> output pdf data (of all images)\n *              &nbytes (<return> size of output pdf data)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) See pixaConvertToPdf().\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "pixaConvertToSameDepth",
      "comment" : "/*!\n *  pixaConvertToSameDepth()\n *\n *      Input:  pixas\n *      Return: pixad, or null on error\n *\n *  Notes:\n *      (1) If any pix has a colormap, they are all converted to rgb.\n *          Otherwise, they are all converted to the maximum depth of\n *          all the pix.\n *      (2) This can be used to allow lossless rendering onto a single pix.\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixaCopy",
      "comment" : "/*!\n *  pixaCopy()\n *\n *      Input:  pixas\n *              copyflag (see pix.h for details):\n *                L_COPY makes a new pixa and copies each pix and each box\n *                L_CLONE gives a new ref-counted handle to the input pixa\n *                L_COPY_CLONE makes a new pixa and inserts clones of\n *                    all pix and boxes\n *      Return: new pixa, or null on error\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaCountPixels",
      "comment" : "/*!\n *  pixaCountPixels()\n *\n *      Input:  pixa (array of 1 bpp pix)\n *      Return: na of ON pixels in each pix, or null on error\n */",
      "file" : "pix3.c"
   },
   {
      "function" : "pixaCountText",
      "comment" : "/*!\n *  pixaCountText()\n *\n *      Input:  pixa\n *              &ntext (<return> number of pix with non-empty text strings)\n *      Return: 0 if OK, 1 on error.\n *\n *  Notes:\n *      (1) All pix have non-empty text strings if the returned value @ntext\n *          equals the pixa count.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaCreate",
      "comment" : "/*!\n *  pixaCreate()\n *\n *      Input:  n  (initial number of ptrs)\n *      Return: pixa, or null on error\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaCreateFromBoxa",
      "comment" : "/*!\n *  pixaCreateFromBoxa()\n *\n *      Input:  pixs\n *              boxa\n *              &cropwarn (<optional return> TRUE if the boxa extent\n *                         is larger than pixs.\n *      Return: pixad, or null on error\n *\n *  Notes:\n *      (1) This simply extracts from pixs the region corresponding to each\n *          box in the boxa.\n *      (2) The 3rd arg is optional.  If the extent of the boxa exceeds the\n *          size of the pixa, so that some boxes are either clipped\n *          or entirely outside the pix, a warning is returned as TRUE.\n *      (3) pixad will have only the properly clipped elements, and\n *          the internal boxa will be correct.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaCreateFromPix",
      "comment" : "/*!\n *  pixaCreateFromPix()\n *\n *      Input:  pixs  (with individual components on a lattice)\n *              n   (number of components)\n *              cellw   (width of each cell)\n *              cellh   (height of each cell)\n *      Return: pixa, or null on error\n *\n *  Notes:\n *      (1) For bpp = 1, we truncate each retrieved pix to the ON\n *          pixels, which we assume for now start at (0,0)\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaCreateFromPixacomp",
      "comment" : "/*!\n *  pixaCreateFromPixacomp()\n *\n *      Input:  pixac\n *              accesstype (L_COPY, L_CLONE, L_COPY_CLONE; for boxa)\n *      Return: pixa if OK, or null on error\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixaDestroy",
      "comment" : "/*!\n *  pixaDestroy()\n *\n *      Input:  &pixa (<can be nulled>)\n *      Return: void\n *\n *  Notes:\n *      (1) Decrements the ref count and, if 0, destroys the pixa.\n *      (2) Always nulls the input ptr.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaDisplay",
      "comment" : "/*!\n *  pixaDisplay()\n *\n *      Input:  pixa\n *              w, h (if set to 0, determines the size from the\n *                    b.b. of the components in pixa)\n *      Return: pix, or null on error\n *\n *  Notes:\n *      (1) This uses the boxes to place each pix in the rendered composite.\n *      (2) Set w = h = 0 to use the b.b. of the components to determine\n *          the size of the returned pix.\n *      (3) Uses the first pix in pixa to determine the depth.\n *      (4) The background is written \"white\".  On 1 bpp, each successive\n *          pix is \"painted\" (adding foreground), whereas for grayscale\n *          or color each successive pix is blitted with just the src.\n *      (5) If the pixa is empty, returns an empty 1 bpp pix.\n */",
      "file" : "pixafunc2.c"
   },
   {
      "function" : "pixaDisplayLinearly",
      "comment" : "/*!\n *  pixaDisplayLinearly()\n *\n *      Input:  pixa\n *              direction (L_HORIZ or L_VERT)\n *              scalefactor (applied to every pix; use 1.0 for no scaling)\n *              background (0 for white, 1 for black; this is the color\n *                 of the spacing between the images)\n *              spacing  (between images, and on outside)\n *              border (width of black border added to each image;\n *                      use 0 for no border)\n *              &boxa (<optional return> location of images in output pix\n *      Return: pix of composite images, or null on error\n *\n *  Notes:\n *      (1) This puts each pix, sequentially, in a line, either horizontally\n *          or vertically.\n *      (2) If any pix has a colormap, all pix are rendered in rgb.\n *      (3) The boxa gives the location of each image.\n */",
      "file" : "pixafunc2.c"
   },
   {
      "function" : "pixaDisplayOnColor",
      "comment" : "/*!\n *  pixaDisplayOnColor()\n *\n *      Input:  pixa\n *              w, h (if set to 0, determines the size from the\n *                    b.b. of the components in pixa)\n *              color (background color to use)\n *      Return: pix, or null on error\n *\n *  Notes:\n *      (1) This uses the boxes to place each pix in the rendered composite.\n *      (2) Set w = h = 0 to use the b.b. of the components to determine\n *          the size of the returned pix.\n *      (3) If any pix in @pixa are colormapped, or if the pix have\n *          different depths, it returns a 32 bpp pix.  Otherwise,\n *          the depth of the returned pixa equals that of the pix in @pixa.\n *      (4) If the pixa is empty, return null.\n */",
      "file" : "pixafunc2.c"
   },
   {
      "function" : "pixaDisplayOnLattice",
      "comment" : "/*!\n *  pixaDisplayOnLattice()\n *\n *      Input:  pixa\n *              cellw (lattice cell width)\n *              cellh (lattice cell height)\n *              &ncols (<optional return> number of columns in output lattice)\n *              &boxa (<optional return> location of images in lattice)\n *      Return: pix of composite images, or null on error\n *\n *  Notes:\n *      (1) This places each pix on sequentially on a regular lattice\n *          in the rendered composite.  If a pix is too large to fit in the\n *          allocated lattice space, it is not rendered.\n *      (2) If any pix has a colormap, all pix are rendered in rgb.\n *      (3) This is useful when putting bitmaps of components,\n *          such as characters, into a single image.\n *      (4) The boxa gives the location of each image.  The UL corner\n *          of each image is on a lattice cell corner.  Omitted images\n *          (due to size) are assigned an invalid width and height of 0.\n */",
      "file" : "pixafunc2.c"
   },
   {
      "function" : "pixaDisplayRandomCmap",
      "comment" : "/*!\n *  pixaDisplayRandomCmap()\n *\n *      Input:  pixa (of 1 bpp components, with boxa)\n *              w, h (if set to 0, determines the size from the\n *                    b.b. of the components in pixa)\n *      Return: pix (8 bpp, cmapped, with random colors on the components),\n *              or null on error\n *\n *  Notes:\n *      (1) This uses the boxes to place each pix in the rendered composite.\n *      (2) By default, the background color is: black, cmap index 0.\n *          This can be changed by pixcmapResetColor()\n */",
      "file" : "pixafunc2.c"
   },
   {
      "function" : "pixaDisplayTiled",
      "comment" : "/*!\n *  pixaDisplayTiled()\n *\n *      Input:  pixa\n *              maxwidth (of output image)\n *              background (0 for white, 1 for black)\n *              spacing\n *      Return: pix of tiled images, or null on error\n *\n *  Notes:\n *      (1) This renders a pixa to a single image file of width not to\n *          exceed maxwidth, with background color either white or black,\n *          and with each subimage spaced on a regular lattice.\n *      (2) The lattice size is determined from the largest width and height,\n *          separately, of all pix in the pixa.\n *      (3) All pix in the pixa must be of equal depth.\n *      (4) If any pix has a colormap, all pix are rendered in rgb.\n *      (5) Careful: because no components are omitted, this is\n *          dangerous if there are thousands of small components and\n *          one or more very large one, because the size of the\n *          resulting pix can be huge!\n */",
      "file" : "pixafunc2.c"
   },
   {
      "function" : "pixaDisplayTiledAndScaled",
      "comment" : "/*!\n *  pixaDisplayTiledAndScaled()\n *\n *      Input:  pixa\n *              outdepth (output depth: 1, 8 or 32 bpp)\n *              tilewidth (each pix is scaled to this width)\n *              ncols (number of tiles in each row)\n *              background (0 for white, 1 for black; this is the color\n *                 of the spacing between the images)\n *              spacing  (between images, and on outside)\n *              border (width of additional black border on each image;\n *                      use 0 for no border)\n *      Return: pix of tiled images, or null on error\n *\n *  Notes:\n *      (1) This can be used to tile a number of renderings of\n *          an image that are at different scales and depths.\n *      (2) Each image, after scaling and optionally adding the\n *          black border, has width 'tilewidth'.  Thus, the border does\n *          not affect the spacing between the image tiles.  The\n *          maximum allowed border width is tilewidth / 5.\n */",
      "file" : "pixafunc2.c"
   },
   {
      "function" : "pixaDisplayTiledInRows",
      "comment" : "/*!\n *  pixaDisplayTiledInRows()\n *\n *      Input:  pixa\n *              outdepth (output depth: 1, 8 or 32 bpp)\n *              maxwidth (of output image)\n *              scalefactor (applied to every pix; use 1.0 for no scaling)\n *              background (0 for white, 1 for black; this is the color\n *                 of the spacing between the images)\n *              spacing  (between images, and on outside)\n *              border (width of black border added to each image;\n *                      use 0 for no border)\n *      Return: pixd (of tiled images), or null on error\n *\n *  Notes:\n *      (1) This renders a pixa to a single image file of width not to\n *          exceed maxwidth, with background color either white or black,\n *          and with each row tiled such that the top of each pix is\n *          aligned and separated by 'spacing' from the next one.\n *          A black border can be added to each pix.\n *      (2) All pix are converted to outdepth; existing colormaps are removed.\n *      (3) This does a reasonably spacewise-efficient job of laying\n *          out the individual pix images into a tiled composite.\n *      (4) A serialized boxa giving the location in pixd of each input\n *          pix (without added border) is stored in the text string of pixd.\n *          This allows, e.g., regeneration of a pixa from pixd, using\n *          pixaCreateFromBoxa().  If there is no scaling and the depth of\n *          each input pix in the pixa is the same, this tiling operation\n *          can be inverted using the boxa (except for loss of text in\n *          each of the input pix):\n *            pix1 = pixaDisplayTiledInRows(pixa1, 1, 1500, 1.0, 0, 30, 0);\n *            char *boxatxt = pixGetText(pix1);\n *            boxa1 = boxaReadMem((l_uint8 *)boxatxt, strlen(boxatxt));\n *            pixa2 = pixaCreateFromBoxa(pix1, boxa1, NULL);\n */",
      "file" : "pixafunc2.c"
   },
   {
      "function" : "pixaDisplayUnsplit",
      "comment" : "/*!\n *  pixaDisplayUnsplit()\n *\n *      Input:  pixa\n *              nx   (number of mosaic cells horizontally)\n *              ny   (number of mosaic cells vertically)\n *              borderwidth  (of added border on all sides)\n *              bordercolor  (in our RGBA format: 0xrrggbbaa)\n *      Return: pix of tiled images, or null on error\n *\n *  Notes:\n *      (1) This is a logical inverse of pixaSplitPix().  It\n *          constructs a pix from a mosaic of tiles, all of equal size.\n *      (2) For added generality, a border of arbitrary color can\n *          be added to each of the tiles.\n *      (3) In use, pixa will typically have either been generated\n *          from pixaSplitPix() or will derived from a pixa that\n *          was so generated.\n *      (4) All pix in the pixa must be of equal depth, and, if\n *          colormapped, have the same colormap.\n */",
      "file" : "pixafunc2.c"
   },
   {
      "function" : "pixaEqual",
      "comment" : "/*!\n *  pixaEqual()\n *\n *      Input:  pixa1\n *              pixa2\n *              maxdist\n *              &naindex (<optional return> index array of correspondences\n *              &same (<return> 1 if equal; 0 otherwise)\n *      Return  0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The two pixa are the \"same\" if they contain the same\n *          boxa and the same ordered set of pix.  However, if they\n *          have boxa, the pix in each pixa can differ in ordering\n *          by an amount given by the parameter @maxdist.  If they\n *          don't have a boxa, the @maxdist parameter is ignored,\n *          and the ordering must be identical.\n *      (2) This applies only to boxa geometry, pixels and ordering;\n *          other fields in the pix are ignored.\n *      (3) naindex[i] gives the position of the box in pixa2 that\n *          corresponds to box i in pixa1.  It is only returned if the\n *          pixa have boxa and the boxa are equal.\n *      (4) In situations where the ordering is very different, so that\n *          a large @maxdist is required for \"equality\", this should be\n *          implemented with a hash function for efficiency.\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixaExtendArray",
      "comment" : "/*!\n *  pixaExtendArray()\n *\n *      Input:  pixa\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) Doubles the size of the pixa and boxa ptr arrays.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaExtendArrayToSize",
      "comment" : "/*!\n *  pixaExtendArrayToSize()\n *\n *      Input:  pixa\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) If necessary, reallocs new pixa and boxa ptrs arrays to @size.\n *          The pixa and boxa ptr arrays must always be equal in size.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaExtractColumnFromEachPix",
      "comment" : "/*!\n *  pixaExtractColumnFromEachPix()\n *\n *      Input:  pixa (of identically sized, 8 bpp; not cmapped)\n *              col (column index)\n *              pixd (pix into which each column is inserted)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pix4.c"
   },
   {
      "function" : "pixaFindAreaFraction",
      "comment" : "/*!\n *  pixaFindAreaFraction()\n *\n *      Input:  pixa (of 1 bpp pix)\n *      Return: na (of area fractions for each pix), or null on error\n *\n *  Notes:\n *      (1) This is typically used for a pixa consisting of\n *          1 bpp connected components.\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixaFindAreaFractionMasked",
      "comment" : "/*!\n *  pixaFindAreaFractionMasked()\n *\n *      Input:  pixa (of 1 bpp pix)\n *              pixm (mask image)\n *              debug (1 for output, 0 to suppress)\n *      Return: na (of ratio masked/total fractions for each pix),\n *                  or null on error\n *\n *  Notes:\n *      (1) This is typically used for a pixa consisting of\n *          1 bpp connected components, which has an associated\n *          boxa giving the location of the components relative\n *          to the mask origin.\n *      (2) The debug flag displays in green and red the masked and\n *          unmasked parts of the image from which pixa was derived.\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixaFindDimensions",
      "comment" : "/*!\n *  pixaFindDimensions()\n *\n *      Input:  pixa\n *              &naw (<optional return> numa of pix widths)\n *              &nah (<optional return> numa of pix heights)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixaFindPerimSizeRatio",
      "comment" : "/*!\n *  pixaFindPerimSizeRatio()\n *\n *      Input:  pixa (of 1 bpp pix)\n *      Return: na (of fg perimeter/(2*(w+h)) ratio for each pix),\n *                  or null on error\n *\n *  Notes:\n *      (1) This is typically used for a pixa consisting of\n *          1 bpp connected components.\n *      (2) This has a minimum value for a circle of pi/4; a value for\n *          a rectangle component of approx. 1.0; and a value much larger\n *          than 1.0 for a component with a highly irregular boundary.\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixaFindPerimToAreaRatio",
      "comment" : "/*!\n *  pixaFindPerimToAreaRatio()\n *\n *      Input:  pixa (of 1 bpp pix)\n *      Return: na (of perimeter/arear ratio for each pix), or null on error\n *\n *  Notes:\n *      (1) This is typically used for a pixa consisting of\n *          1 bpp connected components.\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixaFindWidthHeightProduct",
      "comment" : "/*!\n *  pixaFindWidthHeightProduct()\n *\n *      Input:  pixa (of 1 bpp pix)\n *      Return: na (of width*height products for each pix), or null on error\n *\n *  Notes:\n *      (1) This is typically used for a pixa consisting of\n *          1 bpp connected components.\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixaFindWidthHeightRatio",
      "comment" : "/*!\n *  pixaFindWidthHeightRatio()\n *\n *      Input:  pixa (of 1 bpp pix)\n *      Return: na (of width/height ratios for each pix), or null on error\n *\n *  Notes:\n *      (1) This is typically used for a pixa consisting of\n *          1 bpp connected components.\n */",
      "file" : "pix5.c"
   },
   {
      "function" : "pixaGenerateFont",
      "comment" : "/*!\n *  pixaGenerateFont()\n *\n *      Input:  dir (directory holding image of character set)\n *              size (4, 6, 8, ... , 20, in pts at 300 ppi)\n *              &bl1 (<return> baseline of row 1)\n *              &bl2 (<return> baseline of row 2)\n *              &bl3 (<return> baseline of row 3)\n *      Return: pixa of font bitmaps for 95 characters, or null on error\n *\n *  These font generation functions use 9 sets, each with bitmaps\n *  of 94 ascii characters, all in Palatino-Roman font.\n *  Each input bitmap has 3 rows of characters.  The range of\n *  ascii values in each row is as follows:\n *    row 0:  32-57   (32 is a space)\n *    row 1:  58-91   (92, '\\', is not represented in this font)\n *    row 2:  93-126\n *  We LR flip the '/' char to generate a bitmap for the missing\n *  '\\' character, so that we have representations of all 95\n *  printable chars.\n *\n *  Computation of the bitmaps and baselines for a single\n *  font takes from 40 to 200 msec on a 2 GHz processor,\n *  depending on the size.  Use pixaGetFont() to read the\n *  generated character set directly from files that were\n *  produced in prog/genfonts.c using this function.\n */",
      "file" : "bmf.c"
   },
   {
      "function" : "pixaGetAlignedStats",
      "comment" : "/*!\n *  pixaGetAlignedStats()\n *\n *      Input:  pixa (of identically sized, 8 bpp pix; not cmapped)\n *              type (L_MEAN_ABSVAL, L_MEDIAN_VAL, L_MODE_VAL, L_MODE_COUNT)\n *              nbins (of histogram for median and mode; ignored for mean)\n *              thresh (on histogram for mode val; ignored for all other types)\n *      Return: pix (with pixelwise aligned stats), or null on error.\n *\n *  Notes:\n *      (1) Each pixel in the returned pix represents an average\n *          (or median, or mode) over the corresponding pixels in each\n *          pix in the pixa.\n *      (2) The @thresh parameter works with L_MODE_VAL only, and\n *          sets a minimum occupancy of the mode bin.\n *          If the occupancy of the mode bin is less than @thresh, the\n *          mode value is returned as 0.  To always return the actual\n *          mode value, set @thresh = 0.  See pixGetRowStats().\n */",
      "file" : "pix4.c"
   },
   {
      "function" : "pixaGetBox",
      "comment" : "/*!\n *  pixaGetBox()\n *\n *      Input:  pixa\n *              index  (to the index-th pix)\n *              accesstype  (L_COPY or L_CLONE)\n *      Return: box (if null, not automatically an error), or null on error\n *\n *  Notes:\n *      (1) There is always a boxa with a pixa, and it is initialized so\n *          that each box ptr is NULL.\n *      (2) In general, we expect that there is either a box associated\n *          with each pix, or no boxes at all in the boxa.\n *      (3) Having no boxes is thus not an automatic error.  Whether it\n *          is an actual error is determined by the calling program.\n *          If the caller expects to get a box, it is an error; see, e.g.,\n *          pixaGetBoxGeometry().\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaGetBoxGeometry",
      "comment" : "/*!\n *  pixaGetBoxGeometry()\n *\n *      Input:  pixa\n *              index  (to the index-th box)\n *              &x, &y, &w, &h (<optional return>; each can be null)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaGetBoxa",
      "comment" : "/*!\n *  pixaGetBoxa()\n *\n *      Input:  pixa\n *              accesstype  (L_COPY, L_CLONE, L_COPY_CLONE)\n *      Return: boxa, or null on error\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaGetBoxaCount",
      "comment" : "/*!\n *  pixaGetBoxaCount()\n *\n *      Input:  pixa\n *      Return: count, or 0 on error\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaGetCount",
      "comment" : "/*!\n *  pixaGetCount()\n *\n *      Input:  pixa\n *      Return: count, or 0 if no pixa\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaGetDepthInfo",
      "comment" : "/*!\n *  pixaGetDepthInfo()\n *\n *      Input:  pixa\n *              &maxdepth (<optional return> max pixel depth of pix in pixa)\n *              &same (<optional return> true if all depths are equal)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixaGetFont",
      "comment" : "/*!\n *  pixaGetFont()\n *\n *      Input:  dir (directory holding pixa of character set)\n *              size (4, 6, 8, ... , 20)\n *              &bl1 (<return> baseline of row 1)\n *              &bl2 (<return> baseline of row 2)\n *              &bl3 (<return> baseline of row 3)\n *      Return: pixa of font bitmaps for 95 characters, or null on error\n *\n *  Notes:\n *      (1) This reads a pre-computed pixa file with the 95 ascii chars.\n */",
      "file" : "bmf.c"
   },
   {
      "function" : "pixaGetLinePtrs",
      "comment" : "/*!\n *  pixaGetLinePtrs()\n *\n *      Input:  pixa (of pix that all have the same depth)\n *              &size (<optional return> number of pix in the pixa)\n *      Return: array of array of line ptrs, or null on error\n *\n *  Notes:\n *      (1) See pixGetLinePtrs() for details.\n *      (2) It is best if all pix in the pixa are the same size.\n *          The size of each line ptr array is equal to the height\n *          of the pix that it refers to.\n *      (3) This is an array of arrays.  To destroy it:\n *            for (i = 0; i < size; i++)\n *                FREE(lineset[i]);\n *            FREE(lineset);\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaGetPix",
      "comment" : "/*!\n *  pixaGetPix()\n *\n *      Input:  pixa\n *              index  (to the index-th pix)\n *              accesstype  (L_COPY or L_CLONE)\n *      Return: pix, or null on error\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaGetPixArray",
      "comment" : "/*!\n *  pixaGetPixArray()\n *\n *      Input:  pixa\n *      Return: pix array, or null on error\n *\n *  Notes:\n *      (1) This returns a ptr to the actual array.  The array is\n *          owned by the pixa, so it must not be destroyed.\n *      (2) The caller should always check if the return value is NULL\n *          before accessing any of the pix ptrs in this array!\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaGetPixDimensions",
      "comment" : "/*!\n *  pixaGetPixDimensions()\n *\n *      Input:  pixa\n *              index  (to the index-th box)\n *              &w, &h, &d (<optional return>; each can be null)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaInitFull",
      "comment" : "/*!\n *  pixaInitFull()\n *\n *      Input:  pixa (typically empty)\n *              pix (<optional> to be replicated into the entire pixa ptr array)\n *              box (<optional> to be replicated into the entire boxa ptr array)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This initializes a pixa by filling up the entire pix ptr array\n *          with copies of @pix.  If @pix == NULL, we use a tiny placeholder\n *          pix (w = h = d = 1).  Any existing pix are destroyed.\n *          It also optionally fills the boxa with copies of @box.\n *          After this operation, the numbers of pix and (optionally)\n *          boxes are equal to the number of allocated ptrs.\n *      (2) Note that we use pixaReplacePix() instead of pixaInsertPix().\n *          They both have the same effect when inserting into a NULL ptr\n *          in the pixa ptr array:\n *      (3) If the boxa is not initialized (i.e., filled with boxes),\n *          later insertion of boxes will cause an error, because the\n *          'n' field is 0.\n *      (4) Example usage.  This function is useful to prepare for a\n *          random insertion (or replacement) of pix into a pixa.\n *          To randomly insert pix into a pixa, without boxes, up to\n *          some index \"max\":\n *             Pixa *pixa = pixaCreate(max);\n *             pixaInitFull(pixa, NULL, NULL);\n *          An existing pixa with a smaller ptr array can also be reused:\n *             pixaExtendArrayToSize(pixa, max);\n *             pixaInitFull(pixa, NULL, NULL);\n *          The initialization allows the pixa to always be properly\n *          filled, even if all pix (and boxes) are not later replaced.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaInsertPix",
      "comment" : "/*!\n *  pixaInsertPix()\n *\n *      Input:  pixa\n *              index (at which pix is to be inserted)\n *              pixs (new pix to be inserted)\n *              box (<optional> new box to be inserted)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This shifts pixa[i] --> pixa[i + 1] for all i >= index,\n *          and then inserts at pixa[index].\n *      (2) To insert at the beginning of the array, set index = 0.\n *      (3) It should not be used repeatedly on large arrays,\n *          because the function is O(n).\n *      (4) To append a pix to a pixa, it's easier to use pixaAddPix().\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaIsFull",
      "comment" : "/*!\n *  pixaIsFull()\n *\n *      Input:  pixa\n *              &fullpa (<optional return> 1 if pixa is full)\n *              &fullba (<optional return> 1 if boxa is full)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) A pixa is \"full\" if the array of pix is fully\n *          occupied from index 0 to index (pixa->n - 1).\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaJoin",
      "comment" : "/*!\n *  pixaJoin()\n *\n *      Input:  pixad  (dest pixa; add to this one)\n *              pixas  (<optional> source pixa; add from this one)\n *              istart  (starting index in pixas)\n *              iend  (ending index in pixas; use -1 to cat all)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This appends a clone of each indicated pix in pixas to pixad\n *      (2) istart < 0 is taken to mean 'read from the start' (istart = 0)\n *      (3) iend < 0 means 'read to the end'\n *      (4) If pixas is NULL or contains no pix, this is a no-op.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaMakeSizeIndicator",
      "comment" : "/*!\n *  pixaMakeSizeIndicator()\n *\n *      Input:  pixa\n *              width, height (threshold dimensions)\n *              type (L_SELECT_WIDTH, L_SELECT_HEIGHT,\n *                    L_SELECT_IF_EITHER, L_SELECT_IF_BOTH)\n *              relation (L_SELECT_IF_LT, L_SELECT_IF_GT,\n *                        L_SELECT_IF_LTE, L_SELECT_IF_GTE)\n *      Return: na (indicator array), or null on error\n *\n *  Notes:\n *      (1) The args specify constraints on the size of the\n *          components that are kept.\n *      (2) If the selection type is L_SELECT_WIDTH, the input\n *          height is ignored, and v.v.\n *      (3) To keep small components, use relation = L_SELECT_IF_LT or\n *          L_SELECT_IF_LTE.\n *          To keep large components, use relation = L_SELECT_IF_GT or\n *          L_SELECT_IF_GTE.\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixaMorphSequenceByComponent",
      "comment" : "/*!\n *  pixaMorphSequenceByComponent()\n *\n *      Input:  pixas (of 1 bpp pix)\n *              sequence (string specifying sequence)\n *              minw  (minimum width to consider; use 0 or 1 for any width)\n *              minh  (minimum height to consider; use 0 or 1 for any height)\n *      Return: pixad, or null on error\n *\n *  Notes:\n *      (1) See pixMorphSequence() for composing operation sequences.\n *      (2) This operates separately on each c.c. in the input pixa.\n *      (3) You can specify that the width and/or height must equal\n *          or exceed a minimum size for the operation to take place.\n *      (4) The input pixa should have a boxa giving the locations\n *          of the pix components.\n */",
      "file" : "morphapp.c"
   },
   {
      "function" : "pixaMorphSequenceByRegion",
      "comment" : "/*!\n *  pixaMorphSequenceByRegion()\n *\n *      Input:  pixs (1 bpp)\n *              pixam (of 1 bpp mask elements)\n *              sequence (string specifying sequence)\n *              minw  (minimum width to consider; use 0 or 1 for any width)\n *              minh  (minimum height to consider; use 0 or 1 for any height)\n *      Return: pixad, or null on error\n *\n *  Notes:\n *      (1) See pixMorphSequence() for composing operation sequences.\n *      (2) This operates separately on each region in the input pixs\n *          defined by the components in pixam.\n *      (3) You can specify that the width and/or height of a mask\n *          component must equal or exceed a minimum size for the\n *          operation to take place.\n *      (4) The input pixam should have a boxa giving the locations\n *          of the regions in pixs.\n */",
      "file" : "morphapp.c"
   },
   {
      "function" : "pixaRead",
      "comment" : "/*!\n *  pixaRead()\n *\n *      Input:  filename\n *      Return: pixa, or null on error\n *\n *  Notes:\n *      (1) The pix are stored in the file as png.\n *          If the png library is not linked, this will fail.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaReadFiles",
      "comment" : "/*!\n *  pixaReadFiles()\n *\n *      Input:  dirname\n *              substr (<optional> substring filter on filenames; can be null)\n *      Return: pixa, or null on error\n *\n *  Notes:\n *      (1) @dirname is the full path for the directory.\n *      (2) @substr is the part of the file name (excluding\n *          the directory) that is to be matched.  All matching\n *          filenames are read into the Pixa.  If substr is NULL,\n *          all filenames are read into the Pixa.\n */",
      "file" : "readfile.c"
   },
   {
      "function" : "pixaReadFilesSA",
      "comment" : "/*!\n *  pixaReadFilesSA()\n *\n *      Input:  sarray (full pathnames for all files)\n *      Return: pixa, or null on error\n */",
      "file" : "readfile.c"
   },
   {
      "function" : "pixaReadMultipageTiff",
      "comment" : "/*\n *  pixaReadMultipageTiff()\n *\n *      Input:  filename (input tiff file)\n *      Return: pixa (of page images), or null on error\n */",
      "file" : "tiffio.c"
   },
   {
      "function" : "pixaReadStream",
      "comment" : "/*!\n *  pixaReadStream()\n *\n *      Input:  stream\n *      Return: pixa, or null on error\n *\n *  Notes:\n *      (1) The pix are stored in the file as png.\n *          If the png library is not linked, this will fail.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaRemovePix",
      "comment" : "/*!\n *  pixaRemovePix()\n *\n *      Input:  pixa\n *              index (of pix to be removed)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This shifts pixa[i] --> pixa[i - 1] for all i > index.\n *      (2) It should not be used repeatedly on large arrays,\n *          because the function is O(n).\n *      (3) The corresponding box is removed as well, if it exists.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaRemovePixAndSave",
      "comment" : "/*!\n *  pixaRemovePixAndSave()\n *\n *      Input:  pixa\n *              index (of pix to be removed)\n *              &pix (<optional return> removed pix)\n *              &box (<optional return> removed box)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This shifts pixa[i] --> pixa[i - 1] for all i > index.\n *      (2) It should not be used repeatedly on large arrays,\n *          because the function is O(n).\n *      (3) The corresponding box is removed as well, if it exists.\n *      (4) The removed pix and box can either be retained or destroyed.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaRenderComponent",
      "comment" : "/*!\n *  pixaRenderComponent()\n *\n *      Input:  pixs (<optional> 1 bpp pix)\n *              pixa (of 1 bpp connected components, one of which will\n *                    be rendered in pixs, with its origin determined\n *                    by the associated box.)\n *              index (of component to be rendered)\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) If pixs is null, this generates an empty pix of a size determined\n *          by union of the component bounding boxes, and including the origin.\n *      (2) The selected component is blitted into pixs.\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixaReplacePix",
      "comment" : "/*!\n *  pixaReplacePix()\n *\n *      Input:  pixa\n *              index  (to the index-th pix)\n *              pix (insert to replace existing one)\n *              box (<optional> insert to replace existing)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) In-place replacement of one pix.\n *      (2) The previous pix at that location is destroyed.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaSaveFont",
      "comment" : "/*!\n *  pixaSaveFont()\n *\n *      Input:  indir (directory holding image of character set)\n *              outdir (directory into which the output pixa file\n *                      will be written)\n *              size (in pts, at 300 ppi)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This saves a font of a particular size.\n *      (2) prog/genfonts calls this function for each of the\n *          nine font sizes, to generate all the font pixa files.\n */",
      "file" : "bmf.c"
   },
   {
      "function" : "pixaScaleToSize",
      "comment" : "/*!\n *  pixaScaleToSize()\n *\n *      Input:  pixas\n *              wd  (target width; use 0 if using height as target)\n *              hd  (target height; use 0 if using width as target)\n *      Return: pixad, or null on error\n *\n *  Notes:\n *      (1) See pixaaScaleToSize()\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixaSelectByAreaFraction",
      "comment" : "/*!\n *  pixaSelectByAreaFraction()\n *\n *      Input:  pixas\n *              thresh (threshold ratio of fg pixels to (w * h))\n *              type (L_SELECT_IF_LT, L_SELECT_IF_GT,\n *                    L_SELECT_IF_LTE, L_SELECT_IF_GTE)\n *              &changed (<optional return> 1 if changed; 0 if clone returned)\n *      Return: pixad, or null on error\n *\n *  Notes:\n *      (1) Returns a pixa clone if no components are removed.\n *      (2) Uses pix and box clones in the new pixa.\n *      (3) This filters components based on the fraction of fg pixels\n *          of the component in its bounding box.\n *      (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save components\n *          with less than the threshold fraction of foreground, and\n *          L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixaSelectByPerimSizeRatio",
      "comment" : "/*!\n *  pixaSelectByPerimSizeRatio()\n *\n *      Input:  pixas\n *              thresh (threshold ratio of fg boundary to b.b. circumference)\n *              type (L_SELECT_IF_LT, L_SELECT_IF_GT,\n *                    L_SELECT_IF_LTE, L_SELECT_IF_GTE)\n *              &changed (<optional return> 1 if changed; 0 if clone returned)\n *      Return: pixad, or null on error\n *\n *  Notes:\n *      (1) Returns a pixa clone if no components are removed.\n *      (2) Uses pix and box clones in the new pixa.\n *      (3) See pixSelectByPerimSizeRatio().\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixaSelectByPerimToAreaRatio",
      "comment" : "/*!\n *  pixaSelectByPerimToAreaRatio()\n *\n *      Input:  pixas\n *              thresh (threshold ratio of fg boundary to fg pixels)\n *              type (L_SELECT_IF_LT, L_SELECT_IF_GT,\n *                    L_SELECT_IF_LTE, L_SELECT_IF_GTE)\n *              &changed (<optional return> 1 if changed; 0 if clone returned)\n *      Return: pixad, or null on error\n *\n *  Notes:\n *      (1) Returns a pixa clone if no components are removed.\n *      (2) Uses pix and box clones in the new pixa.\n *      (3) See pixSelectByPerimToAreaRatio().\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixaSelectBySize",
      "comment" : "/*!\n *  pixaSelectBySize()\n *\n *      Input:  pixas\n *              width, height (threshold dimensions)\n *              type (L_SELECT_WIDTH, L_SELECT_HEIGHT,\n *                    L_SELECT_IF_EITHER, L_SELECT_IF_BOTH)\n *              relation (L_SELECT_IF_LT, L_SELECT_IF_GT,\n *                        L_SELECT_IF_LTE, L_SELECT_IF_GTE)\n *              &changed (<optional return> 1 if changed; 0 otherwise)\n *      Return: pixad, or null on error\n *\n *  Notes:\n *      (1) The args specify constraints on the size of the\n *          components that are kept.\n *      (2) Uses pix and box clones in the new pixa.\n *      (3) If the selection type is L_SELECT_WIDTH, the input\n *          height is ignored, and v.v.\n *      (4) To keep small components, use relation = L_SELECT_IF_LT or\n *          L_SELECT_IF_LTE.\n *          To keep large components, use relation = L_SELECT_IF_GT or\n *          L_SELECT_IF_GTE.\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixaSelectByWidthHeightRatio",
      "comment" : "/*!\n *  pixaSelectByWidthHeightRatio()\n *\n *      Input:  pixas\n *              thresh (threshold ratio of width/height)\n *              type (L_SELECT_IF_LT, L_SELECT_IF_GT,\n *                    L_SELECT_IF_LTE, L_SELECT_IF_GTE)\n *              &changed (<optional return> 1 if changed; 0 if clone returned)\n *      Return: pixad, or null on error\n *\n *  Notes:\n *      (1) Returns a pixa clone if no components are removed.\n *      (2) Uses pix and box clones in the new pixa.\n *      (3) This filters components based on the width-to-height ratio\n *          of each pix.\n *      (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save components\n *          with less than the threshold ratio, and\n *          L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixaSelectRange",
      "comment" : "/*!\n *  pixaSelectRange()\n *\n *      Input:  pixas\n *              first (use 0 to select from the beginning)\n *              last (use 0 to select to the end)\n *              copyflag (L_COPY, L_CLONE)\n *      Return: pixad, or null on error\n *\n *  Notes:\n *      (1) The copyflag specifies what we do with each pix from pixas.\n *          Specifically, L_CLONE inserts a clone into pixad of each\n *          selected pix from pixas.\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixaSelectWithIndicator",
      "comment" : "/*!\n *  pixaSelectWithIndicator()\n *\n *      Input:  pixas\n *              na (indicator numa)\n *              &changed (<optional return> 1 if changed; 0 if clone returned)\n *      Return: pixad, or null on error\n *\n *  Notes:\n *      (1) Returns a pixa clone if no components are removed.\n *      (2) Uses pix and box clones in the new pixa.\n *      (3) The indicator numa has values 0 (ignore) and 1 (accept).\n *      (4) If the source boxa is not fully populated, it is left\n *          empty in the dest pixa.\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixaSetBoxa",
      "comment" : "/*!\n *  pixaSetBoxa()\n *\n *      Input:  pixa\n *              boxa\n *              accesstype  (L_INSERT, L_COPY, L_CLONE)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This destroys the existing boxa in the pixa.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaSizeRange",
      "comment" : "/*!\n *  pixaSizeRange()\n *\n *      Input:  pixa\n *              &minw, &minh, &maxw, &maxh (<optional return> range of\n *                                          dimensions of pix in the array)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixaSort",
      "comment" : "/*!\n *  pixaSort()\n *\n *      Input:  pixas\n *              sorttype (L_SORT_BY_X, L_SORT_BY_Y, L_SORT_BY_WIDTH,\n *                        L_SORT_BY_HEIGHT, L_SORT_BY_MIN_DIMENSION,\n *                        L_SORT_BY_MAX_DIMENSION, L_SORT_BY_PERIMETER,\n *                        L_SORT_BY_AREA, L_SORT_BY_ASPECT_RATIO)\n *              sortorder  (L_SORT_INCREASING, L_SORT_DECREASING)\n *              &naindex (<optional return> index of sorted order into\n *                        original array)\n *              copyflag (L_COPY, L_CLONE)\n *      Return: pixad (sorted version of pixas), or null on error\n *\n *  Notes:\n *      (1) This sorts based on the data in the boxa.  If the boxa\n *          count is not the same as the pixa count, this returns an error.\n *      (2) The copyflag refers to the pix and box copies that are\n *          inserted into the sorted pixa.  These are either L_COPY\n *          or L_CLONE.\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixaSort2dByIndex",
      "comment" : "/*!\n *  pixaSort2dByIndex()\n *\n *      Input:  pixas\n *              naa (numaa that maps from the new pixaa to the input pixas)\n *              copyflag (L_CLONE or L_COPY)\n *      Return: paa (sorted), or null on error\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixaSortByIndex",
      "comment" : "/*!\n *  pixaSortByIndex()\n *\n *      Input:  pixas\n *              naindex (na that maps from the new pixa to the input pixa)\n *              copyflag (L_COPY, L_CLONE)\n *      Return: pixad (sorted), or null on error\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixaSplitPix",
      "comment" : "/*!\n *  pixaSplitPix()\n *\n *      Input:  pixs  (with individual components on a lattice)\n *              nx   (number of mosaic cells horizontally)\n *              ny   (number of mosaic cells vertically)\n *              borderwidth  (of added border on all sides)\n *              bordercolor  (in our RGBA format: 0xrrggbbaa)\n *      Return: pixa, or null on error\n *\n *  Notes:\n *      (1) This is a variant on pixaCreateFromPix(), where we\n *          simply divide the image up into (approximately) equal\n *          subunits.  If you want the subimages to have essentially\n *          the same aspect ratio as the input pix, use nx = ny.\n *      (2) If borderwidth is 0, we ignore the input bordercolor and\n *          redefine it to white.\n *      (3) The bordercolor is always used to initialize each tiled pix,\n *          so that if the src is clipped, the unblitted part will\n *          be this color.  This avoids 1 pixel wide black stripes at the\n *          left and lower edges.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaVerifyDepth",
      "comment" : "/*!\n *  pixaVerifyDepth()\n *\n *      Input:  pixa\n *              &maxdepth (<optional return> max depth of all pix)\n *      Return: depth (return 0 if they're not all the same, or on error)\n *\n *  Notes:\n *      (1) It is considered to be an error if there are no pix.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaWrite",
      "comment" : "/*!\n *  pixaWrite()\n *\n *      Input:  filename\n *              pixa\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The pix are stored in the file as png.\n *          If the png library is not linked, this will fail.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaWriteCompressedToPS",
      "comment" : "/*\n *  pixaWriteCompressedToPS()\n *\n *      Input:  pixa (any set of images)\n *              fileout (output ps file)\n *              res (of input image)\n *              level (compression: 2 or 3)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This generates a PS file of multiple page images, all\n *          with bounding boxes.\n *      (2) It compresses to:\n *              cmap + level2:        jpeg\n *              cmap + level3:        flate\n *              1 bpp:                tiffg4\n *              2 or 4 bpp + level2:  jpeg\n *              2 or 4 bpp + level3:  flate\n *              8 bpp:                jpeg\n *              16 bpp:               flate\n *              32 bpp:               jpeg\n *      (3) To generate a pdf, use: ps2pdf <infile.ps> <outfile.pdf>\n */",
      "file" : "psio1.c"
   },
   {
      "function" : "pixaWriteFiles",
      "comment" : "/*!\n *  pixaWriteFiles()\n *\n *      Input:  rootname\n *              pixa\n *              format  (defined in imageio.h)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "writefile.c"
   },
   {
      "function" : "pixaWriteStream",
      "comment" : "/*!\n *  pixaWriteStream()\n *\n *      Input:  stream (opened for \"wb\")\n *              pixa\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The pix are stored in the file as png.\n *          If the png library is not linked, this will fail.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaaAddBox",
      "comment" : "/*!\n *  pixaaAddBox()\n *\n *      Input:  paa\n *              box\n *              copyflag (L_INSERT, L_COPY, L_CLONE)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The box can be used, for example, to hold the support region\n *          of a pixa that is being added to the pixaa.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaaAddPix",
      "comment" : "/*!\n *  pixaaAddPix()\n *\n *      Input:  paa  (input paa)\n *              index (index of pixa in paa)\n *              pix (to be added)\n *              box (<optional> to be added)\n *              copyflag (L_INSERT, L_COPY, L_CLONE)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaaAddPixa",
      "comment" : "/*!\n *  pixaaAddPixa()\n *\n *      Input:  paa\n *              pixa  (to be added)\n *              copyflag:\n *                L_INSERT inserts the pixa directly\n *                L_COPY makes a new pixa and copies each pix and each box\n *                L_CLONE gives a new handle to the input pixa\n *                L_COPY_CLONE makes a new pixa and inserts clones of\n *                    all pix and boxes\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaaClear",
      "comment" : "/*!\n *  pixaaClear()\n *\n *      Input:  paa\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This destroys all pixa in the pixaa, and nulls the ptrs\n *          in the pixa ptr array.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaaCreate",
      "comment" : "/*!\n *  pixaaCreate()\n *\n *      Input:  n  (initial number of pixa ptrs)\n *      Return: paa, or null on error\n *\n *  Notes:\n *      (1) A pixaa provides a 2-level hierarchy of images.\n *          A common use is for segmentation masks, which are\n *          inexpensive to store in png format.\n *      (2) For example, suppose you want a mask for each textline\n *          in a two-column page.  The textline masks for each column\n *          can be represented by a pixa, of which there are 2 in the pixaa.\n *          The boxes for the textline mask components within a column\n *          can have their origin referred to the column rather than the page.\n *          Then the boxa field can be used to represent the two box (regions)\n *          for the columns, and the (x,y) components of each box can\n *          be used to get the absolute position of the textlines on\n *          the page.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaaCreateFromPixa",
      "comment" : "/*!\n *  pixaaCreateFromPixa()\n *\n *      Input:  pixa\n *              n (number specifying subdivision of pixa)\n *              type (L_CHOOSE_CONSECUTIVE, L_CHOOSE_SKIP_BY)\n *              copyflag (L_CLONE, L_COPY)\n *      Return: paa, or null on error\n *\n *  Notes:\n *      (1) This subdivides a pixa into a set of smaller pixa that\n *          are accumulated into a pixaa.\n *      (2) If type == L_CHOOSE_CONSECUTIVE, the first 'n' pix are\n *          put in a pixa and added to pixaa, then the next 'n', etc.\n *          If type == L_CHOOSE_SKIP_BY, the first pixa is made by\n *          aggregating pix[0], pix[n], pix[2*n], etc.\n *      (3) The copyflag specifies if each new pix is a copy or a clone.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaaDestroy",
      "comment" : "/*!\n *  pixaaDestroy()\n *\n *      Input:  &paa <to be nulled>\n *      Return: void\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaaDisplay",
      "comment" : "/*!\n *  pixaaDisplay()\n *\n *      Input:  paa\n *              w, h (if set to 0, determines the size from the\n *                    b.b. of the components in paa)\n *      Return: pix, or null on error\n *\n *  Notes:\n *      (1) Each pix of the paa is displayed at the location given by\n *          its box, translated by the box of the containing pixa\n *          if it exists.\n */",
      "file" : "pixafunc2.c"
   },
   {
      "function" : "pixaaDisplayByPixa",
      "comment" : "/*!\n *  pixaaDisplayByPixa()\n *\n *      Input:  paa (with pix that may have different depths)\n *              xspace between pix in pixa\n *              yspace between pixa\n *              max width of output pix\n *      Return: pixd, or null on error\n *\n *  Notes:\n *      (1) Displays each pixa on a line (or set of lines),\n *          in order from top to bottom.  Within each pixa,\n *          the pix are displayed in order from left to right.\n *      (2) The sizes and depths of each pix can differ.  The output pix\n *          has a depth equal to the max depth of all the pix.\n *      (3) This ignores the boxa of the paa.\n */",
      "file" : "pixafunc2.c"
   },
   {
      "function" : "pixaaDisplayTiledAndScaled",
      "comment" : "/*!\n *  pixaaDisplayTiledAndScaled()\n *\n *      Input:  paa\n *              outdepth (output depth: 1, 8 or 32 bpp)\n *              tilewidth (each pix is scaled to this width)\n *              ncols (number of tiles in each row)\n *              background (0 for white, 1 for black; this is the color\n *                 of the spacing between the images)\n *              spacing  (between images, and on outside)\n *              border (width of additional black border on each image;\n *                      use 0 for no border)\n *      Return: pixa (of tiled images, one image for each pixa in\n *                    the paa), or null on error\n *\n *  Notes:\n *      (1) For each pixa, this generates from all the pix a\n *          tiled/scaled output pix, and puts it in the output pixa.\n *      (2) See comments in pixaDisplayTiledAndScaled().\n */",
      "file" : "pixafunc2.c"
   },
   {
      "function" : "pixaaExtendArray",
      "comment" : "/*!\n *  pixaaExtendArray()\n *\n *      Input:  paa\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaaFlattenToPixa",
      "comment" : "/*!\n *  pixaaFlattenToPixa()\n *\n *      Input:  paa\n *              &naindex  (<optional return> the pixa index in the pixaa)\n *              copyflag  (L_COPY or L_CLONE)\n *      Return: pixa, or null on error\n *\n *  Notes:\n *      (1) This 'flattens' the pixaa to a pixa, taking the pix in\n *          order in the first pixa, then the second, etc.\n *      (2) If &naindex is defined, we generate a Numa that gives, for\n *          each pix in the pixaa, the index of the pixa to which it belongs.\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixaaGetBoxa",
      "comment" : "/*!\n *  pixaaGetBoxa()\n *\n *      Input:  paa\n *              accesstype  (L_COPY, L_CLONE)\n *      Return: boxa, or null on error\n *\n *  Notes:\n *      (1) L_COPY returns a copy; L_CLONE returns a new reference to the boxa.\n *      (2) In both cases, invoke boxaDestroy() on the returned boxa.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaaGetCount",
      "comment" : "/*!\n *  pixaaGetCount()\n *\n *      Input:  paa\n *              &na (<optional return> number of pix in each pixa)\n *      Return: count, or 0 if no pixaa\n *\n *  Notes:\n *      (1) If paa is empty, a returned na will also be empty.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaaGetPix",
      "comment" : "/*!\n *  pixaaGetPix()\n *\n *      Input:  paa\n *              index  (index into the pixa array in the pixaa)\n *              ipix  (index into the pix array in the pixa)\n *              accessflag  (L_COPY or L_CLONE)\n *      Return: pix, or null on error\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaaGetPixa",
      "comment" : "/*!\n *  pixaaGetPixa()\n *\n *      Input:  paa\n *              index  (to the index-th pixa)\n *              accesstype  (L_COPY, L_CLONE, L_COPY_CLONE)\n *      Return: pixa, or null on error\n *\n *  Notes:\n *      (1) L_COPY makes a new pixa with a copy of every pix\n *      (2) L_CLONE just makes a new reference to the pixa,\n *          and bumps the counter.  You would use this, for example,\n *          when you need to extract some data from a pix within a\n *          pixa within a pixaa.\n *      (3) L_COPY_CLONE makes a new pixa with a clone of every pix\n *          and box\n *      (4) In all cases, you must invoke pixaDestroy() on the returned pixa\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaaInitFull",
      "comment" : "/*!\n *  pixaaInitFull()\n *\n *      Input:  paa (typically empty)\n *              pixa (to be replicated into the entire pixa ptr array)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This initializes a pixaa by filling up the entire pixa ptr array\n *          with copies of @pixa.  Any existing pixa are destroyed.\n *      (2) Example usage.  This function is useful to prepare for a\n *          random insertion (or replacement) of pixa into a pixaa.\n *          To randomly insert pixa into a pixaa, up to some index \"max\":\n *             Pixaa *paa = pixaaCreate(max);\n *             Pixa *pixa = pixaCreate(1);  // if you want little memory\n *             pixaaInitFull(paa, pixa);  // copy it to entire array\n *             pixaDestroy(&pixa);  // no longer needed\n *          The initialization allows the pixaa to always be properly filled.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaaIsFull",
      "comment" : "/*!\n *  pixaaIsFull()\n *\n *      Input:  paa\n *              &full (<return> 1 if all pixa in the paa have full pix arrays)\n *      Return: return 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Does not require boxa associated with each pixa to be full.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaaJoin",
      "comment" : "/*!\n *  pixaaJoin()\n *\n *      Input:  paad  (dest pixaa; add to this one)\n *              paas  (<optional> source pixaa; add from this one)\n *              istart  (starting index in pixaas)\n *              iend  (ending index in pixaas; use -1 to cat all)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This appends a clone of each indicated pixa in paas to pixaad\n *      (2) istart < 0 is taken to mean 'read from the start' (istart = 0)\n *      (3) iend < 0 means 'read to the end'\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaaRead",
      "comment" : "/*!\n *  pixaaRead()\n *\n *      Input:  filename\n *      Return: paa, or null on error\n *\n *  Notes:\n *      (1) The pix are stored in the file as png.\n *          If the png library is not linked, this will fail.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaaReadFromFiles",
      "comment" : "/*!\n *  pixaaReadFromFiles()\n *\n *      Input:  dirname (directory)\n *              substr (<optional> substring filter on filenames; can be NULL)\n *              first (0-based)\n *              nfiles (use 0 for everything from @first to the end)\n *      Return: paa, or null on error or if no pixa files are found.\n *\n *  Notes:\n *      (1) The files must be serialized pixa files (e.g., *.pa)\n *          If some files cannot be read, warnings are issued.\n *      (2) Use @substr to filter filenames in the directory.  If\n *          @substr == NULL, this takes all files.\n *      (3) After filtering, use @first and @nfiles to select\n *          a contiguous set of files, that have been lexically\n *          sorted in increasing order.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaaReadStream",
      "comment" : "/*!\n *  pixaaReadStream()\n *\n *      Input:  stream\n *      Return: paa, or null on error\n *\n *  Notes:\n *      (1) The pix are stored in the file as png.\n *          If the png library is not linked, this will fail.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaaReplacePixa",
      "comment" : "/*!\n *  pixaaReplacePixa()\n *\n *      Input:  paa\n *              index  (to the index-th pixa)\n *              pixa (insert to replace existing one)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This allows random insertion of a pixa into a pixaa, with\n *          destruction of any existing pixa at that location.\n *          The input pixa is now owned by the pixaa.\n *      (2) No other pixa in the array are affected.\n *      (3) The index must be within the allowed set.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaaScaleToSize",
      "comment" : "/*!\n *  pixaaScaleToSize()\n *\n *      Input:  paas\n *              wd  (target width; use 0 if using height as target)\n *              hd  (target height; use 0 if using width as target)\n *      Return: paad, or null on error\n *\n *  Notes:\n *      (1) This guarantees that each output scaled image has the\n *          dimension(s) you specify.\n *           - To specify the width with isotropic scaling, set @hd = 0.\n *           - To specify the height with isotropic scaling, set @wd = 0.\n *           - If both @wd and @hd are specified, the image is scaled\n *             (in general, anisotropically) to that size.\n *           - It is an error to set both @wd and @hd to 0.\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixaaScaleToSizeVar",
      "comment" : "/*!\n *  pixaaScaleToSizeVar()\n *\n *      Input:  paas\n *              nawd  (<optional> target widths; use NULL if using height)\n *              nahd  (<optional> target height; use NULL if using width)\n *      Return: paad, or null on error\n *\n *  Notes:\n *      (1) This guarantees that the scaled images in each pixa have the\n *          dimension(s) you specify in the numas.\n *           - To specify the width with isotropic scaling, set @nahd = NULL.\n *           - To specify the height with isotropic scaling, set @nawd = NULL.\n *           - If both @nawd and @nahd are specified, the image is scaled\n *             (in general, anisotropically) to that size.\n *           - It is an error to set both @nawd and @nahd to NULL.\n *      (2) If either nawd and/or nahd is defined, it must have the same\n *          count as the number of pixa in paas.\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixaaSelectRange",
      "comment" : "/*!\n *  pixaaSelectRange()\n *\n *      Input:  paas\n *              first (use 0 to select from the beginning)\n *              last (use 0 to select to the end)\n *              copyflag (L_COPY, L_CLONE)\n *      Return: paad, or null on error\n *\n *  Notes:\n *      (1) The copyflag specifies what we do with each pixa from paas.\n *          Specifically, L_CLONE inserts a clone into paad of each\n *          selected pixa from paas.\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixaaSizeRange",
      "comment" : "/*!\n *  pixaaSizeRange()\n *\n *      Input:  paa\n *              &minw, &minh, &maxw, &maxh (<optional return> range of\n *                                          dimensions of all boxes)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pixafunc1.c"
   },
   {
      "function" : "pixaaTruncate",
      "comment" : "/*!\n *  pixaaTruncate()\n *\n *      Input:  paa\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This identifies the largest index containing a pixa that\n *          has any pix within it, destroys all pixa above that index,\n *          and resets the count.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaaVerifyDepth",
      "comment" : "/*!\n *  pixaaVerifyDepth()\n *\n *      Input:  paa\n *              &maxdepth (<optional return> max depth of all pix in pixaa)\n *      Return: depth (return 0 if they're not all the same, or on error)\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaaWrite",
      "comment" : "/*!\n *  pixaaWrite()\n *\n *      Input:  filename\n *              paa\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The pix are stored in the file as png.\n *          If the png library is not linked, this will fail.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaaWriteStream",
      "comment" : "/*!\n *  pixaaWriteStream()\n *\n *      Input:  stream (opened for \"wb\")\n *              paa\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The pix are stored in the file as png.\n *          If the png library is not linked, this will fail.\n */",
      "file" : "pixabasic.c"
   },
   {
      "function" : "pixaccAdd",
      "comment" : "/*!\n *  pixaccAdd()\n *\n *      Input:  pixacc\n *              pix (to be added)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pixacc.c"
   },
   {
      "function" : "pixaccCreate",
      "comment" : "/*!\n *  pixaccCreate()\n *\n *      Input:  w, h (of 32 bpp internal Pix)\n *              negflag (0 if only positive numbers are involved;\n *                       1 if there will be negative numbers)\n *      Return: pixacc, or null on error\n *\n *  Notes:\n *      (1) Use @negflag = 1 for safety if any negative numbers are going\n *          to be used in the chain of operations.  Negative numbers\n *          arise, e.g., by subtracting a pix, or by adding a pix\n *          that has been pre-multiplied by a negative number.\n *      (2) Initializes the internal 32 bpp pix, similarly to the\n *          initialization in pixInitAccumulate().\n */",
      "file" : "pixacc.c"
   },
   {
      "function" : "pixaccCreateFromPix",
      "comment" : "/*!\n *  pixaccCreateFromPix()\n *\n *      Input:  pix\n *              negflag (0 if only positive numbers are involved;\n *                       1 if there will be negative numbers)\n *      Return: pixacc, or null on error\n *\n *  Notes:\n *      (1) See pixaccCreate()\n */",
      "file" : "pixacc.c"
   },
   {
      "function" : "pixaccDestroy",
      "comment" : "/*!\n *  pixaccDestroy()\n *\n *      Input:  &pixacc (<can be null>)\n *      Return: void\n *\n *  Notes:\n *      (1) Always nulls the input ptr.\n */",
      "file" : "pixacc.c"
   },
   {
      "function" : "pixaccFinal",
      "comment" : "/*!\n *  pixaccFinal()\n *\n *      Input:  pixacc\n *              outdepth (8, 16 or 32 bpp)\n *      Return: pixd (8 , 16 or 32 bpp), or null on error\n */",
      "file" : "pixacc.c"
   },
   {
      "function" : "pixaccGetOffset",
      "comment" : "/*!\n *  pixaccGetOffset()\n *\n *      Input:  pixacc\n *      Return: offset, or -1 on error\n */",
      "file" : "pixacc.c"
   },
   {
      "function" : "pixaccGetPix",
      "comment" : "/*!\n *  pixaccGetPix()\n *\n *      Input:  pixacc\n *      Return: pix, or null on error\n */",
      "file" : "pixacc.c"
   },
   {
      "function" : "pixaccMultConst",
      "comment" : "/*!\n *  pixaccMultConst()\n *\n *      Input:  pixacc\n *              factor\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pixacc.c"
   },
   {
      "function" : "pixaccMultConstAccumulate",
      "comment" : "/*!\n *  pixaccMultConstAccumulate()\n *\n *      Input:  pixacc\n *              pix\n *              factor\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This creates a temp pix that is @pix multiplied by the\n *          constant @factor.  It then adds that into @pixacc.\n */",
      "file" : "pixacc.c"
   },
   {
      "function" : "pixaccSubtract",
      "comment" : "/*!\n *  pixaccSubtract()\n *\n *      Input:  pixacc\n *              pix (to be subtracted)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pixacc.c"
   },
   {
      "function" : "pixacompAddBox",
      "comment" : "/*!\n *  pixacompAddBox()\n *\n *      Input:  pixac\n *              box\n *              copyflag (L_INSERT, L_COPY)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixacompAddPix",
      "comment" : "/*!\n *  pixacompAddPix()\n *\n *      Input:  pixac\n *              pix  (to be added)\n *              comptype (IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) The array is filled up to the (n-1)-th element, and this\n *          converts the input pix to a pixcomp and adds it at\n *          the n-th position.\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixacompAddPixcomp",
      "comment" : "/*!\n *  pixacompAddPixcomp()\n *\n *      Input:  pixac\n *              pixc  (to be added by insertion)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixacompConvertToPdf",
      "comment" : "/*!\n *  pixacompConvertToPdf()\n *\n *      Input:  pixac (containing images all at the same resolution)\n *              res (override the resolution of each input image, in ppi;\n *                   use 0 to respect the resolution embedded in the input)\n *              scalefactor (scaling factor applied to each image; > 0.0)\n *              type (encoding type (L_JPEG_ENCODE, L_G4_ENCODE,\n *                    L_FLATE_ENCODE, or 0 for default)\n *              quality (used for JPEG only; 0 for default (75))\n *              title (<optional> pdf title)\n *              fileout (pdf file of all images)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This follows closely the function pixaConvertToPdf() in pdfio.c.\n *      (2) The images are encoded with G4 if 1 bpp; JPEG if 8 bpp without\n *          colormap and many colors, or 32 bpp; FLATE for anything else.\n *      (3) The scalefactor must be > 0.0; otherwise it is set to 1.0.\n *      (4) Specifying one of the three encoding types for @type forces\n *          all images to be compressed with that type.  Use 0 to have\n *          the type determined for each image based on depth and whether\n *          or not it has a colormap.\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixacompConvertToPdfData",
      "comment" : "/*!\n *  pixacompConvertToPdfData()\n *\n *      Input:  pixac (containing images all at the same resolution)\n *              res (input resolution of all images)\n *              scalefactor (scaling factor applied to each image; > 0.0)\n *              type (encoding type (L_JPEG_ENCODE, L_G4_ENCODE,\n *                    L_FLATE_ENCODE, or 0 for default)\n *              quality (used for JPEG only; 0 for default (75))\n *              title (<optional> pdf title)\n *              &data (<return> output pdf data (of all images)\n *              &nbytes (<return> size of output pdf data)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) See pixacompConvertToPdf().\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixacompCreate",
      "comment" : "/*!\n *  pixacompCreate()\n *\n *      Input:  n  (initial number of ptrs)\n *      Return: pixac, or null on error\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixacompCreateFromFiles",
      "comment" : "/*!\n *  pixacompCreateFromFiles()\n *\n *      Input:  dirname\n *              substr (<optional> substring filter on filenames; can be null)\n *              comptype (IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG)\n *      Return: pixac, or null on error\n *\n *  Notes:\n *      (1) @dirname is the full path for the directory.\n *      (2) @substr is the part of the file name (excluding\n *          the directory) that is to be matched.  All matching\n *          filenames are read into the Pixa.  If substr is NULL,\n *          all filenames are read into the Pixa.\n *      (3) Use @comptype == IFF_DEFAULT to have the compression\n *          type automatically determined for each file.\n *      (4) If the comptype is invalid for a file, the default will\n *          be substituted.\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixacompCreateFromPixa",
      "comment" : "/*!\n *  pixacompCreateFromPixa()\n *\n *      Input:  pixa\n *              comptype (IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG)\n *              accesstype (L_COPY, L_CLONE, L_COPY_CLONE)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If @format == IFF_DEFAULT, the conversion format for each\n *          image is chosen automatically.  Otherwise, we use the\n *          specified format unless it can't be done (e.g., jpeg\n *          for a 1, 2 or 4 bpp pix, or a pix with a colormap),\n *          in which case we use the default (assumed best) compression.\n *      (2) @accesstype is used to extract a boxa from @pixa.\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixacompCreateFromSA",
      "comment" : "/*!\n *  pixacompCreateFromSA()\n *\n *      Input:  sarray (full pathnames for all files)\n *              comptype (IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG)\n *      Return: pixac, or null on error\n *\n *  Notes:\n *      (1) Use @comptype == IFF_DEFAULT to have the compression\n *          type automatically determined for each file.\n *      (2) If the comptype is invalid for a file, the default will\n *          be substituted.\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixacompCreateWithInit",
      "comment" : "/*!\n *  pixacompCreateWithInit()\n *\n *      Input:  n  (initial number of ptrs)\n *              offset (difference: accessor index - pixacomp array index)\n *              pix (<optional> initialize each ptr in pixacomp to this pix;\n *                   can be NULL)\n *              comptype (IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG)\n *      Return: pixac, or null on error\n *\n *  Notes:\n *      (1) Initializes a pixacomp to be fully populated with @pix,\n *          compressed using @comptype.  If @pix == NULL, @comptype\n *          is ignored.\n *      (2) Typically, the array is initialized with a tiny pix.\n *          This is most easily done by setting @pix == NULL, causing\n *          initialization of each array element with a tiny placeholder\n *          pix (w = h = d = 1), using comptype = IFF_TIFF_G4 .\n *      (3) Example usage:\n *            // Generate pixacomp for pages 30 - 49.  This has an array\n *            // size of 20 and the page number offset is 30.\n *            PixaComp *pixac = pixacompCreateWithInit(20, 30, NULL,\n *                                                     IFF_TIFF_G4);\n *            // Now insert png-compressed images into the initialized array\n *            for (pageno = 30; pageno < 50; pageno++) {\n *                Pix *pixt = ...   // derived from image[pageno]\n *                if (pixt)\n *                    pixacompReplacePix(pixac, pageno, pixt, IFF_PNG);\n *                pixDestroy(&pixt);\n *            }\n *          The result is a pixac with 20 compressed strings, and with\n *          selected pixt replacing the placeholders.\n *          To extract the image for page 38, which is decompressed\n *          from element 8 in the array, use:\n *            pixt = pixacompGetPix(pixac, 38);\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixacompDestroy",
      "comment" : "/*!\n *  pixacompDestroy()\n *\n *      Input:  &pixac (<to be nulled>)\n *      Return: void\n *\n *  Notes:\n *      (1) Always nulls the input ptr.\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixacompDisplayTiledAndScaled",
      "comment" : "/*!\n *  pixacompDisplayTiledAndScaled()\n *\n *      Input:  pixac\n *              outdepth (output depth: 1, 8 or 32 bpp)\n *              tilewidth (each pix is scaled to this width)\n *              ncols (number of tiles in each row)\n *              background (0 for white, 1 for black; this is the color\n *                 of the spacing between the images)\n *              spacing  (between images, and on outside)\n *              border (width of additional black border on each image;\n *                      use 0 for no border)\n *      Return: pix of tiled images, or null on error\n *\n *  Notes:\n *      (1) This is the same function as pixaDisplayTiledAndScaled(),\n *          except it works on a Pixacomp instead of a Pix.  It is particularly\n *          useful for showing the images in a Pixacomp at reduced resolution.\n *      (2) This can be used to tile a number of renderings of\n *          an image that are at different scales and depths.\n *      (3) Each image, after scaling and optionally adding the\n *          black border, has width 'tilewidth'.  Thus, the border does\n *          not affect the spacing between the image tiles.  The\n *          maximum allowed border width is tilewidth / 5.\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixacompExtendArray",
      "comment" : "/*!\n *  pixacompExtendArray()\n *\n *      Input:  pixac\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) We extend the boxa array simultaneously.  This is\n *          necessary in case we are NOT adding boxes simultaneously\n *          with adding pixc.  We always want the sizes of the\n *          pixac and boxa ptr arrays to be equal.\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixacompGetBox",
      "comment" : "/*!\n *  pixacompGetBox()\n *\n *      Input:  pixac\n *              index (caller's view of index within pixac; includes offset)\n *              accesstype  (L_COPY or L_CLONE)\n *      Return: box (if null, not automatically an error), or null on error\n *\n *  Notes:\n *      (1) The @index includes the offset, which must be subtracted\n *          to get the actual index into the ptr array.\n *      (2) There is always a boxa with a pixac, and it is initialized so\n *          that each box ptr is NULL.\n *      (3) In general, we expect that there is either a box associated\n *          with each pixc, or no boxes at all in the boxa.\n *      (4) Having no boxes is thus not an automatic error.  Whether it\n *          is an actual error is determined by the calling program.\n *          If the caller expects to get a box, it is an error; see, e.g.,\n *          pixacGetBoxGeometry().\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixacompGetBoxGeometry",
      "comment" : "/*!\n *  pixacompGetBoxGeometry()\n *\n *      Input:  pixac\n *              index (caller's view of index within pixac; includes offset)\n *              &x, &y, &w, &h (<optional return>; each can be null)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The @index includes the offset, which must be subtracted\n *          to get the actual index into the ptr array.\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixacompGetBoxa",
      "comment" : "/*!\n *  pixacompGetBoxa()\n *\n *      Input:  pixac\n *              accesstype  (L_COPY, L_CLONE, L_COPY_CLONE)\n *      Return: boxa, or null on error\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixacompGetBoxaCount",
      "comment" : "/*!\n *  pixacompGetBoxaCount()\n *\n *      Input:  pixac\n *      Return: count, or 0 on error\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixacompGetCount",
      "comment" : "/*!\n *  pixacompGetCount()\n *\n *      Input:  pixac\n *      Return: count, or 0 if no pixa\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixacompGetOffset",
      "comment" : "/*!\n *  pixacompGetOffset()\n *\n *      Input:  pixac\n *      Return: offset, or 0 on error\n *\n *  Notes:\n *      (1) The offset is the difference between the caller's view of\n *          the index into the array and the actual array index.\n *          By default it is 0.\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixacompGetPix",
      "comment" : "/*!\n *  pixacompGetPix()\n *\n *      Input:  pixac\n *              index (caller's view of index within pixac; includes offset)\n *      Return: pix, or null on error\n *\n *  Notes:\n *      (1) The @index includes the offset, which must be subtracted\n *          to get the actual index into the ptr array.\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixacompGetPixDimensions",
      "comment" : "/*!\n *  pixacompGetPixDimensions()\n *\n *      Input:  pixa\n *              index (caller's view of index within pixac; includes offset)\n *              &w, &h, &d (<optional return>; each can be null)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The @index includes the offset, which must be subtracted\n *          to get the actual index into the ptr array.\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixacompGetPixcomp",
      "comment" : "/*!\n *  pixacompGetPixcomp()\n *\n *      Input:  pixac\n *              index (caller's view of index within pixac; includes offset)\n *      Return: pixc, or null on error\n *\n *  Notes:\n *      (1) The @index includes the offset, which must be subtracted\n *          to get the actual index into the ptr array.\n *      (2) Important: this is just a ptr to the pixc owned by the pixac.\n *          Do not destroy unless you are replacing the pixc.\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixacompRead",
      "comment" : "/*!\n *  pixacompRead()\n *\n *      Input:  filename\n *      Return: pixac, or null on error\n *\n *  Notes:\n *      (1) Unlike the situation with serialized Pixa, where the image\n *          data is stored in png format, the Pixacomp image data\n *          can be stored in tiffg4, png and jpg formats.\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixacompReadStream",
      "comment" : "/*!\n *  pixacompReadStream()\n *\n *      Input:  stream\n *      Return: pixac, or null on error\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixacompReplacePix",
      "comment" : "/*!\n *  pixacompReplacePix()\n *\n *      Input:  pixac\n *              index (caller's view of index within pixac; includes offset)\n *              pix  (owned by the caller)\n *              comptype (IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) The @index includes the offset, which must be subtracted\n *          to get the actual index into the ptr array.\n *      (2) The input @pix is converted to a pixc, which is then inserted\n *          into the pixac.\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixacompReplacePixcomp",
      "comment" : "/*!\n *  pixacompReplacePixcomp()\n *\n *      Input:  pixac\n *              index (caller's view of index within pixac; includes offset)\n *              pixc  (to replace existing one, which is destroyed)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) The @index includes the offset, which must be subtracted\n *          to get the actual index into the ptr array.\n *      (2) The inserted @pixc is now owned by the pixac.  The caller\n *          must not destroy it.\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixacompSetOffset",
      "comment" : "/*!\n *  pixacompSetOffset()\n *\n *      Input:  pixac\n *              offset (non-negative)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The offset is the difference between the caller's view of\n *          the index into the array and the actual array index.\n *          By default it is 0.\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixacompWrite",
      "comment" : "/*!\n *  pixacompWrite()\n *\n *      Input:  filename\n *              pixac\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Unlike the situation with serialized Pixa, where the image\n *          data is stored in png format, the Pixacomp image data\n *          can be stored in tiffg4, png and jpg formats.\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixacompWriteStream",
      "comment" : "/*!\n *  pixacompWriteStream()\n *\n *      Input:  stream\n *              pixac\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixacompWriteStreamInfo",
      "comment" : "/*!\n *  pixacompWriteStreamInfo()\n *\n *      Input:  fp (file stream)\n *              pixac\n *              text (<optional> identifying string; can be null)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixcmapAddBlackOrWhite",
      "comment" : "/*!\n *  pixcmapAddBlackOrWhite()\n *\n *      Input:  cmap\n *              color (0 for black, 1 for white)\n *              &index (<optional return> index of color; can be null)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This only adds color if not already there.\n *      (2) The alpha component is 255 (opaque)\n *      (3) This sets index to the requested color.\n *      (4) If there is no room in the colormap, returns the index\n *          of the closest color.\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapAddColor",
      "comment" : "/*!\n *  pixcmapAddColor()\n *\n *      Input:  cmap\n *              rval, gval, bval (colormap entry to be added; each number\n *                                is in range [0, ... 255])\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This always adds the color if there is room.\n *      (2) The alpha component is 255 (opaque)\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapAddNearestColor",
      "comment" : "/*!\n *  pixcmapAddNearestColor()\n *\n *      Input:  cmap\n *              rval, gval, bval (colormap entry to be added; each number\n *                                is in range [0, ... 255])\n *              &index (<return> index of color)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This only adds color if not already there.\n *      (2) The alpha component is 255 (opaque)\n *      (3) If it's not in the colormap and there is no room to add\n *          another color, this returns the index of the nearest color.\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapAddNewColor",
      "comment" : "/*!\n *  pixcmapAddNewColor()\n *\n *      Input:  cmap\n *              rval, gval, bval (colormap entry to be added; each number\n *                                is in range [0, ... 255])\n *              &index (<return> index of color)\n *      Return: 0 if OK, 1 on error; 2 if unable to add color\n *\n *  Notes:\n *      (1) This only adds color if not already there.\n *      (2) The alpha component is 255 (opaque)\n *      (3) This returns the index of the new (or existing) color.\n *      (4) Returns 2 with a warning if unable to add this color;\n *          the caller should check the return value.\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapAddRGBA",
      "comment" : "/*!\n *  pixcmapAddRGBA()\n *\n *      Input:  cmap\n *              rval, gval, bval, aval (colormap entry to be added;\n *                                      each number is in range [0, ... 255])\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This always adds the color if there is room.\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapClear",
      "comment" : "/*!\n *  pixcmapClear()\n *\n *      Input:  cmap\n *      Return: 0 if OK, 1 on error\n *\n *  Note: this removes the colors by setting the count to 0.\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapColorToGray",
      "comment" : "/*!\n *  pixcmapColorToGray()\n *\n *      Input:  cmap\n *              rwt, gwt, bwt  (non-negative; these should add to 1.0)\n *      Return: cmap (gray), or null on error\n *\n *  Notes:\n *      (1) This creates a gray colormap from an arbitrary colormap.\n *      (2) In use, attach the output gray colormap to the pix\n *          (or a copy of it) that provided the input colormap.\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapContrastTRC",
      "comment" : "/*!\n *  pixcmapContrastTRC()\n *\n *      Input:  colormap\n *              factor (generally between 0.0 (no enhancement)\n *                      and 1.0, but can be larger than 1.0)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This is an in-place transform\n *      (2) See pixContrastTRC() and numaContrastTRC() in enhance.c\n *          for description and use of transform\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapConvertHSVToRGB",
      "comment" : "/*!\n *  pixcmapConvertHSVToRGB()\n *\n *      Input:  colormap\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      - in-place transform\n *      - See convertRGBToHSV() for def'n of HSV space.\n *      - replaces: h --> r, s --> g, v --> b\n */",
      "file" : "colorspace.c"
   },
   {
      "function" : "pixcmapConvertRGBToHSV",
      "comment" : "/*!\n *  pixcmapConvertRGBToHSV()\n *\n *      Input:  colormap\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      - in-place transform\n *      - See convertRGBToHSV() for def'n of HSV space.\n *      - replaces: r --> h, g --> s, b --> v\n */",
      "file" : "colorspace.c"
   },
   {
      "function" : "pixcmapConvertRGBToYUV",
      "comment" : "/*!\n *  pixcmapConvertRGBToYUV()\n *\n *      Input:  colormap\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      - in-place transform\n *      - See convertRGBToYUV() for def'n of YUV space.\n *      - replaces: r --> y, g --> u, b --> v\n */",
      "file" : "colorspace.c"
   },
   {
      "function" : "pixcmapConvertToHex",
      "comment" : "/*!\n *  pixcmapConvertToHex()\n *\n *      Input:  data  (binary serialized data)\n *              ncolors (in colormap)\n *      Return: hexdata (bracketed, space-separated ascii hex string),\n *                       or null on error.\n *\n *  Notes:\n *      (1) The number of bytes in @data is 3 * ncolors.\n *      (2) Output is in form:\n *             < r0g0b0 r1g1b1 ... rngnbn >\n *          where r0, g0, b0 ... are each 2 bytes of hex ascii\n *      (3) This is used in pdf files to express the colormap as an\n *          array in ascii (human-readable) format.\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapConvertYUVToRGB",
      "comment" : "/*!\n *  pixcmapConvertYUVToRGB()\n *\n *      Input:  colormap\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      - in-place transform\n *      - See convertRGBToYUV() for def'n of YUV space.\n *      - replaces: y --> r, u --> g, v --> b\n */",
      "file" : "colorspace.c"
   },
   {
      "function" : "pixcmapCopy",
      "comment" : "/*!\n *  pixcmapCopy()\n *\n *      Input:  cmaps\n *      Return: cmapd, or null on error\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapCountGrayColors",
      "comment" : "/*!\n *  pixcmapCountGrayColors()\n *\n *      Input:  cmap\n *              &ngray (<return> number of gray colors)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This counts the unique gray colors, including black and white.\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapCreate",
      "comment" : "/*!\n *  pixcmapCreate()\n *\n *      Input:  depth (bpp, of pix)\n *      Return: cmap, or null on error\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapCreateLinear",
      "comment" : "/*!\n *  pixcmapCreateLinear()\n *\n *      Input:  d (depth of pix for this colormap; 1, 2, 4 or 8)\n *              nlevels (valid in range [2, 2^d])\n *      Return: cmap, or null on error\n *\n *  Notes:\n *      (1) Colormap has equally spaced gray color values\n *          from black (0, 0, 0) to white (255, 255, 255).\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapCreateRandom",
      "comment" : "/*!\n *  pixcmapCreateRandom()\n *\n *      Input:  depth (bpp, of pix; 2, 4 or 8)\n *              hasblack (1 if the first color is black; 0 if no black)\n *              haswhite (1 if the last color is white; 0 if no white)\n *      Return: cmap, or null on error\n *\n *  Notes:\n *      (1) This sets up a colormap with random colors,\n *          where the first color is optionally black, the last color\n *          is optionally white, and the remaining colors are\n *          chosen randomly.\n *      (2) The number of randomly chosen colors is:\n *               2^(depth) - haswhite - hasblack\n *      (3) Because rand() is seeded, it might disrupt otherwise\n *          deterministic results if also used elsewhere in a program.\n *      (4) rand() is not threadsafe, and will generate garbage if run\n *          on multiple threads at once -- though garbage is generally\n *          what you want from a random number generator!\n *      (5) Modern rand()s have equal randomness in low and high order\n *          bits, but older ones don't.  Here, we're just using rand()\n *          to choose colors for output.\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapDeserializeFromMemory",
      "comment" : "/*!\n *  pixcmapDeserializeFromMemory()\n *\n *      Input:  data (binary string, 3 or 4 bytes per color)\n *              cpc (components/color: 3 for rgb, 4 for rgba)\n *              ncolors\n *      Return: cmap, or null on error\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapDestroy",
      "comment" : "/*!\n *  pixcmapDestroy()\n *\n *      Input:  &cmap (<set to null>)\n *      Return: void\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapGammaTRC",
      "comment" : "/*!\n *  pixcmapGammaTRC()\n *\n *      Input:  colormap\n *              gamma (gamma correction; must be > 0.0)\n *              minval  (input value that gives 0 for output; can be < 0)\n *              maxval  (input value that gives 255 for output; can be > 255)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This is an in-place transform\n *      (2) See pixGammaTRC() and numaGammaTRC() in enhance.c\n *          for description and use of transform\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapGenerateFromHisto",
      "comment" : "/*!\n *  pixcmapGenerateFromHisto()\n *\n *      Input:  pixs  (32 bpp; rgb color)\n *              depth (of colormap)\n *              histo\n *              histosize\n *              sigbits\n *      Return: colormap, or null on error\n *\n *  Notes:\n *      (1) This is used when the number of colors in the histo\n *          is not greater than maxcolors.\n *      (2) As a side-effect, the histo becomes an inverse colormap,\n *          labeling the cmap indices for each existing color.\n */",
      "file" : "colorquant2.c"
   },
   {
      "function" : "pixcmapGenerateFromMedianCuts",
      "comment" : "/*!\n *  pixcmapGenerateFromMedianCuts()\n *\n *      Input:  lh (priority queue of pointers to vboxes)\n *              histo\n *              sigbits (valid: 5 or 6)\n *      Return: cmap, or null on error\n *\n *  Notes:\n *      (1) Each vbox in the heap represents a color in the colormap.\n *      (2) As a side-effect, the histo becomes an inverse colormap,\n *          where the part of the array correpsonding to each vbox\n *          is labeled with the cmap index for that vbox.  Then\n *          for each rgb pixel, the colormap index is found directly\n *          by mapping the rgb value to the histo array index.\n */",
      "file" : "colorquant2.c"
   },
   {
      "function" : "pixcmapGetColor",
      "comment" : "/*!\n *  pixcmapGetColor()\n *\n *      Input:  cmap\n *              index\n *              &rval, &gval, &bval (<return> each color value)\n *      Return: 0 if OK, 1 if not accessable (caller should check)\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapGetColor32",
      "comment" : "/*!\n *  pixcmapGetColor32()\n *\n *      Input:  cmap\n *              index\n *              &val32 (<return> 32-bit rgb color value)\n *      Return: 0 if OK, 1 if not accessable (caller should check)\n *\n *  Notes:\n *      (1) The returned alpha channel value is 0.\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapGetComponentRange",
      "comment" : "/*!\n *  pixcmapGetComponentRange()\n *\n *      Input:  cmap\n *              color (L_SELECT_RED, L_SELECT_GREEN or L_SELECT_BLUE)\n *              &minval (<optional return> minimum value of component)\n *              &maxval (<optional return> minimum value of component)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Returns for selected components the extreme value\n *          (either min or max) of the color component that is\n *          found in the colormap.\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapGetCount",
      "comment" : "/*!\n *  pixcmapGetCount()\n *\n *      Input:  cmap\n *      Return: count, or 0 on error\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapGetDepth",
      "comment" : "/*!\n *  pixcmapGetDepth()\n *\n *      Input:  cmap\n *      Return: depth, or 0 on error\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapGetExtremeValue",
      "comment" : "/*!\n *  pixcmapGetExtremeValue()\n *\n *      Input:  cmap\n *              type (L_SELECT_MIN or L_SELECT_MAX)\n *              &rval (<optional return> red component)\n *              &gval (<optional return> green component)\n *              &bval (<optional return> blue component)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Returns for selected components the extreme value\n *          (either min or max) of the color component that is\n *          found in the colormap.\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapGetFreeCount",
      "comment" : "/*!\n *  pixcmapGetFreeCount()\n *\n *      Input:  cmap\n *      Return: free entries, or 0 on error\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapGetIndex",
      "comment" : "/*!\n *  pixcmapGetIndex()\n *\n *      Input:  cmap\n *              rval, gval, bval (colormap colors to search for; each number\n *                                is in range [0, ... 255])\n *              &index (<return>)\n *      Return: 0 if found, 1 if not found (caller must check)\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapGetMinDepth",
      "comment" : "/*!\n *  pixcmapGetMinDepth()\n *\n *      Input:  cmap\n *              &mindepth (<return> minimum depth to support the colormap)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) On error, &mindepth is returned as 0.\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapGetNearestGrayIndex",
      "comment" : "/*!\n *  pixcmapGetNearestGrayIndex()\n *\n *      Input:  cmap\n *              val (gray value to search for; in range [0, ... 255])\n *              &index (<return> the index of the nearest color)\n *      Return: 0 if OK, 1 on error (caller must check)\n *\n *  Notes:\n *      (1) This should be used on gray colormaps.  It uses only the\n *          green value of the colormap.\n *      (2) Returns the index of the exact color if possible, otherwise the\n *          index of the color closest to the target color.\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapGetNearestIndex",
      "comment" : "/*!\n *  pixcmapGetNearestIndex()\n *\n *      Input:  cmap\n *              rval, gval, bval (colormap colors to search for; each number\n *                                is in range [0, ... 255])\n *              &index (<return> the index of the nearest color)\n *      Return: 0 if OK, 1 on error (caller must check)\n *\n *  Notes:\n *      (1) Returns the index of the exact color if possible, otherwise the\n *          index of the color closest to the target color.\n *      (2) Nearest color is that which is the least sum-of-squares distance\n *          from the target color.\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapGetRGBA",
      "comment" : "/*!\n *  pixcmapGetRGBA()\n *\n *      Input:  cmap\n *              index\n *              &rval, &gval, &bval, &aval (<return> each color value)\n *      Return: 0 if OK, 1 if not accessable (caller should check)\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapGetRGBA32",
      "comment" : "/*!\n *  pixcmapGetRGBA32()\n *\n *      Input:  cmap\n *              index\n *              &val32 (<return> 32-bit rgba color value)\n *      Return: 0 if OK, 1 if not accessable (caller should check)\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapGetRankIntensity",
      "comment" : "/*!\n *  pixcmapGetRankIntensity()\n *\n *      Input:  cmap\n *              rankval (0.0 for darkest, 1.0 for lightest color)\n *              &index (<return> the index into the colormap that\n *                      corresponds to the rank intensity color)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapGrayToColor",
      "comment" : "/*!\n *  pixcmapGrayToColor()\n *\n *      Input:  color\n *      Return: cmap, or null on error\n *\n *  Notes:\n *      (1) This creates a colormap that maps from gray to\n *          a specific color.  In the mapping, each component\n *          is faded to white, depending on the gray value.\n *      (2) In use, this is simply attached to a grayscale pix\n *          to give it the input color.\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapHasColor",
      "comment" : "/*!\n *  pixcmapHasColor()\n *\n *      Input:  cmap\n *              &color (<return> TRUE if cmap has color; FALSE otherwise)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapIsOpaque",
      "comment" : "/*!\n *  pixcmapIsOpaque()\n *\n *      Input:  cmap\n *              &opaque (<return> TRUE if fully opaque: all entries are 255)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapReadStream",
      "comment" : "/*!\n *  pixcmapReadStream()\n *\n *      Input:  stream\n *      Return: cmap, or null on error\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapResetColor",
      "comment" : "/*!\n *  pixcmapResetColor()\n *\n *      Input:  cmap\n *              index\n *              rval, gval, bval (colormap entry to be reset; each number\n *                                is in range [0, ... 255])\n *      Return: 0 if OK, 1 if not accessable (caller should check)\n *\n *  Notes:\n *      (1) This resets sets the color of an entry that has already\n *          been set and included in the count of colors.\n *      (2) The alpha component is 255 (opaque)\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapSerializeToMemory",
      "comment" : "/*!\n *  pixcmapSerializeToMemory()\n *\n *      Input:  colormap\n *              cpc (components/color: 3 for rgb, 4 for rgba)\n *              &ncolors (<return> number of colors in table)\n *              &data (<return> binary string, cpc bytes per color)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) When serializing to store in a pdf, use @cpc = 3.\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapSetBlackAndWhite",
      "comment" : "/*!\n *  pixcmapSetBlackAndWhite()\n *\n *      Input:  cmap\n *              setblack (0 for no operation; 1 to set darkest color to black)\n *              setwhite (0 for no operation; 1 to set lightest color to white)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapShiftByComponent",
      "comment" : "/*!\n *  pixcmapShiftByComponent()\n *\n *      Input:  colormap\n *              srcval (source color: 0xrrggbb00)\n *              dstval (target color: 0xrrggbb00)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This is an in-place transform\n *      (2) It implements pixelShiftByComponent() for each color.\n *          The mapping is specified by srcval and dstval.\n *      (3) If a component decreases, the component in the colormap\n *          decreases by the same ratio.  Likewise for increasing, except\n *          all ratios are taken with respect to the distance from 255.\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapShiftIntensity",
      "comment" : "/*!\n *  pixcmapShiftIntensity()\n *\n *      Input:  colormap\n *              fraction (between -1.0 and +1.0)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This is an in-place transform\n *      (2) It does a proportional shift of the intensity for each color.\n *      (3) If fraction < 0.0, it moves all colors towards (0,0,0).\n *          This darkens the image.\n *          If fraction > 0.0, it moves all colors towards (255,255,255)\n *          This fades the image.\n *      (4) The equivalent transform can be accomplished with pixcmapGammaTRC(),\n *          but it is considerably more difficult (see numaGammaTRC()).\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapToArrays",
      "comment" : "/*!\n *  pixcmapToArrays()\n *\n *      Input:  colormap\n *              &rmap, &gmap, &bmap  (<return> colormap arrays)\n *              &amap (<optional return> alpha array)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapToOctcubeLUT",
      "comment" : "/*!\n *  pixcmapToOctcubeLUT()\n *\n *      Input:  cmap\n *              level (significant bits for each of RGB; valid in [1...6])\n *              metric (L_MANHATTAN_DISTANCE, L_EUCLIDEAN_DISTANCE)\n *      Return: tab[2**(3 * level)]\n *\n *  Notes:\n *      (1) This function is used to quickly find the colormap color\n *          that is closest to any rgb color.  It is used to assign\n *          rgb colors to an existing colormap.  It can be very expensive\n *          to search through the entire colormap for the closest color\n *          to each pixel.  Instead, we first set up this table, which is\n *          populated by the colormap index nearest to each octcube\n *          color.  Then we go through the image; for each pixel,\n *          do two table lookups: first to generate the octcube index\n *          from rgb and second to use this table to read out the\n *          colormap index.\n *      (2) Do a slight modification for white and black.  For level = 4,\n *          each octcube size is 16.  The center of the whitest octcube\n *          is at (248, 248, 248), which is closer to 242 than 255.\n *          Consequently, any gray color between 242 and 254 will\n *          be selected, even if white (255, 255, 255) exists.  This is\n *          typically not optimal, because the original color was\n *          likely white.  Therefore, if white exists in the colormap,\n *          use it for any rgb color that falls into the most white octcube.\n *          Do the similar thing for black.\n *      (3) Here are the actual function calls for quantizing to a\n *          specified colormap:\n *            - first make the tables that map from rgb --> octcube index\n *                     makeRGBToIndexTables()\n *            - then for each pixel:\n *                * use the tables to get the octcube index\n *                     getOctcubeIndexFromRGB()\n *                * use this table to get the nearest color in the colormap\n *                     cmap_index = tab[index]\n *      (4) Distance can be either manhattan or euclidean.\n *      (5) In typical use, level = 4 gives reasonable results, and\n *          level = 5 is slightly better.  When this function is used\n *          for color segmentation, there are typically a small number\n *          of colors and the number of levels can be small (e.g., level = 3).\n */",
      "file" : "colorquant1.c"
   },
   {
      "function" : "pixcmapToRGBTable",
      "comment" : "/*!\n *  pixcmapToRGBTable()\n *\n *      Input:  colormap\n *              &tab (<return> table of rgba values for the colormap)\n *              &ncolors (<optional return> size of table)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapUsableColor",
      "comment" : "/*!\n *  pixcmapUsableColor()\n *\n *      Input:  cmap\n *              rval, gval, bval (colormap entry to be added; each number\n *                                is in range [0, ... 255])\n *              usable (<return> 1 if usable; 0 if not)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This checks if the color already exists or if there is\n *          room to add it.  It makes no change in the colormap.\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcmapWriteStream",
      "comment" : "/*!\n *  pixcmapWriteStream()\n *\n *      Input:  stream, cmap\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "colormap.c"
   },
   {
      "function" : "pixcompCreateFromFile",
      "comment" : "/*!\n *  pixcompCreateFromFile()\n *\n *      Input:  filename\n *              comptype (IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG)\n *      Return: pixc, or null on error\n *\n *  Notes:\n *      (1) Use @comptype == IFF_DEFAULT to have the compression\n *          type automatically determined.\n *      (2) If the comptype is invalid for this file, the default will\n *          be substituted.\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixcompCreateFromPix",
      "comment" : "/*!\n *  pixcompCreateFromPix()\n *\n *      Input:  pix\n *              comptype (IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG)\n *      Return: pixc, or null on error\n *\n *  Notes:\n *      (1) Use @comptype == IFF_DEFAULT to have the compression\n *          type automatically determined.\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixcompCreateFromString",
      "comment" : "/*!\n *  pixcompCreateFromString()\n *\n *      Input:  data (compressed string)\n *              size (number of bytes)\n *              copyflag (L_INSERT or L_COPY)\n *      Return: pixc, or null on error\n *\n *  Notes:\n *      (1) This works when the compressed string is png, jpeg or tiffg4.\n *      (2) The copyflag determines if the data in the new Pixcomp is\n *          a copy of the input data.\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixcompDestroy",
      "comment" : "/*!\n *  pixcompDestroy()\n *\n *      Input:  &pixc <will be nulled>\n *      Return: void\n *\n *  Notes:\n *      (1) Always nulls the input ptr.\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixcompDetermineFormat",
      "comment" : "/*!\n *  pixcompDetermineFormat()\n *\n *      Input:  comptype (IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG)\n *              d (pix depth)\n *              cmapflag (1 if pix to be compressed as a colormap; 0 otherwise)\n *              &format (return IFF_TIFF, IFF_PNG or IFF_JFIF_JPEG)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This determines the best format for a pix, given both\n *          the request (@comptype) and the image characteristics.\n *      (2) If @comptype == IFF_DEFAULT, this does not necessarily result\n *          in png encoding.  Instead, it returns one of the three formats\n *          that is both valid and most likely to give best compression.\n *      (3) If the pix cannot be compressed by the input value of\n *          @comptype, this selects IFF_PNG, which can compress all pix.\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixcompGetDimensions",
      "comment" : "/*!\n *  pixcompGetDimensions()\n *\n *      Input:  pixc\n *              &w, &h, &d (<optional return>)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixcompWriteStreamInfo",
      "comment" : "/*!\n *  pixcompWriteStreamInfo()\n *\n *      Input:  fp (file stream)\n *              pixc\n *              text (<optional> identifying string; can be null)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pixcomp.c"
   },
   {
      "function" : "pixelFractionalShift",
      "comment" : "/*!\n *  pixelFractionalShift()\n *\n *      Input:  rval, gval, bval\n *              fraction (negative toward black; positive toward white)\n *              &ppixel (<return> rgb value)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This transformation leaves the hue invariant, while changing\n *          the saturation and intensity.  It can be used for that\n *          purpose in pixLinearMapToTargetColor().\n *      (2) @fraction is in the range [-1 .... +1].  If @fraction < 0,\n *          saturation is increased and brightness is reduced.  The\n *          opposite results if @fraction > 0.  If @fraction == -1,\n *          the resulting pixel is black; @fraction == 1 results in white.\n */",
      "file" : "coloring.c"
   },
   {
      "function" : "pixelLinearMapToTargetColor",
      "comment" : "/*!\n *  pixelLinearMapToTargetColor()\n *\n *      Input:  scolor (rgb source color: 0xrrggbb00)\n *              srcmap (source mapping color: 0xrrggbb00)\n *              dstmap (target mapping color: 0xrrggbb00)\n *              &pdcolor (<return> rgb dest color: 0xrrggbb00)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This does this does a piecewise linear mapping of each\n *          component of @scolor to @dcolor, based on the relation\n *          between the components of @srcmap and @dstmap.  It is the\n *          same transformation, performed on a single color, as mapped\n *          on every pixel in a pix by pixLinearMapToTargetColor().\n *      (2) For each component, if the sval is larger than the smap,\n *          the dval will be pushed up from dmap towards white.\n *          Otherwise, dval will be pushed down from dmap towards black.\n *          This is because you can visualize the transformation as\n *          a linear stretching where smap moves to dmap, and everything\n *          else follows linearly with 0 and 255 fixed.\n *      (3) The mapping will in general change the hue of @scolor.\n *          However, if the @srcmap and @dstmap targets are related by\n *          a transformation given by pixelFractionalShift(), the hue\n *          will be invariant.\n */",
      "file" : "coloring.c"
   },
   {
      "function" : "pixelShiftByComponent",
      "comment" : "/*!\n *  pixelShiftByComponent()\n *\n *      Input:  rval, gval, bval\n *              srcval (source color: 0xrrggbb00)\n *              dstval (target color: 0xrrggbb00)\n *              &ppixel (<return> rgb value)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is a linear transformation that gives the same result\n *          on a single pixel as pixShiftByComponent() gives\n *          on a pix.  Each component is handled separately.  If\n *          the dest component is larger than the src, then the\n *          component is pushed toward 255 by the same fraction as\n *          the src --> dest shift.\n */",
      "file" : "coloring.c"
   },
   {
      "function" : "pmsCreate",
      "comment" : "/*!\n *  pmsCreate()\n *\n *      Input:  minsize (of data chunk that can be supplied by pms)\n *              smallest (bytes of the smallest pre-allocated data chunk.\n *              numalloc (array with the number of data chunks for each\n *                        size that are in the memory store)\n *              logfile (use for debugging; null otherwise)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This computes the size of the block of memory required\n *          and allocates it.  Each chunk starts on a 32-bit word boundary.\n *          The chunk sizes are in powers of 2, starting at @smallest,\n *          and the number of levels and chunks at each level is\n *          specified by @numalloc.\n *      (2) This is intended to manage the image data for a small number\n *          of relatively large pix.  The system malloc is expected to\n *          handle very large numbers of small chunks efficiently.\n *      (3) Important: set the allocators and call this function\n *          before any pix have been allocated.  Destroy all the pix\n *          in the normal way before calling pmsDestroy().\n *      (4) The pms struct is stored in a static global, so this function\n *          is not thread-safe.  When used, there must be only one thread\n *          per process.\n */",
      "file" : "pixalloc.c"
   },
   {
      "function" : "pmsCustomAlloc",
      "comment" : "/*!\n *  pmsCustomAlloc()\n *\n *      Input: nbytes (min number of bytes in the chunk to be retrieved)\n *      Return: data (ptr to chunk)\n *\n *  Notes:\n *      (1) This attempts to find a suitable pre-allocated chunk.\n *          If not found, it dynamically allocates the chunk.\n *      (2) If logging is turned on, the allocations that are not taken\n *          from the memory store, and are at least as large as the\n *          minimum size the store can handle, are logged to file.\n */",
      "file" : "pixalloc.c"
   },
   {
      "function" : "pmsCustomDealloc",
      "comment" : "/*!\n *  pmsCustomDealloc()\n *\n *      Input: data (to be freed or returned to the storage)\n *      Return: void\n */",
      "file" : "pixalloc.c"
   },
   {
      "function" : "pmsDestroy",
      "comment" : "/*!\n *  pmsDestroy()\n *\n *      Input:  (none)\n *      Return: void\n *\n *  Notes:\n *      (1) Important: call this function at the end of the program, after\n *          the last pix has been destroyed.\n */",
      "file" : "pixalloc.c"
   },
   {
      "function" : "pmsGetAlloc",
      "comment" : "/*!\n *  pmsGetAlloc()\n *\n *      Input:  nbytes\n *      Return: data\n *\n *  Notes:\n *      (1) This is called when a request for pix data cannot be\n *          obtained from the preallocated memory store.  After use it\n *          is freed like normal memory.\n *      (2) If logging is on, only write out allocs that are as large as\n *          the minimum size handled by the memory store.\n *      (3) size_t is %lu on 64 bit platforms and %u on 32 bit platforms.\n *          The C99 platform-independent format specifier for size_t is %zu,\n *          but windows hasn't conformed, so we are forced to go back to\n *          C89, use %lu, and cast to get platform-independence.  Ugh.\n */",
      "file" : "pixalloc.c"
   },
   {
      "function" : "pmsGetLevelForAlloc",
      "comment" : "/*!\n *  pmsGetLevelForAlloc()\n *\n *      Input: nbytes (min number of bytes in the chunk to be retrieved)\n *             &level (<return>; -1 if either too small or too large)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pixalloc.c"
   },
   {
      "function" : "pmsGetLevelForDealloc",
      "comment" : "/*!\n *  pmsGetLevelForDealloc()\n *\n *      Input: data (ptr to memory chunk)\n *             &level (<return> level in memory store; -1 if allocated\n *                     outside the store)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pixalloc.c"
   },
   {
      "function" : "pmsLogInfo",
      "comment" : "/*!\n *  pmsLogInfo()\n *\n *      Input:  (none)\n *      Return: void\n */",
      "file" : "pixalloc.c"
   },
   {
      "function" : "pnmReadNextAsciiValue",
      "comment" : "/*!\n *  pnmReadNextAsciiValue()\n *\n *      Return: 0 if OK, 1 on error or EOF.\n *\n *  Notes:\n *      (1) This reads the next sample value in ascii from the the file.\n */",
      "file" : "pnmio.c"
   },
   {
      "function" : "pnmSkipCommentLines",
      "comment" : "/*!\n *  pnmSkipCommentLines()\n *\n *      Return: 0 if OK, 1 on error or EOF\n *\n *  Notes:\n *      (1) Comment lines begin with '#'\n *      (2) Usage: caller should check return value for EOF\n */",
      "file" : "pnmio.c"
   },
   {
      "function" : "popFillseg",
      "comment" : "/*!\n *  popFillseg()\n *\n *      Input:  stack\n *              &xleft (<return>)\n *              &xright (<return>)\n *              &y (<return>)\n *              &dy (<return>)\n *      Return: void\n *\n *  Notes:\n *      (1) This removes a line segment from the stack, and returns its size.\n *      (2) The surplussed fillseg is placed on the auxiliary stack\n *          for future use.\n */",
      "file" : "conncomp.c"
   },
   {
      "function" : "popNewPixel",
      "comment" : "/*\n *  popNewPixel()\n *\n *      Input:  lqueue\n *              &x, &y   (<return> pixel coordinates)\n *      Return: void\n *\n *   Notes:\n *       (1) This is a wrapper for removing a NewPixel from a queue,\n *           which returns the pixel coordinates and saves the NewPixel\n *           on the storage stack.\n */",
      "file" : "watershed.c"
   },
   {
      "function" : "popWSPixel",
      "comment" : "/*\n *  popWSPixel()\n *\n *      Input:  lh  (priority queue)\n *              stack  (of reusable WSPixels)\n *              &val  (<return> pixel value)\n *              &x, &y  (<return> pixel coordinates)\n *              &index  (<return> label for set to which pixel belongs)\n *      Return: void\n *\n *   Notes:\n *       (1) This is a wrapper for removing a WSPixel from a heap,\n *           which returns the WSPixel data and saves the WSPixel\n *           on the storage stack.\n */",
      "file" : "watershed.c"
   },
   {
      "function" : "printRowIndices",
      "comment" : "/* mark the rows */",
      "file" : "classapp.c"
   },
   {
      "function" : "processMorphArgs1",
      "comment" : "/*!\n *  processMorphArgs1()\n *\n *      Input:  pixd (<optional>; this can be null, equal to pixs,\n *                    or different from pixs)\n *              pixs (1 bpp)\n *              sel\n *              &pixt (<returned>)\n *      Return: pixd, or null on error.\n *\n *  Notes:\n *      (1) This is used for generic erosion, dilation and HMT.\n */",
      "file" : "morph.c"
   },
   {
      "function" : "processMorphArgs2",
      "comment" : "/*!\n *  processMorphArgs2()\n *\n *  This is used for generic openings and closings.\n */",
      "file" : "morph.c"
   },
   {
      "function" : "projectiveXformPt",
      "comment" : "/*!\n *  projectiveXformPt()\n *\n *      Input:  vc (vector of 8 coefficients)\n *              (x, y)  (initial point)\n *              (&xp, &yp)   (<return> transformed point)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This computes the floating point location of the transformed point.\n *      (2) It does not check ptrs for returned data!\n */",
      "file" : "projective.c"
   },
   {
      "function" : "projectiveXformSampledPt",
      "comment" : "/*!\n *  projectiveXformSampledPt()\n *\n *      Input:  vc (vector of 8 coefficients)\n *              (x, y)  (initial point)\n *              (&xp, &yp)   (<return> transformed point)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This finds the nearest pixel coordinates of the transformed point.\n *      (2) It does not check ptrs for returned data!\n */",
      "file" : "projective.c"
   },
   {
      "function" : "ptaAddPt",
      "comment" : "/*!\n *  ptaAddPt()\n *\n *      Input:  pta\n *              x, y\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaAffineTransform",
      "comment" : "/*!\n *  ptaAffineTransform()\n *\n *      Input:  ptas (for initial points)\n *              mat  (3x3 transform matrix; canonical form)\n *      Return: ptad  (transformed points), or null on error\n */",
      "file" : "affinecompose.c"
   },
   {
      "function" : "ptaChangeRefcount",
      "comment" : "/*---------------------------------------------------------------------*\n *                           Pta accessors                             *\n *---------------------------------------------------------------------*/",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaClone",
      "comment" : "/*!\n *  ptaClone()\n *\n *      Input:  pta\n *      Return: ptr to same pta, or null on error\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaContainsPt",
      "comment" : "/*!\n *  ptaContainsPt()\n *\n *      Input:  pta\n *              x, y  (point)\n *      Return: 1 if contained, 0 otherwise or on error\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "ptaConvertToBoxa",
      "comment" : "/*!\n *  ptaConvertToBoxa()\n *\n *      Input:  pta\n *              ncorners (2 or 4 for the representation of each box)\n *      Return: boxa (with one box for each 2 or 4 points in the pta),\n *                    or null on error\n *\n *  Notes:\n *      (1) For 2 corners, the order of the 2 points is UL, LR.\n *          For 4 corners, the order of points is UL, UR, LL, LR.\n *      (2) Each derived box is the minimum szie containing all corners.\n */",
      "file" : "boxfunc4.c"
   },
   {
      "function" : "ptaCopy",
      "comment" : "/*!\n *  ptaCopy()\n *\n *      Input:  pta\n *      Return: copy of pta, or null on error\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaCopyRange",
      "comment" : "/*!\n *  ptaCopyRange()\n *\n *      Input:  ptas\n *              istart  (starting index in ptas)\n *              iend  (ending index in ptas; use 0 to copy to end)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaCreate",
      "comment" : "/*!\n *  ptaCreate()\n *\n *      Input:  n  (initial array sizes)\n *      Return: pta, or null on error.\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaCreateFromNuma",
      "comment" : "/*!\n *  ptaCreateFromNuma()\n *\n *      Input:  nax (<optional> can be null)\n *              nay\n *      Return: pta, or null on error.\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaCyclicPerm",
      "comment" : "/*!\n *  ptaCyclicPerm()\n *\n *      Input:  ptas\n *              xs, ys  (start point; must be in ptas)\n *      Return: ptad (cyclic permutation, starting and ending at (xs, ys),\n *              or null on error\n *\n *  Notes:\n *      (1) Check to insure that (a) ptas is a closed path where\n *          the first and last points are identical, and (b) the\n *          resulting pta also starts and ends on the same point\n *          (which in this case is (xs, ys).\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "ptaDestroy",
      "comment" : "/*!\n *  ptaDestroy()\n *\n *      Input:  &pta (<to be nulled>)\n *      Return: void\n *\n *  Note:\n *      - Decrements the ref count and, if 0, destroys the pta.\n *      - Always nulls the input ptr.\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaEmpty",
      "comment" : "/*!\n *  ptaEmpty()\n *\n *      Input:  pta\n *      Return: 0 if OK, 1 on error\n *\n *  Note: this only resets the \"n\" field, for reuse\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaExtendArrays",
      "comment" : "/*!\n *  ptaExtendArrays()\n *\n *      Input:  pta\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaGetArrays",
      "comment" : "/*!\n *  ptaGetArrays()\n *\n *      Input:  pta\n *              &nax (<optional return> numa of x array)\n *              &nay (<optional return> numa of y array)\n *      Return: 0 if OK; 1 on error or if pta is empty\n *\n *  Notes:\n *      (1) This copies the internal arrays into new Numas.\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaGetBoundaryPixels",
      "comment" : "/*!\n *  ptaGetBoundaryPixels()\n *\n *      Input:  pixs (1 bpp)\n *              type (L_BOUNDARY_FG, L_BOUNDARY_BG)\n *      Return: pta, or null on error\n *\n *  Notes:\n *      (1) This generates a pta of either fg or bg boundary pixels.\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "ptaGetBoundingRegion",
      "comment" : "/*!\n *  ptaGetBoundingRegion()\n *\n *      Input:  pta\n *      Return: box, or null on error\n *\n *  Notes:\n *      (1) This is used when the pta represents a set of points in\n *          a two-dimensional image.  It returns the box of minimum\n *          size containing the pts in the pta.\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "ptaGetCount",
      "comment" : "/*!\n *  ptaGetCount()\n *\n *      Input:  pta\n *      Return: count, or 0 if no pta\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaGetCubicLSF",
      "comment" : "/*!\n *  ptaGetCubicLSF()\n *\n *      Input:  pta\n *              &a  (<optional return> coeff a of LSF: y = ax^3 + bx^2 + cx + d)\n *              &b  (<optional return> coeff b of LSF)\n *              &c  (<optional return> coeff c of LSF)\n *              &d  (<optional return> coeff d of LSF)\n *              &nafit (<optional return> numa of least square fit)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This does a cubic least square fit to the set of points\n *          in @pta.  That is, it finds coefficients a, b, c and d\n *          that minimize:\n *\n *              sum (yi - a*xi*xi*xi -b*xi*xi -c*xi - d)^2\n *               i\n *\n *          Differentiate this expression w/rt a, b, c and d, and solve\n *          the resulting four equations for these coefficients in\n *          terms of various sums over the input data (xi, yi).\n *          The four equations are in the form:\n *             f[0][0]a + f[0][1]b + f[0][2]c + f[0][3] = g[0]\n *             f[1][0]a + f[1][1]b + f[1][2]c + f[1][3] = g[1]\n *             f[2][0]a + f[2][1]b + f[2][2]c + f[2][3] = g[2]\n *             f[3][0]a + f[3][1]b + f[3][2]c + f[3][3] = g[3]\n *      (2) If @nafit is defined, this returns an array of fitted values,\n *          corresponding to the two implicit Numa arrays (nax and nay) in pta.\n *          Thus, just as you can plot the data in pta as nay vs. nax,\n *          you can plot the linear least square fit as nafit vs. nax.\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "ptaGetIPt",
      "comment" : "/*!\n *  ptaGetIPt()\n *\n *      Input:  pta\n *              index  (into arrays)\n *              &x (<optional return> integer x value)\n *              &y (<optional return> integer y value)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaGetInsideBox",
      "comment" : "/*!\n *  ptaGetInsideBox()\n *\n *      Input:  ptas (input pts)\n *              box\n *      Return: ptad (of pts in ptas that are inside the box), or null on error\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "ptaGetLinearLSF",
      "comment" : "/*!\n *  ptaGetLinearLSF()\n *\n *      Input:  pta\n *              &a  (<optional return> slope a of least square fit: y = ax + b)\n *              &b  (<optional return> intercept b of least square fit)\n *              &nafit (<optional return> numa of least square fit)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Either or both &a and &b must be input.  They determine the\n *          type of line that is fit.\n *      (2) If both &a and &b are defined, this returns a and b that minimize:\n *\n *              sum (yi - axi -b)^2\n *               i\n *\n *          The method is simple: differentiate this expression w/rt a and b,\n *          and solve the resulting two equations for a and b in terms of\n *          various sums over the input data (xi, yi).\n *      (3) We also allow two special cases, where either a = 0 or b = 0:\n *           (a) If &a is given and &b = null, find the linear LSF that\n *               goes through the origin (b = 0).\n *           (b) If &b is given and &a = null, find the linear LSF with\n *               zero slope (a = 0).\n *      (4) If @nafit is defined, this returns an array of fitted values,\n *          corresponding to the two implicit Numa arrays (nax and nay) in pta.\n *          Thus, just as you can plot the data in pta as nay vs. nax,\n *          you can plot the linear least square fit as nafit vs. nax.\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "ptaGetPixelsFromPix",
      "comment" : "/*!\n *  ptaGetPixelsFromPix()\n *\n *      Input:  pixs (1 bpp)\n *              box (<optional> can be null)\n *      Return: pta, or null on error\n *\n *  Notes:\n *      (1) Generates a pta of fg pixels in the pix, within the box.\n *          If box == NULL, it uses the entire pix.\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "ptaGetPt",
      "comment" : "/*!\n *  ptaGetPt()\n *\n *      Input:  pta\n *              index  (into arrays)\n *              &x (<optional return> float x value)\n *              &y (<optional return> float y value)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaGetQuadraticLSF",
      "comment" : "/*!\n *  ptaGetQuadraticLSF()\n *\n *      Input:  pta\n *              &a  (<optional return> coeff a of LSF: y = ax^2 + bx + c)\n *              &b  (<optional return> coeff b of LSF: y = ax^2 + bx + c)\n *              &c  (<optional return> coeff c of LSF: y = ax^2 + bx + c)\n *              &nafit (<optional return> numa of least square fit)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This does a quadratic least square fit to the set of points\n *          in @pta.  That is, it finds coefficients a, b and c that minimize:\n *\n *              sum (yi - a*xi*xi -b*xi -c)^2\n *               i\n *\n *          The method is simple: differentiate this expression w/rt\n *          a, b and c, and solve the resulting three equations for these\n *          coefficients in terms of various sums over the input data (xi, yi).\n *          The three equations are in the form:\n *             f[0][0]a + f[0][1]b + f[0][2]c = g[0]\n *             f[1][0]a + f[1][1]b + f[1][2]c = g[1]\n *             f[2][0]a + f[2][1]b + f[2][2]c = g[2]\n *      (2) If @nafit is defined, this returns an array of fitted values,\n *          corresponding to the two implicit Numa arrays (nax and nay) in pta.\n *          Thus, just as you can plot the data in pta as nay vs. nax,\n *          you can plot the linear least square fit as nafit vs. nax.\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "ptaGetQuarticLSF",
      "comment" : "/*!\n *  ptaGetQuarticLSF()\n *\n *      Input:  pta\n *              &a  (<optional return> coeff a of LSF:\n *                        y = ax^4 + bx^3 + cx^2 + dx + e)\n *              &b  (<optional return> coeff b of LSF)\n *              &c  (<optional return> coeff c of LSF)\n *              &d  (<optional return> coeff d of LSF)\n *              &e  (<optional return> coeff e of LSF)\n *              &nafit (<optional return> numa of least square fit)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This does a quartic least square fit to the set of points\n *          in @pta.  That is, it finds coefficients a, b, c, d and 3\n *          that minimize:\n *\n *              sum (yi - a*xi*xi*xi*xi -b*xi*xi*xi -c*xi*xi - d*xi - e)^2\n *               i\n *\n *          Differentiate this expression w/rt a, b, c, d and e, and solve\n *          the resulting five equations for these coefficients in\n *          terms of various sums over the input data (xi, yi).\n *          The five equations are in the form:\n *             f[0][0]a + f[0][1]b + f[0][2]c + f[0][3] + f[0][4] = g[0]\n *             f[1][0]a + f[1][1]b + f[1][2]c + f[1][3] + f[1][4] = g[1]\n *             f[2][0]a + f[2][1]b + f[2][2]c + f[2][3] + f[2][4] = g[2]\n *             f[3][0]a + f[3][1]b + f[3][2]c + f[3][3] + f[3][4] = g[3]\n *             f[4][0]a + f[4][1]b + f[4][2]c + f[4][3] + f[4][4] = g[4]\n *      (2) If @nafit is defined, this returns an array of fitted values,\n *          corresponding to the two implicit Numa arrays (nax and nay) in pta.\n *          Thus, just as you can plot the data in pta as nay vs. nax,\n *          you can plot the linear least square fit as nafit vs. nax.\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "ptaGetRange",
      "comment" : "/*!\n *  ptaGetRange()\n *\n *      Input:  pta\n *              &minx (<optional return> min value of x)\n *              &maxx (<optional return> max value of x)\n *              &miny (<optional return> min value of y)\n *              &maxy (<optional return> max value of y)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) We can use pts to represent pairs of floating values, that\n *          are not necessarily tied to a two-dimension region.  For\n *          example, the pts can represent a general function y(x).\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "ptaGetRefcount",
      "comment" : "/*---------------------------------------------------------------------*\n *                           Pta accessors                             *\n *---------------------------------------------------------------------*/",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaGetSortIndex",
      "comment" : "/*!\n *  ptaGetSortIndex()\n *\n *      Input:  ptas\n *              sorttype (L_SORT_BY_X, L_SORT_BY_Y)\n *              sortorder  (L_SORT_INCREASING, L_SORT_DECREASING)\n *              &naindex (<return> index of sorted order into\n *                        original array)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "ptaInsertPt",
      "comment" : "/*!\n *  ptaInsertPt()\n *\n *      Input:  pta\n *              index (at which pt is to be inserted)\n *              x, y (point values)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaJoin",
      "comment" : "/*!\n *  ptaJoin()\n *\n *      Input:  ptad  (dest pta; add to this one)\n *              ptas  (source pta; add from this one)\n *              istart  (starting index in ptas)\n *              iend  (ending index in ptas; use -1 to cat all)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) istart < 0 is taken to mean 'read from the start' (istart = 0)\n *      (2) iend < 0 means 'read to the end'\n *      (3) if ptas == NULL, this is a no-op\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "ptaNoisyLinearLSF",
      "comment" : "/*!\n *  ptaNoisyLinearLSF()\n *\n *      Input:  pta\n *              factor (reject outliers with error greater than this\n *                      number of medians; typically ~ 3)\n *              &ptad (<optional return> with outliers removed)\n *              &a  (<optional return> slope a of least square fit: y = ax + b)\n *              &b  (<optional return> intercept b of least square fit)\n *              &mederr (<optional return> median error)\n *              &nafit (<optional return> numa of least square fit to ptad)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This does a linear least square fit to the set of points\n *          in @pta.  It then evaluates the errors and removes points\n *          whose error is >= factor * median_error.  It then re-runs\n *          the linear LSF on the resulting points.\n *      (2) Either or both &a and &b must be input.  They determine the\n *          type of line that is fit.\n *      (3) The median error can give an indication of how good the fit\n *          is likely to be.\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "ptaNoisyQuadraticLSF",
      "comment" : "/*!\n *  ptaNoisyQuadraticLSF()\n *\n *      Input:  pta\n *              factor (reject outliers with error greater than this\n *                      number of medians; typically ~ 3)\n *              &ptad (<optional return> with outliers removed)\n *              &a  (<optional return> coeff a of LSF: y = ax^2 + bx + c)\n *              &b  (<optional return> coeff b of LSF: y = ax^2 + bx + c)\n *              &c  (<optional return> coeff c of LSF: y = ax^2 + bx + c)\n *              &mederr (<optional return> median error)\n *              &nafit (<optional return> numa of least square fit to ptad)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This does a quadratic least square fit to the set of points\n *          in @pta.  It then evaluates the errors and removes points\n *          whose error is >= factor * median_error.  It then re-runs\n *          a quadratic LSF on the resulting points.\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "ptaPtInsidePolygon",
      "comment" : "/*!\n *  ptaPtInsidePolygon()\n *\n *      Input:  pta (vertices of a polygon)\n *              x, y (point to be tested)\n *              &inside (<return> 1 if inside; 0 if outside or on boundary)\n *      Return: 1 if OK, 0 on error\n *\n *  The abs value of the sum of the angles subtended from a point by\n *  the sides of a polygon, when taken in order traversing the polygon,\n *  is 0 if the point is outside the polygon and 2*pi if inside.\n *  The sign will be positive if traversed cw and negative if ccw.\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "ptaRead",
      "comment" : "/*!\n *  ptaRead()\n *\n *      Input:  filename\n *      Return: pta, or null on error\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaReadStream",
      "comment" : "/*!\n *  ptaReadStream()\n *\n *      Input:  stream\n *      Return: pta, or null on error\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaRemoveDuplicates",
      "comment" : "/*!\n *  ptaRemoveDuplicates()\n *\n *      Input:  ptas (assumed to be integer values)\n *              factor (should be larger than the largest point value;\n *                      use 0 for default)\n *      Return: ptad (with duplicates removed), or null on error\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "ptaRemovePt",
      "comment" : "/*!\n *  ptaRemovePt()\n *\n *      Input:  pta\n *              index (of point to be removed)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This shifts pta[i] --> pta[i - 1] for all i > index.\n *      (2) It should not be used repeatedly on large arrays,\n *          because the function is O(n).\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaReplicatePattern",
      "comment" : "/*!\n *  ptaReplicatePattern()\n *\n *      Input:  ptas (\"sparse\" input pta)\n *              pixp (<optional> 1 bpp pattern, to be replicated in output pta)\n *              ptap (<optional> set of pts, to be replicated in output pta)\n *              cx, cy (reference point in pattern)\n *              w, h (clipping sizes for output pta)\n *      Return: ptad (with all points of replicated pattern), or null on error\n *\n *  Notes:\n *      (1) You can use either the image @pixp or the set of pts @ptap.\n *      (2) The pattern is placed with its reference point at each point\n *          in ptas, and all the fg pixels are colleced into ptad.\n *          For @pixp, this is equivalent to blitting pixp at each point\n *          in ptas, and then converting the resulting pix to a pta.\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "ptaReverse",
      "comment" : "/*!\n *  ptaReverse()\n *\n *      Input:  ptas\n *              type  (0 for float values; 1 for integer values)\n *      Return: ptad (reversed pta), or null on error\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "ptaRotate",
      "comment" : "/*!\n *  ptaRotate()\n *\n *      Input:  ptas (for initial points)\n *              (xc, yc)  (location of center of rotation)\n *              angle  (rotation in radians; clockwise is positive)\n *              (&ptad)  (<return> new locations)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes;\n *      (1) See createMatrix2dScale() for details of transform.\n */",
      "file" : "affinecompose.c"
   },
   {
      "function" : "ptaScale",
      "comment" : "/*!\n *  ptaScale()\n *\n *      Input:  ptas (for initial points)\n *              scalex  (horizontal scale factor)\n *              scaley  (vertical scale factor)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes;\n *      (1) See createMatrix2dScale() for details of transform.\n */",
      "file" : "affinecompose.c"
   },
   {
      "function" : "ptaSetPt",
      "comment" : "/*!\n *  ptaSetPt()\n *\n *      Input:  pta\n *              index  (into arrays)\n *              x, y\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaSort",
      "comment" : "/*!\n *  ptaSort()\n *\n *      Input:  ptas\n *              sorttype (L_SORT_BY_X, L_SORT_BY_Y)\n *              sortorder  (L_SORT_INCREASING, L_SORT_DECREASING)\n *              &naindex (<optional return> index of sorted order into\n *                        original array)\n *      Return: ptad (sorted version of ptas), or null on error\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "ptaSortByIndex",
      "comment" : "/*!\n *  ptaSortByIndex()\n *\n *      Input:  ptas\n *              naindex (na that maps from the new pta to the input pta)\n *      Return: ptad (sorted), or null on  error\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "ptaSubsample",
      "comment" : "/*!\n *  ptaSubsample()\n *\n *      Input:  ptas\n *              subfactor (subsample factor, >= 1)\n *      Return: ptad (evenly sampled pt values from ptas, or null on error\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "ptaTestIntersection",
      "comment" : "/*!\n *  ptaTestIntersection()\n *\n *      Input:  pta1, pta2\n *      Return: bval which is 1 if they have any elements in common;\n *              0 otherwise or on error.\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "ptaTransform",
      "comment" : "/*!\n *  ptaTransform()\n *\n *      Input:  pta\n *              shiftx, shifty\n *              scalex, scaley\n *      Return: pta, or null on error\n *\n *  Notes:\n *      (1) Shift first, then scale.\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "ptaTranslate",
      "comment" : "/*!\n *  ptaTranslate()\n *\n *      Input:  ptas (for initial points)\n *              transx  (x component of translation wrt. the origin)\n *              transy  (y component of translation wrt. the origin)\n *      Return: ptad  (translated points), or null on error\n *\n *  Notes;\n *      (1) See createMatrix2dTranslate() for details of transform.\n */",
      "file" : "affinecompose.c"
   },
   {
      "function" : "ptaTranspose",
      "comment" : "/*!\n *  ptaTranspose()\n *\n *      Input:  ptas\n *      Return: ptad (with x and y values swapped), or null on error\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "ptaWrite",
      "comment" : "/*!\n *  ptaWrite()\n *\n *      Input:  filename\n *              pta\n *              type  (0 for float values; 1 for integer values)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaWriteStream",
      "comment" : "/*!\n *  ptaWriteStream()\n *\n *      Input:  stream\n *              pta\n *              type  (0 for float values; 1 for integer values)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaaAddPt",
      "comment" : "/*!\n *  ptaaAddPt()\n *\n *      Input:  ptaa\n *              ipta  (to the i-th pta)\n *              x,y (point coordinates)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaaAddPta",
      "comment" : "/*!\n *  ptaaAddPta()\n *\n *      Input:  ptaa\n *              pta  (to be added)\n *              copyflag  (L_INSERT, L_COPY, L_CLONE)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaaCreate",
      "comment" : "/*!\n *  ptaaCreate()\n *\n *      Input:  n  (initial number of ptrs)\n *      Return: ptaa, or null on error\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaaDestroy",
      "comment" : "/*!\n *  ptaaDestroy()\n *\n *      Input:  &ptaa <to be nulled>\n *      Return: void\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaaExtendArray",
      "comment" : "/*!\n *  ptaaExtendArray()\n *\n *      Input:  ptaa\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaaGetBoundaryPixels",
      "comment" : "/*!\n *  ptaaGetBoundaryPixels()\n *\n *      Input:  pixs (1 bpp)\n *              type (L_BOUNDARY_FG, L_BOUNDARY_BG)\n *              connectivity (4 or 8)\n *              &boxa (<optional return> bounding boxes of the c.c.)\n *              &pixa (<optional return> pixa of the c.c.)\n *      Return: ptaa, or null on error\n *\n *  Notes:\n *      (1) This generates a ptaa of either fg or bg boundary pixels,\n *          where each pta has the boundary pixels for a connected\n *          component.\n *      (2) We can't simply find all the boundary pixels and then select\n *          those within the bounding box of each component, because\n *          bounding boxes can overlap.  It is necessary to extract and\n *          dilate or erode each component separately.  Note also that\n *          special handling is required for bg pixels when the\n *          component touches the pix boundary.\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "ptaaGetCount",
      "comment" : "/*!\n *  ptaaGetCount()\n *\n *      Input:  ptaa\n *      Return: count, or 0 if no ptaa\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaaGetPt",
      "comment" : "/*!\n *  ptaaGetPt()\n *\n *      Input:  ptaa\n *              ipta  (to the i-th pta)\n *              jpt (index to the j-th pt in the pta)\n *              &x (<optional return> float x value)\n *              &y (<optional return> float y value)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaaGetPta",
      "comment" : "/*!\n *  ptaaGetPta()\n *\n *      Input:  ptaa\n *              index  (to the i-th pta)\n *              accessflag  (L_COPY or L_CLONE)\n *      Return: pta, or null on error\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaaInitFull",
      "comment" : "/*!\n *  ptaaInitFull()\n *\n *      Input:  ptaa (can have non-null ptrs in the ptr array)\n *              pta (to be replicated into the entire ptr array)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaaJoin",
      "comment" : "/*!\n *  ptaaJoin()\n *\n *      Input:  ptaad  (dest ptaa; add to this one)\n *              ptaas  (source ptaa; add from this one)\n *              istart  (starting index in ptaas)\n *              iend  (ending index in ptaas; use -1 to cat all)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) istart < 0 is taken to mean 'read from the start' (istart = 0)\n *      (2) iend < 0 means 'read to the end'\n *      (3) if ptas == NULL, this is a no-op\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "ptaaRead",
      "comment" : "/*!\n *  ptaaRead()\n *\n *      Input:  filename\n *      Return: ptaa, or null on error\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaaReadStream",
      "comment" : "/*!\n *  ptaaReadStream()\n *\n *      Input:  stream\n *      Return: ptaa, or null on error\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaaReplacePta",
      "comment" : "/*!\n *  ptaaReplacePta()\n *\n *      Input:  ptaa\n *              index  (to the index-th pta)\n *              pta (insert and replace any existing one)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Any existing pta is destroyed, and the input one\n *          is inserted in its place.\n *      (2) If the index is invalid, return 1 (error)\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaaSortByIndex",
      "comment" : "/*!\n *  ptaaSortByIndex()\n *\n *      Input:  ptaas\n *              naindex (na that maps from the new ptaa to the input ptaa)\n *      Return: ptaad (sorted), or null on error\n */",
      "file" : "ptafunc1.c"
   },
   {
      "function" : "ptaaTruncate",
      "comment" : "/*!\n *  ptaaTruncate()\n *\n *      Input:  ptaa\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This identifies the largest index containing a pta that\n *          has any points within it, destroys all pta above that index,\n *          and resets the count.\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaaWrite",
      "comment" : "/*!\n *  ptaaWrite()\n *\n *      Input:  filename\n *              ptaa\n *              type  (0 for float values; 1 for integer values)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptaaWriteStream",
      "comment" : "/*!\n *  ptaaWriteStream()\n *\n *      Input:  stream\n *              ptaa\n *              type  (0 for float values; 1 for integer values)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "ptabasic.c"
   },
   {
      "function" : "ptraAdd",
      "comment" : "/*!\n *  ptraAdd()\n *\n *      Input:  ptra\n *              item  (generic ptr to a struct)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This adds the element to the next location beyond imax,\n *          which is the largest occupied ptr in the array.  This is\n *          what you expect from a stack, where all ptrs up to and\n *          including imax are occupied, but here the occuption of\n *          items in the array is entirely arbitrary.\n */",
      "file" : "ptra.c"
   },
   {
      "function" : "ptraCompactArray",
      "comment" : "/*!\n *  ptraCompactArray()\n *\n *      Input:  ptra\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This compacts the items on the array, filling any empty ptrs.\n *      (2) This does not change the size of the array of ptrs.\n */",
      "file" : "ptra.c"
   },
   {
      "function" : "ptraConcatenatePdf",
      "comment" : "/*!\n *  ptraConcatenatePdf()\n *\n *      Input:  ptra (array of pdf strings, each for a single-page pdf file)\n *              fileout (concatenated pdf file)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This only works with leptonica-formatted single-page pdf files.\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "ptraConcatenatePdfToData",
      "comment" : "/*!\n *  ptraConcatenatePdfToData()\n *\n *      Input:  ptra (array of pdf strings, each for a single-page pdf file)\n *              sarray (<optional> of pathnames for input pdf files)\n *              &data (<return> concatenated pdf data in memory)\n *              &nbytes (<return> number of bytes in pdf data)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This only works with leptonica-formatted single-page pdf files.\n *          pdf files generated by other programs will have unpredictable\n *          (and usually bad) results.  The requirements for each pdf file:\n *            (a) The Catalog and Info objects are the first two.\n *            (b) Object 3 is Pages\n *            (c) Object 4 is Page\n *            (d) The remaining objects are Contents, XObjects, and ColorSpace\n *      (2) We remove trailers from each page, and append the full trailer\n *          for all pages at the end.\n *      (3) For all but the first file, remove the ID and the first 3\n *          objects (catalog, info, pages), so that each subsequent\n *          file has only objects of these classes:\n *              Page, Contents, XObject, ColorSpace (Indexed RGB).\n *          For those objects, we substitute these refs to objects\n *          in the local file:\n *              Page:  Parent(object 3), Contents, XObject(typically multiple)\n *              XObject:  [ColorSpace if indexed]\n *          The Pages object on the first page (object 3) has a Kids array\n *          of references to all the Page objects, with a Count equal\n *          to the number of pages.  Each Page object refers back to\n *          this parent.\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "ptraCreate",
      "comment" : "/*!\n *  ptraCreate()\n *\n *      Input:  size of ptr array to be alloc'd (0 for default)\n *      Return: pa, or null on error\n */",
      "file" : "ptra.c"
   },
   {
      "function" : "ptraDestroy",
      "comment" : "/*!\n *  ptraDestroy()\n *\n *      Input:  &ptra (<to be nulled>)\n *              freeflag (TRUE to free each remaining item in the array)\n *              warnflag (TRUE to warn if any remaining items are not destroyed)\n *      Return: void\n *\n *  Notes:\n *      (1) If @freeflag == TRUE, frees each item in the array.\n *      (2) If @freeflag == FALSE and warnflag == TRUE, and there are\n *          items on the array, this gives a warning and destroys the array.\n *          If these items are not owned elsewhere, this will cause\n *          a memory leak of all the items that were on the array.\n *          So if the items are not owned elsewhere and require their\n *          own destroy function, they must be destroyed before the ptra.\n *      (3) If warnflag == FALSE, no warnings will be issued.  This is\n *          useful if the items are owned elsewhere, such as a\n *          PixMemoryStore().\n *      (4) To destroy the ptra, we destroy the ptr array, then\n *          the ptra, and then null the contents of the input ptr.\n */",
      "file" : "ptra.c"
   },
   {
      "function" : "ptraExtendArray",
      "comment" : "/*!\n *  ptraExtendArray()\n *\n *      Input:  ptra\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "ptra.c"
   },
   {
      "function" : "ptraGetActualCount",
      "comment" : "/*!\n *  ptraGetActualCount()\n *\n *      Input:  ptra\n *              &count (<return> actual number of items on the ptr array)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) The actual number of items on the ptr array, pa->nactual,\n *          will be smaller than pa->n if the array is not compacted.\n */",
      "file" : "ptra.c"
   },
   {
      "function" : "ptraGetMaxIndex",
      "comment" : "/*!\n *  ptraGetMaxIndex()\n *\n *      Input:  ptra\n *              &maxindex (<return> index of last item in the array);\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) The largest index to an item in the array is @maxindex.\n *          @maxindex is one less than the number of items that would be\n *          in the array if there were no null pointers between 0\n *          and @maxindex - 1.  However, because the internal ptr array\n *          need not be compacted, there may be null pointers at\n *          indices below @maxindex; for example, if items have\n *          been removed.\n *      (2) When an item is added to the end of the array, it goes\n *          into pa->array[maxindex + 1], and maxindex is then\n *          incremented by 1.\n *      (3) If there are no items in the array, this returns @maxindex = -1.\n */",
      "file" : "ptra.c"
   },
   {
      "function" : "ptraGetPtrToItem",
      "comment" : "/*!\n *  ptraGetPtrToItem()\n *\n *      Input:  ptra\n *              index (of element to be retrieved)\n *      Return: a ptr to the element, or null on error\n *\n *  Notes:\n *      (1) This returns a ptr to the item.  You must cast it to\n *          the type of item.  Do not destroy it; the item belongs\n *          to the Ptra.\n *      (2) This can access all possible items on the ptr array.\n *          If an item doesn't exist, it returns null.\n */",
      "file" : "ptra.c"
   },
   {
      "function" : "ptraInsert",
      "comment" : "/*!\n *  ptraInsert()\n *\n *      Input:  ptra\n *              index (location in ptra to insert new value)\n *              item  (generic ptr to a struct; can be null)\n *              shiftflag (L_AUTO_DOWNSHIFT, L_MIN_DOWNSHIFT, L_FULL_DOWNSHIFT)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This checks first to see if the location is valid, and\n *          then if there is presently an item there.  If there is not,\n *          it is simply inserted into that location.\n *      (2) If there is an item at the insert location, items must be\n *          moved down to make room for the insert.  In the downward\n *          shift there are three options, given by @shiftflag.\n *            - If @shiftflag == L_AUTO_DOWNSHIFT, a decision is made\n *              whether, in a cascade of items, to downshift a minimum\n *              amount or for all items above @index.  The decision is\n *              based on the expectation of finding holes (null ptrs)\n *              between @index and the bottom of the array.\n *              Assuming the holes are distributed uniformly, if 2 or more\n *              holes are expected, we do a minimum shift.\n *            - If @shiftflag == L_MIN_DOWNSHIFT, the downward shifting\n *              cascade of items progresses a minimum amount, until\n *              the first empty slot is reached.  This mode requires\n *              some computation before the actual shifting is done.\n *            - If @shiftflag == L_FULL_DOWNSHIFT, a shifting cascade is\n *              performed where pa[i] --> pa[i + 1] for all i >= index.\n *              Then, the item is inserted at pa[index].\n *      (3) If you are not using L_AUTO_DOWNSHIFT, the rule of thumb is\n *          to use L_FULL_DOWNSHIFT if the array is compacted (each\n *          element points to an item), and to use L_MIN_DOWNSHIFT\n *          if there are a significant number of null pointers.\n *          There is no penalty to using L_MIN_DOWNSHIFT for a\n *          compacted array, however, because the full shift is required\n *          and we don't do the O(n) computation to look for holes.\n *      (4) This should not be used repeatedly on large arrays,\n *          because the function is generally O(n).\n *      (5) However, it can be used repeatedly if we start with an empty\n *          ptr array and insert only once at each location.  For example,\n *          you can support an array of Numa, where at each ptr location\n *          you store either 0 or 1 Numa, and the Numa can be added\n *          randomly to the ptr array.\n */",
      "file" : "ptra.c"
   },
   {
      "function" : "ptraJoin",
      "comment" : "/*!\n *  ptraJoin()\n *\n *      Input:  ptra1 (add to this one)\n *              ptra2 (appended to ptra1, and emptied of items; can be null)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "ptra.c"
   },
   {
      "function" : "ptraRemove",
      "comment" : "/*!\n *  ptraRemove()\n *\n *      Input:  ptra\n *              index (element to be removed)\n *              flag (L_NO_COMPACTION, L_COMPACTION)\n *      Return: item, or null on error\n *\n *  Notes:\n *      (1) If flag == L_NO_COMPACTION, this removes the item and\n *          nulls the ptr on the array.  If it takes the last item\n *          in the array, pa->n is reduced to the next item.\n *      (2) If flag == L_COMPACTION, this compacts the array for\n *          for all i >= index.  It should not be used repeatedly on\n *          large arrays, because compaction is O(n).\n *      (3) The ability to remove without automatic compaction allows\n *          removal with cost O(1).\n */",
      "file" : "ptra.c"
   },
   {
      "function" : "ptraRemoveLast",
      "comment" : "/*!\n *  ptraRemoveLast()\n *\n *      Input:  ptra\n *      Return: item, or null on error or if the array is empty\n */",
      "file" : "ptra.c"
   },
   {
      "function" : "ptraReplace",
      "comment" : "/*!\n *  ptraReplace()\n *\n *      Input:  ptra\n *              index (element to be replaced)\n *              item  (new generic ptr to a struct; can be null)\n *              freeflag (TRUE to free old item; FALSE to return it)\n *      Return: item  (old item, if it exists and is not freed),\n *                     or null on error\n */",
      "file" : "ptra.c"
   },
   {
      "function" : "ptraReverse",
      "comment" : "/*!\n *  ptraReverse()\n *\n *      Input:  ptra\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "ptra.c"
   },
   {
      "function" : "ptraSwap",
      "comment" : "/*!\n *  ptraSwap()\n *\n *      Input:  ptra\n *              index1\n *              index2\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "ptra.c"
   },
   {
      "function" : "ptraaCreate",
      "comment" : "/*!\n *  ptraaCreate()\n *\n *      Input:  size of ptr array to be alloc'd\n *      Return: paa, or null on error\n *\n *  Notes:\n *      (1) The ptraa is generated with a fixed size, that can not change.\n *          The ptra can be generated and inserted randomly into this array.\n */",
      "file" : "ptra.c"
   },
   {
      "function" : "ptraaDestroy",
      "comment" : "/*!\n *  ptraaDestroy()\n *\n *      Input:  &paa (<to be nulled>)\n *              freeflag (TRUE to free each remaining item in each ptra)\n *              warnflag (TRUE to warn if any remaining items are not destroyed)\n *      Return: void\n *\n *  Notes:\n *      (1) See ptraDestroy() for use of @freeflag and @warnflag.\n *      (2) To destroy the ptraa, we destroy each ptra, then the ptr array,\n *          then the ptraa, and then null the contents of the input ptr.\n */",
      "file" : "ptra.c"
   },
   {
      "function" : "ptraaFlattenToPtra",
      "comment" : "/*!\n *  ptraaFlattenToPtra()\n *\n *      Input:  ptraa\n *      Return: ptra, or null on error\n *\n *  Notes:\n *      (1) This 'flattens' the ptraa to a ptra, taking the items in\n *          each ptra, in order, starting with the first ptra, etc.\n *      (2) As a side-effect, the ptra are all removed from the ptraa\n *          and destroyed, leaving an empty ptraa.\n */",
      "file" : "ptra.c"
   },
   {
      "function" : "ptraaGetPtra",
      "comment" : "/*!\n *  ptraaGetPtra()\n *\n *      Input:  ptraa\n *              index (location in array)\n *              accessflag (L_HANDLE_ONLY, L_REMOVE)\n *      Return: ptra (at index location), or NULL on error or if there\n *              is no ptra there.\n *\n *  Notes:\n *      (1) This returns the ptra ptr.  If @accessflag == L_HANDLE_ONLY,\n *          the ptra is left on the ptraa.  If @accessflag == L_REMOVE,\n *          the ptr in the ptraa is set to NULL, and the caller\n *          is responsible for disposing of the ptra (either putting it\n *          back on the ptraa, or destroying it).\n *      (2) This returns NULL if there is no Ptra at the index location.\n */",
      "file" : "ptra.c"
   },
   {
      "function" : "ptraaGetSize",
      "comment" : "/*!\n *  ptraaGetSize()\n *\n *      Input:  ptraa\n *              &size (<return> size of ptr array)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "ptra.c"
   },
   {
      "function" : "ptraaInsertPtra",
      "comment" : "/*!\n *  ptraaInsertPtra()\n *\n *      Input:  ptraa\n *              index (location in array for insertion)\n *              ptra (to be inserted)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) Caller should check return value.  On success, the Ptra\n *          is inserted in the Ptraa and is owned by it.  However,\n *          on error, the Ptra remains owned by the caller.\n */",
      "file" : "ptra.c"
   },
   {
      "function" : "pushFillseg",
      "comment" : "/*!\n *  pushFillseg()\n *\n *      Input:  stack\n *              xleft, xright\n *              y\n *              dy\n *              ymax\n *      Return: void\n *\n *  Notes:\n *      (1) This adds a line segment to the stack.\n *      (2) The auxiliary stack is used as a storage area to recycle\n *          fillsegs that are no longer in use.  We only calloc new\n *          fillsegs if the auxiliary stack is empty.\n */",
      "file" : "conncomp.c"
   },
   {
      "function" : "pushFillsegBB",
      "comment" : "/*!\n *  pushFillsegBB()\n *\n *      Input:  stack\n *              xleft, xright\n *              y\n *              dy\n *              ymax,\n *              &minx (<return>)\n *              &maxx (<return>)\n *              &miny (<return>)\n *              &maxy (<return>)\n *      Return: void\n *\n *  Notes:\n *      (1) This adds a line segment to the stack, and returns its size.\n *      (2) The auxiliary stack is used as a storage area to recycle\n *          fillsegs that are no longer in use.  We only calloc new\n *          fillsegs if the auxiliary stack is empty.\n */",
      "file" : "conncomp.c"
   },
   {
      "function" : "pushNewPixel",
      "comment" : "/*\n *  pushNewPixel()\n *\n *      Input:  lqueue\n *              x, y   (pixel coordinates)\n *              &minx, &maxx, &miny, &maxy  (<return> bounding box update)\n *      Return: void\n *\n *  Notes:\n *      (1) This is a wrapper for adding a NewPixel to a queue, which\n *          updates the bounding box for all pixels on that queue and\n *          uses the storage stack to retrieve a NewPixel.\n */",
      "file" : "watershed.c"
   },
   {
      "function" : "pushWSPixel",
      "comment" : "/*\n *  pushWSPixel()\n *\n *      Input:  lh  (priority queue)\n *              stack  (of reusable WSPixels)\n *              val  (pixel value: used for ordering the heap)\n *              x, y  (pixel coordinates)\n *              index  (label for set to which pixel belongs)\n *      Return: void\n *\n *  Notes:\n *      (1) This is a wrapper for adding a WSPixel to a heap.  It\n *          uses the storage stack to retrieve a WSPixel.\n */",
      "file" : "watershed.c"
   },
   {
      "function" : "quadtreeGetChildren",
      "comment" : "/*!\n *  quadtreeGetChildren()\n *\n *      Input:  fpixa (mean, variance or root variance)\n *              level, x, y (of current pixel)\n *              &val00, val01, val10, val11  (<return> child pixel values)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Check return value for error.  On error, all return vals are 0.0.\n *      (2) The returned child pixels are located at:\n *             level + 1\n *             (2x, 2y), (2x+1, 2y), (2x, 2y+1), (2x+1, 2y+1)\n */",
      "file" : "quadtree.c"
   },
   {
      "function" : "quadtreeGetParent",
      "comment" : "/*!\n *  quadtreeGetParent()\n *\n *      Input:  fpixa (mean, variance or root variance)\n *              level, x, y (of current pixel)\n *              &val (<return> parent pixel value), or 0.0 on error.\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Check return value for error.  On error, val is returned as 0.0.\n *      (2) The parent is located at:\n *             level - 1\n *             (x/2, y/2)\n */",
      "file" : "quadtree.c"
   },
   {
      "function" : "quadtreeMaxLevels",
      "comment" : "/*!\n *  quadtreeMaxLevels()\n *\n *      Input:  w, h (of image)\n *      Return: maxlevels (maximum number of levels allowed), or -1 on error\n *\n *  Notes:\n *      (1) The criterion for maxlevels is that the subdivision not\n *          go down below the single pixel level.  The 1.5 factor\n *          is intended to keep any rectangle from accidentally\n *          having zero dimension due to integer truncation.\n */",
      "file" : "quadtree.c"
   },
   {
      "function" : "rasteropGeneralLow",
      "comment" : "/*!\n *  rasteropGeneralLow()\n *\n *      Input:  datad  (ptr to dest image data)\n *              dwpl   (wpl of dest)\n *              dx     (x val of UL corner of dest rectangle)\n *              dy     (y val of UL corner of dest rectangle)\n *              dw     (width of dest rectangle)\n *              dh     (height of dest rectangle)\n *              op     (op code)\n *              datas  (ptr to src image data)\n *              swpl   (wpl of src)\n *              sx     (x val of UL corner of src rectangle)\n *              sy     (y val of UL corner of src rectangle)\n *      Return: void\n *\n *  This is called when the src and dest rects are\n *  do not have the same (32-bit) word alignment.\n *\n *  The method is a generalization of rasteropVAlignLow().\n *  There, the src image pieces were directly merged\n *  with the dest.  Here, we shift the source bits\n *  to fill words that are aligned with the dest, and\n *  then use those \"source words\" exactly in place\n *  of the source words that were used in rasteropVAlignLow().\n *\n *  The critical parameter is thus the shift required\n *  for the src.  Consider the left edge of the rectangle.\n *  The overhang into the src and dest words are found,\n *  and the difference is exactly this shift.  There are\n *  two separate cases, depending on whether the src pixels\n *  are shifted left or right.  If the src overhang is\n *  larger than the dest overhang, the src is shifted to\n *  the right, a number of pixels equal to the shift are\n *  left over for filling the next dest word, if necessary.\n *  But if the dest overhang is larger than the src,\n *  the src is shifted to the left, and it may also be\n *  necessary to shift an equal number of pixels in from\n *  the next src word.  However, in both cases, after\n *  the first partial (or complete) dest word has been\n *  filled, the next src pixels will come from a left\n *  shift that exhausts the pixels in the src word.\n */",
      "file" : "roplow.c"
   },
   {
      "function" : "rasteropHipLow",
      "comment" : "/*!\n *  rasteropHipLow()\n *\n *      Input:  data   (ptr to image data)\n *              pixh   (height)\n *              depth  (depth)\n *              wpl    (wpl)\n *              y      (y val of UL corner of rectangle)\n *              h      (height of rectangle)\n *              shift  (+ shifts data to the left in a horizontal column)\n *      Return: 0 if OK; 1 on error.\n *\n *  Notes:\n *      (1) This clears the pixels that are left exposed after the rasterop.\n *          Therefore, for Pix with depth > 1, these pixels become black,\n *          and must be subsequently SET if they are to be white.\n *          For example, see pixRasteropHip().\n *      (2) This function performs clipping and calls shiftDataHorizontalLine()\n *          to do the in-place rasterop on each line.\n */",
      "file" : "ropiplow.c"
   },
   {
      "function" : "rasteropLow",
      "comment" : "/*!\n *  rasteropLow()\n *\n *      Input:  datad  (ptr to dest image data)\n *              dpixw  (width of dest)\n *              dpixh  (height of dest)\n *              depth  (depth of src and dest)\n *              dwpl   (wpl of dest)\n *              dx     (x val of UL corner of dest rectangle)\n *              dy     (y val of UL corner of dest rectangle)\n *              dw     (width of dest rectangle)\n *              dh     (height of dest rectangle)\n *              op     (op code)\n *              datas  (ptr to src image data)\n *              spixw  (width of src)\n *              spixh  (height of src)\n *              swpl   (wpl of src)\n *              sx     (x val of UL corner of src rectangle)\n *              sy     (y val of UL corner of src rectangle)\n *      Return: void\n *\n *  Action: Scales width, performs clipping, checks alignment, and\n *          dispatches for the rasterop.\n *\n *  Warning: the two images must have equal depth.  This is not checked.\n */",
      "file" : "roplow.c"
   },
   {
      "function" : "rasteropUniGeneralLow",
      "comment" : "/*!\n *  rasteropUniGeneralLow()\n *\n *      Input:  datad  (ptr to dest image data)\n *              dwpl   (wpl of dest)\n *              dx     (x val of UL corner of dest rectangle)\n *              dy     (y val of UL corner of dest rectangle)\n *              dw     (width of dest rectangle)\n *              dh     (height of dest rectangle)\n *              op     (op code)\n *      Return: void\n */",
      "file" : "roplow.c"
   },
   {
      "function" : "rasteropUniLow",
      "comment" : "/*!\n *  rasteropUniLow()\n *\n *      Input:  datad  (ptr to dest image data)\n *              dpixw  (width of dest)\n *              dpixh  (height of dest)\n *              depth  (depth of src and dest)\n *              dwpl   (wpl of dest)\n *              dx     (x val of UL corner of dest rectangle)\n *              dy     (y val of UL corner of dest rectangle)\n *              dw     (width of dest rectangle)\n *              dh     (height of dest rectangle)\n *              op     (op code)\n *      Return: void\n *\n *  Action: scales width, performs clipping, checks alignment, and\n *          dispatches for the rasterop.\n */",
      "file" : "roplow.c"
   },
   {
      "function" : "rasteropUniWordAlignedLow",
      "comment" : "/*!\n *  rasteropUniWordAlignedLow()\n *\n *      Input:  datad  (ptr to dest image data)\n *              dwpl   (wpl of dest)\n *              dx     (x val of UL corner of dest rectangle)\n *              dy     (y val of UL corner of dest rectangle)\n *              dw     (width of dest rectangle)\n *              dh     (height of dest rectangle)\n *              op     (op code)\n *      Return: void\n *\n *  This is called when the dest rect is left aligned\n *  on (32-bit) word boundaries.   That is: dx & 31 == 0.\n *\n *  We make an optimized implementation of this because\n *  it is a common case: e.g., operating on a full dest image.\n */",
      "file" : "roplow.c"
   },
   {
      "function" : "rasteropVAlignedLow",
      "comment" : "/*!\n *  rasteropVAlignedLow()\n *\n *      Input:  datad  (ptr to dest image data)\n *              dwpl   (wpl of dest)\n *              dx     (x val of UL corner of dest rectangle)\n *              dy     (y val of UL corner of dest rectangle)\n *              dw     (width of dest rectangle)\n *              dh     (height of dest rectangle)\n *              op     (op code)\n *              datas  (ptr to src image data)\n *              swpl   (wpl of src)\n *              sx     (x val of UL corner of src rectangle)\n *              sy     (y val of UL corner of src rectangle)\n *      Return: void\n *\n *  This is called when the left side of the src and dest\n *  rects have the same alignment relative to (32-bit) word\n *  boundaries; i.e., (dx & 31) == (sx & 31)\n */",
      "file" : "roplow.c"
   },
   {
      "function" : "rasteropVipLow",
      "comment" : "/*!\n *  rasteropVipLow()\n *\n *      Input:  data   (ptr to image data)\n *              pixw   (width)\n *              pixh   (height)\n *              depth  (depth)\n *              wpl    (wpl)\n *              x      (x val of UL corner of rectangle)\n *              w      (width of rectangle)\n *              shift  (+ shifts data downward in vertical column)\n *      Return: 0 if OK; 1 on error.\n *\n *  Notes:\n *      (1) This clears the pixels that are left exposed after the\n *          translation.  You can consider them as pixels that are\n *          shifted in from outside the image.  This can be later\n *          overridden by the incolor parameter in higher-level functions\n *          that call this.  For example, for images with depth > 1,\n *          these pixels are cleared to black; to be white they\n *          must later be SET to white.  See, e.g., pixRasteropVip().\n *      (2) This function scales the width to accommodate any depth,\n *          performs clipping, and then does the in-place rasterop.\n */",
      "file" : "ropiplow.c"
   },
   {
      "function" : "rasteropWordAlignedLow",
      "comment" : "/*!\n *  rasteropWordAlignedLow()\n *\n *      Input:  datad  (ptr to dest image data)\n *              dwpl   (wpl of dest)\n *              dx     (x val of UL corner of dest rectangle)\n *              dy     (y val of UL corner of dest rectangle)\n *              dw     (width of dest rectangle)\n *              dh     (height of dest rectangle)\n *              op     (op code)\n *              datas  (ptr to src image data)\n *              swpl   (wpl of src)\n *              sx     (x val of UL corner of src rectangle)\n *              sy     (y val of UL corner of src rectangle)\n *      Return: void\n *\n *  This is called when both the src and dest rects\n *  are left aligned on (32-bit) word boundaries.\n *  That is: dx & 31 == 0 and sx & 31 == 0\n *\n *  We make an optimized implementation of this because\n *  it is a common case: e.g., two images are rasterop'd\n *  starting from their UL corners (0,0).\n */",
      "file" : "roplow.c"
   },
   {
      "function" : "rchCreate",
      "comment" : "/*!\n *  rchCreate()\n *\n *      Input:  index (index of best template)\n *              score (correlation score of best template)\n *              text (character string of best template)\n *              sample (index of best sample; -1 if averages are used)\n *              xloc (x-location of template: delx + shiftx)\n *              yloc (y-location of template: dely + shifty)\n *              width (width of best template)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Be sure to destroy any existing rch before assigning this.\n */",
      "file" : "recogident.c"
   },
   {
      "function" : "rchDestroy",
      "comment" : "/*!\n *  rchDestroy()\n *\n *      Input:  &rch\n *      Return: void\n */",
      "file" : "recogident.c"
   },
   {
      "function" : "rchExtract",
      "comment" : "/*!\n *  rchExtract()\n *\n *      Input:  rch\n *              &index (<optional return> index of best template)\n *              &score (<optional return> correlation score of best template)\n *              &text (<optional return> character string of best template)\n *              &sample (<optional return> index of best sample)\n *              &xloc (<optional return> x-location of template)\n *              &yloc (<optional return> y-location of template)\n *              &width (<optional return> width of best template)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "recogident.c"
   },
   {
      "function" : "rchaCreate",
      "comment" : "/*!\n *  rchaCreate()\n *\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Be sure to destroy any existing rcha before assigning this.\n */",
      "file" : "recogident.c"
   },
   {
      "function" : "rchaDestroy",
      "comment" : "/*!\n *  rchaDestroy()\n *\n *      Input:  &rcha\n *      Return: void\n */",
      "file" : "recogident.c"
   },
   {
      "function" : "rchaExtract",
      "comment" : "/*!\n *  rchaExtract()\n *\n *      Input:  rcha\n *              &naindex (<optional return> indices of best templates)\n *              &nascore (<optional return> correl scores of best templates)\n *              &satext (<optional return> character strings of best templates)\n *              &nasample (<optional return> indices of best samples)\n *              &naxloc (<optional return> x-locations of templates)\n *              &nayloc (<optional return> y-locations of templates)\n *              &nawidth (<optional return> widths of best templates)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This returns clones of the number and string arrays.  They must\n *          be destroyed by the caller.\n */",
      "file" : "recogident.c"
   },
   {
      "function" : "readHeaderJp2k",
      "comment" : "/*!\n *  readHeaderJp2k()\n *\n *      Input:  filename\n *              &w (<optional return>)\n *              &h (<optional return>)\n *              &spp (<optional return>, samples/pixel)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "jp2kio.c"
   },
   {
      "function" : "readHeaderJpeg",
      "comment" : "/*!\n *  readHeaderJpeg()\n *\n *      Input:  filename\n *              &w (<optional return>)\n *              &h (<optional return>)\n *              &spp (<optional return>, samples/pixel)\n *              &ycck (<optional return>, 1 if ycck color space; 0 otherwise)\n *              &cmyk (<optional return>, 1 if cmyk color space; 0 otherwise)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "jpegio.c"
   },
   {
      "function" : "readHeaderMemJpeg",
      "comment" : "/*!\n *  readHeaderMemJpeg()\n *\n *      Input:  cdata (const; jpeg-encoded)\n *              size (of data)\n *              &w (<optional return>)\n *              &h (<optional return>)\n *              &spp (<optional return>, samples/pixel)\n *              &ycck (<optional return>, 1 if ycck color space; 0 otherwise)\n *              &cmyk (<optional return>, 1 if cmyk color space; 0 otherwise)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "jpegio.c"
   },
   {
      "function" : "readHeaderMemTiff",
      "comment" : "/*!\n *  readHeaderMemTiff()\n *\n *      Input:  cdata (const; tiff-encoded)\n *              size (size of data)\n *              n (page image number: 0-based)\n *              &width (<return>)\n *              &height (<return>)\n *              &bps (<return> bits per sample -- 1, 2, 4 or 8)\n *              &spp (<return>; samples per pixel -- 1 or 3)\n *              &res (<optional return>; resolution in x dir; NULL to ignore)\n *              &cmap (<optional return>; colormap exists; input NULL to ignore)\n *              &format (<optional return>; tiff format; input NULL to ignore)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Use TIFFClose(); TIFFCleanup() doesn't free internal memstream.\n */",
      "file" : "tiffio.c"
   },
   {
      "function" : "readHeaderPng",
      "comment" : "/*!\n *  readHeaderPng()\n *\n *      Input:  filename\n *              &w (<optional return>)\n *              &h (<optional return>)\n *              &bps (<optional return>, bits/sample)\n *              &spp (<optional return>, samples/pixel)\n *              &iscmap (<optional return>)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If there is a colormap, iscmap is returned as 1; else 0.\n *      (2) For gray+alpha, although the png records bps = 16, we\n *          consider this as two 8 bpp samples (gray and alpha).\n *          When a gray+alpha is read, it is converted to 32 bpp RGBA.\n */",
      "file" : "pngio.c"
   },
   {
      "function" : "readHeaderPnm",
      "comment" : "/*!\n *  readHeaderPnm()\n *\n *      Input:  filename\n *              &w (<optional return>)\n *              &h (<optional return>)\n *              &d (<optional return>)\n *              &type (<optional return> pnm type)\n *              &bps (<optional return>, bits/sample)\n *              &spp (<optional return>, samples/pixel)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pnmio.c"
   },
   {
      "function" : "readHeaderSpix",
      "comment" : "/*!\n *  readHeaderSpix()\n *\n *      Input:  filename\n *              &width (<return>)\n *              &height (<return>)\n *              &bps (<return>, bits/sample)\n *              &spp (<return>, samples/pixel)\n *              &iscmap (<optional return>; input NULL to ignore)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If there is a colormap, iscmap is returned as 1; else 0.\n */",
      "file" : "spixio.c"
   },
   {
      "function" : "readHeaderTiff",
      "comment" : "/*!\n *  readHeaderTiff()\n *\n *      Input:  filename\n *              n (page image number: 0-based)\n *              &width (<return>)\n *              &height (<return>)\n *              &bps (<return> bits per sample -- 1, 2, 4 or 8)\n *              &spp (<return>; samples per pixel -- 1 or 3)\n *              &res (<optional return>; resolution in x dir; NULL to ignore)\n *              &cmap (<optional return>; colormap exists; input NULL to ignore)\n *              &format (<optional return>; tiff format; input NULL to ignore)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If there is a colormap, cmap is returned as 1; else 0.\n *      (2) If @n is equal to or greater than the number of images, returns 1.\n */",
      "file" : "tiffio.c"
   },
   {
      "function" : "readHeaderWebP",
      "comment" : "/*!\n *  readHeaderWebP()\n *\n *      Input:  filename\n *              &w (<return> width)\n *              &h (<return> height)\n *              &spp (<return> spp (3 or 4))\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "webpio.c"
   },
   {
      "function" : "reallocNew",
      "comment" : "/*!\n *  reallocNew()\n *\n *      Input:  &indata (<optional>; nulls indata)\n *              oldsize (size of input data to be copied, in bytes)\n *              newsize (size of data to be reallocated in bytes)\n *      Return: ptr to new data, or null on error\n *\n *  Action: !N.B. (3) and (4)!\n *      (1) Allocates memory, initialized to 0\n *      (2) Copies as much of the input data as possible\n *          to the new block, truncating the copy if necessary\n *      (3) Frees the input data\n *      (4) Zeroes the input data ptr\n *\n *  Notes:\n *      (1) If newsize <=0, just frees input data and nulls ptr\n *      (2) If input ptr is null, just callocs new memory\n *      (3) This differs from realloc in that it always allocates\n *          new memory (if newsize > 0) and initializes it to 0,\n *          it requires the amount of old data to be copied,\n *          and it takes the address of the input ptr and\n *          nulls the handle.\n */",
      "file" : "utils.c"
   },
   {
      "function" : "recogAddAllSamples",
      "comment" : "/*!\n *  recogAddAllSamples()\n *\n *      Input:  recog\n *              paa (pixaa from previously trained recog)\n *              debug\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is used with the serialization routine recogRead(),\n *          where each pixa in the pixaa represents a set of characters\n *          in a different class.  Two different pixa may represent\n *          characters with the same label.  Before calling this\n *          function, we verify that the number of character classes,\n *          given by the setsize field in recog, equals the number of\n *          pixa in the paa.  The character labels for each set are\n *          in the sa_text field.\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "recogAddCharstrLabels",
      "comment" : "/*!\n *  recogAddCharstrLabels()\n *\n *      Input:  filename\n *              recog\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "recogAddSamples",
      "comment" : "/*!\n *  recogAddSamples()\n *\n *      Input:  recog\n *              pixa (1 or more characters)\n *              classindex (use -1 if not forcing into a specified class)\n *              debug\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The pix in the pixa are all 1 bpp, and the character string\n *          labels are embedded in the pix.\n *      (2) Note: this function decides what class each pix belongs in.\n *          When input is from a multifont pixaa, with a valid value\n *          for @classindex, the character string label in each pix\n *          is ignored, and @classindex is used as the class index\n *          for all the pix in the pixa.  Thus, for that situation we\n *          use this class index to avoid making the decision through a\n *          lookup based on the character strings embedded in the pix.\n *      (3) When a recog is initially filled with samples, the pixaa_u\n *          array is initialized to accept up to 256 different classes.\n *          When training is finished, the arrays are truncated to the\n *          actual number of classes.  To pad an existing recog from\n *          the boot recognizers, training is started again; if samples\n *          from a new class are added, the pixaa_u array must be\n *          extended by adding a pixa to hold them.\n */",
      "file" : "recogtrain.c"
   },
   {
      "function" : "recogAppend",
      "comment" : "/*!\n *  recogAppend()\n *\n *      Input:  recog1\n *              recog2 (gets added to recog1)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is used to make a training recognizer from more than\n *          one trained recognizer source.  It should only be used\n *          when the bitmaps for corresponding character classes are\n *          very similar.  That constraint does not arise when\n *          the character classes are disjoint; e.g., if recog1 is\n *          digits and recog2 is alphabetical.\n *      (2) This is done by appending recog2 to recog1.  Averages are\n *          computed for each recognizer, if necessary, before appending.\n *      (3) Non-array fields are combined using the appropriate min and max.\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "recogAverageClassGeom",
      "comment" : "/*!\n *  recogAverageClassGeom()\n *\n *      Input:  recog\n *              &naw (<optional return> average widths for each class)\n *              &nah (<optional return> average heights for each class)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "recogtrain.c"
   },
   {
      "function" : "recogAverageSamples",
      "comment" : "/*!\n *  recogAverageSamples()\n *\n *      Input:  recog\n *              debug\n *      Return: 0 on success, 1 on failure\n *\n *  Notes:\n *      (1) This is called when training is finished, and after\n *          outliers have been removed.\n *          Both unscaled and scaled inputs are averaged.\n *          Averages must be computed before any identification is done.\n *      (2) Set debug = 1 to view the resulting templates\n *          and their centroids.\n */",
      "file" : "recogtrain.c"
   },
   {
      "function" : "recogBestCorrelForPadding",
      "comment" : "/*!\n *  recogBestCorrelForPadding()\n *\n *      Input:  recog (typically the recog to be padded)\n *              recoga (array of recogs for potentially providing the padding)\n *              &naset (<return> of indices into the sets to be matched)\n *              &naindex (<return> of matching indices into the best set)\n *              &nascore (<return> of best correlation scores)\n *              &naave (<return> average of correlation scores from each recog)\n *              &pixadb (<optional return> debug images; use NULL for no debug)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This finds, for each class in recog, the best matching template\n *          in the recoga.  For that best match, it returns:\n *            * the recog set index in the recoga,\n *            * the index in that recog for the class,\n *            * the score for the best match\n *      (2) It also returns in @naave, for each recog in recoga, the\n *          average overall correlation for all averaged templates to\n *          those in the input recog.  The recog with the largest average\n *          can supply templates in cases where the input recog has\n *          no examples.\n *      (3) For classes in recog1 for which no corresponding class\n *          is found in any recog in recoga, the index -1 is stored\n *          in both naset and naindex, and 0.0 is stored in nascore.\n *      (4) Both recog and all the recog in recoga should be generated\n *          with isotropic scaling to the same character height (e.g., 30).\n */",
      "file" : "recogtrain.c"
   },
   {
      "function" : "recogCharsetAvailable",
      "comment" : "/*!\n *  recogCharsetAvailable()\n *\n *      Input:  type (of charset for padding)\n *      Return: 1 if available; 0 if not.\n */",
      "file" : "recogtrain.c"
   },
   {
      "function" : "recogCorrelAverages",
      "comment" : "/*!\n *  recogCorrelAverages()\n *\n *      Input:  recog1 (typically the recog to be padded)\n *              recog2 (potentially providing the padding)\n *              &naindex (<return> of classes in 2 with respect to classes in 1)\n *              &nascore (<return> correlation scores of corresponding classes)\n *              &pixadb (<optional return> debug images)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Use this for potentially padding recog1 with instances in recog2.\n *          The recog have been generated with isotropic scaling to the\n *          same fixed height (e.g., 30).  The training has been \"finished\"\n *          in the sense that all arrays have been computed and they\n *          could potentially be used as they are.  This is necessary\n *          for doing the correlation between scaled images.\n *          However, this function is called when there is a request to\n *          augument some of the examples in classes in recog1.\n *      (2) Iterate over classes in recog1, finding the corresponding\n *          class in recog2 and computing the correlation score between\n *          the average templates of the two.  naindex is a LUT between\n *          the index of a class in recog1 and the corresponding one in recog2.\n *      (3) For classes in recog1 that do not exist in recog2, the index\n *          -1 is stored in naindex, and 0.0 is stored in the score.\n */",
      "file" : "recogtrain.c"
   },
   {
      "function" : "recogCorrelationBestChar",
      "comment" : "/*!\n *  recogCorrelationBestChar()\n *\n *      Input:  recog (with LUT's pre-computed)\n *              pixs (can be of multiple touching characters, 1 bpp)\n *              &box (<return> bounding box of best fit character)\n *              &score (<return> correlation score)\n *              &index (<optional return> index of class)\n *              &charstr (<optional return> character string of class)\n *              &pixdb (<optional return> debug pix showing input and best fit)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Basic matching character splitter.  Finds the best match among\n *          all templates to some region of the image.  This can result\n *          in splitting the image into two parts.  This is \"image decoding\"\n *          without dynamic programming, because we don't use a setwidth\n *          and compute the best matching score for the entire image.\n *      (2) Matching is to the average templates, without character scaling.\n */",
      "file" : "recogident.c"
   },
   {
      "function" : "recogCorrelationBestRow",
      "comment" : "/*!\n *  recogCorrelationBestRow()\n *\n *      Input:  recog (with LUT's pre-computed)\n *              pixs (typically of multiple touching characters, 1 bpp)\n *              &boxa (<return> bounding boxs of best fit character)\n *              &nascores (<optional return> correlation scores)\n *              &naindex (<optional return> indices of classes)\n *              &sachar (<optional return> array of character strings)\n *              debug (1 for results written to pixadb_split)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Supervises character matching for (in general) a c.c with\n *          multiple touching characters.  Finds the best match greedily.\n *          Rejects small parts that are left over after splitting.\n *      (2) Matching is to the average, and without character scaling.\n */",
      "file" : "recogident.c"
   },
   {
      "function" : "recogCreate",
      "comment" : "/*!\n *  recogCreate()\n *\n *      Input:  scalew  (scale all widths to this; use 0 for no scaling)\n *              scaleh  (scale all heights to this; use 0 for no scaling)\n *              templ_type (L_USE_AVERAGE or L_USE_ALL)\n *              threshold (for binarization; typically ~128)\n *              maxyshift (from nominal centroid alignment; typically 0 or 1)\n *              fontdir  (<optional> directory for bitmap fonts for debugging)\n *      Return: recog, or null on error\n *\n *  Notes:\n *      (1) For a set trained on one font, such as numbers in a book,\n *          it is sensible to set scalew = scaleh = 0.\n *      (2) For a mixed training set, scaling to a fixed height,\n *          such as 32 pixels, but leaving the width unscaled, is effective.\n *      (3) The storage for most of the arrays is allocated when training\n *          is finished.\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "recogCreateDid",
      "comment" : "/*!\n *  recogCreateDid()\n *\n *      Input:  recog\n *              pixs (of 1 bpp image to match)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "recogdid.c"
   },
   {
      "function" : "recogCreateFromPixa",
      "comment" : "/*!\n *  recogCreateFromPixa()\n *\n *      Input:  pixa (of labelled, 1 bpp images)\n *              scalew  (scale all widths to this; use 0 for no scaling)\n *              scaleh  (scale all heights to this; use 0 for no scaling)\n *              templ_type (L_USE_AVERAGE or L_USE_ALL)\n *              threshold (for binarization; typically ~128)\n *              maxyshift (from nominal centroid alignment; typically 0 or 1)\n *              fontdir  (<optional> directory for bitmap fonts for debugging)\n *      Return: recog, or null on error\n *\n *  Notes:\n *      (1) This is a convenience function for training from labelled data.\n *          The pixa can be read from file.\n *      (2) The pixa should contain the unscaled bitmaps used for training.\n *      (3) The characters here should work as a single \"font\", because\n *          each image example is put into a class defined by its\n *          character label.  All examples in the same class should be\n *          similar.\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "recogCreateFromRecog",
      "comment" : "/*!\n *  recogCreateFromRecog()\n *\n *      Input:  recs (source recog with arbitrary input parameters)\n *              scalew  (scale all widths to this; use 0 for no scaling)\n *              scaleh  (scale all heights to this; use 0 for no scaling)\n *              templ_type (L_USE_AVERAGE or L_USE_ALL)\n *              threshold (for binarization; typically ~128)\n *              maxyshift (from nominal centroid alignment; typically 0 or 1)\n *              fontdir  (<optional> directory for bitmap fonts for debugging)\n *      Return: recd, or null on error\n *\n *  Notes:\n *      (1) This is a convenience function that generates a recog using\n *          the unscaled training data in an existing recog.\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "recogDebugAverages",
      "comment" : "/*!\n *  recogDebugAverages()\n *\n *      Input:  recog\n *              debug (0 no output; 1 for images; 2 for text; 3 for both)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Generates an image that pairs each of the input images used\n *          in training with the average template that it is best\n *          correlated to.  This is written into the recog.\n *      (2) It also generates pixa_tr of all the input training images,\n *          which can be used, e.g., in recogShowMatchesInRange().\n */",
      "file" : "recogtrain.c"
   },
   {
      "function" : "recogDecode",
      "comment" : "/*!\n *  recogDecode()\n *\n *      Input:  recog (with LUT's pre-computed)\n *              pixs (typically of multiple touching characters, 1 bpp)\n *              nlevels (of templates; 2 for now)\n *              &pixdb (<optional return> debug result; can be null)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "recogdid.c"
   },
   {
      "function" : "recogDestroy",
      "comment" : "/*!\n *  recogDestroy()\n *\n *      Input:  &recog (<will be set to null before returning>)\n *      Return: void\n *\n *  Notes:\n *      (1) If a recog has a parent, the parent owns it.  A recogDestroy()\n *          will fail if there is a parent.\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "recogDestroyDid",
      "comment" : "/*!\n *  recogDestroyDid()\n *\n *      Input:  recog\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) As the signature indicates, this is owned by the recog, and can\n *          only be destroyed using this function.\n */",
      "file" : "recogdid.c"
   },
   {
      "function" : "recogDidExists",
      "comment" : "/*!\n *  recogDidExists()\n *\n *      Input:  recog\n *      Return: 1 if recog->did exists; 0 if not or on error.\n */",
      "file" : "recogdid.c"
   },
   {
      "function" : "recogGetCharsetSize",
      "comment" : "/*!\n *  recogGetCharsetSize()\n *\n *      Input:  type (of charset)\n *      Return: size of charset, or 0 if unknown or on error\n */",
      "file" : "recogtrain.c"
   },
   {
      "function" : "recogGetClassIndex",
      "comment" : "/*!\n *  recogGetClassIndex()\n *\n *      Input:  recog (with LUT's pre-computed)\n *              val (integer value; can be up to 3 bytes for UTF-8)\n *              text (text from which @val was derived; used if not found)\n *              &index (<return> index into dna_tochar)\n *      Return: 0 if found; 1 if not found and added; 2 on error.\n *\n *  Notes:\n *      (1) This is used during training.  It searches the\n *          dna character array for @val.  If not found, it increments\n *          the setsize by 1, augmenting both the index and text arrays.\n *      (2) Returns the index in &index, except on error.\n *      (3) Caller must check the function return value.\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "recogGetClassString",
      "comment" : "/*!\n *  recogGetClassString()\n *\n *      Input:  recog\n *              index (into array of char types)\n *              &charstr (<return> string representation;\n *                        returns an empty string on error)\n *      Return: 0 if found, 1 on error\n *\n *  Notes:\n *      (1) Extracts a copy of the string from sa_text, which\n *          the caller must free.\n *      (2) Caller must check the function return value.\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "recogGetCount",
      "comment" : "/*!\n *  recogGetCount()\n *\n *      Input:  recog\n *      Return: count of classes in recog; 0 if no recog or on error\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "recogGetDid",
      "comment" : "/*!\n *  recogGetDid()\n *\n *      Input:  recog\n *      Return: did (still owned by the recog), or null on error\n *\n *  Notes:\n *      (1) This also makes sure the arrays are defined.\n */",
      "file" : "recogdid.c"
   },
   {
      "function" : "recogGetIndex",
      "comment" : "/*!\n *  recogGetIndex()\n *\n *      Input:  recog\n *             &index (into the parent recoga; -1 if no parent)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "recogGetParent",
      "comment" : "/*!\n *  recogGetParent()\n *\n *      Input:  recog\n *      Return: recoga (back-pointer to parent); can be null\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "recogGetWindowedArea",
      "comment" : "/*!\n *  recogGetWindowedArea()\n *\n *      Input:  recog\n *              index (of template)\n *              x (pixel position of left hand edge of template)\n *              &dely (<return> y shift of template relative to pix1)\n *              &wsum (<return> number of fg pixels in window of pixs)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is called after the best path has been found through\n *          the trellis, in order to produce a correlation that can be used\n *          to evaluate the confidence we have in the identification.\n *          The correlation is |1 & 2|^2 / (|1| * |2|).\n *          |1 & 2| is given by the count array, |2| is found from\n *          nasum_u[], and |1| is wsum returned from this function.\n */",
      "file" : "recogdid.c"
   },
   {
      "function" : "recogIdentifyPix",
      "comment" : "/*!\n *  recogIdentifyPix()\n *\n *      Input:  recog (with LUT's pre-computed)\n *              pixs (of a single character, 1 bpp)\n *              &pixdb (<optional return> debug pix showing input and best fit)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Basic recognition function for a single character.\n *      (2) If L_USE_AVERAGE, the matching is only to the averaged bitmaps,\n *          and the index of the sample is meaningless (0 is returned\n *          if requested).\n *      (3) The score is related to the confidence (probability of correct\n *          identification), in that a higher score is correlated with\n *          a higher probability.  However, the actual relation between\n *          the correlation (score) and the probability is not known;\n *          we call this a \"score\" because \"confidence\" can be misinterpreted\n *          as an actual probability.\n */",
      "file" : "recogident.c"
   },
   {
      "function" : "recogIdentifyPixa",
      "comment" : "/*!\n *  recogIdentifyPixa()\n *\n *      Input:  recog\n *              pixa (of 1 bpp images to match)\n *              naid (<optional> indices of components to identify; can be null)\n *              &pixdb (<optional return> pix showing inputs and best fits)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) See recogIdentifyPix().  This does the same operation\n *          for each pix in a pixa, and optionally returns the arrays\n *          of results (scores, class index and character string)\n *          for the best correlation match.\n */",
      "file" : "recogident.c"
   },
   {
      "function" : "recogMakeBmf",
      "comment" : "/*!\n *  recogMakeBmf()\n *\n *      Input:  recog\n *              fontdir (for bitmap fonts; typically \"fonts\")\n *              size  (of font; even integer between 4 and 20; default is 6)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This can be used to (re)set the size of the font used for\n *          debug labelling.\n */",
      "file" : "recogtrain.c"
   },
   {
      "function" : "recogMakeDecodingArray",
      "comment" : "/*!\n *  recogMakeDecodingArray()\n *\n *      Input:  recog\n *              index (of averaged template)\n *              debug (1 for debug output; 0 otherwise)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Generates the bit-and sum array for a character template along pixs.\n *      (2) The values are saved in the scoring arrays at the left edge\n *          of the template as it is positioned on pixs.\n */",
      "file" : "recogdid.c"
   },
   {
      "function" : "recogMakeDecodingArrays",
      "comment" : "/*!\n *  recogMakeDecodingArrays()\n *\n *      Input:  recog (with LUT's pre-computed)\n *              pixs (typically of multiple touching characters, 1 bpp)\n *              debug (1 for debug output; 0 otherwise)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Generates the bit-and sum arrays for each character template\n *          along pixs.  These are used in the dynamic programming step.\n *      (2) Previous arrays are destroyed and the new arrays are allocated.\n *      (3) The values are saved in the scoring arrays at the left edge\n *          of the template.  They are used in the viterbi process\n *          at the setwidth position (which is near the RHS of the template\n *          as it is positioned on pixs) in the generated trellis.\n */",
      "file" : "recogdid.c"
   },
   {
      "function" : "recogMapIndexToIndex",
      "comment" : "/*!\n *  recogMapIndexToIndex()\n *\n *      Input:  recog1\n *              recog2\n *      Return: lut (from recog1 --> recog2), or null on error\n *\n *  Notes:\n *      (1) This returns a map from each index in recog1 to the\n *          corresponding index in recog2.  Caller must free.\n *      (2) If the character string doesn't exist in any of the classes\n *          in recog2, the value -1 is inserted in the lut.\n */",
      "file" : "recogtrain.c"
   },
   {
      "function" : "recogPadTrainingSet",
      "comment" : "/*!\n *  recogPadTrainingSet()\n *\n *      Input:  &recog (to be replaced if padding or more drastic measures\n *                      are necessary; otherwise, it is unchanged.)\n *              debug (1 for debug output saved to recog; 0 otherwise)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Before calling this, call recogSetPadParams() if you want\n *          non-default values for the character set type, min_nopad\n *          and max_afterpad values, and paths for labelled bitmap\n *          character sets that can be used to augment an input recognizer.\n *      (2) If all classes in @recog have at least min_nopad samples,\n *          nothing is done.  If the total number of samples in @recog\n *          is very small, @recog is replaced by a boot recog from the\n *          specified bootpath.  Otherwise (the intermediate case),\n *          @recog is replaced by one with scaling to fixed height,\n *          where an array of recog are used to augment the input recog.\n *      (3) If padding or total replacement is done, this destroys\n *          the input recog and replaces it by a new one.  If the recog\n *          belongs to a recoga, the replacement is also done in the recoga.\n */",
      "file" : "recogtrain.c"
   },
   {
      "function" : "recogPreSplittingFilter",
      "comment" : "/*!\n *  recogPreSplittingFilter()\n *\n *      Input:  recog\n *              pixs (1 bpp, single connected component)\n *              maxasp (maximum asperity ratio (width/height) to be retained)\n *              minaf (minimum area fraction (|fg|/(w*h)) to be retained)\n *              maxaf (maximum area fraction (|fg|/(w*h)) to be retained)\n *              debug (1 to output indicator arrays)\n *      Return: pixd (with filtered components removed) or null on error\n */",
      "file" : "recogident.c"
   },
   {
      "function" : "recogProcessMultLabelled",
      "comment" : "/*!\n *  recogProcessMultLabelled()\n *\n *      Input:  recog (in training mode)\n *              pixs (if depth > 1, will be thresholded to 1 bpp)\n *              box (<optional> cropping box)\n *              text (<optional> if null, use text field in pix)\n *              &pixa (<return> of split and thresholded characters)\n *              debug (1 to display images of samples not captured)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This crops and segments one or more labelled and contiguous\n *          ascii characters, for input in training.  It is a special case.\n *      (2) The character images are bundled into a pixa with the\n *          character text data embedded in each pix.\n *      (3) Where there is more than one character, this does some\n *          noise reduction and extracts the resulting character images\n *          from left to right.  No scaling is performed.\n */",
      "file" : "recogtrain.c"
   },
   {
      "function" : "recogProcessSingleLabelled",
      "comment" : "/*!\n *  recogProcessSingleLabelled()\n *\n *      Input:  recog (in training mode)\n *              pixs (if depth > 1, will be thresholded to 1 bpp)\n *              box (<optional> cropping box)\n *              text (<optional> if null, use text field in pix)\n *              &pixa (one pix, 1 bpp, labelled)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This crops and binarizes the input image, generating a pix\n *          of one character where the charval is inserted into the pix.\n */",
      "file" : "recogtrain.c"
   },
   {
      "function" : "recogProcessToIdentify",
      "comment" : "/*!\n *  recogProcessToIdentify()\n *\n *      Input:  recog (with LUT's pre-computed)\n *              pixs (typ. single character, possibly d > 1 and uncropped)\n *              pad (extra pixels added to left and right sides)\n *      Return: pixd (1 bpp, clipped to foreground), or null on error.\n *\n *  Notes:\n *      (1) This is a lightweight operation to insure that the input\n *          image is 1 bpp, properly cropped, and padded on each side.\n *          If bpp > 1, the image is thresholded.\n */",
      "file" : "recogident.c"
   },
   {
      "function" : "recogRead",
      "comment" : "/*!\n *  recogRead()\n *\n *      Input:  filename\n *      Return: recog, or null on error\n *\n *  Notes:\n *      (1) Serialization can be applied to any recognizer, including\n *          one with more than one \"font\".  That is, it can have\n *          multiple character classes with the same character set\n *          description, where each of those classes contains characters\n *          that are very similar in size and shape.  Each pixa in\n *          the serialized pixaa contains images for a single character\n *          class.\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "recogReadStream",
      "comment" : "/*!\n *  recogReadStream()\n *\n *      Input:  stream\n *      Return: recog, or null on error\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "recogRemoveOutliers",
      "comment" : "/*!\n *  recogRemoveOutliers()\n *\n *      Input:  recog (after training samples are entered)\n *              targetscore (keep everything with at least this score)\n *              minfract (minimum fraction to retain)\n *              debug (1 for debug output)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Removing outliers is particularly important when recognition\n *          goes against all the samples in the training set, as opposed\n *          to the averages for each class.  The reason is that we get\n *          an identification error if a mislabeled sample is a best\n *          match for an input bitmap.\n *      (2) However, the score values depend strongly on the quality\n *          of the character images.  To avoid losing too many samples,\n *          we supplement a target score for retention with a minimum\n *          fraction that we must keep.  With poor quality images, we\n *          may keep samples with a score less than the targetscore,\n *          in order to satisfy the @minfract requirement.\n *      (3) We always require that at least one sample will be retained.\n *      (4) Where the training set is from the same source (e.g., the\n *          same book), use a relatively large minscore; say, ~0.8.\n *      (5) Method: for each class, generate the averages and match each\n *          scaled sample against the average.  Decide which\n *          samples will be ejected, and throw out both the\n *          scaled and unscaled samples and associated data.\n *          Recompute the average without the poor matches.\n */",
      "file" : "recogtrain.c"
   },
   {
      "function" : "recogReplaceInRecoga",
      "comment" : "/*!\n *  recogReplaceInRecoga()\n *\n *      Input:  &recog1 (old recog, to be destroyed)\n *              recog2 (new recog, to be inserted in place of @recog1)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This always destroys recog1.\n *      (2) If recog1 belongs to a recoga, this inserts recog2 into\n *          the slot that recog1 previously occupied.\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "recogRescoreDidResult",
      "comment" : "/*!\n *  recogRescoreDidResult()\n *\n *      Input:  recog (with LUT's pre-computed)\n *              &pixdb (<optional return> debug result; can be null)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This does correlation matching with all templates using the\n *          viterbi path segmentation.\n */",
      "file" : "recogdid.c"
   },
   {
      "function" : "recogRunViterbi",
      "comment" : "/*!\n *  recogRunViterbi()\n *\n *      Input:  recog (with LUT's pre-computed)\n *              &pixdb (<optional return> debug result; can be null)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is recursive, in that\n *          (a) we compute the score successively at all pixel positions x,\n *          (b) to compute the score at x in the trellis, for each\n *              template we look backwards to (x - setwidth) to get the\n *              score if that template were to be printed with its\n *              setwidth location at x.  We save at x the template and\n *              score that maximizes the sum of the score at (x - setwidth)\n *              and the log-likelihood for the template to be printed with\n *              its LHS there.\n */",
      "file" : "recogdid.c"
   },
   {
      "function" : "recogScaleCharacter",
      "comment" : "/*!\n *  recogScaleCharacter()\n *\n *      Input:  recog\n *              pixs (1 bpp, to be scaled)\n *      Return: pixd (scaled) if OK, null on error\n */",
      "file" : "recogtrain.c"
   },
   {
      "function" : "recogSetBootflag",
      "comment" : "/*!\n *  recogSetBootflag()\n *\n *      Input:  recog\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This must be set for any bootstrap recog, where the samples\n *          are not from the media being identified.\n *      (2) It is used to enforce scaled bitmaps for identification,\n *          and to prevent the recog from being used to split touching\n *          characters (which requires unscaled samples from the\n *          material being identified).\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "recogSetChannelParams",
      "comment" : "/*!\n *  recogSetChannelParams()\n *\n *      Input:  recog\n *              nlevels\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This converts the independent bit-flip probabilities in the\n *          \"channel\" into log-likelihood coefficients on image sums.\n *          These coefficients are only defined for the non-background\n *          template levels.  Thus for nlevels = 2 (one fg, one bg),\n *          only beta[1] and gamma[1] are used.  For nlevels = 4 (three\n *          fg templates), we use beta[1-3] and gamma[1-3].\n */",
      "file" : "recogdid.c"
   },
   {
      "function" : "recogSetPadParams",
      "comment" : "/*!\n *  recogSetPadParams()\n *\n *      Input:  recog (to be padded, if necessary)\n *              bootdir (<optional> directory to bootstrap labelled pixa)\n *              bootpattern (<optional> pattern for bootstrap labelled pixa)\n *              bootpath (<optional> path to single bootstrap labelled pixa)\n *              type (character set type; -1 for default; see enum in recog.h)\n *              size (character set size; -1 for default)\n *              min_nopad (min number in a class without padding; -1 default)\n *              max_afterpad (max number of samples in padded classes;\n *                            -1 for default)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is used to augment or replace a book-adapted recognizer (BAR).\n *          It is called when the recognizer is created, and must be\n *          called again before recogPadTrainingSet() if non-default\n *          values are to be used.\n *      (2) Default values allow for some padding.  To disable padding,\n *          set @min_nopad = 0.\n *      (3) Constraint on @min_nopad and @max_afterpad guarantees that\n *          padding will be allowed if requested.\n *      (4) The file directory (@bootdir) and tail pattern (@bootpattern)\n *          are used to identify serialized pixa, from which we can\n *          generate an array of recog.  These can be used to augment\n *          an input but incomplete BAR (book adapted recognizer).\n *      (5) If the BAR is very sparse, we will ignore it and use a generic\n *          bootstrap recognizer at @bootpath.\n */",
      "file" : "recogtrain.c"
   },
   {
      "function" : "recogSetScaling",
      "comment" : "/*!\n *  recogSetScaling()\n *\n *      Input:  recog\n *              scalew  (scale all widths to this; use 0 for no scaling)\n *              scaleh  (scale all heights to this; use 0 for no scaling)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "recogident.c"
   },
   {
      "function" : "recogSetTemplateType",
      "comment" : "/*!\n *  recogSetTemplateType()\n *\n *      Input:  recog\n *              templ_type (L_USE_AVERAGE or L_USE_ALL)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "recogident.c"
   },
   {
      "function" : "recogShowAverageTemplates",
      "comment" : "/*!\n *  recogShowAverageTemplates()\n *\n *      Input:  recog\n *      Return: 0 on success, 1 on failure\n *\n *  Notes:\n *      (1) This debug routine generates a display of the averaged templates,\n *          both scaled and unscaled, with the centroid visible in red.\n */",
      "file" : "recogtrain.c"
   },
   {
      "function" : "recogShowContent",
      "comment" : "/*!\n *  recogShowContent()\n *\n *      Input:  stream\n *              recog\n *              display (1 for showing template images, 0 otherwise)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "recogtrain.c"
   },
   {
      "function" : "recogShowMatch",
      "comment" : "/*!\n *  recogShowMatch()\n *\n *      Input:  recog\n *              pix1  (input pix; several possibilities)\n *              pix2  (<optional> matching template)\n *              box  (<optional> region in pix1 for which pix2 matches)\n *              index  (index of matching template; use -1 to disable printing)\n *              score  (score of match)\n *      Return: pixd (pair of images, showing input pix and best template),\n *                    or null on error.\n *\n *  Notes:\n *      (1) pix1 can be one of these:\n *          (a) The input pix alone, which can be either a single character\n *              (box == NULL) or several characters that need to be\n *              segmented.  If more than character is present, the box\n *              region is displayed with an outline.\n *          (b) Both the input pix and the matching template.  In this case,\n *              pix2 and box will both be null.\n *      (2) If the bmf has been made (by a call to recogMakeBmf())\n *          and the index >= 0, the index and score will be rendered;\n *          otherwise their values will be ignored.\n */",
      "file" : "recogtrain.c"
   },
   {
      "function" : "recogShowMatchesInRange",
      "comment" : "/*!\n *  recogShowMatchesInRange()\n *\n *      Input:  recog\n *              pixa (of 1 bpp images to match)\n *              minscore, maxscore (range to include output)\n *              display (to display the result)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This gives a visual output of the best matches for a given\n *          range of scores.  Each pair of images can optionally be\n *          labelled with the index of the best match and the correlation.\n *          If the bmf has been previously made, it will be used here.\n *      (2) To use this, save a set of 1 bpp images (labelled or\n *          unlabelled) that can be given to a recognizer in a pixa.\n *          Then call this function with the pixa and parameters\n *          to filter a range of score.\n */",
      "file" : "recogtrain.c"
   },
   {
      "function" : "recogShowPath",
      "comment" : "/*!\n *  recogShowPath()\n *\n *      Input:  recog (with LUT's pre-computed)\n *              select (0 for Viterbi; 1 for rescored)\n *      Return: pix (debug output), or null on error)\n */",
      "file" : "recogdid.c"
   },
   {
      "function" : "recogSkipIdentify",
      "comment" : "/*!\n *  recogSkipIdentify()\n *\n *      Input:  recog\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This just writes a \"dummy\" result with 0 score and empty\n *          string id into the rch.\n */",
      "file" : "recogident.c"
   },
   {
      "function" : "recogSplitIntoCharacters",
      "comment" : "/*!\n *  recogSplitIntoCharacters()\n *\n *      Input:  recog\n *              pixs (1 bpp, contains only mostly deskewed text)\n *              minw (remove components with width less than this;\n *                    use -1 for default removing out of band components)\n *              minh (remove components with height less than this;\n *                    use -1 for default removing out of band components)\n *              &boxa (<return> character bounding boxes)\n *              &pixa (<return> character images)\n *              &naid (<return> indices of components to identify)\n *              debug (1 for results written to pixadb_split)\n *\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This can be given an image that has an arbitrary number\n *          of text characters.  It does splitting of connected\n *          components based on greedy correlation matching in\n *          recogCorrelationBestRow().  The returned pixa includes\n *          the boxes from which the (possibly split) components\n *          are extracted.\n *      (2) If either @minw < 0 or @minh < 0, noise components are\n *          filtered out, and the returned @naid array is all 1.\n *          Otherwise, some noise components whose dimensions (w,h)\n *          satisfy w >= @minw and h >= @minh are allowed through, but\n *          they are identified in the returned @naid, where they are\n *          labelled by 0 to indicate that they are not to be run\n *          through identification.  Retaining the noise components\n *          provides spatial information that can help applications\n *          interpret the results.\n *      (3) In addition to optional filtering of the noise, the\n *          resulting components are put in row-major (2D) order,\n *          and the smaller of overlapping components are removed if\n *          they satisfy conditions of relative size and fractional overlap.\n *      (4) Note that the spliting function uses unscaled templates\n *          and does not bother returning the class results and scores.\n *          Thes are more accurately found later using the scaled templates.\n */",
      "file" : "recogident.c"
   },
   {
      "function" : "recogSplittingFilter",
      "comment" : "/*!\n *  recogSplittingFilter()\n *\n *      Input:  recog\n *              pixs (1 bpp, single connected component)\n *              maxasp (maximum asperity ratio (width/height) to be retained)\n *              minaf (minimum area fraction (|fg|/(w*h)) to be retained)\n *              maxaf (maximum area fraction (|fg|/(w*h)) to be retained)\n *              &remove (<return> 0 to save, 1 to remove)\n *              debug (1 to output indicator arrays)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) We don't want to eliminate sans serif characters like \"1\" or \"l\",\n *          so we use the filter condition requiring both a large area fill\n *          and a w/h ratio > 1.0.\n */",
      "file" : "recogident.c"
   },
   {
      "function" : "recogStringToIndex",
      "comment" : "/*!\n *  recogStringToIndex()\n *\n *      Input:  recog\n *              text (text string for some class)\n *              &index (<return> index for that class; -1 if not found)\n *      Return: 0 if OK, 1 on error (not finding the string is an error)\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "recogTrainLabelled",
      "comment" : "/*!\n *  recogTrainLabelled()\n *\n *      Input:  recog (in training mode)\n *              pixs (if depth > 1, will be thresholded to 1 bpp)\n *              box (<optional> cropping box)\n *              text (<optional> if null, use text field in pix)\n *              multflag (1 if one or more contiguous ascii characters;\n *                        0 for a single arbitrary character)\n *              debug (1 to display images of samples not captured)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Training is restricted to the addition of either:\n *          (a) multflag == 0: a single character in an arbitrary\n *              (e.g., UTF8) charset\n *          (b) multflag == 1: one or more ascii characters rendered\n *              contiguously in pixs\n *      (2) If box != null, it should represent the cropped location of\n *          the character image.\n *      (3) If multflag == 1, samples will be rejected if the number of\n *          connected components does not equal to the number of ascii\n *          characters in the textstring.  In that case, if debug == 1,\n *          the rejected samples will be displayed.\n */",
      "file" : "recogtrain.c"
   },
   {
      "function" : "recogTrainUnlabelled",
      "comment" : "/*!\n *  recogTrainUnlabelled()\n *\n *      Input:  recog (in training mode: the input characters in pixs are\n *                     inserted after labelling)\n *              recogboot (labels the input)\n *              pixs (if depth > 1, will be thresholded to 1 bpp)\n *              box (<optional> cropping box)\n *              singlechar (1 if pixs is a single character; 0 otherwise)\n *              minscore (min score for accepting the example; e.g., 0.75)\n *              debug (1 for debug output saved to recog; 0 otherwise)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This trains on unlabelled data, using a bootstrap recognizer\n *          to apply the labels.  In this way, we can build a recognizer\n *          using a source of unlabelled data.\n *      (2) The input pix can have several (non-touching) characters.\n *          If box != NULL, we treat the region in the box as a single char\n *          If box == NULL, use all of pixs:\n *             if singlechar == 0, we identify each c.c. as a single character\n *             if singlechar == 1, we treat pixs as a single character\n *          Multiple chars are identified separately by recogboot and\n *          inserted into recog.\n *      (3) recogboot is a trained recognizer.  It would typically be\n *          constructed from a variety of sources, and use the average\n *          templates for scoring.\n *      (4) For debugging, if bmf is defined in the recog, the correlation\n *          scores are generated and saved (by adding to the pixadb_boot\n *          field) with the matching images.\n */",
      "file" : "recogtrain.c"
   },
   {
      "function" : "recogTrainingFinished",
      "comment" : "/*!\n *  recogTrainingFinished()\n *\n *      Input:  recog\n *              debug\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This must be called after all training samples have been added.\n *      (2) Set debug = 1 to view the resulting templates\n *          and their centroids.\n *      (3) The following things are done here:\n *          (a) Allocate (or reallocate) storage for (possibly) scaled\n *              bitmaps, centroids, and fg areas.\n *          (b) Generate the (possibly) scaled bitmaps.\n *          (c) Compute centroid and fg area data for both unscaled and\n *              scaled bitmaps.\n *          (d) Compute the averages for both scaled and unscaled bitmaps\n *          (e) Truncate the pixaa, ptaa and numaa arrays down from\n *              256 to the actual size.\n *      (4) Putting these operations here makes it simple to recompute\n *          the recog with different scaling on the bitmaps.\n *      (5) Removal of outliers must happen after this is called.\n */",
      "file" : "recogtrain.c"
   },
   {
      "function" : "recogTransferRchToDid",
      "comment" : "/*!\n *  recogTransferRchToDid()\n *\n *      Input:  recog (with rch and did defined)\n *              x (left edge of extracted region, relative to decoded line)\n *              y (top edge of extracted region, relative to input image)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is used to transfer the results for a single character match\n *          to the rescored did arrays.\n */",
      "file" : "recogdid.c"
   },
   {
      "function" : "recogWrite",
      "comment" : "/*!\n *  recogWrite()\n *\n *      Input:  filename\n *              recog\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "recogWritePixa",
      "comment" : "/*!\n *  recogWritePixa()\n *\n *      Input:  filename\n *              recog\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This generates a pixa of all the unscaled images in the\n *          recognizer, where each one has its character string in\n *          the pix text field, by flattening pixaa_u to a pixa.\n *      (2) As a side-effect, the character class label is written\n *          into each pix in recog.\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "recogWriteStream",
      "comment" : "/*!\n *  recogWriteStream()\n *\n *      Input:  stream (opened for \"wb\")\n *              recog\n *              filename (output serialized filename; embedded in file)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "recogaAddRecog",
      "comment" : "/*!\n *  recogaAddRecog()\n *\n *      Input:  recoga\n *              recog (to be added and owned by the recoga; not a copy)\n *      Return: recoga, or null on error\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "recogaCreate",
      "comment" : "/*!\n *  recogaCreate()\n *\n *      Input:  n (initial number of recog ptrs)\n *      Return: recoga, or null on error\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "recogaCreateFromPixaa",
      "comment" : "/*!\n *  recogaCreateFromPixaa()\n *\n *      Input:  paa (of labelled, 1 bpp images)\n *              scalew  (scale all widths to this; use 0 for no scaling)\n *              scaleh  (scale all heights to this; use 0 for no scaling)\n *              templ_type (L_USE_AVERAGE or L_USE_ALL)\n *              threshold (for binarization; typically ~128)\n *              maxyshift (from nominal centroid alignment; typically 0 or 1)\n *              fontdir  (<optional> directory for bitmap fonts for debugging)\n *      Return: recoga, or null on error\n *\n *  Notes:\n *      (1) This is a convenience function for training from labelled data.\n *      (2) Each pixa in the paa is a set of labelled data that is used\n *          to train a recognizer (e.g., for a set of characters in a font).\n *          Each image example in the pixa is put into a class in its\n *          recognizer, defined by its character label.  All examples in\n *          the same class should be similar.\n *      (3) The pixaa can be written by recogaWritePixaa(), and must contain\n *          the unscaled bitmaps used for training.\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "recogaCreateFromRecog",
      "comment" : "/*!\n *  recogaCreateFromRecog()\n *\n *      Input:  recog\n *      Return: recoga, or null on error\n *\n *  Notes:\n *      (1) This is a convenience function for making a recoga after\n *          you have a recog.  The recog is owned by the recoga.\n *      (2) For splitting connected components, the\n *          input recog must be from the material to be identified,\n *          and not a generic bootstrap recog.  Those can be added later.\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "recogaDestroy",
      "comment" : "/*!\n *  recogaDestroy()\n *\n *      Input:  &recoga (<will be set to null before returning>)\n *      Return: void\n *\n *  Notes:\n *      (1) If a recog has a parent, the parent owns it.  To destroy\n *          a recog, it must first be \"orphaned\".\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "recogaExtendArray",
      "comment" : "/*!\n *  recogaExtendArray()\n *\n *      Input:  recoga\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "recogaExtractNumbers",
      "comment" : "/*!\n *  recogaExtractNumbers()\n *\n *      Input:  recog\n *              boxas (location of components)\n *              scorethresh (min score for which we accept a component)\n *              spacethresh (max horizontal distance allowed between digits,\n *                           use -1 for default)\n *              &baa (<optional return> bounding boxes of identified numbers)\n *              &naa (<optional return> scores of identified digits)\n *      Return: sa (of identified numbers), or null on error\n *\n *  Notes:\n *      (1) Each string in the returned sa contains a sequence of ascii\n *          digits in a number.\n *      (2) The horizontal distance between boxes (limited by @spacethresh)\n *          is the negative of the horizontal overlap.\n *      (3) We allow two digits to be combined if these conditions apply:\n *            (a) the first is to the left of the second\n *            (b) the second has a horizontal separation less than @spacethresh\n *            (c) the vertical overlap >= 0 (vertical separation < 0)\n *            (d) both have a score that exceeds @scorethresh\n *      (4) Each numa in the optionally returned naa contains the digit\n *          scores of a number.  Each boxa in the optionally returned baa\n *          contains the bounding boxes of the digits in the number.\n *      (5) Components with a score less than @scorethresh, which may\n *          be hyphens or other small characters, will signal the\n *          end of the current sequence of digits in the number.\n */",
      "file" : "recogident.c"
   },
   {
      "function" : "recogaFinishAveraging",
      "comment" : "/*!\n *  recogaFinishAveraging()\n *\n *      Input:  recoga\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "recogtrain.c"
   },
   {
      "function" : "recogaGetCount",
      "comment" : "/*!\n *  recogaGetCount()\n *\n *      Input:  recoga\n *      Return: count of recog in array; 0 if no recog or on error\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "recogaGetRecog",
      "comment" : "/*!\n *  recogaGetRecog()\n *\n *      Input:  recoga\n *              index (to the index-th recog)\n *      Return: recog, or null on error\n *\n *  Notes:\n *      (1) This returns a ptr to the recog, which is still owned by\n *          the recoga.  Do not destroy it.\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "recogaIdentifyMultiple",
      "comment" : "/*!\n *  recogaIdentifyMultiple()\n *\n *      Input:  recoga (with training finished)\n *              pixs (containing typically a small number of characters)\n *              nitems (to be identified in pix; use 0 if not known)\n *              minw (remove components with width less than this;\n *                    use -1 for removing all noise components)\n *              minh (remove components with height less than this;\n *                    use -1 for removing all noise components)\n *              &boxa (<optional return> locations of identified components)\n *              &pixa (<optional return> images of identified components)\n *              &pixdb (<optional return> debug pix: inputs and best fits)\n *              debugsplit (1 returns pix split debugging images)\n *      Return: 0 if OK; 1 if more or less than nitems were found (a warning);\n *              2 on error.\n *\n *  Notes:\n *      (1) This filters the input pixa, looking for @nitems if requested.\n *          Set @nitems == 0 if you don't know how many chars to expect.\n *      (2) This bundles the filtered components into a pixa and calls\n *          recogIdentifyPixa().  If @nitems > 0, use @minw = -1 and\n *          @minh = -1 to remove all noise components.  If @nitems > 0\n *          and it doesn't agree with the number of filtered components\n *          in pixs, a warning is issued and a 1 is returned.\n *      (3) Set @minw = 0 and @minh = 0 to get all noise components.\n *          Set @minw > 0 and/or @minh > 0 to retain selected noise components.\n *          All noise components are recognized as an empty string with\n *          a score of 0.0.\n *      (4) An attempt is made to return 2-dimensional sorted arrays\n *          of (optional) images and boxes, which can then be used to\n *          aggregate identified characters into numbers or words.\n *          One typically wants the pixa, which contains a boxa of the\n *          extracted subimages.\n */",
      "file" : "recogident.c"
   },
   {
      "function" : "recogaIdentifyPixa",
      "comment" : "/*!\n *  recogaIdentifyPixa()\n *\n *      Input:  recoga\n *              pixa (of 1 bpp images to match)\n *              naid (<optional> indices of components to identify; can be null)\n *              &pixdb (<optional return> pix showing inputs and best fits)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) See recogIdentifyPixa().  This does the same operation\n *          for each recog, returning the arrays of results (scores,\n *          class index and character string) for the best correlation match.\n */",
      "file" : "recogident.c"
   },
   {
      "function" : "recogaRead",
      "comment" : "/*!\n *  recogaRead()\n *\n *      Input:  filename\n *      Return: recoga, or null on error\n *\n *  Notes:\n *      (1) This allows serialization of an array of recognizers, each of which\n *          can be used for different fonts, font styles, etc.\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "recogaReadStream",
      "comment" : "/*!\n *  recogaReadStream()\n *\n *      Input:  stream\n *      Return: recog, or null on error\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "recogaSaveBestRcha",
      "comment" : "/*!\n *  recogaSaveBestRcha()\n *\n *      Input:  recoga\n *              pixa (with all components having been identified)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Finds the best score among the recognizers for each character,\n *          and puts the rch data into a rcha in the recoga.  This is\n *          run after all recognizers have been applied to the pixa.\n *      (2) This also writes the best text id for each pix into its text field.\n */",
      "file" : "recogident.c"
   },
   {
      "function" : "recogaShowContent",
      "comment" : "/*!\n *  recogaShowContent()\n *\n *      Input:  stream\n *              recoga\n *              display (1 for showing template images, 0 otherwise)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "recogtrain.c"
   },
   {
      "function" : "recogaTrainingDone",
      "comment" : "/*!\n *  recogaTrainingDone()\n *\n *      Input:  recoga\n *             &done  (1 if training finished on all recog; 0 otherwise)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "recogtrain.c"
   },
   {
      "function" : "recogaTransferRch",
      "comment" : "/*!\n *  recogaTransferRch()\n *\n *      Input:  recoga (destination, with rcha defined)\n *              recog (source, with best scoring char in its rcha)\n *              index (index of component in the original pixa)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is called by recogaGetBestRcha() to transfer the results\n *          of a single character identification in a selected recog to the\n *          rcha array in the recoga, which holds the best scoring characters.\n */",
      "file" : "recogident.c"
   },
   {
      "function" : "recogaWrite",
      "comment" : "/*!\n *  recogaWrite()\n *\n *      Input:  filename\n *              recoga\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "recogaWritePixaa",
      "comment" : "/*!\n *  recogaWritePixaa()\n *\n *      Input:  filename\n *              recoga\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) For each recognizer, this generates a pixa of all the\n *          unscaled images.  They are combined into a pixaa for\n *          the set of recognizers.  Each pix has has its character\n *          string in the pix text field.\n *      (2) As a side-effect, the character class label is written\n *          into each pix in recog.\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "recogaWriteStream",
      "comment" : "/*!\n *  recogaWriteStream()\n *\n *      Input:  stream (opened for \"wb\")\n *              recoga\n *              filename (output serialized filename; embedded in file)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "recogbasic.c"
   },
   {
      "function" : "regTestCheckFile",
      "comment" : "/*!\n *  regTestCheckFile()\n *\n *      Input:  rp (regtest parameters)\n *              localname (name of output file from reg test)\n *      Return: 0 if OK, 1 on error (a failure in comparison is not an error)\n *\n *  Notes:\n *      (1) This function does one of three things, depending on the mode:\n *           * \"generate\": makes a \"golden\" file as a copy @localname.\n *           * \"compare\": compares @localname contents with the golden file\n *           * \"display\": makes the @localname file but does no comparison\n *      (2) The canonical format of the golden filenames is:\n *            /tmp/golden/<root of main name>_golden.<index>.<ext of localname>\n *          e.g.,\n *             /tmp/golden/maze_golden.0.png\n *          It is important to add an extension to the local name, because\n *          the extension is added to the name of the golden file.\n */",
      "file" : "regutils.c"
   },
   {
      "function" : "regTestCleanup",
      "comment" : "/*!\n *  regTestCleanup()\n *\n *      Input:  rp (regression test parameters)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This copies anything written to the temporary file to the\n *          output file /tmp/reg_results.txt.\n */",
      "file" : "regutils.c"
   },
   {
      "function" : "regTestCompareFiles",
      "comment" : "/*!\n *  regTestCompareFiles()\n *\n *      Input:  rp (regtest parameters)\n *              index1 (of one output file from reg test)\n *              index2 (of another output file from reg test)\n *      Return: 0 if OK, 1 on error (a failure in comparison is not an error)\n *\n *  Notes:\n *      (1) This only does something in \"compare\" mode.\n *      (2) The canonical format of the golden filenames is:\n *            /tmp/golden/<root of main name>_golden.<index>.<ext of localname>\n *          e.g.,\n *            /tmp/golden/maze_golden.0.png\n */",
      "file" : "regutils.c"
   },
   {
      "function" : "regTestComparePix",
      "comment" : "/*!\n *  regTestComparePix()\n *\n *      Input:  rp (regtest parameters)\n *              pix1, pix2 (to be tested for equality)\n *      Return: 0 if OK, 1 on error (a failure in comparison is not an error)\n *\n *  Notes:\n *      (1) This function compares two pix for equality.  On failure,\n *          this writes to stderr.\n */",
      "file" : "regutils.c"
   },
   {
      "function" : "regTestCompareSimilarPix",
      "comment" : "/*!\n *  regTestCompareSimilarPix()\n *\n *      Input:  rp (regtest parameters)\n *              pix1, pix2 (to be tested for near equality)\n *              mindiff (minimum pixel difference to be counted; > 0)\n *              maxfract (maximum fraction of pixels allowed to have\n *                        diff greater than or equal to mindiff)\n *              printstats (use 1 to print normalized histogram to stderr)\n *      Return: 0 if OK, 1 on error (a failure in similarity comparison\n *              is not an error)\n *\n *  Notes:\n *      (1) This function compares two pix for near equality.  On failure,\n *          this writes to stderr.\n *      (2) The pix are similar if the fraction of non-conforming pixels\n *          does not exceed @maxfract.  Pixels are non-conforming if\n *          the difference in pixel values equals or exceeds @mindiff.\n *          Typical values might be @mindiff = 15 and @maxfract = 0.01.\n *      (3) The input images must have the same size and depth.  The\n *          pixels for comparison are typically subsampled from the images.\n *      (4) Normally, use @printstats = 0.  In debugging mode, to see\n *          the relation between @mindiff and the minimum value of\n *          @maxfract for success, set this to 1.\n */",
      "file" : "regutils.c"
   },
   {
      "function" : "regTestCompareStrings",
      "comment" : "/*!\n *  regTestCompareStrings()\n *\n *      Input:  rp (regtest parameters)\n *              string1 (typ. the expected string)\n *              bytes1 (size of string1)\n *              string2 (typ. the computed string)\n *              bytes2 (size of string2)\n *      Return: 0 if OK, 1 on error (a failure in comparison is not an error)\n */",
      "file" : "regutils.c"
   },
   {
      "function" : "regTestCompareValues",
      "comment" : "/*!\n *  regTestCompareValues()\n *\n *      Input:  rp (regtest parameters)\n *              val1 (typ. the golden value)\n *              val2 (typ. the value computed)\n *              delta (allowed max absolute difference)\n *      Return: 0 if OK, 1 on error (a failure in comparison is not an error)\n */",
      "file" : "regutils.c"
   },
   {
      "function" : "regTestSetup",
      "comment" : "/*!\n *  regTestSetup()\n *\n *      Input:  argc (from invocation; can be either 1 or 2)\n *              argv (to regtest: @argv[1] is one of these:\n *                    \"generate\", \"compare\", \"display\")\n *              &rp (<return> all regression params)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Call this function with the args to the reg test.\n *          There are three cases:\n *          Case 1:\n *              There is either only one arg, or the second arg is \"compare\".\n *              This is the mode in which you run a regression test\n *              (or a set of them), looking for failures and logging\n *              the results to a file.  The output, which includes\n *              logging of all reg test failures plus a SUCCESS or\n *              FAILURE summary for each test, is appended to the file\n *              \"/tmp/reg_results.txt.  For this case, as in Case 2,\n *              the display field in rp is set to FALSE, preventing\n *              image display.\n *          Case 2:\n *              The second arg is \"generate\".  This will cause\n *              generation of new golden files for the reg test.\n *              The results of the reg test are not recorded, and\n *              the display field in rp is set to FALSE.\n *          Case 3:\n *              The second arg is \"display\".  The test will run and\n *              files will be written.  Comparisons with golden files\n *              will not be carried out, so the only notion of success\n *              or failure is with tests that do not involve golden files.\n *              The display field in rp is TRUE, and this is used by\n *              pixDisplayWithTitle().\n *      (2) See regutils.h for examples of usage.\n */",
      "file" : "regutils.c"
   },
   {
      "function" : "regTestWritePixAndCheck",
      "comment" : "/*!\n *  regTestWritePixAndCheck()\n *\n *      Input:  rp (regtest parameters)\n *              pix (to be written)\n *              format (of output pix)\n *      Return: 0 if OK, 1 on error (a failure in comparison is not an error)\n *\n *  Notes:\n *      (1) This function makes it easy to write the pix in a numbered\n *          sequence of files, and either to:\n *             (a) write the golden file (\"generate\" arg to regression test)\n *             (b) make a local file and \"compare\" with the golden file\n *             (c) make a local file and \"display\" the results\n *      (3) The canonical format of the local filename is:\n *            /tmp/<root of main name>.<count>.<format extension string>\n *          e.g., for scale_reg,\n *            /tmp/scale.0.png\n */",
      "file" : "regutils.c"
   },
   {
      "function" : "resetMorphBoundaryCondition",
      "comment" : "/*!\n *  resetMorphBoundaryCondition()\n *\n *      Input:  bc (SYMMETRIC_MORPH_BC, ASYMMETRIC_MORPH_BC)\n *      Return: void\n */",
      "file" : "morph.c"
   },
   {
      "function" : "returnErrorFloat",
      "comment" : "/*!\n *  returnErrorFloat()\n *\n *      Input:  msg (error message)\n *              procname\n *              fval (return val)\n *      Return: fval\n */",
      "file" : "utils.c"
   },
   {
      "function" : "returnErrorInt",
      "comment" : "/*!\n *  returnErrorInt()\n *\n *      Input:  msg (error message)\n *              procname\n *              ival (return val)\n *      Return: ival (typically 1 for an error return)\n */",
      "file" : "utils.c"
   },
   {
      "function" : "returnErrorPtr",
      "comment" : "/*!\n *  returnErrorPtr()\n *\n *      Input:  msg (error message)\n *              procname\n *              pval  (return val)\n *      Return: pval (typically null)\n */",
      "file" : "utils.c"
   },
   {
      "function" : "rotate90Low",
      "comment" : "/*!\n *  rotate90Low()\n *\n *      direction:  1 for cw rotation\n *                 -1 for ccw rotation\n *\n *  Notes:\n *      (1) The dest must be cleared in advance because not\n *          all source pixels are written to the destination.\n */",
      "file" : "rotateorthlow.c"
   },
   {
      "function" : "rotateAMColorCornerLow",
      "comment" : "/*------------------------------------------------------------------*\n *           32 bpp grayscale rotation about the UL corner          *\n *------------------------------------------------------------------*/",
      "file" : "rotateamlow.c"
   },
   {
      "function" : "rotateAMColorFastLow",
      "comment" : "/*!\n *  rotateAMColorFastLow()\n *\n *     This is a special simplification of area mapping with division\n *     of each pixel into 16 sub-pixels.  The exact coefficients that\n *     should be used are the same as for the 4x linear interpolation\n *     scaling case, and are given there.  I tried to approximate these\n *     as weighted coefficients with a maximum sum of 4, which\n *     allows us to do the arithmetic in parallel for the R, G and B\n *     components in a 32 bit pixel.  However, there are three reasons\n *     for not doing that:\n *        (1) the loss of accuracy in the parallel implementation\n *            is visually significant\n *        (2) the parallel implementation (described below) is slower\n *        (3) the parallel implementation requires allocation of\n *            a temporary color image\n *\n *     There are 16 cases for the choice of the subpixel, and\n *     for each, the mapping to the relevant source\n *     pixels is as follows:\n *\n *      subpixel      src pixel weights\n *      --------      -----------------\n *         0          sp1\n *         1          (3 * sp1 + sp2) / 4\n *         2          (sp1 + sp2) / 2\n *         3          (sp1 + 3 * sp2) / 4\n *         4          (3 * sp1 + sp3) / 4\n *         5          (9 * sp1 + 3 * sp2 + 3 * sp3 + sp4) / 16\n *         6          (3 * sp1 + 3 * sp2 + sp3 + sp4) / 8\n *         7          (3 * sp1 + 9 * sp2 + sp3 + 3 * sp4) / 16\n *         8          (sp1 + sp3) / 2\n *         9          (3 * sp1 + sp2 + 3 * sp3 + sp4) / 8\n *         10         (sp1 + sp2 + sp3 + sp4) / 4\n *         11         (sp1 + 3 * sp2 + sp3 + 3 * sp4) / 8\n *         12         (sp1 + 3 * sp3) / 4\n *         13         (3 * sp1 + sp2 + 9 * sp3 + 3 * sp4) / 16\n *         14         (sp1 + sp2 + 3 * sp3 + 3 * sp4) / 8\n *         15         (sp1 + 3 * sp2 + 3 * sp3 + 9 * sp4) / 16\n *\n *     Another way to visualize this is to consider the area mapping\n *     (or linear interpolation) coefficients  for the pixel sp1.\n *     Expressed in fourths, they can be written as asymmetric matrix:\n *\n *           4      3      2      1\n *           3      2.25   1.5    0.75\n *           2      1.5    1      0.5\n *           1      0.75   0.5    0.25\n *\n *     The coefficients for the three neighboring pixels can be\n *     similarly written.\n *\n *     This is implemented here, where, for each color component,\n *     we inline its extraction from each participating word,\n *     construct the linear combination, and combine the results\n *     into the destination 32 bit RGB pixel, using the appropriate shifts.\n *\n *     It is interesting to note that an alternative method, where\n *     we do the arithmetic on the 32 bit pixels directly (after\n *     shifting the components so they won't overflow into each other)\n *     is significantly inferior.  Because we have only 8 bits for\n *     internal overflows, which can be distributed as 2, 3, 3, it\n *     is impossible to add these with the correct linear\n *     interpolation coefficients, which require a sum of up to 16.\n *     Rounding off to a sum of 4 causes appreciable visual artifacts\n *     in the rotated image.  The code for the inferior method\n *     can be found in prog/rotatefastalt.c, for reference.\n *\n *     *** Warning: explicit assumption about RGB component ordering ***\n */",
      "file" : "rotateamlow.c"
   },
   {
      "function" : "rotateAMColorLow",
      "comment" : "/*------------------------------------------------------------------*\n *             32 bpp grayscale rotation about the center           *\n *------------------------------------------------------------------*/",
      "file" : "rotateamlow.c"
   },
   {
      "function" : "rotateAMGrayCornerLow",
      "comment" : "/*------------------------------------------------------------------*\n *            8 bpp grayscale rotation about the UL corner          *\n *------------------------------------------------------------------*/",
      "file" : "rotateamlow.c"
   },
   {
      "function" : "rotateAMGrayLow",
      "comment" : "/*------------------------------------------------------------------*\n *             8 bpp grayscale rotation about the center            *\n *------------------------------------------------------------------*/",
      "file" : "rotateamlow.c"
   },
   {
      "function" : "runlengthMembershipOnLine",
      "comment" : "/*!\n *  runlengthMembershipOnLine()\n *\n *      Input:   buffer (into which full line of data is placed)\n *               size (full size of line; w or h)\n *               depth (8 or 16 bpp)\n *               start (array of start positions for fg runs)\n *               end (array of end positions for fg runs)\n *               n   (the number of runs)\n *      Return:  0 if OK; 1 on error\n *\n *  Notes:\n *      (1) Converts a set of runlengths into a buffer of\n *          runlength membership values.\n *      (2) Initialization of the array gives pixels that are\n *          not within a run the value 0.\n */",
      "file" : "runlength.c"
   },
   {
      "function" : "saConcatenatePdf",
      "comment" : "/*!\n *  saConcatenatePdf()\n *\n *      Input:  sarray (of pathnames for single-page pdf files)\n *              fileout (concatenated pdf file)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This only works with leptonica-formatted single-page pdf files.\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "saConcatenatePdfToData",
      "comment" : "/*!\n *  saConcatenatePdfToData()\n *\n *      Input:  sarray (of pathnames for single-page pdf files)\n *              &data (<return> concatenated pdf data in memory)\n *              &nbytes (<return> number of bytes in pdf data)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This only works with leptonica-formatted single-page pdf files.\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "saConvertFilesToPdf",
      "comment" : "/*!\n *  saConvertFilesToPdf()\n *\n *      Input:  sarray (of pathnames for images)\n *              res (input resolution of all images)\n *              scalefactor (scaling factor applied to each image; > 0.0)\n *              type (encoding type (L_JPEG_ENCODE, L_G4_ENCODE,\n *                    L_FLATE_ENCODE, or 0 for default)\n *              quality (used for JPEG only; 0 for default (75))\n *              title (<optional> pdf title; if null, taken from the first\n *                     image filename)\n *              fileout (pdf file of all images)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) See convertFilesToPdf().\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "saConvertFilesToPdfData",
      "comment" : "/*!\n *  saConvertFilesToPdfData()\n *\n *      Input:  sarray (of pathnames for images)\n *              res (input resolution of all images)\n *              scalefactor (scaling factor applied to each image; > 0.0)\n *              type (encoding type (L_JPEG_ENCODE, L_G4_ENCODE,\n *                    L_FLATE_ENCODE, or 0 for default)\n *              quality (used for JPEG only; 0 for default (75))\n *              title (<optional> pdf title; if null, taken from the first\n *                     image filename)\n *              &data (<return> output pdf data (of all images)\n *              &nbytes (<return> size of output pdf data)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) See convertFilesToPdf().\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "saConvertUnscaledFilesToPdf",
      "comment" : "/*!\n *  saConvertUnscaledFilesToPdf()\n *\n *      Input:  sarray (of pathnames for images)\n *              title (<optional> pdf title; if null, taken from the first\n *                     image filename)\n *              fileout (pdf file of all images)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) See convertUnscaledFilesToPdf().\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "saConvertUnscaledFilesToPdfData",
      "comment" : "/*!\n *  saConvertUnscaledFilesToPdfData()\n *\n *      Input:  sarray (of pathnames for images)\n *              title (<optional> pdf title; if null, taken from the first\n *                     image filename)\n *              &data (<return> output pdf data (of all images)\n *              &nbytes (<return> size of output pdf data)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "sarrayAddString",
      "comment" : "/*!\n *  sarrayAddString()\n *\n *      Input:  sarray\n *              string  (string to be added)\n *              copyflag (L_INSERT, L_COPY)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Legacy usage decrees that we always use 0 to insert a string\n *          directly and 1 to insert a copy of the string.  The\n *          enums for L_INSERT and L_COPY agree with this convention,\n *          and will not change in the future.\n *      (2) See usage comments at the top of this file.\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarrayAppend",
      "comment" : "/*!\n *  sarrayAppend()\n *\n *      Input:  filename\n *              sarray\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarrayAppendRange",
      "comment" : "/*!\n *  sarrayAppendRange()\n *\n *      Input:  sa1  (to be added to)\n *              sa2  (append specified range of strings in sa2 to sa1)\n *              start (index of first string of sa2 to append)\n *              end (index of last string of sa2 to append; -1 to end of array)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Copies of the strings in sarray2 are added to sarray1.\n *      (2) The [start ... end] range is truncated if necessary.\n *      (3) Use end == -1 to append to the end of sa2.\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarrayChangeRefcount",
      "comment" : "/*!\n *  sarrayChangeRefCount()\n *\n *      Input:  sarray\n *              delta (change to be applied)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarrayClear",
      "comment" : "/*!\n *  sarrayClear()\n *\n *      Input:  sarray\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarrayClone",
      "comment" : "/*!\n *  sarrayClone()\n *\n *      Input:  sarray\n *      Return: ptr to same sarray, or null on error\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarrayConcatenate",
      "comment" : "/*!\n *  sarrayConcatenate()\n *\n *      Input:  sa1  (to be added to)\n *              sa2  (append to sa1)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Copies of the strings in sarray2 are added to sarray1.\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarrayConvertFilesFittedToPS",
      "comment" : "/*\n *  sarrayConvertFilesFittedToPS()\n *\n *      Input:  sarray (of full path names)\n *              xpts, ypts (desired size in printer points; use 0 for default)\n *              fileout (output ps file)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) See convertFilesFittedToPS()\n */",
      "file" : "psio1.c"
   },
   {
      "function" : "sarrayConvertFilesToPS",
      "comment" : "/*\n *  sarrayConvertFilesToPS()\n *\n *      Input:  sarray (of full path names)\n *              res (typ. 300 or 600 ppi)\n *              fileout (output ps file)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) See convertFilesToPS()\n */",
      "file" : "psio1.c"
   },
   {
      "function" : "sarrayConvertWordsToLines",
      "comment" : "/*!\n *  sarrayConvertWordsToLines()\n *\n *      Input:  sa  (sa of individual words)\n *              linesize  (max num of chars in each line)\n *      Return: saout (sa of formatted lines), or null on error\n *\n *  This is useful for re-typesetting text to a specific maximum\n *  line length.  The individual words in the input sarray\n *  are concatenated into textlines.  An input word string of zero\n *  length is taken to be a paragraph separator.  Each time\n *  such a string is found, the current line is ended and\n *  a new line is also produced that contains just the\n *  string of zero length (\"\").  When the output sarray\n *  of lines is eventually converted to a string with newlines\n *  (typically) appended to each line string, the empty\n *  strings are just converted to newlines, producing the visible\n *  paragraph separation.\n *\n *  What happens when a word is larger than linesize?\n *  We write it out as a single line anyway!  Words preceding\n *  or following this long word are placed on lines preceding\n *  or following the line with the long word.  Why this choice?\n *  Long \"words\" found in text documents are typically URLs, and\n *  it's often desirable not to put newlines in the middle of a URL.\n *  The text display program (e.g., text editor) will typically\n *  wrap the long \"word\" to fit in the window.\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarrayCopy",
      "comment" : "/*!\n *  sarrayCopy()\n *\n *      Input:  sarray\n *      Return: copy of sarray, or null on error\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarrayCreate",
      "comment" : "/*!\n *  sarrayCreate()\n *\n *      Input:  size of string ptr array to be alloc'd\n *              (use 0 for default)\n *      Return: sarray, or null on error\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarrayCreateInitialized",
      "comment" : "/*!\n *  sarrayCreateInitialized()\n *\n *      Input:  n (size of string ptr array to be alloc'd)\n *              initstr (string to be initialized on the full array)\n *      Return: sarray, or null on error\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarrayCreateLinesFromString",
      "comment" : "/*!\n *  sarrayCreateLinesFromString()\n *\n *      Input:  string\n *              blankflag  (0 to exclude blank lines; 1 to include)\n *      Return: sarray, or null on error\n *\n *  Notes:\n *      (1) This finds the number of line substrings, each of which\n *          ends with a newline, and puts a copy of each substring\n *          in a new sarray.\n *      (2) The newline characters are removed from each substring.\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarrayCreateWordsFromString",
      "comment" : "/*!\n *  sarrayCreateWordsFromString()\n *\n *      Input:  string\n *      Return: sarray, or null on error\n *\n *  Notes:\n *      (1) This finds the number of word substrings, creates an sarray\n *          of this size, and puts copies of each substring into the sarray.\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarrayDestroy",
      "comment" : "/*!\n *  sarrayDestroy()\n *\n *      Input:  &sarray <to be nulled>\n *      Return: void\n *\n *  Notes:\n *      (1) Decrements the ref count and, if 0, destroys the sarray.\n *      (2) Always nulls the input ptr.\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarrayExtendArray",
      "comment" : "/*!\n *  sarrayExtendArray()\n *\n *      Input:  sarray\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarrayGetArray",
      "comment" : "/*!\n *  sarrayGetArray()\n *\n *      Input:  sarray\n *              &nalloc  (<optional return> number allocated string ptrs)\n *              &n  (<optional return> number allocated strings)\n *      Return: ptr to string array, or null on error\n *\n *  Notes:\n *      (1) Caution: the returned array is not a copy, so caller\n *          must not destroy it!\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarrayGetCount",
      "comment" : "/*!\n *  sarrayGetCount()\n *\n *      Input:  sarray\n *      Return: count, or 0 if no strings or on error\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarrayGetRefcount",
      "comment" : "/*!\n *  sarrayGetRefCount()\n *\n *      Input:  sarray\n *      Return: refcount, or UNDEF on error\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarrayGetString",
      "comment" : "/*!\n *  sarrayGetString()\n *\n *      Input:  sarray\n *              index   (to the index-th string)\n *              copyflag  (L_NOCOPY or L_COPY)\n *      Return: string, or null on error\n *\n *  Notes:\n *      (1) Legacy usage decrees that we always use 0 to get the\n *          pointer to the string itself, and 1 to get a copy of\n *          the string.\n *      (2) See usage comments at the top of this file.\n *      (3) To get a pointer to the string itself, use for copyflag:\n *             L_NOCOPY or 0 or FALSE\n *          To get a copy of the string, use for copyflag:\n *             L_COPY or 1 or TRUE\n *          The const values of L_NOCOPY and L_COPY are guaranteed not\n *          to change.\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarrayMakeInnerLoopDWACode",
      "comment" : "/*!\n *  sarrayMakeInnerLoopDWACode()\n */",
      "file" : "fhmtauto.c"
   },
   {
      "function" : "sarrayMakeInnerLoopDWACode",
      "comment" : "/*!\n *  sarrayMakeInnerLoopDWACode()\n */",
      "file" : "fmorphauto.c"
   },
   {
      "function" : "sarrayMakeWplsCode",
      "comment" : "/*!\n *  sarrayMakeWplsCode()\n */",
      "file" : "fhmtauto.c"
   },
   {
      "function" : "sarrayMakeWplsCode",
      "comment" : "/*!\n *  sarrayMakeWplsCode()\n */",
      "file" : "fmorphauto.c"
   },
   {
      "function" : "sarrayPadToSameSize",
      "comment" : "/*!\n *  sarrayPadToSameSize()\n *\n *      Input:  sa1, sa2\n *              padstring\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If two sarrays have different size, this adds enough\n *          instances of @padstring to the smaller so that they are\n *          the same size.  It is useful when two or more sarrays\n *          are being sequenced in parallel, and it is necessary to\n *          find a valid string at each index.\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarrayParseRange",
      "comment" : "/*!\n *  sarrayParseRange()\n *\n *      Input:  sa (input sarray)\n *              start (index to start range search)\n *             &actualstart (<return> index of actual start; may be > 'start')\n *             &end (<return> index of end)\n *             &newstart (<return> index of start of next range)\n *              substr (substring for matching at beginning of string)\n *              loc (byte offset within the string for the pattern; use\n *                   -1 if the location does not matter);\n *      Return: 0 if valid range found; 1 otherwise\n *\n *  Notes:\n *      (1) This finds the range of the next set of strings in SA,\n *          beginning the search at 'start', that does NOT have\n *          the substring 'substr' either at the indicated location\n *          in the string or anywhere in the string.  The input\n *          variable 'loc' is the specified offset within the string;\n *          use -1 to indicate 'anywhere in the string'.\n *      (2) Always check the return value to verify that a valid range\n *          was found.\n *      (3) If a valid range is not found, the values of actstart,\n *          end and newstart are all set to the size of sa.\n *      (4) If this is the last valid range, newstart returns the value n.\n *          In use, this should be tested before calling the function.\n *      (5) Usage example.  To find all the valid ranges in a file\n *          where the invalid lines begin with two dashes, copy each\n *          line in the file to a string in an sarray, and do:\n *             start = 0;\n *             while (!sarrayParseRange(sa, start, &actstart, &end, &start,\n *                    \"--\", 0))\n *                 fprintf(stderr, \"start = %d, end = %d\\n\", actstart, end);\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarrayRead",
      "comment" : "/*!\n *  sarrayRead()\n *\n *      Input:  filename\n *      Return: sarray, or null on error\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarrayReadStream",
      "comment" : "/*!\n *  sarrayReadStream()\n *\n *      Input:  stream\n *      Return: sarray, or null on error\n *\n *  Notes:\n *      (1) We store the size of each string along with the string.\n *      (2) This allows a string to have embedded newlines.  By reading\n *          the entire string, as determined by its size, we are\n *          not affected by any number of embedded newlines.\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarrayRemoveString",
      "comment" : "/*!\n *  sarrayRemoveString()\n *\n *      Input:  sarray\n *              index (of string within sarray)\n *      Return: removed string, or null on error\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarrayReplaceString",
      "comment" : "/*!\n *  sarrayReplaceString()\n *\n *      Input:  sarray\n *              index (of string within sarray to be replaced)\n *              newstr (string to replace existing one)\n *              copyflag (L_INSERT, L_COPY)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This destroys an existing string and replaces it with\n *          the new string or a copy of it.\n *      (2) By design, an sarray is always compacted, so there are\n *          never any holes (null ptrs) in the ptr array up to the\n *          current count.\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarraySelectByRange",
      "comment" : "/*!\n *  sarraySelectByRange()\n *\n *      Input:  sain (input sarray)\n *              first (index of first string to be selected)\n *              last (index of last string to be selected; use 0 to go to the\n *                    end of the sarray)\n *      Return: saout (output sarray), or null on error\n *\n *  Notes:\n *      (1) This makes @saout consisting of copies of all strings in @sain\n *          in the index set [first ... last].  Use @last == 0 to get all\n *          strings from @first to the last string in the sarray.\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarraySelectBySubstring",
      "comment" : "/*!\n *  sarraySelectBySubstring()\n *\n *      Input:  sain (input sarray)\n *              substr (<optional> substring for matching; can be NULL)\n *      Return: saout (output sarray, filtered with substring) or null on error\n *\n *  Notes:\n *      (1) This selects all strings in sain that have substr as a substring.\n *          Note that we can't use strncmp() because we're looking for\n *          a match to the substring anywhere within each filename.\n *      (2) If substr == NULL, returns a copy of the sarray.\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarraySort",
      "comment" : "/*!\n *  sarraySort()\n *\n *      Input:  saout (output sarray; can be NULL or equal to sain)\n *              sain (input sarray)\n *              sortorder (L_SORT_INCREASING or L_SORT_DECREASING)\n *      Return: saout (output sarray, sorted by ascii value), or null on error\n *\n *  Notes:\n *      (1) Set saout = sain for in-place; otherwise, set naout = NULL.\n *      (2) Shell sort, modified from K&R, 2nd edition, p.62.\n *          Slow but simple O(n logn) sort.\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarraySortByIndex",
      "comment" : "/*!\n *  sarraySortByIndex()\n *\n *      Input:  sain\n *              naindex (na that maps from the new sarray to the input sarray)\n *      Return: saout (sorted), or null on error\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarraySplitString",
      "comment" : "/*\n *  sarraySplitString()\n *\n *      Input:  sa (to append to; typically empty initially)\n *              str (string to split; not changed)\n *              separators (characters that split input string)\n *      Return: 0 if OK, 1 on error.\n *\n *  Notes:\n *      (1) This uses strtokSafe().  See the notes there in utils.c.\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarrayToString",
      "comment" : "/*!\n *  sarrayToString()\n *\n *      Input:  sarray\n *              addnlflag (flag: 0 adds nothing to each substring\n *                               1 adds '\\n' to each substring\n *                               2 adds ' ' to each substring)\n *      Return: dest string, or null on error\n *\n *  Notes:\n *      (1) Concatenates all the strings in the sarray, preserving\n *          all white space.\n *      (2) If addnlflag != 0, adds either a '\\n' or a ' ' after\n *          each substring.\n *      (3) This function was NOT implemented as:\n *            for (i = 0; i < n; i++)\n *                     strcat(dest, sarrayGetString(sa, i, L_NOCOPY));\n *          Do you see why?\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarrayToStringRange",
      "comment" : "/*!\n *  sarrayToStringRange()\n *\n *      Input: sarray\n *             first  (index of first string to use; starts with 0)\n *             nstrings (number of strings to append into the result; use\n *                       0 to append to the end of the sarray)\n *             addnlflag (flag: 0 adds nothing to each substring\n *                              1 adds '\\n' to each substring\n *                              2 adds ' ' to each substring)\n *      Return: dest string, or null on error\n *\n *  Notes:\n *      (1) Concatenates the specified strings inthe sarray, preserving\n *          all white space.\n *      (2) If addnlflag != 0, adds either a '\\n' or a ' ' after\n *          each substring.\n *      (3) If the sarray is empty, this returns a string with just\n *          the character corresponding to @addnlflag.\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarrayWrite",
      "comment" : "/*!\n *  sarrayWrite()\n *\n *      Input:  filename\n *              sarray\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "sarrayWriteStream",
      "comment" : "/*!\n *  sarrayWriteStream()\n *\n *      Input:  stream\n *              sarray\n *      Returns 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This appends a '\\n' to each string, which is stripped\n *          off by sarrayReadStream().\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "scaleAreaMapLow2",
      "comment" : "/*!\n *  scaleAreaMapLow2()\n *\n *  Note: This function is called with either 8 bpp gray or 32 bpp RGB.\n *        The result is a 2x reduced dest.\n */",
      "file" : "scalelow.c"
   },
   {
      "function" : "scaleBinaryLow",
      "comment" : "/*\n *  scaleBinaryLow()\n *\n *  Notes:\n *      (1) The dest must be cleared prior to this operation,\n *          and we clear it here in the low-level code.\n *      (2) We reuse dest pixels and dest pixel rows whenever\n *          possible for upscaling; downscaling is done by\n *          strict subsampling.\n */",
      "file" : "scalelow.c"
   },
   {
      "function" : "scaleBySamplingLow",
      "comment" : "/*!\n *  scaleBySamplingLow()\n *\n *  Notes:\n *      (1) The dest must be cleared prior to this operation,\n *          and we clear it here in the low-level code.\n *      (2) We reuse dest pixels and dest pixel rows whenever\n *          possible.  This speeds the upscaling; downscaling\n *          is done by strict subsampling and is unaffected.\n *      (3) Because we are sampling and not interpolating, this\n *          routine works directly, without conversion to full\n *          RGB color, for 2, 4 or 8 bpp palette color images.\n */",
      "file" : "scalelow.c"
   },
   {
      "function" : "scaleColor2xLILineLow",
      "comment" : "/*!\n *  scaleColor2xLILineLow()\n *\n *      Input:  lined   (ptr to top destline, to be made from current src line)\n *              wpld\n *              lines   (ptr to current src line)\n *              ws\n *              wpls\n *              lastlineflag  (1 if last src line; 0 otherwise)\n *      Return: void\n *\n *  *** Warning: implicit assumption about RGB component ordering ***\n */",
      "file" : "scalelow.c"
   },
   {
      "function" : "scaleColor2xLILow",
      "comment" : "/*!\n *  scaleColor2xLILow()\n *\n *  This is a special case of 2x expansion by linear\n *  interpolation.  Each src pixel contains 4 dest pixels.\n *  The 4 dest pixels in src pixel 1 are numbered at\n *  their UL corners.  The 4 dest pixels in src pixel 1\n *  are related to that src pixel and its 3 neighboring\n *  src pixels as follows:\n *\n *             1-----2-----|-----|-----|\n *             |     |     |     |     |\n *             |     |     |     |     |\n *  src 1 -->  3-----4-----|     |     |  <-- src 2\n *             |     |     |     |     |\n *             |     |     |     |     |\n *             |-----|-----|-----|-----|\n *             |     |     |     |     |\n *             |     |     |     |     |\n *  src 3 -->  |     |     |     |     |  <-- src 4\n *             |     |     |     |     |\n *             |     |     |     |     |\n *             |-----|-----|-----|-----|\n *\n *           dest      src\n *           ----      ---\n *           dp1    =  sp1\n *           dp2    =  (sp1 + sp2) / 2\n *           dp3    =  (sp1 + sp3) / 2\n *           dp4    =  (sp1 + sp2 + sp3 + sp4) / 4\n *\n *  We iterate over the src pixels, and unroll the calculation\n *  for each set of 4 dest pixels corresponding to that src\n *  pixel, caching pixels for the next src pixel whenever possible.\n *  The method is exactly analogous to the one we use for\n *  scaleGray2xLILow() and its line version.\n *\n *  P3 speed is about 5 x 10^7 dst pixels/sec/GHz\n */",
      "file" : "scalelow.c"
   },
   {
      "function" : "scaleColorAreaMapLow",
      "comment" : "/*!\n *  scaleColorAreaMapLow()\n *\n *  This should only be used for downscaling.\n *  We choose to divide each pixel into 16 x 16 sub-pixels.\n *  This is much slower than scaleSmoothLow(), but it gives a\n *  better representation, esp. for downscaling factors between\n *  1.5 and 5.  All src pixels are subdivided into 256 sub-pixels,\n *  and are weighted by the number of sub-pixels covered by\n *  the dest pixel.  This is about 2x slower than scaleSmoothLow(),\n *  but the results are significantly better on small text.\n */",
      "file" : "scalelow.c"
   },
   {
      "function" : "scaleColorLILow",
      "comment" : "/*!\n *  scaleColorLILow()\n *\n *  We choose to divide each pixel into 16 x 16 sub-pixels.\n *  Linear interpolation is equivalent to finding the\n *  fractional area (i.e., number of sub-pixels divided\n *  by 256) associated with each of the four nearest src pixels,\n *  and weighting each pixel value by this fractional area.\n *\n *  P3 speed is about 7 x 10^6 dst pixels/sec/GHz\n */",
      "file" : "scalelow.c"
   },
   {
      "function" : "scaleGray2xLILineLow",
      "comment" : "/*!\n *  scaleGray2xLILineLow()\n *\n *      Input:  lined   (ptr to top destline, to be made from current src line)\n *              wpld\n *              lines   (ptr to current src line)\n *              ws\n *              wpls\n *              lastlineflag  (1 if last src line; 0 otherwise)\n *      Return: void\n */",
      "file" : "scalelow.c"
   },
   {
      "function" : "scaleGray2xLILow",
      "comment" : "/*!\n *  scaleGray2xLILow()\n *\n *  This is a special case of 2x expansion by linear\n *  interpolation.  Each src pixel contains 4 dest pixels.\n *  The 4 dest pixels in src pixel 1 are numbered at\n *  their UL corners.  The 4 dest pixels in src pixel 1\n *  are related to that src pixel and its 3 neighboring\n *  src pixels as follows:\n *\n *             1-----2-----|-----|-----|\n *             |     |     |     |     |\n *             |     |     |     |     |\n *  src 1 -->  3-----4-----|     |     |  <-- src 2\n *             |     |     |     |     |\n *             |     |     |     |     |\n *             |-----|-----|-----|-----|\n *             |     |     |     |     |\n *             |     |     |     |     |\n *  src 3 -->  |     |     |     |     |  <-- src 4\n *             |     |     |     |     |\n *             |     |     |     |     |\n *             |-----|-----|-----|-----|\n *\n *           dest      src\n *           ----      ---\n *           dp1    =  sp1\n *           dp2    =  (sp1 + sp2) / 2\n *           dp3    =  (sp1 + sp3) / 2\n *           dp4    =  (sp1 + sp2 + sp3 + sp4) / 4\n *\n *  We iterate over the src pixels, and unroll the calculation\n *  for each set of 4 dest pixels corresponding to that src\n *  pixel, caching pixels for the next src pixel whenever possible.\n */",
      "file" : "scalelow.c"
   },
   {
      "function" : "scaleGray4xLILineLow",
      "comment" : "/*!\n *  scaleGray4xLILineLow()\n *\n *      Input:  lined   (ptr to top destline, to be made from current src line)\n *              wpld\n *              lines   (ptr to current src line)\n *              ws\n *              wpls\n *              lastlineflag  (1 if last src line; 0 otherwise)\n *      Return: void\n */",
      "file" : "scalelow.c"
   },
   {
      "function" : "scaleGray4xLILow",
      "comment" : "/*!\n *  scaleGray4xLILow()\n *\n *  This is a special case of 4x expansion by linear\n *  interpolation.  Each src pixel contains 16 dest pixels.\n *  The 16 dest pixels in src pixel 1 are numbered at\n *  their UL corners.  The 16 dest pixels in src pixel 1\n *  are related to that src pixel and its 3 neighboring\n *  src pixels as follows:\n *\n *             1---2---3---4---|---|---|---|---|\n *             |   |   |   |   |   |   |   |   |\n *             5---6---7---8---|---|---|---|---|\n *             |   |   |   |   |   |   |   |   |\n *  src 1 -->  9---a---b---c---|---|---|---|---|  <-- src 2\n *             |   |   |   |   |   |   |   |   |\n *             d---e---f---g---|---|---|---|---|\n *             |   |   |   |   |   |   |   |   |\n *             |===|===|===|===|===|===|===|===|\n *             |   |   |   |   |   |   |   |   |\n *             |---|---|---|---|---|---|---|---|\n *             |   |   |   |   |   |   |   |   |\n *  src 3 -->  |---|---|---|---|---|---|---|---|  <-- src 4\n *             |   |   |   |   |   |   |   |   |\n *             |---|---|---|---|---|---|---|---|\n *             |   |   |   |   |   |   |   |   |\n *             |---|---|---|---|---|---|---|---|\n *\n *           dest      src\n *           ----      ---\n *           dp1    =  sp1\n *           dp2    =  (3 * sp1 + sp2) / 4\n *           dp3    =  (sp1 + sp2) / 2\n *           dp4    =  (sp1 + 3 * sp2) / 4\n *           dp5    =  (3 * sp1 + sp3) / 4\n *           dp6    =  (9 * sp1 + 3 * sp2 + 3 * sp3 + sp4) / 16\n *           dp7    =  (3 * sp1 + 3 * sp2 + sp3 + sp4) / 8\n *           dp8    =  (3 * sp1 + 9 * sp2 + 1 * sp3 + 3 * sp4) / 16\n *           dp9    =  (sp1 + sp3) / 2\n *           dp10   =  (3 * sp1 + sp2 + 3 * sp3 + sp4) / 8\n *           dp11   =  (sp1 + sp2 + sp3 + sp4) / 4\n *           dp12   =  (sp1 + 3 * sp2 + sp3 + 3 * sp4) / 8\n *           dp13   =  (sp1 + 3 * sp3) / 4\n *           dp14   =  (3 * sp1 + sp2 + 9 * sp3 + 3 * sp4) / 16\n *           dp15   =  (sp1 + sp2 + 3 * sp3 + 3 * sp4) / 8\n *           dp16   =  (sp1 + 3 * sp2 + 3 * sp3 + 9 * sp4) / 16\n *\n *  We iterate over the src pixels, and unroll the calculation\n *  for each set of 16 dest pixels corresponding to that src\n *  pixel, caching pixels for the next src pixel whenever possible.\n */",
      "file" : "scalelow.c"
   },
   {
      "function" : "scaleGrayAreaMapLow",
      "comment" : "/*!\n *  scaleGrayAreaMapLow()\n *\n *  This should only be used for downscaling.\n *  We choose to divide each pixel into 16 x 16 sub-pixels.\n *  This is about 2x slower than scaleSmoothLow(), but the results\n *  are significantly better on small text, esp. for downscaling\n *  factors between 1.5 and 5.  All src pixels are subdivided\n *  into 256 sub-pixels, and are weighted by the number of\n *  sub-pixels covered by the dest pixel.\n */",
      "file" : "scalelow.c"
   },
   {
      "function" : "scaleGrayLILow",
      "comment" : "/*!\n *  scaleGrayLILow()\n *\n *  We choose to divide each pixel into 16 x 16 sub-pixels.\n *  Linear interpolation is equivalent to finding the\n *  fractional area (i.e., number of sub-pixels divided\n *  by 256) associated with each of the four nearest src pixels,\n *  and weighting each pixel value by this fractional area.\n */",
      "file" : "scalelow.c"
   },
   {
      "function" : "scaleMipmapLow",
      "comment" : "/*!\n *  scaleMipmapLow()\n *\n *  See notes in scale.c for pixScaleToGrayMipmap().  This function\n *  is here for pedagogical reasons.  It gives poor results on document\n *  images because of aliasing.\n */",
      "file" : "scalelow.c"
   },
   {
      "function" : "scaleRGBToGray2Low",
      "comment" : "/*!\n *  scaleRGBToGray2Low()\n *\n *  Notes:\n *      (1) This function is called with 32 bpp RGB src and 8 bpp,\n *          half-resolution dest.  The weights should add to 1.0.\n */",
      "file" : "scalelow.c"
   },
   {
      "function" : "scaleSmoothLow",
      "comment" : "/*!\n *  scaleSmoothLow()\n *\n *  Notes:\n *      (1) This function is called on 8 or 32 bpp src and dest images.\n *      (2) size is the full width of the lowpass smoothing filter.\n *          It is correlated with the reduction ratio, being the\n *          nearest integer such that size is approximately equal to hs / hd.\n */",
      "file" : "scalelow.c"
   },
   {
      "function" : "scaleToGray16Low",
      "comment" : "/*!\n *  scaleToGray16Low()\n *\n *      Input:  usual image variables\n *              tab8  (made from makePixelSumTab8())\n *      Return: 0 if OK; 1 on error.\n *\n *  The output is processed one dest byte at a time, corresponding\n *  to 16 rows consisting each of 2 src bytes in the input image.\n *  This uses one lookup table, tab8, which gives the sum of\n *  ON pixels in a byte.  After summing for all ON pixels in the\n *  32 src bytes, which is between 0 and 256, this is converted\n *  to an 8 bpp grayscale value between 0 (for 255 or 256 bits ON)\n *  and 255 (for 0 bits ON).\n */",
      "file" : "scalelow.c"
   },
   {
      "function" : "scaleToGray2Low",
      "comment" : "/*!\n *  scaleToGray2Low()\n *\n *      Input:  usual image variables\n *              sumtab  (made from makeSumTabSG2())\n *              valtab  (made from makeValTabSG2())\n *      Return: 0 if OK; 1 on error.\n *\n *  The output is processed in sets of 4 output bytes on a row,\n *  corresponding to 4 2x2 bit-blocks in the input image.\n *  Two lookup tables are used.  The first, sumtab, gets the\n *  sum of ON pixels in 4 sets of two adjacent bits,\n *  storing the result in 4 adjacent bytes.  After sums from\n *  two rows have been added, the second table, valtab,\n *  converts from the sum of ON pixels in the 2x2 block to\n *  an 8 bpp grayscale value between 0 (for 4 bits ON)\n *  and 255 (for 0 bits ON).\n */",
      "file" : "scalelow.c"
   },
   {
      "function" : "scaleToGray3Low",
      "comment" : "/*!\n *  scaleToGray3Low()\n *\n *      Input:  usual image variables\n *              sumtab  (made from makeSumTabSG3())\n *              valtab  (made from makeValTabSG3())\n *      Return: 0 if OK; 1 on error\n *\n *  Each set of 8 3x3 bit-blocks in the source image, which\n *  consist of 72 pixels arranged 24 pixels wide by 3 scanlines,\n *  is converted to a row of 8 8-bit pixels in the dest image.\n *  These 72 pixels of the input image are runs of 24 pixels\n *  in three adjacent scanlines.  Each run of 24 pixels is\n *  stored in the 24 LSbits of a 32-bit word.  We use 2 LUTs.\n *  The first, sumtab, takes 6 of these bits and stores\n *  sum, taken 3 bits at a time, in two bytes.  (See\n *  makeSumTabSG3).  This is done for each of the 3 scanlines,\n *  and the results are added.  We now have the sum of ON pixels\n *  in the first two 3x3 blocks in two bytes.  The valtab LUT\n *  then converts these values (which go from 0 to 9) to\n *  grayscale values between between 255 and 0.  (See makeValTabSG3).\n *  This process is repeated for each of the other 3 sets of\n *  6x3 input pixels, giving 8 output pixels in total.\n *\n *  Note: because the input image is processed in groups of\n *        24 x 3 pixels, the process clips the input height to\n *        (h - h % 3) and the input width to (w - w % 24).\n */",
      "file" : "scalelow.c"
   },
   {
      "function" : "scaleToGray4Low",
      "comment" : "/*!\n *  scaleToGray4Low()\n *\n *      Input:  usual image variables\n *              sumtab  (made from makeSumTabSG4())\n *              valtab  (made from makeValTabSG4())\n *      Return: 0 if OK; 1 on error.\n *\n *  The output is processed in sets of 2 output bytes on a row,\n *  corresponding to 2 4x4 bit-blocks in the input image.\n *  Two lookup tables are used.  The first, sumtab, gets the\n *  sum of ON pixels in two sets of four adjacent bits,\n *  storing the result in 2 adjacent bytes.  After sums from\n *  four rows have been added, the second table, valtab,\n *  converts from the sum of ON pixels in the 4x4 block to\n *  an 8 bpp grayscale value between 0 (for 16 bits ON)\n *  and 255 (for 0 bits ON).\n */",
      "file" : "scalelow.c"
   },
   {
      "function" : "scaleToGray6Low",
      "comment" : "/*!\n *  scaleToGray6Low()\n *\n *      Input:  usual image variables\n *              tab8  (made from makePixelSumTab8())\n *              valtab  (made from makeValTabSG6())\n *      Return: 0 if OK; 1 on error\n *\n *  Each set of 4 6x6 bit-blocks in the source image, which\n *  consist of 144 pixels arranged 24 pixels wide by 6 scanlines,\n *  is converted to a row of 4 8-bit pixels in the dest image.\n *  These 144 pixels of the input image are runs of 24 pixels\n *  in six adjacent scanlines.  Each run of 24 pixels is\n *  stored in the 24 LSbits of a 32-bit word.  We use 2 LUTs.\n *  The first, tab8, takes 6 of these bits and stores\n *  sum in one byte.  This is done for each of the 6 scanlines,\n *  and the results are added.\n *  We now have the sum of ON pixels in the first 6x6 block.  The\n *  valtab LUT then converts these values (which go from 0 to 36) to\n *  grayscale values between between 255 and 0.  (See makeValTabSG6).\n *  This process is repeated for each of the other 3 sets of\n *  6x6 input pixels, giving 4 output pixels in total.\n *\n *  Note: because the input image is processed in groups of\n *        24 x 6 pixels, the process clips the input height to\n *        (h - h % 6) and the input width to (w - w % 24).\n *\n */",
      "file" : "scalelow.c"
   },
   {
      "function" : "scaleToGray8Low",
      "comment" : "/*!\n *  scaleToGray8Low()\n *\n *      Input:  usual image variables\n *              tab8  (made from makePixelSumTab8())\n *              valtab  (made from makeValTabSG8())\n *      Return: 0 if OK; 1 on error.\n *\n *  The output is processed one dest byte at a time,\n *  corresponding to 8 rows of src bytes in the input image.\n *  Two lookup tables are used.  The first, tab8, gets the\n *  sum of ON pixels in a byte.  After sums from 8 rows have\n *  been added, the second table, valtab, converts from this\n *  value (which is between 0 and 64) to an 8 bpp grayscale\n *  value between 0 (for all 64 bits ON) and 255 (for 0 bits ON).\n */",
      "file" : "scalelow.c"
   },
   {
      "function" : "searchForProtoSignature",
      "comment" : "/*\n *  searchForProtoSignature()\n *\n *      Input:  sa (output from cpp, by line)\n *              begin (beginning index to search)\n *              &start (<return> starting index for function definition)\n *              &stop (<return> index of line on which proto is completed)\n *              &charindex (<return> char index of completing ')' character)\n *              &found (<return> 1 if valid signature is found; 0 otherwise)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If this returns found == 0, it means that there are no\n *          more function definitions in the file.  Caller must check\n *          this value and exit the loop over the entire cpp file.\n *      (2) This follows plan 3 (see above).  We skip comment and blank\n *          lines at the beginning.  Then we don't check for keywords.\n *          Instead, find the relative locations of the first occurrences\n *          of these four tokens: left parenthesis (lp), right\n *          parenthesis (rp), left brace (lb) and semicolon (sc).\n *      (3) The signature of a function definition looks like this:\n *               .... '(' .... ')' '{'\n *          where the lp and rp must both precede the lb, with only\n *          whitespace between the rp and the lb.  The '....'\n *          are sets of tokens that have no braces.\n *      (4) If a function definition is found, this returns found = 1,\n *          with 'start' being the first line of the definition and\n *          'charindex' being the position of the ')' in line 'stop'\n *          at the end of the arg list.\n */",
      "file" : "parseprotos.c"
   },
   {
      "function" : "seedfillBinaryLow",
      "comment" : "/*!\n *  seedfillBinaryLow()\n *\n *  Notes:\n *      (1) This is an in-place fill, where the seed image is\n *          filled, clipping to the filling mask, in one full\n *          cycle of UL -> LR and LR -> UL raster scans.\n *      (2) Assume the mask is a filling mask, not a blocking mask.\n *      (3) Assume that the RHS pad bits of the mask\n *          are properly set to 0.\n *      (4) Clip to the smallest dimensions to avoid invalid reads.\n */",
      "file" : "seedfilllow.c"
   },
   {
      "function" : "seedfillGrayInvLow",
      "comment" : "/*!\n *  seedfillGrayInvLow()\n *\n *  Notes:\n *      (1) The pixels are numbered as follows:\n *              1  2  3\n *              4  x  5\n *              6  7  8\n *          This low-level filling operation consists of two scans,\n *          raster and anti-raster, covering the entire seed image.\n *          During the anti-raster scan, every pixel p such that its\n *          current value could still be propogated during the next\n *          raster scanning is put into the FIFO-queue.\n *          Next step is the propagation step where where we update\n *          and propagate the values using FIFO structure created in\n *          anti-raster scan.\n *      (2) The \"Inv\" signifies the fact that in this case, filling\n *          of the seed only takes place when the seed value is\n *          greater than the mask value.  The mask will act to stop\n *          the fill when it is higher than the seed level.  (This is\n *          in contrast to conventional grayscale filling where the\n *          seed always fills below the mask.)\n *      (3) An example of use is a basin, described by the mask (pixm),\n *          where within the basin, the seed pix (pixs) gets filled to the\n *          height of the highest seed pixel that is above its\n *          corresponding max pixel.  Filling occurs while the\n *          propagating seed pixels in pixs are larger than the\n *          corresponding mask values in pixm.\n *      (4) Reference paper :\n *            L. Vincent, Morphological grayscale reconstruction in image\n *            analysis: applications and efficient algorithms, IEEE Transactions\n *            on  Image Processing, vol. 2, no. 2, pp. 176-201, 1993.\n */",
      "file" : "seedfilllow.c"
   },
   {
      "function" : "seedfillGrayInvLowSimple",
      "comment" : "/*!\n *  seedfillGrayInvLowSimple()\n *\n *  Notes:\n *      (1) The pixels are numbered as follows:\n *              1  2  3\n *              4  x  5\n *              6  7  8\n *          This low-level filling operation consists of two scans,\n *          raster and anti-raster, covering the entire seed image.\n *          The caller typically iterates until the filling is\n *          complete.\n *      (2) The \"Inv\" signifies the fact that in this case, filling\n *          of the seed only takes place when the seed value is\n *          greater than the mask value.  The mask will act to stop\n *          the fill when it is higher than the seed level.  (This is\n *          in contrast to conventional grayscale filling where the\n *          seed always fills below the mask.)\n *      (3) An example of use is a basin, described by the mask (pixm),\n *          where within the basin, the seed pix (pixs) gets filled to the\n *          height of the highest seed pixel that is above its\n *          corresponding max pixel.  Filling occurs while the\n *          propagating seed pixels in pixs are larger than the\n *          corresponding mask values in pixm.\n */",
      "file" : "seedfilllow.c"
   },
   {
      "function" : "seedfillGrayLow",
      "comment" : "/*!\n *  seedfillGrayLow()\n *\n *  Notes:\n *      (1) The pixels are numbered as follows:\n *              1  2  3\n *              4  x  5\n *              6  7  8\n *          This low-level filling operation consists of two scans,\n *          raster and anti-raster, covering the entire seed image.\n *          This is followed by a breadth-first propagation operation to\n *          complete the fill.\n *          During the anti-raster scan, every pixel p whose current value\n *          could still be propagated after the anti-raster scan is put into\n *          the FIFO queue.\n *          The propagation step is a breadth-first fill to completion.\n *          Unlike the simple grayscale seedfill pixSeedfillGraySimple(),\n *          where at least two full raster/anti-raster iterations are required\n *          for completion and verification, the hybrid method uses only a\n *          single raster/anti-raster set of scans.\n *      (2) The filling action can be visualized from the following example.\n *          Suppose the mask, which clips the fill, is a sombrero-shaped\n *          surface, where the highest point is 200 and the low pixels\n *          around the rim are 30.  Beyond the rim, the mask goes up a bit.\n *          Suppose the seed, which is filled, consists of a single point\n *          of height 150, located below the max of the mask, with\n *          the rest 0.  Then in the raster scan, nothing happens until\n *          the high seed point is encountered, and then this value is\n *          propagated right and down, until it hits the side of the\n *          sombrero.   The seed can never exceed the mask, so it fills\n *          to the rim, going lower along the mask surface.  When it\n *          passes the rim, the seed continues to fill at the rim\n *          height to the edge of the seed image.  Then on the\n *          anti-raster scan, the seed fills flat inside the\n *          sombrero to the upper and left, and then out from the\n *          rim as before.  The final result has a seed that is\n *          flat outside the rim, and inside it fills the sombrero\n *          but only up to 150.  If the rim height varies, the\n *          filled seed outside the rim will be at the highest\n *          point on the rim, which is a saddle point on the rim.\n *      (3) Reference paper :\n *            L. Vincent, Morphological grayscale reconstruction in image\n *            analysis: applications and efficient algorithms, IEEE Transactions\n *            on  Image Processing, vol. 2, no. 2, pp. 176-201, 1993.\n */",
      "file" : "seedfilllow.c"
   },
   {
      "function" : "seedfillGrayLowSimple",
      "comment" : "/*!\n *  seedfillGrayLowSimple()\n *\n *  Notes:\n *      (1) The pixels are numbered as follows:\n *              1  2  3\n *              4  x  5\n *              6  7  8\n *          This low-level filling operation consists of two scans,\n *          raster and anti-raster, covering the entire seed image.\n *          The caller typically iterates until the filling is\n *          complete.\n *      (2) The filling action can be visualized from the following example.\n *          Suppose the mask, which clips the fill, is a sombrero-shaped\n *          surface, where the highest point is 200 and the low pixels\n *          around the rim are 30.  Beyond the rim, the mask goes up a bit.\n *          Suppose the seed, which is filled, consists of a single point\n *          of height 150, located below the max of the mask, with\n *          the rest 0.  Then in the raster scan, nothing happens until\n *          the high seed point is encountered, and then this value is\n *          propagated right and down, until it hits the side of the\n *          sombrero.   The seed can never exceed the mask, so it fills\n *          to the rim, going lower along the mask surface.  When it\n *          passes the rim, the seed continues to fill at the rim\n *          height to the edge of the seed image.  Then on the\n *          anti-raster scan, the seed fills flat inside the\n *          sombrero to the upper and left, and then out from the\n *          rim as before.  The final result has a seed that is\n *          flat outside the rim, and inside it fills the sombrero\n *          but only up to 150.  If the rim height varies, the\n *          filled seed outside the rim will be at the highest\n *          point on the rim, which is a saddle point on the rim.\n */",
      "file" : "seedfilllow.c"
   },
   {
      "function" : "seedspreadLow",
      "comment" : "/*!\n *  seedspreadLow()\n *\n *    See pixSeedspread() for a brief description of the algorithm here.\n */",
      "file" : "seedfilllow.c"
   },
   {
      "function" : "selCopy",
      "comment" : "/*!\n *  selCopy()\n *\n *      Input:  sel\n *      Return: a copy of the sel, or null on error\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selCreate",
      "comment" : "/*!\n *  selCreate()\n *\n *      Input:  height, width\n *              name (<optional> sel name; can be null)\n *      Return: sel, or null on error\n *\n *  Notes:\n *      (1) selCreate() initializes all values to 0.\n *      (2) After this call, (cy,cx) and nonzero data values must be\n *          assigned.  If a text name is not assigned here, it will\n *          be needed later when the sel is put into a sela.\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selCreateBrick",
      "comment" : "/*!\n *  selCreateBrick()\n *\n *      Input:  height, width\n *              cy, cx  (origin, relative to UL corner at 0,0)\n *              type  (SEL_HIT, SEL_MISS, or SEL_DONT_CARE)\n *      Return: sel, or null on error\n *\n *  Notes:\n *      (1) This is a rectangular sel of all hits, misses or don't cares.\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selCreateComb",
      "comment" : "/*!\n *  selCreateComb()\n *\n *      Input:  factor1 (contiguous space between comb tines)\n *              factor2 (number of comb tines)\n *              direction (L_HORIZ, L_VERT)\n *      Return: sel, or null on error\n *\n *  Notes:\n *      (1) This generates a comb Sel of hits with the origin as\n *          near the center as possible.\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selCreateFromColorPix",
      "comment" : "/*!\n *\n *  selCreateFromColorPix()\n *\n *      Input:  pixs (cmapped or rgb)\n *              selname (<optional> sel name; can be null)\n *      Return: sel if OK, null on error\n *\n *  Notes:\n *      (1) The sel size is given by the size of pixs.\n *      (2) In pixs, hits are represented by green pixels, misses by red\n *          pixels, and don't-cares by white pixels.\n *      (3) In pixs, there may be no misses, but there must be at least 1 hit.\n *      (4) At most there can be only one origin pixel, which is optionally\n *          specified by using a lower-intensity pixel:\n *            if a hit:  dark green\n *            if a miss: dark red\n *            if a don't care: gray\n *          If there is no such pixel, the origin defaults to the approximate\n *          center of the sel.\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selCreateFromPix",
      "comment" : "/*!\n *  selCreateFromPix()\n *\n *      Input:  pix\n *              cy, cx (origin of sel)\n *              name (<optional> sel name; can be null)\n *      Return: sel, or null on error\n *\n *  Notes:\n *      (1) The origin must be positive.\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selCreateFromPta",
      "comment" : "/*!\n *  selCreateFromPta()\n *\n *      Input:  pta\n *              cy, cx (origin of sel)\n *              name (<optional> sel name; can be null)\n *      Return: sel (of minimum required size), or null on error\n *\n *  Notes:\n *      (1) The origin and all points in the pta must be positive.\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selCreateFromSArray",
      "comment" : "/*!\n *  selCreateFromSArray()\n *\n *      Input:  sa\n *              first (line of sarray where Sel begins)\n *              last (line of sarray where Sel ends)\n *      Return: sela, or null on error\n *\n *  Notes:\n *      (1) The Sel contains the following lines:\n *          - The first line is the selname\n *          - The remaining lines contain the Sel data.  They must\n *            be formatted similarly to the string format in\n *            selCreateFromString(), with each line beginning and\n *            ending with a double-quote, and showing the 2D layout.\n *          - 'last' gives the last line in the Sel data.\n *      (2) See selCreateFromString() for a description of the string\n *          format for the Sel data.  As an example, here are the lines\n *          of is a valid file for a single Sel.  In the file, all lines\n *          are left-justified:\n *                    # diagonal sel\n *                    sel_5diag\n *                    \"x    \"\n *                    \" x   \"\n *                    \"  X  \"\n *                    \"   x \"\n *                    \"    x\"\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selCreateFromString",
      "comment" : "/*!\n *  selCreateFromString()\n *\n *      Input:  text\n *              height, width\n *              name (<optional> sel name; can be null)\n *      Return: sel of the given size, or null on error\n *\n *  Notes:\n *      (1) The text is an array of chars (in row-major order) where\n *          each char can be one of the following:\n *             'x': hit\n *             'o': miss\n *             ' ': don't-care\n *      (2) Use an upper case char to indicate the origin of the Sel.\n *          When the origin falls on a don't-care, use 'C' as the uppecase\n *          for ' '.\n *      (3) The text can be input in a format that shows the 2D layout; e.g.,\n *              static const char *seltext = \"x    \"\n *                                           \"x Oo \"\n *                                           \"x    \"\n *                                           \"xxxxx\";\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selDestroy",
      "comment" : "/*!\n *  selDestroy()\n *\n *      Input:  &sel (<to be nulled>)\n *      Return: void\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selDisplayInPix",
      "comment" : "/*!\n *  selDisplayInPix()\n *\n *      Input:  sel\n *              size (of grid interiors; odd; minimum size of 13 is enforced)\n *              gthick (grid thickness; minimum size of 2 is enforced)\n *      Return: pix (display of sel), or null on error\n *\n *  Notes:\n *      (1) This gives a visual representation of a general (hit-miss) sel.\n *      (2) The empty sel is represented by a grid of intersecting lines.\n *      (3) Three different patterns are generated for the sel elements:\n *          - hit (solid black circle)\n *          - miss (black ring; inner radius is radius2)\n *          - origin (cross, XORed with whatever is there)\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selFindMaxTranslations",
      "comment" : "/*!\n *  selFindMaxTranslations()\n *\n *      Input:  sel\n *              &xp, &yp, &xn, &yn  (<return> max shifts)\n *      Return: 0 if OK; 1 on error\n *\n *  Note: these are the maximum shifts for the erosion operation.\n *        For example, when j < cx, the shift of the image\n *        is +x to the cx.  This is a positive xp shift.\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selGetElement",
      "comment" : "/*!\n *  selGetElement()\n *\n *      Input:  sel\n *              row\n *              col\n *              &type  (<return> SEL_HIT, SEL_MISS, SEL_DONT_CARE)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selGetName",
      "comment" : "/*!\n *  selGetName()\n *\n *      Input:  sel\n *      Return: sel name (not copied), or null if no name or on error\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selGetParameters",
      "comment" : "/*!\n *  selGetParameters()\n *\n *      Input:  sel\n *              &sy, &sx, &cy, &cx (<optional return>; each can be null)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selGetTypeAtOrigin",
      "comment" : "/*!\n *  selGetTypeAtOrigin()\n *\n *      Input:  sel\n *              &type  (<return> SEL_HIT, SEL_MISS, SEL_DONT_CARE)\n *      Return: 0 if OK; 1 on error or if origin is not found\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selPrintToString",
      "comment" : "/*!\n *  selPrintToString()\n *\n *      Input:  sel\n *      Return: str (string; caller must free)\n *\n *  Notes:\n *      (1) This is an inverse function of selCreateFromString.\n *          It prints a textual representation of the SEL to a malloc'd\n *          string.  The format is the same as selCreateFromString\n *          except that newlines are inserted into the output\n *          between rows.\n *      (2) This is useful for debugging.  However, if you want to\n *          save some Sels in a file, put them in a Sela and write\n *          them out with selaWrite().  They can then be read in\n *          with selaRead().\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selRead",
      "comment" : "/*!\n *  selRead()\n *\n *      Input:  filename\n *      Return: sel, or null on error\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selReadFromColorImage",
      "comment" : "/*!\n *\n *  selReadFromColorImage()\n *\n *      Input:  pathname\n *      Return: sel if OK; null on error\n *\n *  Notes:\n *      (1) Loads an image from a file and creates a (hit-miss) sel.\n *      (2) The sel name is taken from the pathname without the directory\n *          and extension.\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selReadStream",
      "comment" : "/*!\n *  selReadStream()\n *\n *      Input:  stream\n *      Return: sel, or null on error\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selRotateOrth",
      "comment" : "/*!\n *  selRotateOrth()\n *\n *      Input:  sel\n *              quads (0 - 4; number of 90 degree cw rotations)\n *      Return: seld, or null on error\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selSetElement",
      "comment" : "/*!\n *  selSetElement()\n *\n *      Input:  sel\n *              row\n *              col\n *              type  (SEL_HIT, SEL_MISS, SEL_DONT_CARE)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) Because we use row and column to index into an array,\n *          they are always non-negative.  The location of the origin\n *          (and the type of operation) determine the actual\n *          direction of the rasterop.\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selSetName",
      "comment" : "/*!\n *  selSetName()\n *\n *      Input:  sel\n *              name (<optional>; can be null)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Always frees the existing sel name, if defined.\n *      (2) If name is not defined, just clears any existing sel name.\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selSetOrigin",
      "comment" : "/*!\n *  selSetOrigin()\n *\n *      Input:  sel\n *              cy, cx\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selWrite",
      "comment" : "/*!\n *  selWrite()\n *\n *      Input:  filename\n *              sel\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selWriteStream",
      "comment" : "/*!\n *  selWriteStream()\n *\n *      Input:  stream\n *              sel\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selaAddBasic",
      "comment" : "/*!\n *  selaAddBasic()\n *\n *      Input:  sela (<optional>)\n *      Return: sela with additional sels, or null on error\n *\n *  Notes:\n *      (1) Adds the following sels:\n *            - all linear (horiz, vert) brick sels that are\n *              necessary for decomposable sels up to size 63\n *            - square brick sels up to size 10\n *            - 4 diagonal sels\n */",
      "file" : "sel2.c"
   },
   {
      "function" : "selaAddCrossJunctions",
      "comment" : "/*!\n *  selaAddCrossJunctions()\n *\n *      Input:  sela (<optional>)\n *              hlsize (length of each line of hits from origin)\n *              mdist (distance of misses from the origin)\n *              norient (number of orientations; max of 8)\n *              debugflag (1 for debug output)\n *      Return: sela with additional sels, or null on error\n *\n *  Notes:\n *      (1) Adds hitmiss Sels for the intersection of two lines.\n *          If the lines are very thin, they must be nearly orthogonal\n *          to register.\n *      (2) The number of Sels generated is equal to @norient.\n *      (3) If @norient == 2, this generates 2 Sels of crosses, each with\n *          two perpendicular lines of hits.  One Sel has horizontal and\n *          vertical hits; the other has hits along lines at +-45 degrees.\n *          Likewise, if @norient == 3, this generates 3 Sels of crosses\n *          oriented at 30 degrees with each other.\n *      (4) It is suggested that @hlsize be chosen at least 1 greater\n *          than @mdist.  Try values of (@hlsize, @mdist) such as\n *          (6,5), (7,6), (8,7), (9,7), etc.\n */",
      "file" : "sel2.c"
   },
   {
      "function" : "selaAddDwaCombs",
      "comment" : "/*!\n *  selaAddDwaCombs()\n *\n *      Input:  sela (<optional>)\n *      Return: sela with additional sels, or null on error\n *\n *  Notes:\n *      (1) Adds all comb (horizontal, vertical) Sels that are\n *          used in composite linear morphological operations\n *          up to 63 pixels in length, which are the sizes over\n *          which dwa code can be generated.\n */",
      "file" : "sel2.c"
   },
   {
      "function" : "selaAddDwaLinear",
      "comment" : "/*!\n *  selaAddDwaLinear()\n *\n *      Input:  sela (<optional>)\n *      Return: sela with additional sels, or null on error\n *\n *  Notes:\n *      (1) Adds all linear (horizontal, vertical) sels from\n *          2 to 63 pixels in length, which are the sizes over\n *          which dwa code can be generated.\n */",
      "file" : "sel2.c"
   },
   {
      "function" : "selaAddHitMiss",
      "comment" : "/*!\n *  selaAddHitMiss()\n *\n *      Input:  sela  (<optional>)\n *      Return: sela with additional sels, or null on error\n */",
      "file" : "sel2.c"
   },
   {
      "function" : "selaAddSel",
      "comment" : "/*!\n *  selaAddSel()\n *\n *      Input:  sela\n *              sel to be added\n *              selname (ignored if already defined in sel;\n *                       req'd in sel when added to a sela)\n *              copyflag (for sel: 0 inserts, 1 copies)\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) This adds a sel, either inserting or making a copy.\n *      (2) Because every sel in a sela must have a name, it copies\n *          the input name if necessary.  You can input NULL for\n *          selname if the sel already has a name.\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selaAddTJunctions",
      "comment" : "/*!\n *  selaAddTJunctions()\n *\n *      Input:  sela (<optional>)\n *              hlsize (length of each line of hits from origin)\n *              mdist (distance of misses from the origin)\n *              norient (number of orientations; max of 8)\n *              debugflag (1 for debug output)\n *      Return: sela with additional sels, or null on error\n *\n *  Notes:\n *      (1) Adds hitmiss Sels for the T-junction of two lines.\n *          If the lines are very thin, they must be nearly orthogonal\n *          to register.\n *      (2) The number of Sels generated is 4 * @norient.\n *      (3) It is suggested that @hlsize be chosen at least 1 greater\n *          than @mdist.  Try values of (@hlsize, @mdist) such as\n *          (6,5), (7,6), (8,7), (9,7), etc.\n */",
      "file" : "sel2.c"
   },
   {
      "function" : "selaCreate",
      "comment" : "/*!\n *  selaCreate()\n *\n *      Input:  n (initial number of sel ptrs; use 0 for default)\n *      Return: sela, or null on error\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selaCreateFromFile",
      "comment" : "/*!\n *  selaCreateFromFile()\n *\n *      Input:  filename\n *      Return: sela, or null on error\n *\n *  Notes:\n *      (1) The file contains a sequence of Sel descriptions.\n *      (2) Each Sel is formatted as follows:\n *           - Any number of comment lines starting with '#' are ignored\n *           - The next line contains the selname\n *           - The next lines contain the Sel data.  They must be\n *             formatted similarly to the string format in\n *             selCreateFromString(), with each line beginning and\n *             ending with a double-quote, and showing the 2D layout.\n *           - Each Sel ends when a blank line, a comment line, or\n *             the end of file is reached.\n *      (3) See selCreateFromString() for a description of the string\n *          format for the Sel data.  As an example, here are the lines\n *          of is a valid file for a single Sel.  In the file, all lines\n *          are left-justified:\n *                    # diagonal sel\n *                    sel_5diag\n *                    \"x    \"\n *                    \" x   \"\n *                    \"  X  \"\n *                    \"   x \"\n *                    \"    x\"\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selaDestroy",
      "comment" : "/*!\n *  selaDestroy()\n *\n *      Input:  &sela (<to be nulled>)\n *      Return: void\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selaDisplayInPix",
      "comment" : "/*!\n *  selaDisplayInPix()\n *\n *      Input:  sela\n *              size (of grid interiors; odd; minimum size of 13 is enforced)\n *              gthick (grid thickness; minimum size of 2 is enforced)\n *              spacing (between sels, both horizontally and vertically)\n *              ncols (number of sels per \"line\")\n *      Return: pix (display of all sels in sela), or null on error\n *\n *  Notes:\n *      (1) This gives a visual representation of all the sels in a sela.\n *      (2) See notes in selDisplayInPix() for display params of each sel.\n *      (3) This gives the nicest results when all sels in the sela\n *          are the same size.\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selaExtendArray",
      "comment" : "/*!\n *  selaExtendArray()\n *\n *      Input:  sela\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selaFindSelByName",
      "comment" : "/*!\n *  selaFindSelByName()\n *\n *      Input:  sela\n *              sel name\n *              &index (<optional, return>)\n *              &sel  (<optional, return> sel (not a copy))\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selaGetBrickName",
      "comment" : "/*!\n *  selaGetBrickName()\n *\n *      Input:  sela\n *              hsize, vsize (of brick sel)\n *      Return: sel name (new string), or null if no name or on error\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selaGetCombName",
      "comment" : "/*!\n *  selaGetCombName()\n *\n *      Input:  sela\n *              size (the product of sizes of the brick and comb parts)\n *              direction (L_HORIZ, L_VERT)\n *      Return: sel name (new string), or null if name not found or on error\n *\n *  Notes:\n *      (1) Combs are by definition 1-dimensional, either horiz or vert.\n *      (2) Use this with comb Sels; e.g., from selaAddDwaCombs().\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selaGetCount",
      "comment" : "/*!\n *  selaGetCount()\n *\n *      Input:  sela\n *      Return: count, or 0 on error\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selaGetSel",
      "comment" : "/*!\n *  selaGetSel()\n *\n *      Input:  sela\n *              index of sel to be retrieved (not copied)\n *      Return: sel, or null on error\n *\n *  Notes:\n *      (1) This returns a ptr to the sel, not a copy, so the caller\n *          must not destroy it!\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selaGetSelnames",
      "comment" : "/*!\n *  selaGetSelnames()\n *\n *      Input:  sela\n *      Return: sa (of all sel names), or null on error\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selaRead",
      "comment" : "/*!\n *  selaRead()\n *\n *      Input:  filename\n *      Return: sela, or null on error\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selaReadStream",
      "comment" : "/*!\n *  selaReadStream()\n *\n *      Input:  stream\n *      Return: sela, or null on error\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selaWrite",
      "comment" : "/*!\n *  selaWrite()\n *\n *      Input:  filename\n *              sela\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selaWriteStream",
      "comment" : "/*!\n *  selaWriteStream()\n *\n *      Input:  stream\n *              sela\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "sel1.c"
   },
   {
      "function" : "selectComposableSels",
      "comment" : "/*  selectComposableSels()\n *\n *      Input:  size (of composed sel)\n *              direction (L_HORIZ, L_VERT)\n *              &sel1 (<optional return> contiguous sel; can be null)\n *              &sel2 (<optional return> comb sel; can be null)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) When using composable Sels, where the original Sel is\n *          decomposed into two, the best you can do in terms\n *          of reducing the computation is by a factor:\n *\n *               2 * sqrt(size) / size\n *\n *          In practice, you get quite close to this.  E.g.,\n *\n *             Sel size     |   Optimum reduction factor\n *             --------         ------------------------\n *                36        |          1/3\n *                64        |          1/4\n *               144        |          1/6\n *               256        |          1/8\n */",
      "file" : "morph.c"
   },
   {
      "function" : "selectComposableSizes",
      "comment" : "/*!\n *  selectComposableSizes()\n *\n *      Input:  size (of sel to be decomposed)\n *              &factor1 (<return> larger factor)\n *              &factor2 (<return> smaller factor)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This works for Sel sizes up to 62500, which seems sufficient.\n *      (2) The composable sel size is typically within +- 1 of\n *          the requested size.  Up to size = 300, the maximum difference\n *          is +- 2.\n *      (3) We choose an overall cost function where the penalty for\n *          the size difference between input and actual is 4 times\n *          the penalty for additional rasterops.\n *      (4) Returned values: factor1 >= factor2\n *          If size > 1, then factor1 > 1.\n */",
      "file" : "morph.c"
   },
   {
      "function" : "selectDefaultPdfEncoding",
      "comment" : "/*!\n *  selectDefaultPdfEncoding()\n *\n *      Input:  pix\n *              &type (<return> L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE)\n *\n *  Notes:\n *      (1) This attempts to choose an encoding for the pix that results\n *          in the smallest file, assuming that if jpeg encoded, it will\n *          use quality = 75.  The decision is approximate, in that\n *          (a) all colormapped images will be losslessly encoded with\n *          gzip (flate), and (b) an image with less than about 20 colors\n *          is likely to be smaller if flate encoded than if encoded\n *          as a jpeg (dct).  For example, an image made by pixScaleToGray3()\n *          will have 10 colors, and flate encoding will give about\n *          twice the compression as jpeg with quality = 75.\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "setColormap",
      "comment" : "/*!\n *  setColormap(LPBITMAPINFO pbmi, PIXCMAP *cmap)\n *\n *      Input:  pbmi (pointer to a BITMAPINFO describing a DIB)\n *              cmap (leptonica colormap)\n *      Return: number of colors in cmap\n */",
      "file" : "leptwin.c"
   },
   {
      "function" : "setMsgSeverity",
      "comment" : "/*!\n *  setMsgSeverity()\n *\n *      Input:  newsev\n *      Return: oldsev\n *\n *  Notes:\n *      (1) setMsgSeverity() allows the user to specify the desired\n *          message severity threshold.  Messages of equal or greater\n *          severity will be output.  The previous message severity is\n *          returned when the new severity is set.\n *      (2) If L_SEVERITY_EXTERNAL is passed, then the severity will be\n *          obtained from the LEPT_MSG_SEVERITY environment variable.\n *          If the environmental variable is not set, a warning is issued.\n */",
      "file" : "utils.c"
   },
   {
      "function" : "setPixMemoryManager",
      "comment" : "/*!\n *  setPixMemoryManager()\n *\n *      Input: allocator (<optional>; use null to skip)\n *             deallocator (<optional>; use null to skip)\n *      Return: void\n *\n *  Notes:\n *      (1) Use this to change the alloc and/or dealloc functions;\n *          e.g., setPixMemoryManager(my_malloc, my_free).\n *      (2) The C99 standard (section 6.7.5.3, par. 8) says:\n *            A declaration of a parameter as \"function returning type\"\n *            shall be adjusted to \"pointer to function returning type\"\n *          so that it can be in either of these two forms:\n *            (a) type (function-ptr(type, ...))\n *            (b) type ((*function-ptr)(type, ...))\n *          because form (a) is implictly converted to form (b), as in the\n *          definition of struct PixMemoryManager above.  So, for example,\n *          we should be able to declare either of these:\n *            (a) void *(allocator(size_t))\n *            (b) void *((*allocator)(size_t))\n *          However, MSVC++ only accepts the second version.\n */",
      "file" : "pix1.c"
   },
   {
      "function" : "setPixelLow",
      "comment" : "/*!\n *  setPixelLow()\n *\n *      Input:  line (ptr to beginning of line),\n *              x (pixel location in line)\n *              depth (bpp)\n *              val (to be inserted)\n *      Return: void\n *\n *  Notes:\n *      (1) Caution: input variables are not checked!\n */",
      "file" : "pix2.c"
   },
   {
      "function" : "shiftDataHorizontalLow",
      "comment" : "/*!\n *  shiftDataHorizontalLow()\n *\n *      Input:  datad  (ptr to beginning of dest line)\n *              wpld   (wpl of dest)\n *              datas  (ptr to beginning of src line)\n *              wpls   (wpl of src)\n *              shift  (horizontal shift of block; >0 is to right)\n *      Return: void\n *\n *  Notes:\n *      (1) This can also be used for in-place operation; see, e.g.,\n *          rasteropHipLow().\n *      (2) We are clearing the pixels that are shifted in from\n *          outside the image.  This can be overridden by the\n *          incolor parameter in higher-level functions that call this.\n */",
      "file" : "ropiplow.c"
   },
   {
      "function" : "skipToEndOfFunction",
      "comment" : "/*\n *  skipToEndOfFunction()\n *\n *      Input:  sa (output from cpp, by line)\n *              start (index of starting line with left bracket to search)\n *              lbindex (starting char index for left bracket)\n *              &next (index of line following the ending '}' for function\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "parseprotos.c"
   },
   {
      "function" : "skipToMatchingBrace",
      "comment" : "/*\n *  skipToMatchingBrace()\n *\n *      Input:  sa (output from cpp, by line)\n *              start (index of starting line with left bracket to search)\n *              lbindex (starting char index for left bracket)\n *              &stop (index of line with the matching right bracket)\n *              &rbindex (char index of matching right bracket)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If the matching right brace is not found, returns\n *          stop = -1.  This shouldn't happen.\n */",
      "file" : "parseprotos.c"
   },
   {
      "function" : "skipToSemicolon",
      "comment" : "/*\n *  skipToSemicolon()\n *\n *      Input:  sa (output from cpp, by line)\n *              start (index of starting line to search)\n *              charindex (starting char index for search)\n *              &next (index of line containing the next ';')\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If the semicolon isn't found, returns next = -1.\n *          This shouldn't happen.\n *      (2) This is only used in contexts where the semicolon is\n *          not within a string.\n */",
      "file" : "parseprotos.c"
   },
   {
      "function" : "splitPathAtDirectory",
      "comment" : "/*!\n *  splitPathAtDirectory()\n *\n *      Input:  pathname  (full path; can be a directory)\n *              &dir  (<optional return> root directory name of\n *                     input path, including trailing '/')\n *              &tail (<optional return> path tail, which is either\n *                     the file name within the root directory or\n *                     the last sub-directory in the path)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If you only want the tail, input null for the root directory ptr.\n *      (2) If you only want the root directory name, input null for the\n *          tail ptr.\n *      (3) This function makes decisions based only on the lexical\n *          structure of the input.  Examples:\n *            /usr/tmp/abc  -->  dir: /usr/tmp/       tail: abc\n *            /usr/tmp/     -->  dir: /usr/tmp/       tail: [empty string]\n *            /usr/tmp      -->  dir: /usr/           tail: tmp\n *            abc           -->  dir: [empty string]  tail: abc\n *      (4) For unix, the input pathname must have unix directory\n *          separators (i.e., forward slashes).  For windows, we allow\n *          both forward and backward slash separators, because Win32\n *          pathname functions generally accept either slash form.\n *          Note, however, that the windows command line interpreter\n *          only accepts backward slashes, because forward slashes are\n *          used to demarcate switches (vs. dashes in unix).\n */",
      "file" : "utils.c"
   },
   {
      "function" : "splitPathAtExtension",
      "comment" : "/*!\n *  splitPathAtExtension()\n *\n *      Input:  pathname (full path; can be a directory)\n *              &basename (<optional return> pathname not including the\n *                        last dot and characters after that)\n *              &extension (<optional return> path extension, which is\n *                        the last dot and the characters after it.  If\n *                        there is no extension, it returns the empty string)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If you only want the extension, input null for the basename ptr.\n *      (2) If you only want the basename without extension, input null\n *          for the extension ptr.\n *      (3) This function makes decisions based only on the lexical\n *          structure of the input.  Examples:\n *            /usr/tmp/abc.jpg  -->  basename: /usr/tmp/abc    ext: .jpg\n *            /usr/tmp/.jpg     -->  basename: /usr/tmp/       ext: .jpg\n *            /usr/tmp.jpg/     -->  basename: /usr/tmp.jpg/   ext: [empty str]\n *            ./.jpg            -->  basename: ./              ext: .jpg\n *      (4) N.B. The input pathname must have unix directory separators\n *          for unix and windows directory separators for windows.\n */",
      "file" : "utils.c"
   },
   {
      "function" : "splitStringToParagraphs",
      "comment" : "/*!\n *  splitStringToParagraphs()\n *\n *      Input:  textstring\n *              splitting flag (see enum in bmf.h; valid values in {1,2,3})\n *      Return: sarray (where each string is a paragraph of the input),\n *                      or null on error.\n */",
      "file" : "textops.c"
   },
   {
      "function" : "sreadHeaderJp2k",
      "comment" : "/*!\n *  sreadHeaderJp2k()\n *\n *      Input:  data\n *              size\n *              &w (<optional return>)\n *              &h (<optional return>)\n *              &spp (<optional return>, samples/pixel)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The metadata is stored as follows:\n *          h:    4 bytes @ 48\n *          w:    4 bytes @ 52\n *          spp:  2 bytes @ 56\n */",
      "file" : "jp2kio.c"
   },
   {
      "function" : "sreadHeaderPng",
      "comment" : "/*!\n *  sreadHeaderPng()\n *\n *      Input:  data\n *              &w (<optional return>)\n *              &h (<optional return>)\n *              &bps (<optional return>, bits/sample)\n *              &spp (<optional return>, samples/pixel)\n *              &iscmap (<optional return>; input NULL to ignore)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) See readHeaderPng().\n *      (2) png colortypes (see png.h: PNG_COLOR_TYPE_*):\n *          0:  gray; fully transparent (with tRNS) (1 spp)\n *          2:  RGB (3 spp)\n *          3:  colormap; colormap+alpha (with tRNS) (1 spp)\n *          4:  gray + alpha (2 spp)\n *          6:  RGBA (4 spp)\n *          Note:\n *            0 and 3 have the alpha information in a tRNS chunk\n *            4 and 6 have separate alpha samples with each pixel.\n */",
      "file" : "pngio.c"
   },
   {
      "function" : "sreadHeaderPnm",
      "comment" : "/*!\n *  sreadHeaderPnm()\n *\n *      Input:  cdata (const; pnm-encoded)\n *              size (of data)\n *              &w (<optional return>)\n *              &h (<optional return>)\n *              &d (<optional return>)\n *              &type (<optional return> pnm type)\n *              &bps (<optional return>, bits/sample)\n *              &spp (<optional return>, samples/pixel)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "pnmio.c"
   },
   {
      "function" : "sreadHeaderSpix",
      "comment" : "/*!\n *  sreadHeaderSpix()\n *\n *      Input:  data\n *              &width (<return>)\n *              &height (<return>)\n *              &bps (<return>, bits/sample)\n *              &spp (<return>, samples/pixel)\n *              &iscmap (<optional return>; input NULL to ignore)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) If there is a colormap, iscmap is returned as 1; else 0.\n */",
      "file" : "spixio.c"
   },
   {
      "function" : "startTimer",
      "comment" : "/*!\n *  startTimer(), stopTimer()\n *\n *  Example of usage:\n *\n *      startTimer();\n *      ....\n *      fprintf(stderr, \"Elapsed time = %7.3f sec\\n\", stopTimer());\n */",
      "file" : "utils.c"
   },
   {
      "function" : "startTimer",
      "comment" : "/* Note: if division by 10^7 seems strange, the time is expressed\n     * as the number of 100-nanosecond intervals that have elapsed\n     * since 12:00 A.M. January 1, 1601.  */",
      "file" : "utils.c"
   },
   {
      "function" : "startTimerNested",
      "comment" : "/*!\n *  startTimerNested(), stopTimerNested()\n *\n *  Example of usage:\n *\n *      L_TIMER  t1 = startTimerNested();\n *      ....\n *      L_TIMER  t2 = startTimerNested();\n *      ....\n *      fprintf(stderr, \"Elapsed time 2 = %7.3f sec\\n\", stopTimerNested(t2));\n *      ....\n *      fprintf(stderr, \"Elapsed time 1 = %7.3f sec\\n\", stopTimerNested(t1));\n */",
      "file" : "utils.c"
   },
   {
      "function" : "startTimerNested",
      "comment" : "/* in units of hecto-nanosecond (100 ns) intervals */",
      "file" : "utils.c"
   },
   {
      "function" : "stopTimer",
      "comment" : "/*!\n *  startTimer(), stopTimer()\n *\n *  Example of usage:\n *\n *      startTimer();\n *      ....\n *      fprintf(stderr, \"Elapsed time = %7.3f sec\\n\", stopTimer());\n */",
      "file" : "utils.c"
   },
   {
      "function" : "stopTimer",
      "comment" : "/* Note: if division by 10^7 seems strange, the time is expressed\n     * as the number of 100-nanosecond intervals that have elapsed\n     * since 12:00 A.M. January 1, 1601.  */",
      "file" : "utils.c"
   },
   {
      "function" : "stopTimerNested",
      "comment" : "/*!\n *  startTimerNested(), stopTimerNested()\n *\n *  Example of usage:\n *\n *      L_TIMER  t1 = startTimerNested();\n *      ....\n *      L_TIMER  t2 = startTimerNested();\n *      ....\n *      fprintf(stderr, \"Elapsed time 2 = %7.3f sec\\n\", stopTimerNested(t2));\n *      ....\n *      fprintf(stderr, \"Elapsed time 1 = %7.3f sec\\n\", stopTimerNested(t1));\n */",
      "file" : "utils.c"
   },
   {
      "function" : "stopTimerNested",
      "comment" : "/* in units of hecto-nanosecond (100 ns) intervals */",
      "file" : "utils.c"
   },
   {
      "function" : "stringAllWhitespace",
      "comment" : "/*!\n *  stringAllWhitespace()\n *\n *      Input:  textstring\n *              &val (<return> 1 if all whitespace; 0 otherwise)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "textops.c"
   },
   {
      "function" : "stringCat",
      "comment" : "/*!\n *  stringCat()\n *\n *      Input:  dest (null-terminated byte buffer)\n *              size (size of dest)\n *              src string (can be null or null-terminated string)\n *      Return: number of bytes added to dest; -1 on error\n *\n *  Notes:\n *      (1) Alternative implementation of strncat, that checks the input,\n *          is easier to use (since the size of the dest buffer is specified\n *          rather than the number of bytes to copy), and does not complain\n *          if @src is null.\n *      (2) Never writes past end of dest.\n *      (3) If it can't append src (an error), it does nothing.\n *      (4) N.B. The order of 2nd and 3rd args is reversed from that in\n *          strncat, as in the Windows function strcat_s().\n */",
      "file" : "utils.c"
   },
   {
      "function" : "stringCompareLexical",
      "comment" : "/*!\n *  stringCompareLexical()\n *\n *      Input:  str1\n *              str2\n *      Return: 1 if str1 > str2 (lexically); 0 otherwise\n *\n *  Notes:\n *      (1) If the lexical values are identical, return a 0, to\n *          indicate that no swapping is required to sort the strings.\n */",
      "file" : "sarray.c"
   },
   {
      "function" : "stringCopy",
      "comment" : "/*!\n *  stringCopy()\n *\n *      Input:  dest (existing byte buffer)\n *              src string (can be null)\n *              n (max number of characters to copy)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Relatively safe wrapper for strncpy, that checks the input,\n *          and does not complain if @src is null or @n < 1.\n *          If @n < 1, this is a no-op.\n *      (2) @dest needs to be at least @n bytes in size.\n *      (3) We don't call strncpy() because valgrind complains about\n *          use of uninitialized values.\n */",
      "file" : "utils.c"
   },
   {
      "function" : "stringFindSubstr",
      "comment" : "/*!\n *  stringFindSubstr()\n *\n *      Input:  src (input string; can be of zero length)\n *              sub (substring to be searched for)\n *              &loc (<return optional> location of substring in src)\n *      Return: 1 if found; 0 if not found or on error\n *\n *  Notes:\n *      (1) This is a wrapper around strstr().\n *      (2) Both @src and @sub must be defined, and @sub must have\n *          length of at least 1.\n *      (3) If the substring is not found and loc is returned, it has\n *          the value -1.\n */",
      "file" : "utils.c"
   },
   {
      "function" : "stringJoin",
      "comment" : "/*!\n *  stringJoin()\n *\n *      Input:  src1 string (<optional> can be null)\n *              src2 string (<optional> can be null)\n *      Return: concatenated string, or null on error\n *\n *  Notes:\n *      (1) This is a safe version of strcat; it makes a new string.\n *      (2) It is not an error if either or both of the strings\n *          are empty, or if either or both of the pointers are null.\n */",
      "file" : "utils.c"
   },
   {
      "function" : "stringLeadingWhitespace",
      "comment" : "/*!\n *  stringLeadingWhitespace()\n *\n *      Input:  textstring\n *              &val (<return> 1 if leading char is ' ' or '\\t'; 0 otherwise)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "textops.c"
   },
   {
      "function" : "stringLength",
      "comment" : "/*!\n *  stringLength()\n *\n *      Input:  src string (can be null or null-terminated string)\n *              size (size of src buffer)\n *      Return: length of src in bytes.\n *\n *  Notes:\n *      (1) Safe implementation of strlen that only checks size bytes\n *          for trailing NUL.\n *      (2) Valid returned string lengths are between 0 and size - 1.\n *          If size bytes are checked without finding a NUL byte, then\n *          an error is indicated by returning size.\n */",
      "file" : "utils.c"
   },
   {
      "function" : "stringNew",
      "comment" : "/*!\n *  stringNew()\n *\n *      Input:  src string\n *      Return: dest copy of src string, or null on error\n */",
      "file" : "utils.c"
   },
   {
      "function" : "stringRemoveChars",
      "comment" : "/*!\n *  stringRemoveChars()\n *\n *      Input:  src (input string; can be of zero length)\n *              remchars  (string of chars to be removed from src)\n *      Return: dest (string with specified chars removed), or null on error\n */",
      "file" : "utils.c"
   },
   {
      "function" : "stringReplace",
      "comment" : "/*!\n *  stringReplace()\n *\n *      Input:  &dest string (<return> copy)\n *              src string\n *      Return: 0 if OK; 1 on error\n *\n *  Notes:\n *      (1) Frees any existing dest string\n *      (2) Puts a copy of src string in the dest\n *      (3) If either or both strings are null, does something reasonable.\n */",
      "file" : "utils.c"
   },
   {
      "function" : "stringReplaceEachSubstr",
      "comment" : "/*!\n *  stringReplaceEachSubstr()\n *\n *      Input:  src (input string; can be of zero length)\n *              sub1 (substring to be replaced)\n *              sub2 (substring to put in; can be \"\")\n *              &count (<optional return > the number of times that sub1\n *                      is found in src; 0 if not found)\n *      Return: dest (string with substring replaced), or null if the\n *              substring not found or on error.\n *\n *  Notes:\n *      (1) Replaces every instance.\n *      (2) To only remove each instance of sub1, use \"\" for sub2\n *      (3) Returns NULL if sub1 and sub2 are the same.\n */",
      "file" : "utils.c"
   },
   {
      "function" : "stringReplaceSubstr",
      "comment" : "/*!\n *  stringReplaceSubstr()\n *\n *      Input:  src (input string; can be of zero length)\n *              sub1 (substring to be replaced)\n *              sub2 (substring to put in; can be \"\")\n *              &found (<return optional> 1 if sub1 is found; 0 otherwise)\n *              &loc (<return optional> location of ptr after replacement)\n *      Return: dest (string with substring replaced), or null if the\n *              substring not found or on error.\n *\n *  Notes:\n *      (1) Replaces the first instance.\n *      (2) To only remove sub1, use \"\" for sub2\n *      (3) Returns a new string if sub1 and sub2 are the same.\n *      (4) The optional loc is input as the byte offset within the src\n *          from which the search starts, and after the search it is the\n *          char position in the string of the next character after\n *          the substituted string.\n *      (5) N.B. If ploc is not null, loc must always be initialized.\n *          To search the string from the beginning, set loc = 0.\n */",
      "file" : "utils.c"
   },
   {
      "function" : "stringReverse",
      "comment" : "/*!\n *  stringReverse()\n *\n *      Input:  src (string)\n *      Return: dest (newly-allocated reversed string)\n */",
      "file" : "utils.c"
   },
   {
      "function" : "stringSplitOnToken",
      "comment" : "/*!\n *  stringSplitOnToken()\n *\n *      Input:  cstr (input string to be split; not altered)\n *              seps (a string of character separators)\n *              &head (<return> ptr to copy of the input string, up to\n *                     the first separator token encountered)\n *              &tail (<return> ptr to copy of the part of the input string\n *                     starting with the first non-separator character\n *                     that occurs after the first separator is found)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The input string is not altered; all split parts are new strings.\n *      (2) The split occurs around the first consecutive sequence of\n *          tokens encountered.\n *      (3) The head goes from the beginning of the string up to\n *          but not including the first token found.\n *      (4) The tail contains the second part of the string, starting\n *          with the first char in that part that is NOT a token.\n *      (5) If no separator token is found, 'head' contains a copy\n *          of the input string and 'tail' is null.\n */",
      "file" : "utils.c"
   },
   {
      "function" : "strtokSafe",
      "comment" : "/*!\n *  strtokSafe()\n *\n *      Input:  cstr (input string to be sequentially parsed;\n *                    use NULL after the first call)\n *              seps (a string of character separators)\n *              &saveptr (<return> ptr to the next char after\n *                        the last encountered separator)\n *      Return: substr (a new string that is copied from the previous\n *                      saveptr up to but not including the next\n *                      separator character), or NULL if end of cstr.\n *\n *  Notes:\n *      (1) This is a thread-safe implementation of strtok.\n *      (2) It has the same interface as strtok_r.\n *      (3) It differs from strtok_r in usage in two respects:\n *          (a) the input string is not altered\n *          (b) each returned substring is newly allocated and must\n *              be freed after use.\n *      (4) Let me repeat that.  This is \"safe\" because the input\n *          string is not altered and because each returned string\n *          is newly allocated on the heap.\n *      (5) It is here because, surprisingly, some C libraries don't\n *          include strtok_r.\n *      (6) Important usage points:\n *          - Input the string to be parsed on the first invocation.\n *          - Then input NULL after that; the value returned in saveptr\n *            is used in all subsequent calls.\n *      (7) This is only slightly slower than strtok_k.\n */",
      "file" : "utils.c"
   },
   {
      "function" : "substituteObjectNumbers",
      "comment" : "/*!\n *  substituteObjectNumbers()\n *\n *  Input:  bas (lba of a pdf object)\n *          na_objs (object number mapping array)\n *  Return: bad (lba of rewritten pdf for the object)\n *\n *  Notes:\n *      (1) Interpret the first set of bytes as the object number,\n *          map to the new number, and write it out.\n *      (2) Find all occurrences of this 4-byte sequence: \" 0 R\"\n *      (3) Find the location and value of the integer preceeding this,\n *          and map it to the new value.\n *      (4) Rewrite the object with new object numbers.\n */",
      "file" : "pdfio.c"
   },
   {
      "function" : "sudokuCompareState",
      "comment" : "/*!\n *  sudokuCompareState()\n *\n *      Input:  sud1, sud2\n *              quads (rotation of sud2 input with respect to sud1,\n *                    in units of 90 degrees cw)\n *              &same (<return> 1 if all 4 results are identical; 0 otherwise)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The input to sud2 has been rotated by @quads relative to the\n *          input to sud1.  Therefore, we must rotate the solution to\n *          sud1 by the same amount before comparing it to the\n *          solution to sud2.\n */",
      "file" : "sudoku.c"
   },
   {
      "function" : "sudokuCreate",
      "comment" : "/*!\n *  sudokuCreate()\n *\n *      Input:  array (of 81 numbers, 9 rows of 9 numbers each)\n *      Return: l_sudoku, or null on error\n *\n *  Notes:\n *      (1) The input array has 0 for the unknown values, and 1-9\n *          for the known initial values.  It is generated from\n *          a file using sudokuReadInput(), which checks that the file\n *          data has 81 numbers in 9 rows.\n */",
      "file" : "sudoku.c"
   },
   {
      "function" : "sudokuDestroy",
      "comment" : "/*!\n *  sudokuDestroy()\n *\n *      Input:  &l_sudoku (<to be nulled>)\n *      Return: void\n */",
      "file" : "sudoku.c"
   },
   {
      "function" : "sudokuGenerate",
      "comment" : "/*!\n *  sudokuGenerate()\n *\n *      Input:  array (of 81 numbers, 9 rows of 9 numbers each)\n *              seed (random number)\n *              minelems (min non-zero elements allowed; <= 80)\n *              maxtries (max tries to remove a number and get a valid sudoku)\n *      Return: l_sudoku, or null on error\n *\n *  Notes:\n *      (1) This is a brute force generator.  It starts with a completed\n *          sudoku solution and, by removing elements (setting them to 0),\n *          generates a valid (unique) sudoku initial condition.\n *      (2) The process stops when either @minelems, the minimum\n *          number of non-zero elements, is reached, or when the\n *          number of attempts to remove the next element exceeds @maxtries.\n *      (3) No sudoku is known with less than 17 nonzero elements.\n */",
      "file" : "sudoku.c"
   },
   {
      "function" : "sudokuNewGuess",
      "comment" : "/*!\n *  sudokuNewGuess()\n *\n *      Input:  l_sudoku\n *      Return: 0 if OK; 1 if no solution is possible\n *\n *  Notes:\n *      (1) This attempts to increment the number in the current\n *          location.  If it can't, it backtracks (sets the number\n *          in the current location to zero and decrements the\n *          current location).  If it can, it tests that number,\n *          and if the number is valid, moves forward to the next\n *          empty location (increments the current location).\n *      (2) If there is no solution, backtracking will eventually\n *          exhaust possibilities for the first location.\n */",
      "file" : "sudoku.c"
   },
   {
      "function" : "sudokuOutput",
      "comment" : "/*!\n *  sudokuOutput()\n *\n *      Input:  l_sudoku (at any stage)\n *              arraytype (L_SUDOKU_INIT, L_SUDOKU_STATE)\n *      Return: void\n *\n *  Notes:\n *      (1) Prints either the initial array or the current state\n *          of the solution.\n */",
      "file" : "sudoku.c"
   },
   {
      "function" : "sudokuReadFile",
      "comment" : "/*!\n *  sudokuReadFile()\n *\n *      Input:  filename (of formatted sudoku file)\n *      Return: array (of 81 numbers), or null on error\n *\n *  Notes:\n *      (1) The file format has:\n *          * any number of comment lines beginning with '#'\n *          * a set of 9 lines, each having 9 digits (0-9) separated\n *            by a space\n */",
      "file" : "sudoku.c"
   },
   {
      "function" : "sudokuReadString",
      "comment" : "/*!\n *  sudokuReadString()\n *\n *      Input:  str (of input data)\n *      Return: array (of 81 numbers), or null on error\n *\n *  Notes:\n *      (1) The string is formatted as 81 single digits, each separated\n *          by 81 spaces.\n */",
      "file" : "sudoku.c"
   },
   {
      "function" : "sudokuRotateArray",
      "comment" : "/*!\n *  sudokuRotateArray()\n *\n *      Input:  array (of 81 numbers; 9 lines of 9 numbers each)\n *              quads (1-3; number of 90 degree cw rotations)\n *      Return: rarray (rotated array), or null on error\n */",
      "file" : "sudoku.c"
   },
   {
      "function" : "sudokuSolve",
      "comment" : "/*!\n *  sudokuSolve()\n *\n *      Input:  l_sudoku (starting in initial state)\n *      Return: 1 on success, 0 on failure to solve (note reversal of\n *              typical unix returns)\n */",
      "file" : "sudoku.c"
   },
   {
      "function" : "sudokuTestState",
      "comment" : "/*!\n *  sudokuTestState()\n *\n *      Input:  state (current state: array of 81 values)\n *              index (into state element that we are testing)\n *      Return: 1 if valid; 0 if invalid (no error checking)\n */",
      "file" : "sudoku.c"
   },
   {
      "function" : "sudokuTestUniqueness",
      "comment" : "/*!\n *  sudokuTestUniqueness()\n *\n *      Input:  array (of 81 numbers, 9 lines of 9 numbers each)\n *              &punique (<return> 1 if unique, 0 if not)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This applies the brute force method to all four 90 degree\n *          rotations.  If there is more than one solution, it is highly\n *          unlikely that all four results will be the same;\n *          consequently, if they are the same, the solution is\n *          most likely to be unique.\n */",
      "file" : "sudoku.c"
   },
   {
      "function" : "sudokuValidState",
      "comment" : "/*!\n *  sudokuValidState()\n *\n *      Input:  state (array of size 81)\n *      Return: 1 if valid, 0 if invalid\n *\n *  Notes:\n *      (1) This can be used on either the initial state (init)\n *          or on the current state (state) of the l_soduku.\n *          All values of 0 are ignored.\n */",
      "file" : "sudoku.c"
   },
   {
      "function" : "testLineAlignmentX",
      "comment" : "/* Determine if there are a sufficient number of mutually\n         * aligned matches.  Mutually aligned matches place an additional\n         * constraint on the 'possible' matches, where the relative\n         * shifts must not exceed the (delx, dely) distances. */",
      "file" : "classapp.c"
   },
   {
      "function" : "thresholdTo2bppLow",
      "comment" : "/*\n *  thresholdTo2bppLow()\n *\n *  Low-level function for thresholding from 8 bpp (datas) to\n *  2 bpp (datad), using thresholds implicitly defined through @tab,\n *  a 256-entry lookup table that gives a 2-bit output value\n *  for each possible input.\n *\n *  For each line, unroll the loop so that for each 32 bit src word,\n *  representing four consecutive 8-bit pixels, we compose one byte\n *  of output consisiting of four 2-bit pixels.\n */",
      "file" : "grayquantlow.c"
   },
   {
      "function" : "thresholdTo4bppLow",
      "comment" : "/*\n *  thresholdTo4bppLow()\n *\n *  Low-level function for thresholding from 8 bpp (datas) to\n *  4 bpp (datad), using thresholds implicitly defined through @tab,\n *  a 256-entry lookup table that gives a 4-bit output value\n *  for each possible input.\n *\n *  For each line, unroll the loop so that for each 32 bit src word,\n *  representing four consecutive 8-bit pixels, we compose two bytes\n *  of output consisiting of four 4-bit pixels.\n */",
      "file" : "grayquantlow.c"
   },
   {
      "function" : "thresholdToBinaryLineLow",
      "comment" : "/*\n *  thresholdToBinaryLineLow()\n *\n */",
      "file" : "grayquantlow.c"
   },
   {
      "function" : "thresholdToBinaryLow",
      "comment" : "/*\n *  thresholdToBinaryLow()\n *\n *  If the source pixel is less than thresh,\n *  the dest will be 1; otherwise, it will be 0\n */",
      "file" : "grayquantlow.c"
   },
   {
      "function" : "tiffCloseCallback",
      "comment" : "/* offset >= 0 */",
      "file" : "tiffio.c"
   },
   {
      "function" : "tiffGetCount",
      "comment" : "/*\n *  tiffGetCount()\n *\n *      Input:  stream (opened for read)\n *              &n (<return> number of images)\n *      Return: 0 if OK; 1 on error\n */",
      "file" : "tiffio.c"
   },
   {
      "function" : "tiffMapCallback",
      "comment" : "/* never free the buffer! */",
      "file" : "tiffio.c"
   },
   {
      "function" : "tiffReadCallback",
      "comment" : "/* ditto  */",
      "file" : "tiffio.c"
   },
   {
      "function" : "tiffReadHeaderTiff",
      "comment" : "/*!\n *  tiffReadHeaderTiff()\n *\n *      Input:  tif\n *              &width (<return>)\n *              &height (<return>)\n *              &bps (<return> bits per sample -- 1, 2, 4 or 8)\n *              &spp (<return>; samples per pixel -- 1 or 3)\n *              &res (<optional return>; resolution in x dir; NULL to ignore)\n *              &cmap (<optional return>; cmap exists; input NULL to ignore)\n *              &format (<optional return>; tiff format; input NULL to ignore)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "tiffio.c"
   },
   {
      "function" : "tiffSeekCallback",
      "comment" : "/* reallocNew() uses calloc to initialize the array.\n         * If malloc is used instead, for some of the encoding methods,\n         * not all the data in 'bufsize' bytes in the buffer will\n         * have been initialized by the end of the compression. */",
      "file" : "tiffio.c"
   },
   {
      "function" : "tiffSizeCallback",
      "comment" : "/* never free the buffer! */",
      "file" : "tiffio.c"
   },
   {
      "function" : "tiffUnmapCallback",
      "comment" : "/* never free the buffer! */",
      "file" : "tiffio.c"
   },
   {
      "function" : "tiffWriteCallback",
      "comment" : "/* ditto  */",
      "file" : "tiffio.c"
   },
   {
      "function" : "transferRchToRcha",
      "comment" : "/*!\n *  transferRchToRcha()\n *\n *      Input:  rch (source of data)\n *              rcha (append to arrays in this destination)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This is used to transfer the results of a single character\n *          identification to an rcha array for the array of characters.\n */",
      "file" : "recogident.c"
   },
   {
      "function" : "vboxGetAverageColor",
      "comment" : "/*!\n *  vboxGetAverageColor()\n *\n *      Input:  vbox (3d region of color space for one quantized color)\n *              histo\n *              sigbits (valid: 5 or 6)\n *              index (if >= 0, assign to all colors in histo in this vbox)\n *              &rval, &gval, &bval (<returned> average color)\n *      Return: cmap, or null on error\n *\n *  Notes:\n *      (1) The vbox represents one color in the colormap.\n *      (2) If index >= 0, as a side-effect, all array elements in\n *          the histo corresponding to the vbox are labeled with this\n *          cmap index for that vbox.  Otherwise, the histo array\n *          is not changed.\n *      (3) The vbox is quantized in sigbits.  So the actual 8-bit color\n *          components are found by multiplying the quantized value\n *          by either 4 or 8.  We must add 0.5 to the quantized index\n *          before multiplying to get the approximate 8-bit color in\n *          the center of the vbox; otherwise we get values on\n *          the lower corner.\n */",
      "file" : "colorquant2.c"
   },
   {
      "function" : "vboxGetCount",
      "comment" : "/*!\n *  vboxGetCount()\n *\n *      Input:  vbox (3d region of color space for one quantized color)\n *              histo\n *              sigbits (valid: 5 or 6)\n *      Return: number of image pixels in this region, or 0 on error\n */",
      "file" : "colorquant2.c"
   },
   {
      "function" : "vboxGetVolume",
      "comment" : "/*!\n *  vboxGetVolume()\n *\n *      Input:  vbox (3d region of color space for one quantized color)\n *      Return: quantized volume of vbox, or 0 on error\n */",
      "file" : "colorquant2.c"
   },
   {
      "function" : "writeCustomTiffTags",
      "comment" : "/*!\n *  writeCustomTiffTags()\n *\n *      Input:  tif\n *              natags (<optional> NUMA of custom tiff tags)\n *              savals (<optional> SARRAY of values)\n *              satypes (<optional> SARRAY of types)\n *              nasizes (<optional> NUMA of sizes)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This static function should be called indirectly through\n *          higher level functions, such as pixWriteTiffCustom(),\n *          which call pixWriteToTiffStream().  See details in\n *          pixWriteTiffCustom() for using the 4 input arrays.\n *      (2) This is a no-op if the first 3 arrays are all NULL.\n *      (3) Otherwise, the first 3 arrays must be defined and all\n *          of equal size.\n *      (4) The fourth array is always optional.\n *      (5) The most commonly used types are \"char*\" and \"u_int16\".\n *          See tiff.h for a full listing of the tiff tags.\n *          Note that many of these tags, in particular the bit tags,\n *          are intended to be private, and cannot be set by this function.\n *          Examples are the STRIPOFFSETS and STRIPBYTECOUNTS tags,\n *          which are bit tags that are automatically set in the header,\n *          and can be extracted using tiffdump.\n */",
      "file" : "tiffio.c"
   },
   {
      "function" : "writeImageCompressedToPSFile",
      "comment" : "/*\n *  writeImageCompressedToPSFile()\n *\n *      Input:  filein (input image file)\n *              fileout (output ps file)\n *              res (output printer resolution)\n *              &firstfile (<input and return> 1 if the first image;\n *                          0 otherwise)\n *              &index (<input and return> index of image in output ps file)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This wraps a single page image in PS.\n *      (2) The input file can be in any format.  It is compressed as follows:\n *             * if in tiffg4  -->  use ccittg4\n *             * if in jpeg    -->  use dct\n *             * all others    -->  use flate\n *      (3) Before the first call, set @firstpage = 1.  After writing\n *          the first page, it will be set to 0.\n *      (4) @index is incremented if the page is successfully written.\n */",
      "file" : "psio1.c"
   },
   {
      "function" : "writeMultipageTiff",
      "comment" : "/*\n *  writeMultipageTiff()\n *\n *      Input:  dirin (input directory)\n *              substr (<optional> substring filter on filenames; can be NULL)\n *              fileout (output ps file)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This writes a set of image files in a directory out\n *          as a multipage tiff file.  The images can be in any\n *          initial file format.\n *      (2) Images with a colormap have the colormap removed before\n *          re-encoding as tiff.\n *      (3) All images are encoded losslessly.  Those with 1 bpp are\n *          encoded 'g4'.  The rest are encoded as 'zip' (flate encoding).\n *          Because it is lossless, this is an expensive method for\n *          saving most rgb images.\n */",
      "file" : "tiffio.c"
   },
   {
      "function" : "writeMultipageTiffSA",
      "comment" : "/*\n *  writeMultipageTiffSA()\n *\n *      Input:  sarray (of full path names)\n *              fileout (output ps file)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) See writeMultipageTiff()\n */",
      "file" : "tiffio.c"
   },
   {
      "function" : "wshedApply",
      "comment" : "/*!\n *  wshedApply()\n *\n *      Input:  wshed (generated from wshedCreate())\n *      Return: 0 if OK, 1 on error\n *\n *  Iportant note:\n *      (1) This is buggy.  It seems to locate watersheds that are\n *          duplicates.  The watershed extraction after complete fill\n *          grabs some regions belonging to existing watersheds.\n *          See prog/watershedtest.c for testing.\n */",
      "file" : "watershed.c"
   },
   {
      "function" : "wshedBasins",
      "comment" : "/*!\n *  wshedBasins()\n *\n *      Input:  wshed\n *              &pixa  (<optional return> mask of watershed basins)\n *              &nalevels   (<optional return> watershed levels)\n *      Return: 0 if OK, 1 on error\n */",
      "file" : "watershed.c"
   },
   {
      "function" : "wshedCreate",
      "comment" : "/*!\n *  wshedCreate()\n *\n *      Input:  pixs  (8 bpp source)\n *              pixm  (1 bpp 'marker' seed)\n *              mindepth (minimum depth; anything less is not saved)\n *              debugflag (1 for debug output)\n *      Return: WShed, or null on error\n *\n *  Notes:\n *      (1) It is not necessary for the fg pixels in the seed image\n *          be at minima, or that they be isolated.  We extract a\n *          single pixel from each connected component, and a seed\n *          anywhere in a watershed will eventually label the watershed\n *          when the filling level reaches it.\n *      (2) Set mindepth to some value to ignore noise in pixs that\n *          can create small local minima.  Any watershed shallower\n *          than mindepth, even if it has a seed, will not be saved;\n *          It will either be incorporated in another watershed or\n *          eliminated.\n */",
      "file" : "watershed.c"
   },
   {
      "function" : "wshedDestroy",
      "comment" : "/*!\n *  wshedDestroy()\n *\n *      Input:  &wshed (<will be set to null before returning>)\n *      Return: void\n */",
      "file" : "watershed.c"
   },
   {
      "function" : "wshedGetHeight",
      "comment" : "/*!\n *  wshedGetHeight()\n *\n *      Input:  wshed (array of current indices)\n *              val (value of current pixel popped off queue)\n *              label (of pixel or 32 bpp label image)\n *              &height (<return> height of current value from seed\n *                       or minimum of watershed)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) It is only necessary to find the height for a watershed\n *          that is indexed by a seed or a minima.  This function should\n *          not be called on a finished watershed (that continues to fill).\n */",
      "file" : "watershed.c"
   },
   {
      "function" : "wshedRenderColors",
      "comment" : "/*!\n *  wshedRenderColors()\n *\n *      Input:  wshed\n *      Return: pixd (initial image with all basins filled), or null on error\n */",
      "file" : "watershed.c"
   },
   {
      "function" : "wshedRenderFill",
      "comment" : "/*!\n *  wshedRenderFill()\n *\n *      Input:  wshed\n *      Return: pixd (initial image with all basins filled), or null on error\n */",
      "file" : "watershed.c"
   },
   {
      "function" : "wshedSaveBasin",
      "comment" : "/*!\n *  wshedSaveBasin()\n *\n *      Input:  wshed\n *              index (index of basin to be located)\n *              level (filling level reached at the time this function\n *                     is called)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This identifies a single watershed.  It does not change\n *          the LUT, which must be done subsequently.\n *      (2) The fill level of a basin is taken to be @level - 1.\n */",
      "file" : "watershed.c"
   },
   {
      "function" : "zlibCompress",
      "comment" : "/*!\n *  zlibCompress()\n *\n *      Input:  datain (byte buffer with input data)\n *              nin    (number of bytes of input data)\n *              &nout  (<return> number of bytes of output data)\n *      Return: dataout (compressed data), or null on error\n *\n *  Notes:\n *      (1) We repeatedly read in and fill up an input buffer,\n *          compress the data, and read it back out.  zlib\n *          uses two byte buffers internally in the z_stream\n *          data structure.  We use the bbuffers to feed data\n *          into the fixed bufferin, and feed it out of bufferout,\n *          in the same way that a pair of streams would normally\n *          be used if the data were being read from one file\n *          and written to another.  This is done iteratively,\n *          compressing L_BUF_SIZE bytes of input data at a time.\n */",
      "file" : "zlibmem.c"
   },
   {
      "function" : "zlibUncompress",
      "comment" : "/*!\n *  zlibUncompress()\n *\n *      Input:  datain (byte buffer with compressed input data)\n *              nin    (number of bytes of input data)\n *              &nout  (<return> number of bytes of output data)\n *      Return: dataout (uncompressed data), or null on error\n *\n *  Notes:\n *      (1) See zlibCompress().\n */",
      "file" : "zlibmem.c"
   }
]
